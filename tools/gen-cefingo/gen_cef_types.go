//
// cefingo go type generator for cef type with cef_base_ref_counted_t base member
//
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"

	"github.com/turutcrane/cefingo/tools/gen-cefingo/parser"
)

var output *string

// func init() {
// 	var outputName string
// 	if dir, err := os.Getwd(); err == nil {
// 		baseName := fmt.Sprintf("cefingo_types.go")
// 		outputName = filepath.Join(dir, strings.ToLower(baseName))
// 	} else {
// 		log.Fatal(err)
// 	}
// 	output = flag.String("output", outputName, "output file name; default srcdir/cefingo_types.go")
// }

// func main() {
// 	flag.Parse()
// 	g := Generator{}

// 	// Print the header and package clause.
// 	g.Printf("// Code generated by \"gen_cef_types.go\" DO NOT EDIT.\n")
// 	g.Printf("\n")
// 	g.Printf("package %s", "capi")
// 	g.Printf("\n")
// 	g.Printf(`
// import (
// 	"runtime"
// 	"unsafe"
// )

// // #include "cefingo.h"
// import "C"
// `)

// 	for _, s := range cef_types {
// 		genGotype(&g, s)
// 	}

// 	// Format the output.
// 	src := g.format()

// 	// Write to file.
// 	outputName := *output
// 	err := ioutil.WriteFile(outputName, src, 0644)
// 	if err != nil {
// 		log.Fatalf("writing output: %s", err)
// 	}
// }

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	fname string
	buf   bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) Write(p []byte) (n int, err error) {
	return g.buf.Write(p)
}

func (g *Generator) Lines() (line int) {
	return bytes.Count(g.buf.Bytes(), []byte("\n"))
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func genGotype(g *Generator, d *parser.StructDecl) {
	t := d.Token()
	cName := t.Name()
	typeName := t.BaseName()
	camel := t.TitleCase()

	// container of *C.cef_type
	g.Printf(`
// Go type for %[1]s	
type C%[2]s struct {
	p_%[3]s *C.%[1]s
}
`,
		cName, camel, typeName,
	)

	// Reference to CType
	g.Printf(`
type RefToC%[1]s struct {
	p_%[2]s *C%[1]s
}
`,
		camel, typeName,
	)

	// interface of accessor to *CType
	g.Printf(`
type C%[1]sAccessor interface {
	GetC%[1]s() *C%[1]s
	SetC%[1]s(*C%[1]s)
}

func (r RefToC%[1]s) GetC%[1]s() *C%[1]s {
	return r.p_%[2]s
}

func (r *RefToC%[1]s) SetC%[1]s(p *C%[1]s) {
	r.p_%[2]s = p
}
`,
		camel, typeName,
	)

	b := g.buf.Bytes()
	line := bytes.Count(b, []byte("\n"))
	WriteNewGoType(g, d, line)

	if d.St == parser.StRefCounted {
		g.Printf(`
func (%[3]s *C%[1]s) HasOneRef() bool {
	return BaseHasOneRef(%[3]s.p_%[2]s)
}
`,
			camel, typeName, typeName,
		)

		g.Printf(`
// *C.%[1]s has refCounted interface
func (p *C.%[1]s) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}
	`,
			cName,
		)
	}
}
