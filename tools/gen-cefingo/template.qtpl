{% package main %}
{% import (
	"log"
	"strings"

	"github.com/turutcrane/cefingo/tools/gen-cefingo/parser"
)%}

Generate parameter name for Go func.
{% func goParamName(p parser.Param) -%}
{% switch p.Name() -%}
{% case "type", "string", "map", "time", "range" -%}
	{%-s "c" + p.Name() -%}
{% default -%}
	{%-s p.Name() -%}
{% endswitch -%}
{% endfunc %}

Generate parameter name for Go func.
{% func goParamNameOut(p parser.Param) -%}
{%= goParamName(p) -%}
{% if p.IsInOutParam() %}Out{% endif -%}
{% endfunc %}

{% func goTempName(p parser.Param) -%}
goTmp{%s p.Name() -%}
{% endfunc %}

{% func goTempNameOut(p parser.Param) -%}
{%s goTempName(p) + "Out" -%}
{% endfunc %}

Statemens to convert from C.param to Go type.
{% func convToGoTypeStmts(p parser.Param, lt *LogTag) -%}
{% if p.IsInOutParam() -%}
	{%- if p.Type().Ty == parser.TyStringT -%}
		{%= goTempName(p) %} := string_from_cef_string({%s goParamName(p) %})
	{%- elseif p.Type().Pointer == 2 && p.Type().Deref().IsRefCountedClass() -%}
		{%= goTempName(p) %} := {%s ConvToGoTypeExp(p.Type().Deref(), "*" + goParamName(p)) %}
		cefp := {%s goTempName(p) %}.p_{%s p.Type().BaseName() %}
	{%- elseif p.IsBoolParam() -%}
		{%= goTempName(p) %} := (*{%s p.Name() %}) != 0
	{%- elseif p.Type().Ty == parser.TyStructSimple || p.Type().Ty ==  parser.TyInt -%}
		{%= goTempName(p) %} := {%s p.Type().Deref().GoType() %}(*{%s p.Name() %})
	{%- else -%}
	{%- code log.Panicf("E43: %s::%s::%s", p.CalleeName(), p.Name(), p.Type()) -%}
	{%- endif -%}
{% elseif !p.IsOutParam() -%}
	{%- if bs, maxLenArg := p.IsByteSliceParam(); bs -%}
		{%= goTempName(p) %} := (*[1 << 30]byte)({%s p.Name() %})[:{%s maxLenArg %}:{%s maxLenArg %}]
	{%- elseif s, maxLenArg := p.IsSliceParam(); s -%}
		slice := (*[1 << 30]({%s p.Type().Deref().GoCType() %}))(unsafe.Pointer({%s p.Name() %}))[:{%s maxLenArg %}:{%s maxLenArg %}]
		{%= goTempName(p) %} := make({%s p.GoType() %}, {%s maxLenArg %})
		for i, v := range slice {
			{%= goTempName(p) %}[i] = new{%s p.Type().Deref().Deref().GoType() %}(v)
		}
	{%- else -%}
		{%- if p.IsBoolParam() -%}
		{%= goTempName(p) %} := {%s= goParamName(p) %} != 0
		{%- elseif !p.IsSliceLengthParam() -%}
		{%= goTempName(p) %} := {%s ConvToGoTypeExp(p.Type(), goParamName(p)) %}
		{%- endif -%}
	{%- endif -%}
{% endif -%}
{% endfunc %}

Set returned Go value to C.param and cleanup
{% func postProcess(p parser.Param, lt *LogTag) -%}
{% if p.IsOutParam() -%}
	{%- if p.Type().Ty == parser.TyStringT -%}
		set_cef_string({%= goParamName(p) %}, {%= goTempNameOut(p) %})
	{%- elseif p.Type().Deref().IsRefCountedClass() -%}
		if {%s goTempNameOut(p) %} != nil {
			*{%s goParamName(p) %} = {%s goTempNameOut(p) %}.p_{%s p.Type().BaseName() %}
			BaseAddRef(*{%s goParamName(p) %})
		}
	{%- elseif isSlice, sliceLen := p.IsByteSliceParam(); isSlice -%}
		*{%s sliceLen %} = (C.size_t)(len({%s goTempNameOut(p) %}))
		*{%s goParamName(p) %} = ({%s p.Type().Deref().GoCType() %})(C.calloc(1, C.size_t(len({%s goTempNameOut(p) %}))))
		target := (*[1<<30]byte)(unsafe.Pointer(*{%s goParamName(p) %}))[:*{%s sliceLen %}:*{%s sliceLen %}]
		copy(target, {%s goTempNameOut(p) %})
	{%- elseif isSlice, _ := p.IsSliceParam(); isSlice -%}
		{% code log.Panicf("T76: Not implemented %v", p) %}
	{%- elseif p.IsBoolParam() -%}
		*{%s goParamName(p) %} = 0
		if {%s goTempNameOut(p) %} {
			*{%s goParamName(p) %} = 1
		}
	{%- else -%}
		*{%s goParamName(p) %} = ({%s p.Type().Deref().GoCType() %})({%s goTempNameOut(p) %})
	{%- endif -%}
{% elseif p.IsInOutParam() -%}
	{%- if p.Type().Ty == parser.TyStringT -%}
		set_cef_string({%s goParamName(p) %},{%s goTempNameOut(p) %})
	{%- elseif p.IsBoolParam() -%}
		*{%s goParamName(p) %} = 0
		if {%s goTempNameOut(p) %} {
			*{%s goParamName(p) %} = 1
		}
	{%- elseif p.Type().Ty == parser.TyStructSimple  || p.Type().Ty ==  parser.TyInt -%}
		*{%s p.Name() %} = {%s p.Type().Deref().GoCType() %}({%s goTempNameOut(p) %})
	{%- elseif p.Type().Pointer == 2 -%}
		if cefp != {%= goTempNameOut(p) %}.p_{%s p.Type().BaseName() %} {
			*{%s goParamName(p) %} = {%= goTempNameOut(p) %}.p_{%s p.Type().BaseName() %}
			BaseAddRef(*{%s goParamName(p) %})
		}
	{%- else -%}
	{%- code log.Panicf("E88: %s::%s::%s", p.CalleeName(), p.Name(), p.Type()) -%}
	{%- endif -%}
{% elseif p.Name() != "self" -%}
	{%- if p.IsRefCountedClass() -%}
		BaseRelease({%= goTempName(p) %}.p_{%s p.Type().BaseName() %})
	{%- endif -%}
{% endif -%}
{% endfunc %}

{% func MethodComments(m *parser.MethodDecl) -%}
{% for _, c := range m.Comment -%}
{%s c %}
{% endfor -%}
{% endfunc -%}

{% func goRecieveValue(m *parser.MethodDecl) -%}
{% code first := true -%}
{% if m.HasReturnValue() %}goRet{% code first = false %}{% endif -%}
{%- for _, p := range m.Params() -%}
	{%- if p.IsOutParam() || p.IsInOutParam() -%}
		{%- if !first %}, {% endif -%}
		{%-s goTempNameOut(p) %}{% code first = false -%}
	{%- endif -%}
{%- endfor -%}
{%- if m.HasReturnValue() || m.HasOutParam() -%}:= {% endif -%}
{% endfunc %}

{% func GoCallback(m *parser.MethodDecl, st *parser.CefClassDecl, lt *LogTag) %}
{% code
	var retCtype string
	retCtype = m.ReturnType().GoCType()
	baseName := st.BaseName()
-%}
{%= MethodComments(m) -%}
//export cefingo_{%s baseName %}_{%s m.Funcname.Name() %}
func cefingo_{%s baseName %}_{%s m.Funcname.Name() %}(
{%- for _, p := range m.Params() -%}
	{%s goParamName(p) %} {%s p.GoCType() %},
{%- endfor -%}
) {% if retCtype != "" %}(cRet {%s retCtype %}){% endif %} {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "{%s lt.NextTag() %}:")
	cefingoIfaceAccess.Lock()
	{%- if "*C." + st.CefName() == m.Params()[0].GoCType() -%}
	f := {%s baseName %}_handlers.{%= memberName(m) %}[self]
	{%- else -%}
	f := {%s baseName %}_handlers.{%= memberName(m) %}[(*C.{%s st.CefName() %})(unsafe.Pointer(self))]
	{%- endif -%}
	cefingoIfaceAccess.Unlock()

	if f != nil {
		{%- for _, p := range m.Params() -%}
			{%- if exp := convToGoTypeStmts(p, lt); exp != "" && !p.IsByteSliceLengthParam() -%}
				{%-s= exp -%}
			{%- endif -%}
		{%- endfor %}
		{%= goRecieveValue(m) %}f.{%s m.Funcname.TitleCase()%}{%s "(" -%}
		{%- for _, p := range m.Params() -%}
		{%- if !(p.IsSliceLengthParam() || p.IsByteSliceLengthParam() || p.IsOutParam()) %}{%= goTempName(p) %},{% endif -%}
		{%- endfor %})
		{%- for _, p := range m.Params() -%}
			{%- if exp := postProcess(p, lt); exp != "" -%}
				{%-s= exp -%}
			{%- endif -%}
		{%- endfor %}
		{%- if m.IsBoolValueMethod() %}
		if goRet {cRet = 1}
		{%- elseif m.ReturnType().IsRefCountedClass() %}
		cRet = ({%s retCtype %})(goRet.p_{%s m.ReturnType().BaseName() %})
		BaseAddRef(cRet)
		{%- elseif retCtype != "" %}
		cRet = ({%s retCtype %})(goRet)
		{%- endif -%}
	} else {
		Logf("{%s lt.NextTag() %}: {%s m.Funcname.Name() %}: Noo!")
	}
	{% if retCtype !="" %}return cRet{% endif %}
}
{% endfunc %}

{% func GoBindFunc(st *parser.CefClassDecl, lt *LogTag) %}
{% code baseName := st.BaseName()
	self := baseName -%}
func ({%s self %} *{%s st.GoName() %}) Bind(a interface{}) *{%s st.GoName() %} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	{%- code funcnum := 0 -%}
	{%- for c := st; c != nil; c = c.GetBase() -%}
	{%- for _, m := range c.Methods -%}
	{%- if !m.IsGetFunc() %}
	{%- if funcnum == 0 -%}
	cp := {%s self %}.p_{%s baseName %}

	{%- endif -%}
	{%- code funcnum += 1 -%}
	if h, ok := a.({%s m.IfName() %}); ok {
		{%s baseName %}_handlers.{%= memberName(m) %}[cp] = h
	}
	{%- endif -%}
	{%- endfor -%}
	{%- endfor %}
	if accessor, ok := a.({%s st.GoName() %}Accessor); ok {
		accessor.Set{%s st.GoName() %}({%s self %})
		Logf("{%s lt.NextTag() %}:")
	}

	return {%s self %}
}
{% endfunc %}

{% func GoGetFunc(m *parser.MethodDecl, goName, baseName, cName string, lt *LogTag) %}
//export cefingo_{%s baseName %}_{%s m.Funcname.Name() %}
func cefingo_{%s baseName %}_{%s m.Funcname.Name() %}(self *C.{%s cName %}) (ch {%s m.ReturnType().GoCType() %}) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := {%s baseName %}_handlers.{%s memberName(m) %}[self]
	if handler == nil {
		Logf("{%s lt.NextTag() %}: {%s m.Funcname.Name() %}")
	} else {
		BaseAddRef(handler.p_{%s m.ReturnType().BaseName() %})
		ch = handler.p_{%s m.ReturnType().BaseName() %}
	}
	return ch
}
{% endfunc %}

{% func AssocGetFunc(m *parser.MethodDecl, goName, baseName, cName string, lt *LogTag) %}
func ({%s baseName %} *{%s goName %}) Assoc{%s m.ReturnType().TitleCase() %}(handler {%s m.ReturnType().GoType() %}) {
	cp := {%s baseName %}.p_{%s baseName %}
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	{%s baseName %}_handlers.{%= memberName(m) %}[cp] = handler
}
{% endfunc %}

{% func GoHead(imports []string, defIfMutex, winOnly bool) %}
// Code generated by "gen-cefingo.go" DO NOT EDIT.
{% if winOnly -%}
// +build windows
{% endif -%}

package capi

{% if len(imports) > 0 -%}
import (
{% for _, p := range imports -%}
	"{%s p %}"
{% endfor -%}
)
{% endif -%}
// #include "cefingo.h"
import "C"
{% if defIfMutex %}var cefingoIfaceAccess sync.Mutex
{% endif -%}
{% endfunc %}

{% func GoIface(m *parser.MethodDecl) %}
{%= MethodComments(m) -%}
type {%s m.IfName() %} interface {
	{%s m.Funcname.TitleCase() %} (
		{%- for _, p := range m.Params() -%}
		{%- if !(p.IsSliceLengthParam() || p.IsByteSliceLengthParam() || p.IsOutParam()) -%}
		{%s goParamName(p) %} {%s p.GoTypeIn() %},
		{%- endif -%}
		{%- endfor -%}
	) {%s retTypes(m) %}
}
{% endfunc %}

{% func memberName(m *parser.MethodDecl) -%}
{%- if m.IsGetFunc() -%}
{%-s m.ReturnType().BaseName() -%}
{%- else -%}
{%-s m.Funcname.Name() %}_handler{%s "" -%}
{%- endif -%}
{% endfunc %}

{% func memberGoType(m *parser.MethodDecl) -%}
{%- if m.IsGetFunc() -%}
{%-s m.ReturnType().GoType() -%}
{%- else -%}
{%-s m.IfName() -%}
{%- endif -%}
{% endfunc %}

{% func IfaceStruct(st *parser.CefClassDecl) %}
var {%s st.BaseName() %}_handlers = struct {
{% for c := st; c != nil; c = c.GetBase() -%}
	{%- for _, m := range c.Methods -%}
	{%= memberName(m) %} map[*C.{%s st.CefName() %}]{%= memberGoType(m) %}
	{%- endfor -%}
{% endfor -%}
}{
{% for c := st; c != nil; c = c.GetBase() -%}
	{%- for _, m := range c.Methods -%}
	map[*C.{%s st.CefName() %}]{%= memberGoType(m) %}{},
	{%- endfor -%}
{% endfor -%}
}
{% endfunc %}

{% func GoAllocFunc(st *parser.CefClassDecl, lt *LogTag) %}
// Alloc{%s st.GoName()%} allocates {%s st.GoName() %} and construct it
func Alloc{%s st.GoName()%}() *{%s st.GoName()%} {
	up := c_calloc(1, C.sizeof_cefingo_{%s st.BaseName() %}_wrapper_t, "{%s lt.NextTag() %}:")
	cefp := C.cefingo_construct_{%s st.BaseName() %}((*C.cefingo_{%s st.BaseName() %}_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to {%s st.CefName() %} itself in DeassocFunc,
		// or {%s st.CefName() %} is never GCed.
		Tracef(up, "{%s lt.NextTag() %}:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		{%- for c := st; c != nil; c = c.GetBase() -%}
		{%- for _, m:= range c.Methods -%}
		delete({%s st.BaseName() %}_handlers.{%= memberName(m) %}, cefp)
		{%- endfor -%}
		{%- endfor -%}
	}))

	return new{%s st.GoName() %}(cefp)
}
{% endfunc %}

{% func methodCTypeName(m *parser.MethodDecl) -%}
{% code callee := strings.Replace(m.CalleeName(), "::", "_", 1) -%}
T_{%s strings.ToUpper(callee) -%}
{% endfunc %}

{% func constructorName(st *parser.CefClassDecl) -%}
{%s st.CefName() + " *cefingo_construct_" + st.BaseName() + "(cefingo_" + st.BaseName() + "_wrapper_t* " + st.BaseName() + ")" -%}
{% endfunc %}

{% func CConstruct(st *parser.CefClassDecl, lt *LogTag) %}
{% for _, m := range st.Methods -%}
{% if m.HasConstParams() -%}
typedef {%s m.ReturnType().CType() -%}
 (*{%s methodCTypeName(m) %})(
{% for i, p := range m.Params() -%}
{% if i > 0 %},
{% endif %}	{%s p.CType() -%}
{% endfor%}
);
{% endif -%}
{% endfor -%}

{%s constructorName(st) %}
{
	initialize_cefingo_base_ref_counted(
		offsetof(__typeof__(*{%s st.BaseName() %}), counter),
		(cef_base_ref_counted_t*) {%s st.BaseName() %});
	
	// callbacks
	{%- code base := "" -%}
	{%- for c := st; c != nil; c = c.GetBase() -%}
	{%- for _, m := range c.Methods -%}
	{%s st.BaseName() %}->body{%s base %}.{%s m.Funcname.Name() %} ={% if m.HasConstParams() %} ({%s methodCTypeName(m) %}){% endif %}
		cefingo_{%s st.BaseName() %}_{%s m.Funcname.Name() %};
	{%- endfor -%}
	{%- code base = base + ".base"-%}
	{%- endfor -%}

	return ({%s st.CefName() %}*){%s st.BaseName() %};
}
{% endfunc %}

{% func HCallback(st *parser.CefClassDecl, lt *LogTag) %}
CEFINGO_REF_COUNTER_WRAPPER(cef_{%s st.BaseName() %}_t, cefingo_{%s st.BaseName() %}_wrapper_t);
extern {%s constructorName(st) %};
{% endfunc %}

{% func preConvToC(p parser.Param, lt *LogTag) -%}
{% if p.IsOutParam() -%}
	{%- if ok, argLen := p.IsByteSliceParam(); ok -%}
	{%s argLen %} := len({%s goParamName(p) %})
	{%s cTempName(p) %} := c_calloc(1, C.size_t({%s argLen %}), "{%s lt.NextTag() %}:{%s p.CalleeName() + "::" + p.Name() %}")
	{%- elseif isSlice, argLen := p.IsSliceParam(); isSlice -%}
	var _{%s argLen %} C.size_t
	{%s argLen %} := &_{%s argLen %}
	var {%s cTempName(p) %} {%s p.Type().Deref().GoCType() %}
	{%- elseif p.Type().Ty == parser.TyStringT -%}
	{%s cTempName(p) %} := create_cef_string("")
	defer clear_cef_string({%s cTempName(p) %})
	{%- else -%}
	var {%s cTempName(p) %} {%s p.Type().Deref().GoCType() %}
	{%- endif -%}
{% elseif ok, argLen := p.IsByteSliceParam(); ok && !p.IsInOutParam() -%}
	{%s argLen %} := len({%s goParamName(p) %})
	{%s cTempName(p) %} := C.CBytes({%s goParamName(p) %})
{% elseif ok, argLen := p.IsSliceParam(); ok -%}
	{%s argLen %} := len({%s goParamName(p) %})
	{%s cTempName(p) %} := c_calloc(C.size_t({%s argLen %}), (C.size_t)(unsafe.Sizeof({%= goParamName(p) %}[0])), "{%s lt.NextTag() %}:{%s p.CalleeName() + "::" + p.Name() %}")
	slice := (*[1 << 30]{%s p.Type().Deref().GoCType() %})({%s cTempName(p) %})[:{%s argLen %}:{%s argLen %}]
	for i, v := range {%s goParamName(p) %} {
		cefp := v.p_{%s p.Type().BaseName() %}
		if cefp != nil {
			BaseAddRef(cefp)
		}
		slice[i] = cefp
	}
{% elseif p.Type().IsRefCountedClass() -%}
	var {%= goTempName(p) %} {%s p.GoCType() %} 
	if {%= goParamName(p) %} != nil {
		{%= goTempName(p) %} = {%s goParamName(p) %}.p_{%s p.Type().BaseName() %}
		BaseAddRef({%= goTempName(p) %})
	}
{% else -%}
{% switch p.GoType() -%}
{% case "bool" -%}
	var {%s cTempName(p) %} int
	if {%s goParamName(p) %} {
		{%s cTempName(p) %} = 1
	}
{% case "string" -%}
	{%s cName(p) %} := create_cef_string({%s goParamName(p) %})
	defer clear_cef_string({%s cName(p) %})
{% case "time.Time" -%}
	{%s cName(p) %} := {%s goParamName(p) %}.Unix()
{% endswitch -%}
{% endif -%}
{% endfunc %}

{% func cName(p parser.Param) -%}
{% switch p.Type().GoType() -%}
{% case "string", "*time.Time", "time.Time" -%}
c_{% endswitch %}{%s goParamName(p) -%}
{% endfunc %}

{% func cTempName(p parser.Param) -%}
tmp{%= cName(p) -%}
{% endfunc %}

{% func convToC(p parser.Param, lt *LogTag) -%}
{% if p.IsOutParam() -%}
	{%- if ok, _ := p.IsByteSliceParam(); ok -%}
	{%-s= cTempName(p) -%}
	{%- elseif p.Type().Ty == parser.TyStringT -%}
	{%-s= cTempName(p) -%}
	{%- else -%}
	{%-s= "&" + cTempName(p) -%}
	{%- endif -%}
{% elseif p.IsRefCountedClass() -%}
	{%- if p.Name() == "self" -%}self.p_{%s p.Type().BaseName() -%}
	{%- else %}{%s goTempName(p) %}{% endif -%}
{% elseif p.IsScopedClass() -%}
	{%-s cName(p) %}.p_{%s p.Type().BaseName() -%}
{% elseif ok, _ := p.IsByteSliceParam(); ok && !p.IsInOutParam() -%}
	{%-s= cTempName(p) -%}
{% elseif ok, _ := p.IsSliceParam(); ok -%}
	({%s p.GoCType() %})({%-= cTempName(p) -%}{%s ")" -%}
{% else -%}
	{%- switch p.GoType() -%}
	{%- case "bool" -%}
		{%-s p.GoCType() %}({%-s cTempName(p) + ")" -%}
	{%- case "*time.Time" -%}
		{%-s= "&" + cName(p) -%}
	{%- case "time.Time" -%}
		{%-s "C.time_t(" + cName(p) + ")" -%}
	{%- case "unsafe.Pointer" -%}{% code log.Printf("T335: %s::%s\n", p.CalleeName(), p.Name()) -%}
		{%-s cName(p) -%}
	{%- default -%}
		{%-s "(" + p.GoCType() + ")(" %}{%s cName(p) %}{%s ")" -%}
	{%- endswitch -%}
{% endif -%}
{% endfunc %}

{% func postConvFromC(p parser.Param, lt *LogTag) -%}
{% if p.IsOutParam() -%}
	{%- if isSlice, argLen := p.IsByteSliceParam(); isSlice -%}
	{%s goParamName(p) %} = C.GoBytes({%s cTempName(p) %}, C.int({%s argLen %}))
	C.free({%s cTempName(p) %})
	{%- elseif isSlice, argLen := p.IsSliceParam(); isSlice -%}
	{%s goParamName(p) %} = make([]{%s p.Type().Deref().GoType() %}, *{%s argLen %})
	_{%s cTempName(p) %} := (*[1 << 30]({%s p.Type().Deref().GoCType() %}))(unsafe.Pointer({%s cTempName(p) %}))[:*{%s argLen %}:*{%s argLen %}]
	for i := C.size_t(0); i {%s= "<" %} *{%s argLen %}; i++ {
		{%s goParamName(p) %}[i] = new{%s p.Type().Deref().Deref().GoType() %}(_{%s cTempName(p) %}[i])
	}
	{%- elseif p.Type().Ty == parser.TyStringT -%}
	{%s goParamName(p) %} = string_from_cef_string({%s cTempName(p) %})
	{%- elseif p.Type().Deref().IsRefCountedClass() -%}
	{%s goParamName(p) %} = new{%s p.Type().Deref().Deref().GoType() %}({%s cTempName(p) %})
	{%- elseif p.Type().Ty == parser.TyTimeT %}
	{%s goParamName(p) %} = time.Unix(int64({%= cTempName(p) %}), 0)
	{%- else -%}
	{%s goParamName(p) %} = ({%s p.Type().Deref().GoType() %})({%s cTempName(p) %})
	{%- endif -%}
{% elseif ok, _ := p.IsByteSliceParam(); ok && !p.IsInOutParam() -%}
	C.free({%s cTempName(p) %})
{% endif -%}
{% endfunc %}

{% func GoFunction(f *parser.FuncDecl, lt *LogTag) -%}
func {%s f.Funcname.TitleCase() %}(
	{%- for _, p := range f.Params() -%}
	{%- if !p.IsByteSliceLengthParam() && !p.IsSliceLengthParam() && !p.IsOutParam() -%}
	{%s goParamName(p) %} {%s p.GoType() %},
	{%- endif -%}
	{%- endfor -%}
) {%= retTypes(f) %}{
	{%- for _, p := range f.Params() -%}
		{%- if exp := preConvToC(p, lt); exp != "" -%}
			{%-s= exp -%}
		{%- endif -%}
	{%- endfor %}
	{% if f.HasReturnValue() %}cRet := {% endif %}C.{%s f.CefName() %}({% for i, p := range f.Params() -%}
	{%- if i > 0 %}, {% endif %}{%= convToC(p, lt) -%}
	{%- endfor %})

	{%- for _, p := range f.Params() -%}{%= postConvFromC(p, lt) %}{%endfor -%}
	{%= goReturnStmt(f) %}
}
{% endfunc %}

Generate Go func Return Types
{% func retTypes(m parser.Callable) -%}
{% if m.HasReturnValue() || m.HasOutParam() -%}
({% if m.HasReturnValue() -%}ret {%s m.ReturnGoType() -%},{%- endif -%}
{% for _, p := range m.Params() -%}
{% if p.IsOutParam() || p.IsInOutParam() -%}
{%s goParamNameOut(p) + " " -%}
{% if p.Type().Ty == parser.TyStringT && p.Type().Pointer == 1 -%}
	{%-s p.Type().GoType() -%}
{% elseif isSlice, _ := p.IsSliceParam(); isSlice -%}
	{%-s "[]" + p.Type().Deref().GoType() -%}
{% elseif isSlice, _ := p.IsByteSliceParam(); isSlice -%}
	{%-s "[]byte" -%}
{% elseif p.IsBoolParam() -%}
	{%-s "bool" -%}
{% else -%}
	{%-s p.Type().Deref().GoType() -%}
{% endif -%}
, {% endif -%}
{% endfor -%}
{%s ")" -%}
{% endif -%}
{% endfunc %}

Generate Go method call to object method (self->method(...))
{% func CefObjectMethod(m *parser.MethodDecl, lt *LogTag) %}
{% for _, c := range m.Comment -%}
{%s c %}
{% endfor -%}
func  ({%s goParamName(m.Params()[0]) %} {%s m.Params()[0].GoType() %}) {%s m.Funcname.TitleCase() %}(
{% for i, p := range m.Params() -%}
	{%- if i > 0 && !p.IsOutParam() -%}
	{%- if !p.IsByteSliceLengthParam() && !p.IsSliceLengthParam() -%}
	{%s goParamName(p) %} {%s p.GoType() %},
	{%- endif -%}
	{%- endif -%}
{% endfor -%}
) {%= retTypes(m) %}{
	{%- for i, p := range m.Params() -%}
	{%- if !(i == 0 && p.Name() == "self") -%}
		{%- if stmts := preConvToC(p, lt); stmts != "" -%}
			{%-s= stmts -%}
		{%- endif -%}
	{%- endif -%}
	{%- endfor %}
	{% if m.HasReturnValue() %}cRet := {% endif %}C.{%s methodCName(m) %}({% for i, p := range m.Params() -%}
	{%- if i > 0 %}, {% endif %}{%= convToC(p, lt) -%}
	{%- endfor %})

	{%- for _, p := range m.Params() -%}{%= postConvFromC(p, lt) %}{%endfor -%}
	{%-= goReturnStmt(m) %}
}
{% endfunc %}

{% func goReturnStmt(m parser.Callable) -%}
	{%- if m.HasReturnValue() -%}
	{%- if m.IsBoolValueMethod() %}
	ret = cRet == 1
	{%- elseif m.ReturnType().Ty == parser.TyStringUserfreeT %}
	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	{%- else %}
	ret = {%s ConvToGoTypeExp(m.ReturnType(), "cRet") %}
	{%- endif -%}
	{%- endif -%}
	{%- if m.HasReturnValue() || m.HasOutParam() -%}{% code first := true -%}
	return {%if m.HasReturnValue() %}ret{%code first = false %}{% endif -%}
	{%- for _, p := range m.Params() -%}
		{%- if p.IsOutParam() || p.IsInOutParam() -%}
			{%- if !first %}, {% endif %}{%s goParamName(p) %}{%code first = false -%}
		{%- endif -%}
	{%- endfor -%}
	{%- endif -%}
{% endfunc %}

{% func methodCName(m *parser.MethodDecl) -%}
{%s "cefingo_" + m.ClassBaseName() + "_" + m.Funcname.Name() -%}
{% endfunc %}

{% func methodCSig(m *parser.MethodDecl) -%}
{%s m.ReturnType().CType() %} {%s methodCName(m) %}(
{% for i, p := range m.Params() -%}
{% if i > 0 %},
{% endif -%}
	{%s p.CType() %} {%s p.Name() -%}
{% endfor %}
{%s ")" -%}
{% endfunc %}

{% func CefObjectMethodH(m *parser.MethodDecl) %}
extern {%s methodCSig(m) %};
{% endfunc %}

{% func CefObjectMethodC(m *parser.MethodDecl) %}
{% code retGoType := m.ReturnGoType() -%}
{%s methodCSig(m) %}
{
	{% if retGoType != "" %}return {% endif %}self->{%s m.Funcname.Name() %}(
		{%- for i, p := range m.Params() -%}
		{%- if i > 0 %},
		{%- endif -%}
		{%s p.Name() -%}
		{%- endfor %}
	);
}
{% endfunc %}

// newCXxxxT()
{% func GoType(d *parser.CefClassDecl, lt *LogTag) %}
{% code goName := d.GoName()
	typeName := d.BaseName()
	cName := d.CefName()
-%}
// Go type for {%s cName %}	
type {%s goName %} struct {
	noCopy noCopy
	p_{%s typeName %} *C.{%s cName %}
}

type RefTo{%s goName %} struct {
	p_{%s typeName %} *{%s goName %}
}

type {%s goName %}Accessor interface {
	Get{%s goName %}() *{%s goName %}
	Set{%s goName %}(*{%s goName %})
}

func (r RefTo{%s goName %}) Get{%s goName %}() *{%s goName %} {
	return r.p_{%s typeName %}
}

func (r *RefTo{%s goName %}) Set{%s goName %}(p *{%s goName %}) {
	r.p_{%s typeName %} = p
}

// Go type {%s goName %} wraps cef type *C.{%s cName %}
func new{%s goName %}(p *C.{%s cName %}) *{%s goName %} {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "{%s lt.NextTag() %}:")
	{%- if d.St == parser.StRefCounted -%}
	BaseAddRef(p)
	{%- endif -%}
	go_{%s typeName %} := {%s goName %}{noCopy{}, p}
	{%- if d.St == parser.StRefCounted -%}
	runtime.SetFinalizer(&go_{%s typeName %}, func(g *{%s goName %}) {
		Tracef(unsafe.Pointer(g.p_{%s typeName %}), "{%s lt.NextTag() %}:")
		BaseRelease(g.p_{%s typeName %})
	})
	{%- endif -%}
	return &go_{%s typeName %}
}
{% if d.St == parser.StRefCounted -%}
// *C.{%s cName %} has refCounted interface
func ({%s typeName %} *{%s goName %}) HasOneRef() bool {
	return BaseHasOneRef({%s typeName %}.p_{%s typeName %})
}

func (p *C.{%s cName %}) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}
{% endif -%}
{% if p := d.GetBase(); p != nil %}
func ({%s typeName %} *{%s goName %}) To{%s p.GoName() %}() *{%s p.GoName() %}{
	p := (*C.{%s p.CefName() %})(unsafe.Pointer({%s typeName %}.p_{%s typeName %}))
	return new{%s p.GoName() %}(p)
}
{% endif -%}
{% endfunc %}

{% func cField(f string) -%}
{% if f == "type" || f == "range" %}_{%s f %}{% else %}{%s f %}{% endif -%}
{% endfunc %}

{% func castGoType(s string) -%}
{% if s == "C.VOIDP" -%}unsafe.Pointer{% else %}{%s s %}{% endif %}{% endfunc %}

{% func MemberAccessor(d *parser.StructDecl, m parser.Member) -%}
func (st *{%s d.GoName() %}) {%s m.GoName() %}() {%s m.GoType() %} {
{% if m.Type().Ty == parser.TyStringT && m.Type().Pointer == 0 -%}
	return string_from_cef_string(&st.{%s cField(m.Name()) %})
{% elseif m.IsBoolMember() -%}
	return st.{%s cField(m.Name()) %} != 0
{% else -%}
	return {%s m.GoType() %}(st.{%s cField(m.Name()) %})
{% endif -%}
}

func (st *{%s d.GoName() %}) Set{%s m.GoName() %}(v {%s m.GoType() %}) {
{% if m.Type().Ty == parser.TyStringT && m.Type().Pointer == 0 -%}
	set_cef_string(&st.{%s cField(m.Name()) %}, v)
{% elseif m.IsBoolMember() -%}
	if v {
		st.{%s cField(m.Name()) %} = 1
	} else {
		st.{%s cField(m.Name()) %} = 0
	}
{% else -%}
	st.{%s cField(m.Name()) %} = ({%s castGoType(m.Type().GoCType()) %})(v)
{% endif -%}
}

{% endfunc %}

{% func NewStruct(d *parser.StructDecl) -%}
func New{%s d.GoName() %}() *{%s d.GoName() %} {
	s := &{%s d.GoName() %}{}
	{%- if d.Members[0].Type().Ty == parser.TySizeT && d.Members[0].Name() == "size" -%}
	s.size = C.sizeof_{%s d.CefName() %}
	{%- endif -%}
	return s
}

{% endfunc %}