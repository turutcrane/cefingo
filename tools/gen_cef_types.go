//
// cefingo go type generator for cef type with cef_base_ref_counted_t base member
//
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	strcase "github.com/stoewer/go-strcase"
)

var output *string

func init () {
	var outputName string
	if dir, err := os.Getwd(); err == nil {
		baseName := fmt.Sprintf("cefingo_types.go")
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	} else {
		log.Fatal(err)
	}
	output = flag.String("output", outputName, "output file name; default srcdir/cefingo_types.go")
}

var cef_types = []string{
	"cef_app_t",
	"cef_binary_value_t",
	"cef_browser_t",
	"cef_browser_host_t",
	"cef_browser_process_handler_t",
	"cef_callback_t",
	"cef_client_t",
	"cef_dictionary_value_t",
	"cef_frame_t",
	"cef_life_span_handler_t",
	"cef_list_value_t",
	"cef_load_handler_t",
	"cef_process_message_t",
	"cef_render_process_handler_t",
	"cef_request_t",
	"cef_resource_handler_t",
	"cef_response_t",
	"cef_scheme_handler_factory_t",
	"cef_run_file_dialog_callback_t",
	"cef_v8array_buffer_release_callback_t",
	"cef_v8context_t",
	"cef_v8exception_t",
	"cef_v8handler_t",
	"cef_v8value_t",
	"cef_v8stack_trace_t",
	"cef_value_t",
}

func main() {
	flag.Parse()
	g := Generator{}

	// Print the header and package clause.
	g.Printf("// Code generated by \"gen_cef_types.go\" DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package %s", "capi")
	g.Printf("\n")
	g.Printf(`
import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"
`)

	for _, s := range cef_types {
		genGotype(&g, s)
	}

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := *output
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func genGotype(g *Generator, t string) {
	typeName := strings.Replace(t, "cef_", "", 1)
	camel := strcase.UpperCamelCase(typeName)
	tailT := regexp.MustCompile("_t$")
	typeName = tailT.ReplaceAllString(typeName, "")
	log.Printf("T124: %s: %s", typeName, camel)

	// container of *C.cef_type
	g.Printf(`
// Go type for %[1]s	
type C%[2]s struct {
	p_%[3]s *C.%[1]s
}
`,
		t, camel, typeName,
	)

	// Reference to CType
	g.Printf(`
type RefToC%[1]s struct {
	p_%[2]s *C%[1]s
}
`,
		camel, typeName,
	)

	// interface of accessor to *CType
	g.Printf(`
type C%[1]sAccessor interface {
	GetC%[1]s() *C%[1]s
	SetC%[1]s(*C%[1]s)
}

func (r RefToC%[1]s) GetC%[1]s() *C%[1]s {
	return r.p_%[2]s
}

func (r *RefToC%[1]s) SetC%[1]s(p *C%[1]s) {
	r.p_%[2]s = p
}
`,
		camel, typeName,
	)

	b := g.buf.Bytes()
	line := bytes.Count(b, []byte("\n"))

	g.Printf(`
// Go type C%[1]s wraps cef type *C.%[2]s
func newC%[1]s(p *C.%[2]s) *C%[1]s {
	Tracef(unsafe.Pointer(p), "T%[4]d:")
	BaseAddRef(p)
	go_%[3]s := C%[1]s{p}
	runtime.SetFinalizer(&go_%[3]s, func(g *C%[1]s) {
		Tracef(unsafe.Pointer(g.p_%[3]s), "T%[5]d:")
		BaseRelease(g.p_%[3]s)
	})
	return &go_%[3]s
}
`,
		camel, t, typeName,
		line+4, line+8,
	)

	g.Printf(`
// *C.%[1]s has refCounted interface
func (p *C.%[1]s) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}
`,
		t,
	)
}
