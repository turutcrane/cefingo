//
// cefingo go type generator for cef type with cef_base_ref_counted_t base member
//
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	strcase "github.com/stoewer/go-strcase"
)

var (
	output = flag.String("output", "", "output file name; default srcdir/cefingo_types.go")
)

var cef_types = []string{
	"cef_app_t",
	"cef_binary_value_t",
	"cef_browser_t",
	"cef_browser_host_t",
	"cef_browser_process_handler_t",
	"cef_callback_t",
	"cef_client_t",
	"cef_dictionary_value_t",
	"cef_frame_t",
	"cef_life_span_handler_t",
	"cef_list_value_t",
	"cef_load_handler_t",
	"cef_process_message_t",
	"cef_render_process_handler_t",
	"cef_request_t",
	"cef_resource_handler_t",
	"cef_response_t",
	"cef_scheme_handler_factory_t",
	"cef_run_file_dialog_callback_t",
	"cef_v8array_buffer_release_callback_t",
	"cef_v8context_t",
	"cef_v8exception_t",
	"cef_v8handler_t",
	"cef_v8value_t",
	"cef_v8stack_trace_t",
	"cef_value_t",
}

func main() {
	flag.Parse()
	g := Generator{}

	// Print the header and package clause.
	g.Printf("// Code generated by \"gen_cef_types.go\" DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package %s", "capi")
	g.Printf("\n")
	g.Printf(`
import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"
`)

	for _, s := range cef_types {
		genGotype(&g, s)
	}

	// Format the output.
	src := g.format()

	// Write to file.
	outputName := *output
	if outputName == "" {
		if dir, err := os.Getwd(); err == nil {
			baseName := fmt.Sprintf("cefingo_types.go")
			outputName = filepath.Join(dir, strings.ToLower(baseName))
		} else {
			log.Fatal(err)
		}
	}
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func genGotype(g *Generator, t string) {
	typeName := strings.Replace(t, "cef_", "", 1)
	camel := strcase.UpperCamelCase(typeName)
	tailT := regexp.MustCompile("_t$")
	typeName = tailT.ReplaceAllString(typeName, "")
	log.Printf("A124: %s: %s", typeName, camel)

	// container of *C.cef_type
	g.Printf(`
// Go type for %s	
type C%s struct {
	p_%s *C.%s
}
`, t, camel, typeName, t)

	// Reference to CType
	g.Printf(`
type RefToC%s struct {
	p_%s *C%s
}
`,
		camel, typeName, camel,
	)

	// interface of accessor to *CType
	g.Printf(`
type C%sAccessor interface {
	GetC%s() *C%s
	SetC%s(*C%s)
}

func (r RefToC%s) GetC%s() *C%s {
	return r.p_%s
}

func (r *RefToC%s) SetC%s(p *C%s) {
	r.p_%s = p
}
`,
		camel, camel, camel, camel, camel,
		camel, camel, camel, typeName,
		camel, camel, camel, typeName,
	)

	b := g.buf.Bytes()
	line := bytes.Count(b, []byte("\n"))

	g.Printf(`
// Go type C%s wraps cef type *C.%s
func newC%s(p *C.%s) *C%s {
	Tracef(unsafe.Pointer(p), "L%d:")
	BaseAddRef(p)
	go_%s := C%s{p}
	runtime.SetFinalizer(&go_%s, func(g *C%s) {
		Tracef(unsafe.Pointer(g.p_%s), "L%d:")
		BaseRelease(g.p_%s)
	})
	return &go_%s
}
`,
		camel, t,
		camel, t, camel,
		line+4,
		typeName, camel,
		typeName, camel,
		typeName, line+8,
		typeName,
		typeName,
	)

	g.Printf(`
// *C.%s has refCounted interface
func (p *C.%s) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}
`,
		t, t)
}
