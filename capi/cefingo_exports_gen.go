// Code generated by "gen-cefingo.go" DO NOT EDIT.

package capi

import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"

///
// Called after renderer process sends accessibility tree changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_tree_change
func cefingo_accessibility_handler_on_accessibility_tree_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T101.5:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_tree_change_handler[(*cCAccessibilityHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAccessibilityHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpvalue := newCValueT(value, byApi)

		f.OnAccessibilityTreeChange(goTmpself, goTmpvalue)

	} else {
		Logf("T101.6: on_accessibility_tree_change: Noo!")
	}
	BaseRelease((*cCValueT)(value)) // byApi

}

///
// Called after renderer process sends accessibility location changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_location_change
func cefingo_accessibility_handler_on_accessibility_location_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T101.7:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_location_change_handler[(*cCAccessibilityHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAccessibilityHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpvalue := newCValueT(value, byApi)

		f.OnAccessibilityLocationChange(goTmpself, goTmpvalue)

	} else {
		Logf("T101.8: on_accessibility_location_change: Noo!")
	}
	BaseRelease((*cCValueT)(value)) // byApi

}

///
// Provides an opportunity to view and/or modify command-line arguments before
// processing by CEF and Chromium. The |process_type| value will be NULL for
// the browser process. Do not keep a reference to the cef_command_line_t
// object passed to this function. The CefSettings.command_line_args_disabled
// value can be used to start with an NULL command-line object. Any values
// specified in CefSettings that equate to command-line arguments will be set
// before this function is called. Be cautious when using this function to
// modify command-line arguments for non-browser processes as this may result
// in undefined behavior including crashes.
///
//export cefingo_app_on_before_command_line_processing
func cefingo_app_on_before_command_line_processing(
	self *C.cef_app_t,
	process_type *C.cef_string_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.5:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_before_command_line_processing_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAppT(self, byApi)
		// !p.IsOutParam
		goTmpprocess_type := string_from_cef_string(process_type)
		// !p.IsOutParam
		goTmpcommand_line := newCCommandLineT(command_line, byApi)

		f.OnBeforeCommandLineProcessing(goTmpself, goTmpprocess_type, goTmpcommand_line)

	} else {
		Logf("T102.6: on_before_command_line_processing: Noo!")
	}
	BaseRelease((*cCCommandLineT)(command_line)) // byApi

}

///
// Provides an opportunity to register custom schemes. Do not keep a reference
// to the |registrar| object. This function is called on the main thread for
// each process and the registered schemes should be the same across all
// processes.
///
//export cefingo_app_on_register_custom_schemes
func cefingo_app_on_register_custom_schemes(
	self *C.cef_app_t,
	registrar *C.cef_scheme_registrar_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.7:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_register_custom_schemes_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAppT(self, byApi)
		// !p.IsOutParam
		goTmpregistrar := newCSchemeRegistrarT(registrar)

		f.OnRegisterCustomSchemes(goTmpself, goTmpregistrar)

	} else {
		Logf("T102.8: on_register_custom_schemes: Noo!")
	}

}

///
// Return the handler for resource bundle events. If
// CefSettings.pack_loading_disabled is true (1) a handler must be returned.
// If no handler is returned resources will be loaded from pack files. This
// function is called by the browser and render processes on multiple threads.
///
//export cefingo_app_get_resource_bundle_handler
func cefingo_app_get_resource_bundle_handler(
	self *C.cef_app_t,
) (cRet *C.cef_resource_bundle_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.9:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.get_resource_bundle_handler_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAppT(self, byApi)

		goRet := f.GetResourceBundleHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_resource_bundle_handler) // return GoObj
			}
			cRet = (*C.cef_resource_bundle_handler_t)(goRet.pc_resource_bundle_handler)
		}
	} else {
		Logf("T102.10: get_resource_bundle_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for functionality specific to the browser process. This
// function is called on multiple threads in the browser process.
///
//export cefingo_app_get_browser_process_handler
func cefingo_app_get_browser_process_handler(
	self *C.cef_app_t,
) (cRet *C.cef_browser_process_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.11:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.get_browser_process_handler_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAppT(self, byApi)

		goRet := f.GetBrowserProcessHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_browser_process_handler) // return GoObj
			}
			cRet = (*C.cef_browser_process_handler_t)(goRet.pc_browser_process_handler)
		}
	} else {
		Logf("T102.12: get_browser_process_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for functionality specific to the render process. This
// function is called on the render process main thread.
///
//export cefingo_app_get_render_process_handler
func cefingo_app_get_render_process_handler(
	self *C.cef_app_t,
) (cRet *C.cef_render_process_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.13:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.get_render_process_handler_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAppT(self, byApi)

		goRet := f.GetRenderProcessHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_render_process_handler) // return GoObj
			}
			cRet = (*C.cef_render_process_handler_t)(goRet.pc_render_process_handler)
		}
	} else {
		Logf("T102.14: get_render_process_handler: Noo!")
	}

	return cRet
}

///
// Called on the UI thread to allow configuration of audio stream parameters.
// Return true (1) to proceed with audio stream capture, or false (0) to
// cancel it. All members of |params| can optionally be configured here, but
// they are also pre-filled with some sensible defaults.
///
//export cefingo_audio_handler_get_audio_parameters
func cefingo_audio_handler_get_audio_parameters(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	params *C.cef_audio_parameters_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.5:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.get_audio_parameters_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAudioHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpparams := (*CAudioParametersT)(params)

		goRet := f.GetAudioParameters(goTmpself, goTmpbrowser, goTmpparams)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T103.6: get_audio_parameters: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called on a browser audio capture thread when the browser starts streaming
// audio. OnAudioStreamStopped will always be called after
// OnAudioStreamStarted; both functions may be called multiple times for the
// same browser. |params| contains the audio parameters like sample rate and
// channel layout. |channels| is the number of channels.
///
//export cefingo_audio_handler_on_audio_stream_started
func cefingo_audio_handler_on_audio_stream_started(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	params *C.cef_audio_parameters_t,
	channels C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.7:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_started_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAudioHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpparams := (*CAudioParametersT)(params)
		// !p.IsOutParam
		goTmpchannels := (int)(channels)

		f.OnAudioStreamStarted(goTmpself, goTmpbrowser, goTmpparams, goTmpchannels)

	} else {
		Logf("T103.8: on_audio_stream_started: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called on the UI thread when the stream has stopped. OnAudioSteamStopped
// will always be called after OnAudioStreamStarted; both functions may be
// called multiple times for the same stream.
///
//export cefingo_audio_handler_on_audio_stream_stopped
func cefingo_audio_handler_on_audio_stream_stopped(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.9:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_stopped_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAudioHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnAudioStreamStopped(goTmpself, goTmpbrowser)

	} else {
		Logf("T103.10: on_audio_stream_stopped: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called on the UI or audio stream thread when an error occurred. During the
// stream creation phase this callback will be called on the UI thread while
// in the capturing phase it will be called on the audio stream thread. The
// stream will be stopped immediately.
///
//export cefingo_audio_handler_on_audio_stream_error
func cefingo_audio_handler_on_audio_stream_error(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	message *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.11:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_error_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCAudioHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpmessage := string_from_cef_string(message)

		f.OnAudioStreamError(goTmpself, goTmpbrowser, goTmpmessage)

	} else {
		Logf("T103.12: on_audio_stream_error: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called asynchronously after the file dialog is dismissed.
// |selected_accept_filter| is the 0-based index of the value selected from
// the accept filters array passed to cef_browser_host_t::RunFileDialog.
// |file_paths| will be a single value or a list of values depending on the
// dialog mode. If the selection was cancelled |file_paths| will be NULL.
///
//export cefingo_run_file_dialog_callback_on_file_dialog_dismissed
func cefingo_run_file_dialog_callback_on_file_dialog_dismissed(
	self *C.cef_run_file_dialog_callback_t,
	selected_accept_filter C.int,
	file_paths C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T107.5:")
	cefingoIfaceAccess.Lock()
	f := run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler[(*cCRunFileDialogCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRunFileDialogCallbackT(self, byApi)
		// !p.IsOutParam
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		// !p.IsOutParam
		goTmpfile_paths := (CStringListT)(file_paths)

		f.OnFileDialogDismissed(goTmpself, goTmpselected_accept_filter, goTmpfile_paths)

	} else {
		Logf("T107.6: on_file_dialog_dismissed: Noo!")
	}

}

///
// Method that will be executed. Do not keep a reference to |entry| outside of
// this callback. Return true (1) to continue visiting entries or false (0) to
// stop. |current| is true (1) if this entry is the currently loaded
// navigation entry. |index| is the 0-based index of this entry and |total| is
// the total number of entries.
///
//export cefingo_navigation_entry_visitor_visit
func cefingo_navigation_entry_visitor_visit(
	self *C.cef_navigation_entry_visitor_t,
	entry *C.cef_navigation_entry_t,
	current C.int,
	index C.int,
	total C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T108.5:")
	cefingoIfaceAccess.Lock()
	f := navigation_entry_visitor_handlers.visit_handler[(*cCNavigationEntryVisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCNavigationEntryVisitorT(self, byApi)
		// !p.IsOutParam
		goTmpentry := newCNavigationEntryT(entry, byApi)
		// !p.IsOutParam
		goTmpcurrent := current != 0
		// !p.IsOutParam
		goTmpindex := (int)(index)
		// !p.IsOutParam
		goTmptotal := (int)(total)

		goRet := f.Visit(goTmpself, goTmpentry, goTmpcurrent, goTmpindex, goTmptotal)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T108.6: visit: Noo!")
	}
	BaseRelease((*cCNavigationEntryT)(entry)) // byApi

	return cRet
}

///
// Method that will be executed when the PDF printing has completed. |path| is
// the output path. |ok| will be true (1) if the printing completed
// successfully or false (0) otherwise.
///
//export cefingo_pdf_print_callback_on_pdf_print_finished
func cefingo_pdf_print_callback_on_pdf_print_finished(
	self *C.cef_pdf_print_callback_t,
	path *C.cef_string_t,
	ok C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T109.5:")
	cefingoIfaceAccess.Lock()
	f := pdf_print_callback_handlers.on_pdf_print_finished_handler[(*cCPdfPrintCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCPdfPrintCallbackT(self, byApi)
		// !p.IsOutParam
		goTmppath := string_from_cef_string(path)
		// !p.IsOutParam
		goTmpok := ok != 0

		f.OnPdfPrintFinished(goTmpself, goTmppath, goTmpok)

	} else {
		Logf("T109.6: on_pdf_print_finished: Noo!")
	}

}

///
// Called on the browser process UI thread immediately after the CEF context
// has been initialized.
///
//export cefingo_browser_process_handler_on_context_initialized
func cefingo_browser_process_handler_on_context_initialized(
	self *C.cef_browser_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.5:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_context_initialized_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserProcessHandlerT(self, byApi)

		f.OnContextInitialized(goTmpself)

	} else {
		Logf("T112.6: on_context_initialized: Noo!")
	}

}

///
// Called before a child process is launched. Will be called on the browser
// process UI thread when launching a render process and on the browser
// process IO thread when launching a GPU process. Provides an opportunity to
// modify the child process command line. Do not keep a reference to
// |command_line| outside of this function.
///
//export cefingo_browser_process_handler_on_before_child_process_launch
func cefingo_browser_process_handler_on_before_child_process_launch(
	self *C.cef_browser_process_handler_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.7:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_before_child_process_launch_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpcommand_line := newCCommandLineT(command_line, byApi)

		f.OnBeforeChildProcessLaunch(goTmpself, goTmpcommand_line)

	} else {
		Logf("T112.8: on_before_child_process_launch: Noo!")
	}
	BaseRelease((*cCCommandLineT)(command_line)) // byApi

}

///
// Called from any thread when work has been scheduled for the browser process
// main (UI) thread. This callback is used in combination with CefSettings.
// external_message_pump and cef_do_message_loop_work() in cases where the CEF
// message loop must be integrated into an existing application message loop
// (see additional comments and warnings on CefDoMessageLoopWork). This
// callback should schedule a cef_do_message_loop_work() call to happen on the
// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
// |delay_ms| is &lt;= 0 then the call should happen reasonably soon. If
// |delay_ms| is &gt; 0 then the call should be scheduled to happen after the
// specified delay and any currently pending scheduled call should be
// cancelled.
///
//export cefingo_browser_process_handler_on_schedule_message_pump_work
func cefingo_browser_process_handler_on_schedule_message_pump_work(
	self *C.cef_browser_process_handler_t,
	delay_ms C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.9:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_schedule_message_pump_work_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpdelay_ms := (int64)(delay_ms)

		f.OnScheduleMessagePumpWork(goTmpself, goTmpdelay_ms)

	} else {
		Logf("T112.10: on_schedule_message_pump_work: Noo!")
	}

}

///
// Return the default client for use with a newly created browser window. If
// null is returned the browser will be unmanaged (no callbacks will be
// executed for that browser) and application shutdown will be blocked until
// the browser window is closed manually. This function is currently only used
// with the chrome runtime.
///
//export cefingo_browser_process_handler_get_default_client
func cefingo_browser_process_handler_get_default_client(
	self *C.cef_browser_process_handler_t,
) (cRet *C.cef_client_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.11:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.get_default_client_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserProcessHandlerT(self, byApi)

		goRet := f.GetDefaultClient(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_client) // return GoObj
			}
			cRet = (*C.cef_client_t)(goRet.pc_client)
		}
	} else {
		Logf("T112.12: get_default_client: Noo!")
	}

	return cRet
}

///
// Called when |browser| associated with |browser_view| is created. This
// function will be called after cef_life_span_handler_t::on_after_created()
// is called for |browser| and before on_popup_browser_view_created() is
// called for |browser|&#39;s parent delegate if |browser| is a popup.
///
//export cefingo_browser_view_delegate_on_browser_created
func cefingo_browser_view_delegate_on_browser_created(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.5:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_browser_created_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser_view := newCBrowserViewT(browser_view, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnBrowserCreated(goTmpself, goTmpbrowser_view, goTmpbrowser)

	} else {
		Logf("T114.6: on_browser_created: Noo!")
	}
	BaseRelease((*cCBrowserViewT)(browser_view)) // byApi
	BaseRelease((*cCBrowserT)(browser))          // byApi

}

///
// Called when |browser| associated with |browser_view| is destroyed. Release
// all references to |browser| and do not attempt to execute any functions on
// |browser| after this callback returns. This function will be called before
// cef_life_span_handler_t::on_before_close() is called for |browser|.
///
//export cefingo_browser_view_delegate_on_browser_destroyed
func cefingo_browser_view_delegate_on_browser_destroyed(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.7:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_browser_destroyed_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser_view := newCBrowserViewT(browser_view, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnBrowserDestroyed(goTmpself, goTmpbrowser_view, goTmpbrowser)

	} else {
		Logf("T114.8: on_browser_destroyed: Noo!")
	}
	BaseRelease((*cCBrowserViewT)(browser_view)) // byApi
	BaseRelease((*cCBrowserT)(browser))          // byApi

}

///
// Called before a new popup BrowserView is created. The popup originated from
// |browser_view|. |settings| and |client| are the values returned from
// cef_life_span_handler_t::on_before_popup(). |is_devtools| will be true (1)
// if the popup will be a DevTools browser. Return the delegate that will be
// used for the new popup BrowserView.
///
//export cefingo_browser_view_delegate_get_delegate_for_popup_browser_view
func cefingo_browser_view_delegate_get_delegate_for_popup_browser_view(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	settings *C.cef_browser_settings_t,
	client *C.cef_client_t,
	is_devtools C.int,
) (cRet *C.cef_browser_view_delegate_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.9:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser_view := newCBrowserViewT(browser_view, byApi)
		// !p.IsOutParam
		goTmpsettings := (*CBrowserSettingsT)(settings)
		// !p.IsOutParam
		goTmpclient := newCClientT(client, byApi)
		// !p.IsOutParam
		goTmpis_devtools := is_devtools != 0

		goRet := f.GetDelegateForPopupBrowserView(goTmpself, goTmpbrowser_view, goTmpsettings, goTmpclient, goTmpis_devtools)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_browser_view_delegate) // return GoObj
			}
			cRet = (*C.cef_browser_view_delegate_t)(goRet.pc_browser_view_delegate)
		}
	} else {
		Logf("T114.10: get_delegate_for_popup_browser_view: Noo!")
	}
	BaseRelease((*cCBrowserViewT)(browser_view)) // byApi
	BaseRelease((*cCClientT)(client))            // byApi

	return cRet
}

///
// Called after |popup_browser_view| is created. This function will be called
// after cef_life_span_handler_t::on_after_created() and on_browser_created()
// are called for the new popup browser. The popup originated from
// |browser_view|. |is_devtools| will be true (1) if the popup is a DevTools
// browser. Optionally add |popup_browser_view| to the views hierarchy
// yourself and return true (1). Otherwise return false (0) and a default
// cef_window_t will be created for the popup.
///
//export cefingo_browser_view_delegate_on_popup_browser_view_created
func cefingo_browser_view_delegate_on_popup_browser_view_created(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	popup_browser_view *C.cef_browser_view_t,
	is_devtools C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.11:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_popup_browser_view_created_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser_view := newCBrowserViewT(browser_view, byApi)
		// !p.IsOutParam
		goTmppopup_browser_view := newCBrowserViewT(popup_browser_view, byApi)
		// !p.IsOutParam
		goTmpis_devtools := is_devtools != 0

		goRet := f.OnPopupBrowserViewCreated(goTmpself, goTmpbrowser_view, goTmppopup_browser_view, goTmpis_devtools)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T114.12: on_popup_browser_view_created: Noo!")
	}
	BaseRelease((*cCBrowserViewT)(browser_view))       // byApi
	BaseRelease((*cCBrowserViewT)(popup_browser_view)) // byApi

	return cRet
}

///
// Returns the Chrome toolbar type that will be available via
// cef_browser_view_t::get_chrome_toolbar(). See that function for related
// documentation.
///
//export cefingo_browser_view_delegate_get_chrome_toolbar_type
func cefingo_browser_view_delegate_get_chrome_toolbar_type(
	self *C.cef_browser_view_delegate_t,
) (cRet C.cef_chrome_toolbar_type_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.13:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_chrome_toolbar_type_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCBrowserViewDelegateT(self, byApi)

		goRet := f.GetChromeToolbarType(goTmpself)

		cRet = (C.cef_chrome_toolbar_type_t)(goRet)
	} else {
		Logf("T114.14: get_chrome_toolbar_type: Noo!")
	}

	return cRet
}

//export cefingo_browser_view_delegate_get_preferred_size
func cefingo_browser_view_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.15:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_preferred_size_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T114.16: get_preferred_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_browser_view_delegate_get_minimum_size
func cefingo_browser_view_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.17:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_minimum_size_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T114.18: get_minimum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_browser_view_delegate_get_maximum_size
func cefingo_browser_view_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.19:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_maximum_size_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T114.20: get_maximum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_browser_view_delegate_get_height_for_width
func cefingo_browser_view_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.21:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_height_for_width_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T114.22: get_height_for_width: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_browser_view_delegate_on_parent_view_changed
func cefingo_browser_view_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.23:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_parent_view_changed_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpparent := newCViewT(parent, byApi)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)

	} else {
		Logf("T114.24: on_parent_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))   // byApi
	BaseRelease((*cCViewT)(parent)) // byApi

}

//export cefingo_browser_view_delegate_on_child_view_changed
func cefingo_browser_view_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.25:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_child_view_changed_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpchild := newCViewT(child, byApi)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)

	} else {
		Logf("T114.26: on_child_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))  // byApi
	BaseRelease((*cCViewT)(child)) // byApi

}

//export cefingo_browser_view_delegate_on_window_changed
func cefingo_browser_view_delegate_on_window_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.27:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_window_changed_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)

		f.OnWindowChanged(goTmpself, goTmpview, goTmpadded)

	} else {
		Logf("T114.28: on_window_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_browser_view_delegate_on_layout_changed
func cefingo_browser_view_delegate_on_layout_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	new_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.29:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_layout_changed_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpnew_bounds := (*CRectT)(new_bounds)

		f.OnLayoutChanged(goTmpself, goTmpview, goTmpnew_bounds)

	} else {
		Logf("T114.30: on_layout_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_browser_view_delegate_on_focus
func cefingo_browser_view_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.31:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_focus_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnFocus(goTmpself, goTmpview)

	} else {
		Logf("T114.32: on_focus: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_browser_view_delegate_on_blur
func cefingo_browser_view_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.33:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_blur_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnBlur(goTmpself, goTmpview)

	} else {
		Logf("T114.34: on_blur: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when |button| is pressed.
///
//export cefingo_button_delegate_on_button_pressed
func cefingo_button_delegate_on_button_pressed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.5:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_button_pressed_handler[(*cCButtonDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCButtonDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbutton := newCButtonT(button, byApi)

		f.OnButtonPressed(goTmpself, goTmpbutton)

	} else {
		Logf("T116.6: on_button_pressed: Noo!")
	}
	BaseRelease((*cCButtonT)(button)) // byApi

}

///
// Called when the state of |button| changes.
///
//export cefingo_button_delegate_on_button_state_changed
func cefingo_button_delegate_on_button_state_changed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.7:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_button_state_changed_handler[(*cCButtonDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCButtonDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbutton := newCButtonT(button, byApi)

		f.OnButtonStateChanged(goTmpself, goTmpbutton)

	} else {
		Logf("T116.8: on_button_state_changed: Noo!")
	}
	BaseRelease((*cCButtonT)(button)) // byApi

}

//export cefingo_button_delegate_get_preferred_size
func cefingo_button_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.9:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_preferred_size_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T116.10: get_preferred_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_button_delegate_get_minimum_size
func cefingo_button_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.11:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_minimum_size_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T116.12: get_minimum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_button_delegate_get_maximum_size
func cefingo_button_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.13:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_maximum_size_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T116.14: get_maximum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_button_delegate_get_height_for_width
func cefingo_button_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.15:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_height_for_width_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T116.16: get_height_for_width: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_button_delegate_on_parent_view_changed
func cefingo_button_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.17:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_parent_view_changed_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpparent := newCViewT(parent, byApi)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)

	} else {
		Logf("T116.18: on_parent_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))   // byApi
	BaseRelease((*cCViewT)(parent)) // byApi

}

//export cefingo_button_delegate_on_child_view_changed
func cefingo_button_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.19:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_child_view_changed_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpchild := newCViewT(child, byApi)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)

	} else {
		Logf("T116.20: on_child_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))  // byApi
	BaseRelease((*cCViewT)(child)) // byApi

}

//export cefingo_button_delegate_on_window_changed
func cefingo_button_delegate_on_window_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.21:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_window_changed_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)

		f.OnWindowChanged(goTmpself, goTmpview, goTmpadded)

	} else {
		Logf("T116.22: on_window_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_button_delegate_on_layout_changed
func cefingo_button_delegate_on_layout_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	new_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.23:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_layout_changed_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpnew_bounds := (*CRectT)(new_bounds)

		f.OnLayoutChanged(goTmpself, goTmpview, goTmpnew_bounds)

	} else {
		Logf("T116.24: on_layout_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_button_delegate_on_focus
func cefingo_button_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.25:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_focus_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnFocus(goTmpself, goTmpview)

	} else {
		Logf("T116.26: on_focus: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_button_delegate_on_blur
func cefingo_button_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.27:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_blur_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnBlur(goTmpself, goTmpview)

	} else {
		Logf("T116.28: on_blur: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Return the handler for audio rendering events.
///
//export cefingo_client_get_audio_handler
func cefingo_client_get_audio_handler(
	self *C.cef_client_t,
) (cRet *C.cef_audio_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.5:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_audio_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetAudioHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_audio_handler) // return GoObj
			}
			cRet = (*C.cef_audio_handler_t)(goRet.pc_audio_handler)
		}
	} else {
		Logf("T119.6: get_audio_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for commands. If no handler is provided the default
// implementation will be used.
///
//export cefingo_client_get_command_handler
func cefingo_client_get_command_handler(
	self *C.cef_client_t,
) (cRet *C.cef_command_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.7:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_command_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetCommandHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_command_handler) // return GoObj
			}
			cRet = (*C.cef_command_handler_t)(goRet.pc_command_handler)
		}
	} else {
		Logf("T119.8: get_command_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for context menus. If no handler is provided the default
// implementation will be used.
///
//export cefingo_client_get_context_menu_handler
func cefingo_client_get_context_menu_handler(
	self *C.cef_client_t,
) (cRet *C.cef_context_menu_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.9:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_context_menu_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetContextMenuHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_context_menu_handler) // return GoObj
			}
			cRet = (*C.cef_context_menu_handler_t)(goRet.pc_context_menu_handler)
		}
	} else {
		Logf("T119.10: get_context_menu_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for dialogs. If no handler is provided the default
// implementation will be used.
///
//export cefingo_client_get_dialog_handler
func cefingo_client_get_dialog_handler(
	self *C.cef_client_t,
) (cRet *C.cef_dialog_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.11:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_dialog_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetDialogHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_dialog_handler) // return GoObj
			}
			cRet = (*C.cef_dialog_handler_t)(goRet.pc_dialog_handler)
		}
	} else {
		Logf("T119.12: get_dialog_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for browser display state events.
///
//export cefingo_client_get_display_handler
func cefingo_client_get_display_handler(
	self *C.cef_client_t,
) (cRet *C.cef_display_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.13:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_display_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetDisplayHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_display_handler) // return GoObj
			}
			cRet = (*C.cef_display_handler_t)(goRet.pc_display_handler)
		}
	} else {
		Logf("T119.14: get_display_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for download events. If no handler is returned downloads
// will not be allowed.
///
//export cefingo_client_get_download_handler
func cefingo_client_get_download_handler(
	self *C.cef_client_t,
) (cRet *C.cef_download_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.15:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_download_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetDownloadHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_download_handler) // return GoObj
			}
			cRet = (*C.cef_download_handler_t)(goRet.pc_download_handler)
		}
	} else {
		Logf("T119.16: get_download_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for drag events.
///
//export cefingo_client_get_drag_handler
func cefingo_client_get_drag_handler(
	self *C.cef_client_t,
) (cRet *C.cef_drag_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.17:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_drag_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetDragHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_drag_handler) // return GoObj
			}
			cRet = (*C.cef_drag_handler_t)(goRet.pc_drag_handler)
		}
	} else {
		Logf("T119.18: get_drag_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for find result events.
///
//export cefingo_client_get_find_handler
func cefingo_client_get_find_handler(
	self *C.cef_client_t,
) (cRet *C.cef_find_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.19:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_find_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetFindHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_find_handler) // return GoObj
			}
			cRet = (*C.cef_find_handler_t)(goRet.pc_find_handler)
		}
	} else {
		Logf("T119.20: get_find_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for focus events.
///
//export cefingo_client_get_focus_handler
func cefingo_client_get_focus_handler(
	self *C.cef_client_t,
) (cRet *C.cef_focus_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.21:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_focus_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetFocusHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_focus_handler) // return GoObj
			}
			cRet = (*C.cef_focus_handler_t)(goRet.pc_focus_handler)
		}
	} else {
		Logf("T119.22: get_focus_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for events related to cef_frame_t lifespan. This
// function will be called once during cef_browser_t creation and the result
// will be cached for performance reasons.
///
//export cefingo_client_get_frame_handler
func cefingo_client_get_frame_handler(
	self *C.cef_client_t,
) (cRet *C.cef_frame_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.23:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_frame_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetFrameHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_frame_handler) // return GoObj
			}
			cRet = (*C.cef_frame_handler_t)(goRet.pc_frame_handler)
		}
	} else {
		Logf("T119.24: get_frame_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for JavaScript dialogs. If no handler is provided the
// default implementation will be used.
///
//export cefingo_client_get_jsdialog_handler
func cefingo_client_get_jsdialog_handler(
	self *C.cef_client_t,
) (cRet *C.cef_jsdialog_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.25:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_jsdialog_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetJsdialogHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_jsdialog_handler) // return GoObj
			}
			cRet = (*C.cef_jsdialog_handler_t)(goRet.pc_jsdialog_handler)
		}
	} else {
		Logf("T119.26: get_jsdialog_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for keyboard events.
///
//export cefingo_client_get_keyboard_handler
func cefingo_client_get_keyboard_handler(
	self *C.cef_client_t,
) (cRet *C.cef_keyboard_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.27:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_keyboard_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetKeyboardHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_keyboard_handler) // return GoObj
			}
			cRet = (*C.cef_keyboard_handler_t)(goRet.pc_keyboard_handler)
		}
	} else {
		Logf("T119.28: get_keyboard_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for browser life span events.
///
//export cefingo_client_get_life_span_handler
func cefingo_client_get_life_span_handler(
	self *C.cef_client_t,
) (cRet *C.cef_life_span_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.29:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_life_span_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetLifeSpanHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_life_span_handler) // return GoObj
			}
			cRet = (*C.cef_life_span_handler_t)(goRet.pc_life_span_handler)
		}
	} else {
		Logf("T119.30: get_life_span_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for browser load status events.
///
//export cefingo_client_get_load_handler
func cefingo_client_get_load_handler(
	self *C.cef_client_t,
) (cRet *C.cef_load_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.31:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_load_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetLoadHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_load_handler) // return GoObj
			}
			cRet = (*C.cef_load_handler_t)(goRet.pc_load_handler)
		}
	} else {
		Logf("T119.32: get_load_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for printing on Linux. If a print handler is not
// provided then printing will not be supported on the Linux platform.
///
//export cefingo_client_get_print_handler
func cefingo_client_get_print_handler(
	self *C.cef_client_t,
) (cRet *C.cef_print_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.33:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_print_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetPrintHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_print_handler) // return GoObj
			}
			cRet = (*C.cef_print_handler_t)(goRet.pc_print_handler)
		}
	} else {
		Logf("T119.34: get_print_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for off-screen rendering events.
///
//export cefingo_client_get_render_handler
func cefingo_client_get_render_handler(
	self *C.cef_client_t,
) (cRet *C.cef_render_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.35:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_render_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetRenderHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_render_handler) // return GoObj
			}
			cRet = (*C.cef_render_handler_t)(goRet.pc_render_handler)
		}
	} else {
		Logf("T119.36: get_render_handler: Noo!")
	}

	return cRet
}

///
// Return the handler for browser request events.
///
//export cefingo_client_get_request_handler
func cefingo_client_get_request_handler(
	self *C.cef_client_t,
) (cRet *C.cef_request_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.37:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_request_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)

		goRet := f.GetRequestHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_request_handler) // return GoObj
			}
			cRet = (*C.cef_request_handler_t)(goRet.pc_request_handler)
		}
	} else {
		Logf("T119.38: get_request_handler: Noo!")
	}

	return cRet
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise.  It is safe to keep
// a reference to |message| outside of this callback.
///
//export cefingo_client_on_process_message_received
func cefingo_client_on_process_message_received(
	self *C.cef_client_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.39:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.on_process_message_received_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCClientT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpsource_process := CProcessIdT(source_process)
		// !p.IsOutParam
		goTmpmessage := newCProcessMessageT(message, byApi)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T119.40: on_process_message_received: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))        // byApi
	BaseRelease((*cCFrameT)(frame))            // byApi
	BaseRelease((*cCProcessMessageT)(message)) // byApi

	return cRet
}

///
// Called before a context menu is displayed. |params| provides information
// about the context menu state. |model| initially contains the default
// context menu. The |model| can be cleared to show no context menu or
// modified to show a custom menu. Do not keep references to |params| or
// |model| outside of this callback.
///
//export cefingo_context_menu_handler_on_before_context_menu
func cefingo_context_menu_handler_on_before_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.5:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_before_context_menu_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCContextMenuHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpparams := newCContextMenuParamsT(params, byApi)
		// !p.IsOutParam
		goTmpmodel := newCMenuModelT(model, byApi)

		f.OnBeforeContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel)

	} else {
		Logf("T122.6: on_before_context_menu: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))          // byApi
	BaseRelease((*cCFrameT)(frame))              // byApi
	BaseRelease((*cCContextMenuParamsT)(params)) // byApi
	BaseRelease((*cCMenuModelT)(model))          // byApi

}

///
// Called to allow custom display of the context menu. |params| provides
// information about the context menu state. |model| contains the context menu
// model resulting from OnBeforeContextMenu. For custom display return true
// (1) and execute |callback| either synchronously or asynchronously with the
// selected command ID. For default display return false (0). Do not keep
// references to |params| or |model| outside of this callback.
///
//export cefingo_context_menu_handler_run_context_menu
func cefingo_context_menu_handler_run_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
	callback *C.cef_run_context_menu_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.7:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.run_context_menu_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCContextMenuHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpparams := newCContextMenuParamsT(params, byApi)
		// !p.IsOutParam
		goTmpmodel := newCMenuModelT(model, byApi)
		// !p.IsOutParam
		goTmpcallback := newCRunContextMenuCallbackT(callback, byApi)

		goRet := f.RunContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T122.8: run_context_menu: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))                 // byApi
	BaseRelease((*cCFrameT)(frame))                     // byApi
	BaseRelease((*cCContextMenuParamsT)(params))        // byApi
	BaseRelease((*cCMenuModelT)(model))                 // byApi
	BaseRelease((*cCRunContextMenuCallbackT)(callback)) // byApi

	return cRet
}

///
// Called to execute a command selected from the context menu. Return true (1)
// if the command was handled or false (0) for the default implementation. See
// cef_menu_id_t for the command ids that have default implementations. All
// user-defined command ids should be between MENU_ID_USER_FIRST and
// MENU_ID_USER_LAST. |params| will have the same values as what was passed to
// on_before_context_menu(). Do not keep a reference to |params| outside of
// this callback.
///
//export cefingo_context_menu_handler_on_context_menu_command
func cefingo_context_menu_handler_on_context_menu_command(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.9:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_command_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCContextMenuHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpparams := newCContextMenuParamsT(params, byApi)
		// !p.IsOutParam
		goTmpcommand_id := (int)(command_id)
		// !p.IsOutParam
		goTmpevent_flags := CEventFlagsT(event_flags)

		goRet := f.OnContextMenuCommand(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpcommand_id, goTmpevent_flags)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T122.10: on_context_menu_command: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))          // byApi
	BaseRelease((*cCFrameT)(frame))              // byApi
	BaseRelease((*cCContextMenuParamsT)(params)) // byApi

	return cRet
}

///
// Called when the context menu is dismissed irregardless of whether the menu
// was NULL or a command was selected.
///
//export cefingo_context_menu_handler_on_context_menu_dismissed
func cefingo_context_menu_handler_on_context_menu_dismissed(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.11:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_dismissed_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCContextMenuHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)

		f.OnContextMenuDismissed(goTmpself, goTmpbrowser, goTmpframe)

	} else {
		Logf("T122.12: on_context_menu_dismissed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi

}

///
// Method that will be called once for each cookie. |count| is the 0-based
// index for the current cookie. |total| is the total number of cookies. Set
// |deleteCookie| to true (1) to delete the cookie currently being visited.
// Return false (0) to stop visiting cookies. This function may never be
// called if no cookies are found.
///
//export cefingo_cookie_visitor_visit
func cefingo_cookie_visitor_visit(
	self *C.cef_cookie_visitor_t,
	cookie *C.cef_cookie_t,
	count C.int,
	total C.int,
	deleteCookie *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T125.5:")
	cefingoIfaceAccess.Lock()
	f := cookie_visitor_handlers.visit_handler[(*cCCookieVisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCCookieVisitorT(self, byApi)
		// !p.IsOutParam
		goTmpcookie := (*CCookieT)(cookie)
		// !p.IsOutParam
		goTmpcount := (int)(count)
		// !p.IsOutParam
		goTmptotal := (int)(total)

		goRet, goTmpdeleteCookieOut := f.Visit(goTmpself, goTmpcookie, goTmpcount, goTmptotal)
		*deleteCookie = (C.int)(goTmpdeleteCookieOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T125.6: visit: Noo!")
	}

	return cRet
}

///
// Method that will be called upon completion. |success| will be true (1) if
// the cookie was set successfully.
///
//export cefingo_set_cookie_callback_on_complete
func cefingo_set_cookie_callback_on_complete(
	self *C.cef_set_cookie_callback_t,
	success C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T126.5:")
	cefingoIfaceAccess.Lock()
	f := set_cookie_callback_handlers.on_complete_handler[(*cCSetCookieCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCSetCookieCallbackT(self, byApi)
		// !p.IsOutParam
		goTmpsuccess := (int)(success)

		f.OnComplete(goTmpself, goTmpsuccess)

	} else {
		Logf("T126.6: on_complete: Noo!")
	}

}

///
// Method that will be called upon completion. |num_deleted| will be the
// number of cookies that were deleted.
///
//export cefingo_delete_cookies_callback_on_complete
func cefingo_delete_cookies_callback_on_complete(
	self *C.cef_delete_cookies_callback_t,
	num_deleted C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T127.5:")
	cefingoIfaceAccess.Lock()
	f := delete_cookies_callback_handlers.on_complete_handler[(*cCDeleteCookiesCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDeleteCookiesCallbackT(self, byApi)
		// !p.IsOutParam
		goTmpnum_deleted := (int)(num_deleted)

		f.OnComplete(goTmpself, goTmpnum_deleted)

	} else {
		Logf("T127.6: on_complete: Noo!")
	}

}

///
// Method that will be called on receipt of a DevTools protocol message.
// |browser| is the originating browser instance. |message| is a UTF8-encoded
// JSON dictionary representing either a function result or an event.
// |message| is only valid for the scope of this callback and should be copied
// if necessary. Return true (1) if the message was handled or false (0) if
// the message should be further processed and passed to the
// OnDevToolsMethodResult or OnDevToolsEvent functions as appropriate.
//
// Method result dictionaries include an &quot;id&quot; (int) value that identifies the
// orginating function call sent from cef_browser_host_t::SendDevToolsMessage,
// and optionally either a &quot;result&quot; (dictionary) or &quot;error&quot; (dictionary)
// value. The &quot;error&quot; dictionary will contain &quot;code&quot; (int) and &quot;message&quot;
// (string) values. Event dictionaries include a &quot;function&quot; (string) value and
// optionally a &quot;params&quot; (dictionary) value. See the DevTools protocol
// documentation at https://chromedevtools.github.io/devtools-protocol/ for
// details of supported function calls and the expected &quot;result&quot; or &quot;params&quot;
// dictionary contents. JSON dictionaries can be parsed using the CefParseJSON
// function if desired, however be aware of performance considerations when
// parsing large messages (some of which may exceed 1MB in size).
///
//export cefingo_dev_tools_message_observer_on_dev_tools_message
func cefingo_dev_tools_message_observer_on_dev_tools_message(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
	message C.VOIDP,
	message_size C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.5:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_message_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDevToolsMessageObserverT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpmessage := (*[1 << 30]byte)(message)[:message_size:message_size]

		goRet := f.OnDevToolsMessage(goTmpself, goTmpbrowser, goTmpmessage)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T128.6: on_dev_tools_message: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Method that will be called after attempted execution of a DevTools protocol
// function. |browser| is the originating browser instance. |message_id| is
// the &quot;id&quot; value that identifies the originating function call message. If
// the function succeeded |success| will be true (1) and |result| will be the
// UTF8-encoded JSON &quot;result&quot; dictionary value (which may be NULL). If the
// function failed |success| will be false (0) and |result| will be the
// UTF8-encoded JSON &quot;error&quot; dictionary value. |result| is only valid for the
// scope of this callback and should be copied if necessary. See the
// OnDevToolsMessage documentation for additional details on |result|
// contents.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_method_result
func cefingo_dev_tools_message_observer_on_dev_tools_method_result(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
	message_id C.int,
	success C.int,
	result C.VOIDP,
	result_size C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.7:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_method_result_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDevToolsMessageObserverT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpmessage_id := (int)(message_id)
		// !p.IsOutParam
		goTmpsuccess := (int)(success)
		// !p.IsOutParam
		goTmpresult := (*[1 << 30]byte)(result)[:result_size:result_size]

		f.OnDevToolsMethodResult(goTmpself, goTmpbrowser, goTmpmessage_id, goTmpsuccess, goTmpresult)

	} else {
		Logf("T128.8: on_dev_tools_method_result: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Method that will be called on receipt of a DevTools protocol event.
// |browser| is the originating browser instance. |function| is the &quot;function&quot;
// value. |params| is the UTF8-encoded JSON &quot;params&quot; dictionary value (which
// may be NULL). |params| is only valid for the scope of this callback and
// should be copied if necessary. See the OnDevToolsMessage documentation for
// additional details on |params| contents.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_event
func cefingo_dev_tools_message_observer_on_dev_tools_event(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
	method *C.cef_string_t,
	params C.VOIDP,
	params_size C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.9:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_event_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDevToolsMessageObserverT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpmethod := string_from_cef_string(method)
		// !p.IsOutParam
		goTmpparams := (*[1 << 30]byte)(params)[:params_size:params_size]

		f.OnDevToolsEvent(goTmpself, goTmpbrowser, goTmpmethod, goTmpparams)

	} else {
		Logf("T128.10: on_dev_tools_event: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Method that will be called when the DevTools agent has attached. |browser|
// is the originating browser instance. This will generally occur in response
// to the first message sent while the agent is detached.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_agent_attached
func cefingo_dev_tools_message_observer_on_dev_tools_agent_attached(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.11:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_agent_attached_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDevToolsMessageObserverT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnDevToolsAgentAttached(goTmpself, goTmpbrowser)

	} else {
		Logf("T128.12: on_dev_tools_agent_attached: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Method that will be called when the DevTools agent has detached. |browser|
// is the originating browser instance. Any function results that were pending
// before the agent became detached will not be delivered, and any active
// event subscriptions will be canceled.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_agent_detached
func cefingo_dev_tools_message_observer_on_dev_tools_agent_detached(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.13:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_agent_detached_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDevToolsMessageObserverT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnDevToolsAgentDetached(goTmpself, goTmpbrowser)

	} else {
		Logf("T128.14: on_dev_tools_agent_detached: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called to run a file chooser dialog. |mode| represents the type of dialog
// to display. |title| to the title to be used for the dialog and may be NULL
// to show the default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode).
// |default_file_path| is the path with optional directory and/or file name
// component that should be initially selected in the dialog. |accept_filters|
// are used to restrict the selectable file types and may any combination of
// (a) valid lower-cased MIME types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b)
// individual file extensions (e.g. &quot;.txt&quot; or &quot;.png&quot;), or (c) combined
// description and file extension delimited using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image
// Types|.png;.gif;.jpg&quot;). |selected_accept_filter| is the 0-based index of
// the filter that should be selected by default. To display a custom dialog
// return true (1) and execute |callback| either inline or at a later time. To
// display the default dialog return false (0).
///
//export cefingo_dialog_handler_on_file_dialog
func cefingo_dialog_handler_on_file_dialog(
	self *C.cef_dialog_handler_t,
	browser *C.cef_browser_t,
	mode C.cef_file_dialog_mode_t,
	title *C.cef_string_t,
	default_file_path *C.cef_string_t,
	accept_filters C.cef_string_list_t,
	selected_accept_filter C.int,
	callback *C.cef_file_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T130.5:")
	cefingoIfaceAccess.Lock()
	f := dialog_handler_handlers.on_file_dialog_handler[(*cCDialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDialogHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpmode := CFileDialogModeT(mode)
		// !p.IsOutParam
		goTmptitle := string_from_cef_string(title)
		// !p.IsOutParam
		goTmpdefault_file_path := string_from_cef_string(default_file_path)
		// !p.IsOutParam
		goTmpaccept_filters := (CStringListT)(accept_filters)
		// !p.IsOutParam
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		// !p.IsOutParam
		goTmpcallback := newCFileDialogCallbackT(callback, byApi)

		goRet := f.OnFileDialog(goTmpself, goTmpbrowser, goTmpmode, goTmptitle, goTmpdefault_file_path, goTmpaccept_filters, goTmpselected_accept_filter, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T130.6: on_file_dialog: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))             // byApi
	BaseRelease((*cCFileDialogCallbackT)(callback)) // byApi

	return cRet
}

///
// Called when a frame&#39;s address has changed.
///
//export cefingo_display_handler_on_address_change
func cefingo_display_handler_on_address_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.5:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_address_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpurl := string_from_cef_string(url)

		f.OnAddressChange(goTmpself, goTmpbrowser, goTmpframe, goTmpurl)

	} else {
		Logf("T132.6: on_address_change: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi

}

///
// Called when the page title changes.
///
//export cefingo_display_handler_on_title_change
func cefingo_display_handler_on_title_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	title *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.7:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_title_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmptitle := string_from_cef_string(title)

		f.OnTitleChange(goTmpself, goTmpbrowser, goTmptitle)

	} else {
		Logf("T132.8: on_title_change: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the page icon changes.
///
//export cefingo_display_handler_on_favicon_urlchange
func cefingo_display_handler_on_favicon_urlchange(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	icon_urls C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.9:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_favicon_urlchange_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpicon_urls := (CStringListT)(icon_urls)

		f.OnFaviconUrlchange(goTmpself, goTmpbrowser, goTmpicon_urls)

	} else {
		Logf("T132.10: on_favicon_urlchange: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when web content in the page has toggled fullscreen mode. If
// |fullscreen| is true (1) the content will automatically be sized to fill
// the browser content area. If |fullscreen| is false (0) the content will
// automatically return to its original size and position. The client is
// responsible for resizing the browser if desired.
///
//export cefingo_display_handler_on_fullscreen_mode_change
func cefingo_display_handler_on_fullscreen_mode_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	fullscreen C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.11:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_fullscreen_mode_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpfullscreen := (int)(fullscreen)

		f.OnFullscreenModeChange(goTmpself, goTmpbrowser, goTmpfullscreen)

	} else {
		Logf("T132.12: on_fullscreen_mode_change: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the browser is about to display a tooltip. |text| contains the
// text that will be displayed in the tooltip. To handle the display of the
// tooltip yourself return true (1). Otherwise, you can optionally modify
// |text| and then return false (0) to allow the browser to display the
// tooltip. When window rendering is disabled the application is responsible
// for drawing tooltips and the return value is ignored.
///
//export cefingo_display_handler_on_tooltip
func cefingo_display_handler_on_tooltip(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	text *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.13:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_tooltip_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// p.IsInOutParam
		goTmptext := string_from_cef_string(text)

		goRet, goTmptextOut := f.OnTooltip(goTmpself, goTmpbrowser, goTmptext)
		set_cef_string(text, goTmptextOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T132.14: on_tooltip: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called when the browser receives a status message. |value| contains the
// text that will be displayed in the status message.
///
//export cefingo_display_handler_on_status_message
func cefingo_display_handler_on_status_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	value *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.15:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_status_message_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpvalue := string_from_cef_string(value)

		f.OnStatusMessage(goTmpself, goTmpbrowser, goTmpvalue)

	} else {
		Logf("T132.16: on_status_message: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called to display a console message. Return true (1) to stop the message
// from being output to the console.
///
//export cefingo_display_handler_on_console_message
func cefingo_display_handler_on_console_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	level C.cef_log_severity_t,
	message *C.cef_string_t,
	source *C.cef_string_t,
	line C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.17:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_console_message_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmplevel := CLogSeverityT(level)
		// !p.IsOutParam
		goTmpmessage := string_from_cef_string(message)
		// !p.IsOutParam
		goTmpsource := string_from_cef_string(source)
		// !p.IsOutParam
		goTmpline := (int)(line)

		goRet := f.OnConsoleMessage(goTmpself, goTmpbrowser, goTmplevel, goTmpmessage, goTmpsource, goTmpline)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T132.18: on_console_message: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called when auto-resize is enabled via
// cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-
// resized. |new_size| will be the desired size in view coordinates. Return
// true (1) if the resize was handled or false (0) for default handling.
///
//export cefingo_display_handler_on_auto_resize
func cefingo_display_handler_on_auto_resize(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	new_size *C.cef_size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.19:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_auto_resize_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpnew_size := (*CSizeT)(new_size)

		goRet := f.OnAutoResize(goTmpself, goTmpbrowser, goTmpnew_size)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T132.20: on_auto_resize: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called when the overall page loading progress has changed. |progress|
// ranges from 0.0 to 1.0.
///
//export cefingo_display_handler_on_loading_progress_change
func cefingo_display_handler_on_loading_progress_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	progress C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.21:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_loading_progress_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpprogress := (float64)(progress)

		f.OnLoadingProgressChange(goTmpself, goTmpbrowser, goTmpprogress)

	} else {
		Logf("T132.22: on_loading_progress_change: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the browser&#39;s cursor has changed. If |type| is CT_CUSTOM then
// |custom_cursor_info| will be populated with the custom cursor information.
// Return true (1) if the cursor change was handled or false (0) for default
// handling.
///
//export cefingo_display_handler_on_cursor_change
func cefingo_display_handler_on_cursor_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	cursor C.HCURSOR,
	ctype C.cef_cursor_type_t,
	custom_cursor_info *C.cef_cursor_info_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.23:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_cursor_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDisplayHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpcursor := (CCursorHandleT)(cursor)
		// !p.IsOutParam
		goTmptype := CCursorTypeT(ctype)
		// !p.IsOutParam
		goTmpcustom_cursor_info := (*CCursorInfoT)(custom_cursor_info)

		goRet := f.OnCursorChange(goTmpself, goTmpbrowser, goTmpcursor, goTmptype, goTmpcustom_cursor_info)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T132.24: on_cursor_change: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Method executed for visiting the DOM. The document object passed to this
// function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_domvisitor_visit
func cefingo_domvisitor_visit(
	self *C.cef_domvisitor_t,
	document *C.cef_domdocument_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T133.5:")
	cefingoIfaceAccess.Lock()
	f := domvisitor_handlers.visit_handler[(*cCDomvisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDomvisitorT(self, byApi)
		// !p.IsOutParam
		goTmpdocument := newCDomdocumentT(document, byApi)

		f.Visit(goTmpself, goTmpdocument)

	} else {
		Logf("T133.6: visit: Noo!")
	}
	BaseRelease((*cCDomdocumentT)(document)) // byApi

}

///
// Called before a download begins in response to a user-initiated action
// (e.g. alt + link click or link click that returns a `Content-Disposition:
// attachment` response from the server). |url| is the target download URL and
// |request_function| is the target function (GET, POST, etc). Return true (1)
// to proceed with the download or false (0) to cancel the download.
///
//export cefingo_download_handler_can_download
func cefingo_download_handler_can_download(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	url *C.cef_string_t,
	request_method *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T138.5:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.can_download_handler[(*cCDownloadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDownloadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpurl := string_from_cef_string(url)
		// !p.IsOutParam
		goTmprequest_method := string_from_cef_string(request_method)

		goRet := f.CanDownload(goTmpself, goTmpbrowser, goTmpurl, goTmprequest_method)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T138.6: can_download: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called before a download begins. |suggested_name| is the suggested name for
// the download file. By default the download will be canceled. Execute
// |callback| either asynchronously or in this function to continue the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_before_download
func cefingo_download_handler_on_before_download(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	suggested_name *C.cef_string_t,
	callback *C.cef_before_download_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T138.7:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_before_download_handler[(*cCDownloadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDownloadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpdownload_item := newCDownloadItemT(download_item, byApi)
		// !p.IsOutParam
		goTmpsuggested_name := string_from_cef_string(suggested_name)
		// !p.IsOutParam
		goTmpcallback := newCBeforeDownloadCallbackT(callback, byApi)

		f.OnBeforeDownload(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpsuggested_name, goTmpcallback)

	} else {
		Logf("T138.8: on_before_download: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))                 // byApi
	BaseRelease((*cCDownloadItemT)(download_item))      // byApi
	BaseRelease((*cCBeforeDownloadCallbackT)(callback)) // byApi

}

///
// Called when a download&#39;s status or progress information has been updated.
// This may be called multiple times before and after on_before_download().
// Execute |callback| either asynchronously or in this function to cancel the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_download_updated
func cefingo_download_handler_on_download_updated(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	callback *C.cef_download_item_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T138.9:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_download_updated_handler[(*cCDownloadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDownloadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpdownload_item := newCDownloadItemT(download_item, byApi)
		// !p.IsOutParam
		goTmpcallback := newCDownloadItemCallbackT(callback, byApi)

		f.OnDownloadUpdated(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpcallback)

	} else {
		Logf("T138.10: on_download_updated: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))               // byApi
	BaseRelease((*cCDownloadItemT)(download_item))    // byApi
	BaseRelease((*cCDownloadItemCallbackT)(callback)) // byApi

}

///
// Called when an external drag event enters the browser window. |dragData|
// contains the drag event data and |mask| represents the type of drag
// operation. Return false (0) for default drag handling behavior or true (1)
// to cancel the drag event.
///
//export cefingo_drag_handler_on_drag_enter
func cefingo_drag_handler_on_drag_enter(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	dragData *C.cef_drag_data_t,
	mask C.cef_drag_operations_mask_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T141.5:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_drag_enter_handler[(*cCDragHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDragHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpdragData := newCDragDataT(dragData, byApi)
		// !p.IsOutParam
		goTmpmask := CDragOperationsMaskT(mask)

		goRet := f.OnDragEnter(goTmpself, goTmpbrowser, goTmpdragData, goTmpmask)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T141.6: on_drag_enter: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCDragDataT)(dragData)) // byApi

	return cRet
}

///
// Called whenever draggable regions for the browser window change. These can
// be specified using the &#39;-webkit-app-region: drag/no-drag&#39; CSS-property. If
// draggable regions are never defined in a document this function will also
// never be called. If the last draggable region is removed from a document
// this function will be called with an NULL vector.
///
//export cefingo_drag_handler_on_draggable_regions_changed
func cefingo_drag_handler_on_draggable_regions_changed(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	regionsCount C.size_t,
	regions *C.cef_draggable_region_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T141.7:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_draggable_regions_changed_handler[(*cCDragHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCDragHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpregionsCount := (int64)(regionsCount)
		// !p.IsOutParam
		goTmpregions := (*CDraggableRegionT)(regions)

		f.OnDraggableRegionsChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpregionsCount, goTmpregions)

	} else {
		Logf("T141.8: on_draggable_regions_changed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi

}

///
// Called if the cef_request_context_t::LoadExtension request fails. |result|
// will be the error code.
///
//export cefingo_extension_handler_on_extension_load_failed
func cefingo_extension_handler_on_extension_load_failed(
	self *C.cef_extension_handler_t,
	result C.cef_errorcode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.5:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_load_failed_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpresult := CErrorcodeT(result)

		f.OnExtensionLoadFailed(goTmpself, goTmpresult)

	} else {
		Logf("T144.6: on_extension_load_failed: Noo!")
	}

}

///
// Called if the cef_request_context_t::LoadExtension request succeeds.
// |extension| is the loaded extension.
///
//export cefingo_extension_handler_on_extension_loaded
func cefingo_extension_handler_on_extension_loaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.7:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_loaded_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpextension := newCExtensionT(extension, byApi)

		f.OnExtensionLoaded(goTmpself, goTmpextension)

	} else {
		Logf("T144.8: on_extension_loaded: Noo!")
	}
	BaseRelease((*cCExtensionT)(extension)) // byApi

}

///
// Called after the cef_extension_t::Unload request has completed.
///
//export cefingo_extension_handler_on_extension_unloaded
func cefingo_extension_handler_on_extension_unloaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.9:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_unloaded_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpextension := newCExtensionT(extension, byApi)

		f.OnExtensionUnloaded(goTmpself, goTmpextension)

	} else {
		Logf("T144.10: on_extension_unloaded: Noo!")
	}
	BaseRelease((*cCExtensionT)(extension)) // byApi

}

///
// Called when an extension needs a browser to host a background script
// specified via the &quot;background&quot; manifest key. The browser will have no
// visible window and cannot be displayed. |extension| is the extension that
// is loading the background script. |url| is an internally generated
// reference to an HTML page that will be used to load the background script
// via a &lt;script&gt; src attribute. To allow creation of the browser optionally
// modify |client| and |settings| and return false (0). To cancel creation of
// the browser (and consequently cancel load of the background script) return
// true (1). Successful creation will be indicated by a call to
// cef_life_span_handler_t::OnAfterCreated, and
// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
// browser. See https://developer.chrome.com/extensions/event_pages for more
// information about extension background script usage.
///
//export cefingo_extension_handler_on_before_background_browser
func cefingo_extension_handler_on_before_background_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	url *C.cef_string_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.11:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_background_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpextension := newCExtensionT(extension, byApi)
		// !p.IsOutParam
		goTmpurl := string_from_cef_string(url)
		// p.IsInOutParam
		goTmpclient := newCClientT(*client, byApi)
		cefp := goTmpclient.pc_client
		// p.IsInOutParam
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBackgroundBrowser(goTmpself, goTmpextension, goTmpurl, goTmpclient, goTmpsettings)
		if cefp != goTmpclientOut.pc_client {
			if goTmpclientOut.beUnrefed != byCef {
				BaseAddRef(goTmpclientOut.pc_client) // InOut Param
			}
			*client = (*C.cef_client_t)(goTmpclientOut.pc_client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.12: on_before_background_browser: Noo!")
	}
	BaseRelease((*cCExtensionT)(extension)) // byApi
	BaseRelease((*cCClientT)(*client))      // byApi

	return cRet
}

///
// Called when an extension API (e.g. chrome.tabs.create) requests creation of
// a new browser. |extension| and |browser| are the source of the API call.
// |active_browser| may optionally be specified via the windowId property or
// returned via the get_active_browser() callback and provides the default
// |client| and |settings| values for the new browser. |index| is the position
// value optionally specified via the index property. |url| is the URL that
// will be loaded in the browser. |active| is true (1) if the new browser
// should be active when opened.  To allow creation of the browser optionally
// modify |windowInfo|, |client| and |settings| and return false (0). To
// cancel creation of the browser return true (1). Successful creation will be
// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
// modifications to |windowInfo| will be ignored if |active_browser| is
// wrapped in a cef_browser_view_t.
///
//export cefingo_extension_handler_on_before_browser
func cefingo_extension_handler_on_before_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	active_browser *C.cef_browser_t,
	index C.int,
	url *C.cef_string_t,
	active C.int,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.13:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpextension := newCExtensionT(extension, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpactive_browser := newCBrowserT(active_browser, byApi)
		// !p.IsOutParam
		goTmpindex := (int)(index)
		// !p.IsOutParam
		goTmpurl := string_from_cef_string(url)
		// !p.IsOutParam
		goTmpactive := (int)(active)
		// p.IsInOutParam
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		// p.IsInOutParam
		goTmpclient := newCClientT(*client, byApi)
		cefp := goTmpclient.pc_client
		// p.IsInOutParam
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpactive_browser, goTmpindex, goTmpurl, goTmpactive, goTmpwindowInfo, goTmpclient, goTmpsettings)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.pc_client {
			if goTmpclientOut.beUnrefed != byCef {
				BaseAddRef(goTmpclientOut.pc_client) // InOut Param
			}
			*client = (*C.cef_client_t)(goTmpclientOut.pc_client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.14: on_before_browser: Noo!")
	}
	BaseRelease((*cCExtensionT)(extension))    // byApi
	BaseRelease((*cCBrowserT)(browser))        // byApi
	BaseRelease((*cCBrowserT)(active_browser)) // byApi
	BaseRelease((*cCClientT)(*client))         // byApi

	return cRet
}

///
// Called when no tabId is specified to an extension API call that accepts a
// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
// source of the API call. Return the browser that will be acted on by the API
// call or return NULL to act on |browser|. The returned browser must share
// the same cef_request_context_t as |browser|. Incognito browsers should not
// be considered unless the source extension has incognito access enabled, in
// which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_get_active_browser
func cefingo_extension_handler_get_active_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
) (cRet *C.cef_browser_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.15:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_active_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpextension := newCExtensionT(extension, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpinclude_incognito := (int)(include_incognito)

		goRet := f.GetActiveBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_browser) // return GoObj
			}
			cRet = (*C.cef_browser_t)(goRet.pc_browser)
		}
	} else {
		Logf("T144.16: get_active_browser: Noo!")
	}
	BaseRelease((*cCExtensionT)(extension)) // byApi
	BaseRelease((*cCBrowserT)(browser))     // byApi

	return cRet
}

///
// Called when the tabId associated with |target_browser| is specified to an
// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
// |extension| and |browser| are the source of the API call. Return true (1)
// to allow access of false (0) to deny access. Access to incognito browsers
// should not be allowed unless the source extension has incognito access
// enabled, in which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_can_access_browser
func cefingo_extension_handler_can_access_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
	target_browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.17:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.can_access_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpextension := newCExtensionT(extension, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpinclude_incognito := (int)(include_incognito)
		// !p.IsOutParam
		goTmptarget_browser := newCBrowserT(target_browser, byApi)

		goRet := f.CanAccessBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito, goTmptarget_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.18: can_access_browser: Noo!")
	}
	BaseRelease((*cCExtensionT)(extension))    // byApi
	BaseRelease((*cCBrowserT)(browser))        // byApi
	BaseRelease((*cCBrowserT)(target_browser)) // byApi

	return cRet
}

///
// Called to retrieve an extension resource that would normally be loaded from
// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
// |extension| and |browser| are the source of the resource request. |file| is
// the requested relative file path. To handle the resource request return
// true (1) and execute |callback| either synchronously or asynchronously. For
// the default behavior which reads the resource from the extension directory
// on disk return false (0). Localization substitutions will not be applied to
// resources handled via this function.
///
//export cefingo_extension_handler_get_extension_resource
func cefingo_extension_handler_get_extension_resource(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	file *C.cef_string_t,
	callback *C.cef_get_extension_resource_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.19:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_extension_resource_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCExtensionHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpextension := newCExtensionT(extension, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpfile := string_from_cef_string(file)
		// !p.IsOutParam
		goTmpcallback := newCGetExtensionResourceCallbackT(callback, byApi)

		goRet := f.GetExtensionResource(goTmpself, goTmpextension, goTmpbrowser, goTmpfile, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.20: get_extension_resource: Noo!")
	}
	BaseRelease((*cCExtensionT)(extension))                   // byApi
	BaseRelease((*cCBrowserT)(browser))                       // byApi
	BaseRelease((*cCGetExtensionResourceCallbackT)(callback)) // byApi

	return cRet
}

///
// Called to report find results returned by cef_browser_host_t::find().
// |identifer| is a unique incremental identifier for the currently active
// search, |count| is the number of matches currently identified,
// |selectionRect| is the location of where the match was found (in window
// coordinates), |activeMatchOrdinal| is the current position in the search
// results, and |finalUpdate| is true (1) if this is the last find
// notification.
///
//export cefingo_find_handler_on_find_result
func cefingo_find_handler_on_find_result(
	self *C.cef_find_handler_t,
	browser *C.cef_browser_t,
	identifier C.int,
	count C.int,
	selectionRect *C.cef_rect_t,
	activeMatchOrdinal C.int,
	finalUpdate C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T146.5:")
	cefingoIfaceAccess.Lock()
	f := find_handler_handlers.on_find_result_handler[(*cCFindHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCFindHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpidentifier := (int)(identifier)
		// !p.IsOutParam
		goTmpcount := (int)(count)
		// !p.IsOutParam
		goTmpselectionRect := (*CRectT)(selectionRect)
		// !p.IsOutParam
		goTmpactiveMatchOrdinal := (int)(activeMatchOrdinal)
		// !p.IsOutParam
		goTmpfinalUpdate := (int)(finalUpdate)

		f.OnFindResult(goTmpself, goTmpbrowser, goTmpidentifier, goTmpcount, goTmpselectionRect, goTmpactiveMatchOrdinal, goTmpfinalUpdate)

	} else {
		Logf("T146.6: on_find_result: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the browser component is about to loose focus. For instance, if
// focus was on the last HTML element and the user pressed the TAB key. |next|
// will be true (1) if the browser is giving focus to the next component and
// false (0) if the browser is giving focus to the previous component.
///
//export cefingo_focus_handler_on_take_focus
func cefingo_focus_handler_on_take_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	next C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T147.5:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_take_focus_handler[(*cCFocusHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCFocusHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpnext := (int)(next)

		f.OnTakeFocus(goTmpself, goTmpbrowser, goTmpnext)

	} else {
		Logf("T147.6: on_take_focus: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the browser component is requesting focus. |source| indicates
// where the focus request is originating from. Return false (0) to allow the
// focus to be set or true (1) to cancel setting the focus.
///
//export cefingo_focus_handler_on_set_focus
func cefingo_focus_handler_on_set_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	source C.cef_focus_source_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T147.7:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_set_focus_handler[(*cCFocusHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCFocusHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpsource := CFocusSourceT(source)

		goRet := f.OnSetFocus(goTmpself, goTmpbrowser, goTmpsource)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T147.8: on_set_focus: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called when the browser component has received focus.
///
//export cefingo_focus_handler_on_got_focus
func cefingo_focus_handler_on_got_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T147.9:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_got_focus_handler[(*cCFocusHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCFocusHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnGotFocus(goTmpself, goTmpbrowser)

	} else {
		Logf("T147.10: on_got_focus: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
// and user-friendly display string. The |default_prompt_text| value will be
// specified for prompt dialogs only. Set |suppress_message| to true (1) and
// return false (0) to suppress the message (suppressing messages is
// preferable to immediately executing the callback as this is used to detect
// presumably malicious behavior like spamming alert messages in
// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
// to use the default implementation (the default implementation will show one
// modal dialog at a time and suppress any additional dialog requests until
// the displayed dialog is dismissed). Return true (1) if the application will
// use a custom dialog or if the callback has been executed immediately.
// Custom dialogs may be either modal or modeless. If a custom dialog is used
// the application must execute |callback| once the custom dialog is
// dismissed.
///
//export cefingo_jsdialog_handler_on_jsdialog
func cefingo_jsdialog_handler_on_jsdialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	dialog_type C.cef_jsdialog_type_t,
	message_text *C.cef_string_t,
	default_prompt_text *C.cef_string_t,
	callback *C.cef_jsdialog_callback_t,
	suppress_message *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.5:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_jsdialog_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCJsdialogHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmporigin_url := string_from_cef_string(origin_url)
		// !p.IsOutParam
		goTmpdialog_type := CJsdialogTypeT(dialog_type)
		// !p.IsOutParam
		goTmpmessage_text := string_from_cef_string(message_text)
		// !p.IsOutParam
		goTmpdefault_prompt_text := string_from_cef_string(default_prompt_text)
		// !p.IsOutParam
		goTmpcallback := newCJsdialogCallbackT(callback, byApi)

		goRet, goTmpsuppress_messageOut := f.OnJsdialog(goTmpself, goTmpbrowser, goTmporigin_url, goTmpdialog_type, goTmpmessage_text, goTmpdefault_prompt_text, goTmpcallback)
		*suppress_message = (C.int)(goTmpsuppress_messageOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T151.6: on_jsdialog: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))           // byApi
	BaseRelease((*cCJsdialogCallbackT)(callback)) // byApi

	return cRet
}

///
// Called to run a dialog asking the user if they want to leave a page. Return
// false (0) to use the default dialog implementation. Return true (1) if the
// application will use a custom dialog or if the callback has been executed
// immediately. Custom dialogs may be either modal or modeless. If a custom
// dialog is used the application must execute |callback| once the custom
// dialog is dismissed.
///
//export cefingo_jsdialog_handler_on_before_unload_dialog
func cefingo_jsdialog_handler_on_before_unload_dialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	message_text *C.cef_string_t,
	is_reload C.int,
	callback *C.cef_jsdialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.7:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_before_unload_dialog_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCJsdialogHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpmessage_text := string_from_cef_string(message_text)
		// !p.IsOutParam
		goTmpis_reload := (int)(is_reload)
		// !p.IsOutParam
		goTmpcallback := newCJsdialogCallbackT(callback, byApi)

		goRet := f.OnBeforeUnloadDialog(goTmpself, goTmpbrowser, goTmpmessage_text, goTmpis_reload, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T151.8: on_before_unload_dialog: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))           // byApi
	BaseRelease((*cCJsdialogCallbackT)(callback)) // byApi

	return cRet
}

///
// Called to cancel any pending dialogs and reset any saved dialog state. Will
// be called due to events like page navigation irregardless of whether any
// dialogs are currently pending.
///
//export cefingo_jsdialog_handler_on_reset_dialog_state
func cefingo_jsdialog_handler_on_reset_dialog_state(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.9:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_reset_dialog_state_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCJsdialogHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnResetDialogState(goTmpself, goTmpbrowser)

	} else {
		Logf("T151.10: on_reset_dialog_state: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the default implementation dialog is closed.
///
//export cefingo_jsdialog_handler_on_dialog_closed
func cefingo_jsdialog_handler_on_dialog_closed(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.11:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_dialog_closed_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCJsdialogHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnDialogClosed(goTmpself, goTmpbrowser)

	} else {
		Logf("T151.12: on_dialog_closed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called before a keyboard event is sent to the renderer. |event| contains
// information about the keyboard event. |os_event| is the operating system
// event message, if any. Return true (1) if the event was handled or false
// (0) otherwise. If the event will be handled in on_key_event() as a keyboard
// shortcut set |is_keyboard_shortcut| to true (1) and return false (0).
///
//export cefingo_keyboard_handler_on_pre_key_event
func cefingo_keyboard_handler_on_pre_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
	is_keyboard_shortcut *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T152.5:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_pre_key_event_handler[(*cCKeyboardHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCKeyboardHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpevent := (*CKeyEventT)(event)
		// !p.IsOutParam
		goTmpos_event := CEventHandleT(os_event)

		goRet, goTmpis_keyboard_shortcutOut := f.OnPreKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)
		*is_keyboard_shortcut = (C.int)(goTmpis_keyboard_shortcutOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T152.6: on_pre_key_event: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called after the renderer and JavaScript in the page has had a chance to
// handle the event. |event| contains information about the keyboard event.
// |os_event| is the operating system event message, if any. Return true (1)
// if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_keyboard_handler_on_key_event
func cefingo_keyboard_handler_on_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T152.7:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_key_event_handler[(*cCKeyboardHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCKeyboardHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpevent := (*CKeyEventT)(event)
		// !p.IsOutParam
		goTmpos_event := CEventHandleT(os_event)

		goRet := f.OnKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T152.8: on_key_event: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called on the UI thread before a new popup browser is created. The
// |browser| and |frame| values represent the source of the popup request. The
// |target_url| and |target_frame_name| values indicate where the popup
// browser should navigate and may be NULL if not specified with the request.
// The |target_disposition| value indicates where the user intended to open
// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
// be true (1) if the popup was opened via explicit user gesture (e.g.
// clicking a link) or false (0) if the popup opened automatically (e.g. via
// the DomContentLoaded event). The |popupFeatures| structure contains
// additional information about the requested popup window. To allow creation
// of the popup browser optionally modify |windowInfo|, |client|, |settings|
// and |no_javascript_access| and return false (0). To cancel creation of the
// popup browser return true (1). The |client| and |settings| values will
// default to the source browser&#39;s values. If the |no_javascript_access| value
// is set to false (0) the new browser will not be scriptable and may not be
// hosted in the same renderer process as the source browser. Any
// modifications to |windowInfo| will be ignored if the parent browser is
// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
// the parent browser is destroyed before the popup browser creation completes
// (indicated by a call to OnAfterCreated for the popup browser). The
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created popup browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
//export cefingo_life_span_handler_on_before_popup
func cefingo_life_span_handler_on_before_popup(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_frame_name *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
	popupFeatures *C.cef_popup_features_t,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
	extra_info **C.cef_dictionary_value_t,
	no_javascript_access *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.5:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_popup_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLifeSpanHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmptarget_url := string_from_cef_string(target_url)
		// !p.IsOutParam
		goTmptarget_frame_name := string_from_cef_string(target_frame_name)
		// !p.IsOutParam
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		// !p.IsOutParam
		goTmpuser_gesture := (int)(user_gesture)
		// !p.IsOutParam
		goTmppopupFeatures := (*CPopupFeaturesT)(popupFeatures)
		// p.IsInOutParam
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		// p.IsInOutParam
		goTmpclient := newCClientT(*client, byApi)
		cefp := goTmpclient.pc_client
		// p.IsInOutParam
		goTmpsettings := CBrowserSettingsT(*settings)
		// p.IsInOutParam
		goTmpno_javascript_access := (*no_javascript_access) != 0

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut, goTmpextra_infoOut, goTmpno_javascript_accessOut := f.OnBeforePopup(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_frame_name, goTmptarget_disposition, goTmpuser_gesture, goTmppopupFeatures, goTmpwindowInfo, goTmpclient, goTmpsettings, goTmpno_javascript_access)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.pc_client {
			if goTmpclientOut.beUnrefed != byCef {
				BaseAddRef(goTmpclientOut.pc_client) // InOut Param
			}
			*client = (*C.cef_client_t)(goTmpclientOut.pc_client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)
		if goTmpextra_infoOut != nil {
			if goTmpextra_infoOut.beUnrefed != byCef {
				BaseAddRef(goTmpextra_infoOut.pc_dictionary_value) // Out Param
			}
			*extra_info = (*C.cef_dictionary_value_t)(goTmpextra_infoOut.pc_dictionary_value)
		}
		*no_javascript_access = 0
		if goTmpno_javascript_accessOut {
			*no_javascript_access = 1
		}

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T155.6: on_before_popup: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCClientT)(*client))  // byApi

	return cRet
}

///
// Called after a new browser is created. It is now safe to begin performing
// actions with |browser|. cef_frame_handler_t callbacks related to initial
// main frame creation will arrive before this callback. See
// cef_frame_handler_t documentation for additional usage information.
///
//export cefingo_life_span_handler_on_after_created
func cefingo_life_span_handler_on_after_created(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.7:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_after_created_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLifeSpanHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnAfterCreated(goTmpself, goTmpbrowser)

	} else {
		Logf("T155.8: on_after_created: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when a browser has recieved a request to close. This may result
// directly from a call to cef_browser_host_t::*close_browser() or indirectly
// if the browser is parented to a top-level window created by CEF and the
// user attempts to close that window (by clicking the &#39;X&#39;, for example). The
// do_close() function will be called after the JavaScript &#39;onunload&#39; event
// has been fired.
//
// An application should handle top-level owner window close notifications by
// calling cef_browser_host_t::try_close_browser() or
// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
// to close immediately (see the examples below). This gives CEF an
// opportunity to process the &#39;onbeforeunload&#39; event and optionally cancel the
// close before do_close() is called.
//
// When windowed rendering is enabled CEF will internally create a window or
// view to host the browser. In that case returning false (0) from do_close()
// will send the standard close notification to the browser&#39;s top-level owner
// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
// Linux or cef_window_delegate_t::can_close() callback from Views). If the
// browser&#39;s host window/view has already been destroyed (via view hierarchy
// tear-down, for example) then do_close() will not be called for that browser
// since is no longer possible to cancel the close.
//
// When windowed rendering is disabled returning false (0) from do_close()
// will cause the browser object to be destroyed immediately.
//
// If the browser&#39;s top-level owner window requires a non-standard close
// notification then send that notification from do_close() and return true
// (1).
//
// The cef_life_span_handler_t::on_before_close() function will be called
// after do_close() (if do_close() is called) and immediately before the
// browser object is destroyed. The application should only exit after
// on_before_close() has been called for all existing browsers.
//
// The below examples describe what should happen during window close when the
// browser is parented to an application-provided top-level window.
//
// Example 1: Using cef_browser_host_t::try_close_browser(). This is
// recommended for clients using standard close handling and windows created
// on the browser process UI thread. 1.  User clicks the window close button
// which sends a close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
//     TryCloseBrowser() returns false so the client cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// CEF sends a close notification to the application&#39;s top-level window
//     (because DoClose() returned false by default).
// 7.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
//     allows the window close.
// 8.  Application&#39;s top-level window is destroyed. 9.  Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 10. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
//
// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
// implementing the do_close() callback. This is recommended for clients using
// non-standard close handling or windows that were not created on the browser
// process UI thread. 1.  User clicks the window close button which sends a
// close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and:
//     A. Calls CefBrowserHost::CloseBrowser(false).
//     B. Cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// Application&#39;s do_close() handler is called. Application will:
//     A. Set a flag to indicate that the next close attempt will be allowed.
//     B. Return false.
// 7.  CEF sends an close notification to the application&#39;s top-level window.
// 8.  Application&#39;s top-level window receives the close notification and
//     allows the window to close based on the flag from #6B.
// 9.  Application&#39;s top-level window is destroyed. 10. Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 11. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
///
//export cefingo_life_span_handler_do_close
func cefingo_life_span_handler_do_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.9:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.do_close_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLifeSpanHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		goRet := f.DoClose(goTmpself, goTmpbrowser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T155.10: do_close: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called just before a browser is destroyed. Release all references to the
// browser object and do not attempt to execute any functions on the browser
// object (other than IsValid, GetIdentifier or IsSame) after this callback
// returns. cef_frame_handler_t callbacks related to final main frame
// destruction will arrive after this callback and cef_browser_t::IsValid will
// return false (0) at that time. Any in-progress network requests associated
// with |browser| will be aborted when the browser is destroyed, and
// cef_resource_request_handler_t callbacks related to those requests may
// still arrive on the IO thread after this callback. See cef_frame_handler_t
// and do_close() documentation for additional usage information.
///
//export cefingo_life_span_handler_on_before_close
func cefingo_life_span_handler_on_before_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.11:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_close_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLifeSpanHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnBeforeClose(goTmpself, goTmpbrowser)

	} else {
		Logf("T155.12: on_before_close: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the loading state has changed. This callback will be executed
// twice -- once when loading is initiated either programmatically or by user
// action, and once when loading is terminated due to completion, cancellation
// of failure. It will be called before any calls to OnLoadStart and after all
// calls to OnLoadError and/or OnLoadEnd.
///
//export cefingo_load_handler_on_loading_state_change
func cefingo_load_handler_on_loading_state_change(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	isLoading C.int,
	canGoBack C.int,
	canGoForward C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.5:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_loading_state_change_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLoadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpisLoading := isLoading != 0
		// !p.IsOutParam
		goTmpcanGoBack := canGoBack != 0
		// !p.IsOutParam
		goTmpcanGoForward := canGoForward != 0

		f.OnLoadingStateChange(goTmpself, goTmpbrowser, goTmpisLoading, goTmpcanGoBack, goTmpcanGoForward)

	} else {
		Logf("T156.6: on_loading_state_change: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called after a navigation has been committed and before the browser begins
// loading contents in the frame. The |frame| value will never be NULL -- call
// the is_main() function to check if this frame is the main frame.
// |transition_type| provides information about the source of the navigation
// and an accurate value is only available in the browser process. Multiple
// frames may be loading at the same time. Sub-frames may start or continue
// loading after the main frame load has ended. This function will not be
// called for same page navigations (fragments, history state, etc.) or for
// navigations that fail or are canceled before commit. For notification of
// overall browser load status use OnLoadingStateChange instead.
///
//export cefingo_load_handler_on_load_start
func cefingo_load_handler_on_load_start(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	transition_type C.cef_transition_type_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.7:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_start_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLoadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmptransition_type := CTransitionTypeT(transition_type)

		f.OnLoadStart(goTmpself, goTmpbrowser, goTmpframe, goTmptransition_type)

	} else {
		Logf("T156.8: on_load_start: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi

}

///
// Called when the browser is done loading a frame. The |frame| value will
// never be NULL -- call the is_main() function to check if this frame is the
// main frame. Multiple frames may be loading at the same time. Sub-frames may
// start or continue loading after the main frame load has ended. This
// function will not be called for same page navigations (fragments, history
// state, etc.) or for navigations that fail or are canceled before commit.
// For notification of overall browser load status use OnLoadingStateChange
// instead.
///
//export cefingo_load_handler_on_load_end
func cefingo_load_handler_on_load_end(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	httpStatusCode C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.9:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_end_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLoadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmphttpStatusCode := (int)(httpStatusCode)

		f.OnLoadEnd(goTmpself, goTmpbrowser, goTmpframe, goTmphttpStatusCode)

	} else {
		Logf("T156.10: on_load_end: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi

}

///
// Called when a navigation fails or is canceled. This function may be called
// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
// after commit. |errorCode| is the error code number, |errorText| is the
// error text and |failedUrl| is the URL that failed to load. See
// net\base\net_error_list.h for complete descriptions of the error codes.
///
//export cefingo_load_handler_on_load_error
func cefingo_load_handler_on_load_error(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	errorCode C.cef_errorcode_t,
	errorText *C.cef_string_t,
	failedUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.11:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_error_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCLoadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmperrorCode := CErrorcodeT(errorCode)
		// !p.IsOutParam
		goTmperrorText := string_from_cef_string(errorText)
		// !p.IsOutParam
		goTmpfailedUrl := string_from_cef_string(failedUrl)

		f.OnLoadError(goTmpself, goTmpbrowser, goTmpframe, goTmperrorCode, goTmperrorText, goTmpfailedUrl)

	} else {
		Logf("T156.12: on_load_error: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi

}

///
// The list of available media sinks has changed or
// cef_media_router_t::NotifyCurrentSinks was called.
///
//export cefingo_media_observer_on_sinks
func cefingo_media_observer_on_sinks(
	self *C.cef_media_observer_t,
	sinksCount C.size_t,
	sinks **C.cef_media_sink_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.5:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_sinks_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMediaObserverT(self, byApi)
		// !p.IsOutParam
		// !p.IsOutParam
		// p.IsSliceParam
		slice := (*[1 << 30](*C.cef_media_sink_t))(unsafe.Pointer(sinks))[:sinksCount:sinksCount]
		goTmpsinks := make([]*CMediaSinkT, sinksCount)
		for i, v := range slice {
			goTmpsinks[i] = newCMediaSinkT(v, byApi)
		}

		f.OnSinks(goTmpself, goTmpsinks)

	} else {
		Logf("T158.6: on_sinks: Noo!")
	}

}

///
// The list of available media routes has changed or
// cef_media_router_t::NotifyCurrentRoutes was called.
///
//export cefingo_media_observer_on_routes
func cefingo_media_observer_on_routes(
	self *C.cef_media_observer_t,
	routesCount C.size_t,
	routes **C.cef_media_route_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.7:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_routes_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMediaObserverT(self, byApi)
		// !p.IsOutParam
		// !p.IsOutParam
		// p.IsSliceParam
		slice := (*[1 << 30](*C.cef_media_route_t))(unsafe.Pointer(routes))[:routesCount:routesCount]
		goTmproutes := make([]*CMediaRouteT, routesCount)
		for i, v := range slice {
			goTmproutes[i] = newCMediaRouteT(v, byApi)
		}

		f.OnRoutes(goTmpself, goTmproutes)

	} else {
		Logf("T158.8: on_routes: Noo!")
	}

}

///
// The connection state of |route| has changed.
///
//export cefingo_media_observer_on_route_state_changed
func cefingo_media_observer_on_route_state_changed(
	self *C.cef_media_observer_t,
	route *C.cef_media_route_t,
	state C.cef_media_route_connection_state_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.9:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_route_state_changed_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMediaObserverT(self, byApi)
		// !p.IsOutParam
		goTmproute := newCMediaRouteT(route, byApi)
		// !p.IsOutParam
		goTmpstate := CMediaRouteConnectionStateT(state)

		f.OnRouteStateChanged(goTmpself, goTmproute, goTmpstate)

	} else {
		Logf("T158.10: on_route_state_changed: Noo!")
	}
	BaseRelease((*cCMediaRouteT)(route)) // byApi

}

///
// A message was recieved over |route|. |message| is only valid for the scope
// of this callback and should be copied if necessary.
///
//export cefingo_media_observer_on_route_message_received
func cefingo_media_observer_on_route_message_received(
	self *C.cef_media_observer_t,
	route *C.cef_media_route_t,
	message C.VOIDP,
	message_size C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.11:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_route_message_received_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMediaObserverT(self, byApi)
		// !p.IsOutParam
		goTmproute := newCMediaRouteT(route, byApi)
		// !p.IsOutParam
		goTmpmessage := (*[1 << 30]byte)(message)[:message_size:message_size]

		f.OnRouteMessageReceived(goTmpself, goTmproute, goTmpmessage)

	} else {
		Logf("T158.12: on_route_message_received: Noo!")
	}
	BaseRelease((*cCMediaRouteT)(route)) // byApi

}

///
// Called when |button| is pressed. Call cef_menu_button_t::show_menu() to
// show a popup menu at |screen_point|. When showing a custom popup such as a
// window keep a reference to |button_pressed_lock| until the popup is hidden
// to maintain the pressed button state.
///
//export cefingo_menu_button_delegate_on_menu_button_pressed
func cefingo_menu_button_delegate_on_menu_button_pressed(
	self *C.cef_menu_button_delegate_t,
	menu_button *C.cef_menu_button_t,
	screen_point *C.cef_point_t,
	button_pressed_lock *C.cef_menu_button_pressed_lock_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.5:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_menu_button_pressed_handler[(*cCMenuButtonDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuButtonDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_button := newCMenuButtonT(menu_button, byApi)
		// !p.IsOutParam
		goTmpscreen_point := (*CPointT)(screen_point)
		// !p.IsOutParam
		goTmpbutton_pressed_lock := newCMenuButtonPressedLockT(button_pressed_lock, byApi)

		f.OnMenuButtonPressed(goTmpself, goTmpmenu_button, goTmpscreen_point, goTmpbutton_pressed_lock)

	} else {
		Logf("T165.6: on_menu_button_pressed: Noo!")
	}
	BaseRelease((*cCMenuButtonT)(menu_button))                    // byApi
	BaseRelease((*cCMenuButtonPressedLockT)(button_pressed_lock)) // byApi

}

///
// Called when |button| is pressed.
///
//export cefingo_menu_button_delegate_on_button_pressed
func cefingo_menu_button_delegate_on_button_pressed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.7:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_button_pressed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCButtonDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbutton := newCButtonT(button, byApi)

		f.OnButtonPressed(goTmpself, goTmpbutton)

	} else {
		Logf("T165.8: on_button_pressed: Noo!")
	}
	BaseRelease((*cCButtonT)(button)) // byApi

}

///
// Called when the state of |button| changes.
///
//export cefingo_menu_button_delegate_on_button_state_changed
func cefingo_menu_button_delegate_on_button_state_changed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.9:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_button_state_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCButtonDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpbutton := newCButtonT(button, byApi)

		f.OnButtonStateChanged(goTmpself, goTmpbutton)

	} else {
		Logf("T165.10: on_button_state_changed: Noo!")
	}
	BaseRelease((*cCButtonT)(button)) // byApi

}

//export cefingo_menu_button_delegate_get_preferred_size
func cefingo_menu_button_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.11:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_preferred_size_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T165.12: get_preferred_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_menu_button_delegate_get_minimum_size
func cefingo_menu_button_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.13:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_minimum_size_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T165.14: get_minimum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_menu_button_delegate_get_maximum_size
func cefingo_menu_button_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.15:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_maximum_size_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T165.16: get_maximum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_menu_button_delegate_get_height_for_width
func cefingo_menu_button_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.17:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_height_for_width_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T165.18: get_height_for_width: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_menu_button_delegate_on_parent_view_changed
func cefingo_menu_button_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.19:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_parent_view_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpparent := newCViewT(parent, byApi)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)

	} else {
		Logf("T165.20: on_parent_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))   // byApi
	BaseRelease((*cCViewT)(parent)) // byApi

}

//export cefingo_menu_button_delegate_on_child_view_changed
func cefingo_menu_button_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.21:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_child_view_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpchild := newCViewT(child, byApi)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)

	} else {
		Logf("T165.22: on_child_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))  // byApi
	BaseRelease((*cCViewT)(child)) // byApi

}

//export cefingo_menu_button_delegate_on_window_changed
func cefingo_menu_button_delegate_on_window_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.23:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_window_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)

		f.OnWindowChanged(goTmpself, goTmpview, goTmpadded)

	} else {
		Logf("T165.24: on_window_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_menu_button_delegate_on_layout_changed
func cefingo_menu_button_delegate_on_layout_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	new_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.25:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_layout_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpnew_bounds := (*CRectT)(new_bounds)

		f.OnLayoutChanged(goTmpself, goTmpview, goTmpnew_bounds)

	} else {
		Logf("T165.26: on_layout_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_menu_button_delegate_on_focus
func cefingo_menu_button_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.27:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_focus_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnFocus(goTmpself, goTmpview)

	} else {
		Logf("T165.28: on_focus: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_menu_button_delegate_on_blur
func cefingo_menu_button_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.29:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_blur_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnBlur(goTmpself, goTmpview)

	} else {
		Logf("T165.30: on_blur: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Perform the action associated with the specified |command_id| and optional
// |event_flags|.
///
//export cefingo_menu_model_delegate_execute_command
func cefingo_menu_model_delegate_execute_command(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.5:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.execute_command_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuModelDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_model := newCMenuModelT(menu_model, byApi)
		// !p.IsOutParam
		goTmpcommand_id := (int)(command_id)
		// !p.IsOutParam
		goTmpevent_flags := CEventFlagsT(event_flags)

		f.ExecuteCommand(goTmpself, goTmpmenu_model, goTmpcommand_id, goTmpevent_flags)

	} else {
		Logf("T167.6: execute_command: Noo!")
	}
	BaseRelease((*cCMenuModelT)(menu_model)) // byApi

}

///
// Called when the user moves the mouse outside the menu and over the owning
// window.
///
//export cefingo_menu_model_delegate_mouse_outside_menu
func cefingo_menu_model_delegate_mouse_outside_menu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	screen_point *C.cef_point_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.7:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.mouse_outside_menu_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuModelDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_model := newCMenuModelT(menu_model, byApi)
		// !p.IsOutParam
		goTmpscreen_point := (*CPointT)(screen_point)

		f.MouseOutsideMenu(goTmpself, goTmpmenu_model, goTmpscreen_point)

	} else {
		Logf("T167.8: mouse_outside_menu: Noo!")
	}
	BaseRelease((*cCMenuModelT)(menu_model)) // byApi

}

///
// Called on unhandled open submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_open_submenu
func cefingo_menu_model_delegate_unhandled_open_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.9:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_open_submenu_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuModelDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_model := newCMenuModelT(menu_model, byApi)
		// !p.IsOutParam
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledOpenSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)

	} else {
		Logf("T167.10: unhandled_open_submenu: Noo!")
	}
	BaseRelease((*cCMenuModelT)(menu_model)) // byApi

}

///
// Called on unhandled close submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_close_submenu
func cefingo_menu_model_delegate_unhandled_close_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.11:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_close_submenu_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuModelDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_model := newCMenuModelT(menu_model, byApi)
		// !p.IsOutParam
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledCloseSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)

	} else {
		Logf("T167.12: unhandled_close_submenu: Noo!")
	}
	BaseRelease((*cCMenuModelT)(menu_model)) // byApi

}

///
// The menu is about to show.
///
//export cefingo_menu_model_delegate_menu_will_show
func cefingo_menu_model_delegate_menu_will_show(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.13:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_will_show_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuModelDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_model := newCMenuModelT(menu_model, byApi)

		f.MenuWillShow(goTmpself, goTmpmenu_model)

	} else {
		Logf("T167.14: menu_will_show: Noo!")
	}
	BaseRelease((*cCMenuModelT)(menu_model)) // byApi

}

///
// The menu has closed.
///
//export cefingo_menu_model_delegate_menu_closed
func cefingo_menu_model_delegate_menu_closed(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.15:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_closed_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuModelDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_model := newCMenuModelT(menu_model, byApi)

		f.MenuClosed(goTmpself, goTmpmenu_model)

	} else {
		Logf("T167.16: menu_closed: Noo!")
	}
	BaseRelease((*cCMenuModelT)(menu_model)) // byApi

}

///
// Optionally modify a menu item label. Return true (1) if |label| was
// modified.
///
//export cefingo_menu_model_delegate_format_label
func cefingo_menu_model_delegate_format_label(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	label *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.17:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.format_label_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCMenuModelDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpmenu_model := newCMenuModelT(menu_model, byApi)
		// p.IsInOutParam
		goTmplabel := string_from_cef_string(label)

		goRet, goTmplabelOut := f.FormatLabel(goTmpself, goTmpmenu_model, goTmplabel)
		set_cef_string(label, goTmplabelOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T167.18: format_label: Noo!")
	}
	BaseRelease((*cCMenuModelT)(menu_model)) // byApi

	return cRet
}

//export cefingo_panel_delegate_get_preferred_size
func cefingo_panel_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.5:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_preferred_size_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T170.6: get_preferred_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_panel_delegate_get_minimum_size
func cefingo_panel_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.7:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_minimum_size_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T170.8: get_minimum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_panel_delegate_get_maximum_size
func cefingo_panel_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.9:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_maximum_size_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T170.10: get_maximum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_panel_delegate_get_height_for_width
func cefingo_panel_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.11:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_height_for_width_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T170.12: get_height_for_width: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_panel_delegate_on_parent_view_changed
func cefingo_panel_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.13:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_parent_view_changed_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpparent := newCViewT(parent, byApi)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)

	} else {
		Logf("T170.14: on_parent_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))   // byApi
	BaseRelease((*cCViewT)(parent)) // byApi

}

//export cefingo_panel_delegate_on_child_view_changed
func cefingo_panel_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.15:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_child_view_changed_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpchild := newCViewT(child, byApi)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)

	} else {
		Logf("T170.16: on_child_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))  // byApi
	BaseRelease((*cCViewT)(child)) // byApi

}

//export cefingo_panel_delegate_on_window_changed
func cefingo_panel_delegate_on_window_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.17:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_window_changed_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)

		f.OnWindowChanged(goTmpself, goTmpview, goTmpadded)

	} else {
		Logf("T170.18: on_window_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_panel_delegate_on_layout_changed
func cefingo_panel_delegate_on_layout_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	new_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.19:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_layout_changed_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpnew_bounds := (*CRectT)(new_bounds)

		f.OnLayoutChanged(goTmpself, goTmpview, goTmpnew_bounds)

	} else {
		Logf("T170.20: on_layout_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_panel_delegate_on_focus
func cefingo_panel_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.21:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_focus_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnFocus(goTmpself, goTmpview)

	} else {
		Logf("T170.22: on_focus: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_panel_delegate_on_blur
func cefingo_panel_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.23:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_blur_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnBlur(goTmpself, goTmpview)

	} else {
		Logf("T170.24: on_blur: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when printing has started for the specified |browser|. This function
// will be called before the other OnPrint*() functions and irrespective of
// how printing was initiated (e.g. cef_browser_host_t::print(), JavaScript
// window.print() or PDF extension print button).
///
//export cefingo_print_handler_on_print_start
func cefingo_print_handler_on_print_start(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.5:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_start_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCPrintHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnPrintStart(goTmpself, goTmpbrowser)

	} else {
		Logf("T173.6: on_print_start: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Synchronize |settings| with client state. If |get_defaults| is true (1)
// then populate |settings| with the default print settings. Do not keep a
// reference to |settings| outside of this callback.
///
//export cefingo_print_handler_on_print_settings
func cefingo_print_handler_on_print_settings(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	settings *C.cef_print_settings_t,
	get_defaults C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.7:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_settings_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCPrintHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpsettings := newCPrintSettingsT(settings, byApi)
		// !p.IsOutParam
		goTmpget_defaults := (int)(get_defaults)

		f.OnPrintSettings(goTmpself, goTmpbrowser, goTmpsettings, goTmpget_defaults)

	} else {
		Logf("T173.8: on_print_settings: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))        // byApi
	BaseRelease((*cCPrintSettingsT)(settings)) // byApi

}

///
// Show the print dialog. Execute |callback| once the dialog is dismissed.
// Return true (1) if the dialog will be displayed or false (0) to cancel the
// printing immediately.
///
//export cefingo_print_handler_on_print_dialog
func cefingo_print_handler_on_print_dialog(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	has_selection C.int,
	callback *C.cef_print_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.9:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_dialog_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCPrintHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmphas_selection := (int)(has_selection)
		// !p.IsOutParam
		goTmpcallback := newCPrintDialogCallbackT(callback, byApi)

		goRet := f.OnPrintDialog(goTmpself, goTmpbrowser, goTmphas_selection, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T173.10: on_print_dialog: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))              // byApi
	BaseRelease((*cCPrintDialogCallbackT)(callback)) // byApi

	return cRet
}

///
// Send the print job to the printer. Execute |callback| once the job is
// completed. Return true (1) if the job will proceed or false (0) to cancel
// the job immediately.
///
//export cefingo_print_handler_on_print_job
func cefingo_print_handler_on_print_job(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	document_name *C.cef_string_t,
	pdf_file_path *C.cef_string_t,
	callback *C.cef_print_job_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.11:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_job_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCPrintHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpdocument_name := string_from_cef_string(document_name)
		// !p.IsOutParam
		goTmppdf_file_path := string_from_cef_string(pdf_file_path)
		// !p.IsOutParam
		goTmpcallback := newCPrintJobCallbackT(callback, byApi)

		goRet := f.OnPrintJob(goTmpself, goTmpbrowser, goTmpdocument_name, goTmppdf_file_path, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T173.12: on_print_job: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))           // byApi
	BaseRelease((*cCPrintJobCallbackT)(callback)) // byApi

	return cRet
}

///
// Reset client state related to printing.
///
//export cefingo_print_handler_on_print_reset
func cefingo_print_handler_on_print_reset(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.13:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_reset_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCPrintHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnPrintReset(goTmpself, goTmpbrowser)

	} else {
		Logf("T173.14: on_print_reset: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Return the PDF paper size in device units. Used in combination with
// cef_browser_host_t::print_to_pdf().
///
//export cefingo_print_handler_get_pdf_paper_size
func cefingo_print_handler_get_pdf_paper_size(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	device_units_per_inch C.int,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.15:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.get_pdf_paper_size_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCPrintHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpdevice_units_per_inch := (int)(device_units_per_inch)

		goRet := f.GetPdfPaperSize(goTmpself, goTmpbrowser, goTmpdevice_units_per_inch)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T173.16: get_pdf_paper_size: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Return the handler for accessibility notifications. If no handler is
// provided the default implementation will be used.
///
//export cefingo_render_handler_get_accessibility_handler
func cefingo_render_handler_get_accessibility_handler(
	self *C.cef_render_handler_t,
) (cRet *C.cef_accessibility_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.5:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_accessibility_handler_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)

		goRet := f.GetAccessibilityHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_accessibility_handler) // return GoObj
			}
			cRet = (*C.cef_accessibility_handler_t)(goRet.pc_accessibility_handler)
		}
	} else {
		Logf("T177.6: get_accessibility_handler: Noo!")
	}

	return cRet
}

///
// Called to retrieve the root window rectangle in screen coordinates. Return
// true (1) if the rectangle was provided. If this function returns false (0)
// the rectangle from GetViewRect will be used.
///
//export cefingo_render_handler_get_root_screen_rect
func cefingo_render_handler_get_root_screen_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.7:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_root_screen_rect_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		goRet, goTmprectOut := f.GetRootScreenRect(goTmpself, goTmpbrowser)
		*rect = (C.cef_rect_t)(goTmprectOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.8: get_root_screen_rect: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called to retrieve the view rectangle which is relative to screen
// coordinates. This function must always provide a non-NULL rectangle.
///
//export cefingo_render_handler_get_view_rect
func cefingo_render_handler_get_view_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.9:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_view_rect_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		goTmprectOut := f.GetViewRect(goTmpself, goTmpbrowser)
		*rect = (C.cef_rect_t)(goTmprectOut)

	} else {
		Logf("T177.10: get_view_rect: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called to retrieve the translation from view coordinates to actual screen
// coordinates. Return true (1) if the screen coordinates were provided.
///
//export cefingo_render_handler_get_screen_point
func cefingo_render_handler_get_screen_point(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	viewX C.int,
	viewY C.int,
	screenX *C.int,
	screenY *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.11:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_point_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpviewX := (int)(viewX)
		// !p.IsOutParam
		goTmpviewY := (int)(viewY)

		goRet, goTmpscreenXOut, goTmpscreenYOut := f.GetScreenPoint(goTmpself, goTmpbrowser, goTmpviewX, goTmpviewY)
		*screenX = (C.int)(goTmpscreenXOut)
		*screenY = (C.int)(goTmpscreenYOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.12: get_screen_point: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called to allow the client to fill in the CefScreenInfo object with
// appropriate values. Return true (1) if the |screen_info| structure has been
// modified.
//
// If the screen info rectangle is left NULL the rectangle from GetViewRect
// will be used. If the rectangle is still NULL or invalid popups may not be
// drawn correctly.
///
//export cefingo_render_handler_get_screen_info
func cefingo_render_handler_get_screen_info(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	screen_info *C.cef_screen_info_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.13:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_info_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// p.IsInOutParam
		goTmpscreen_info := CScreenInfoT(*screen_info)

		goRet, goTmpscreen_infoOut := f.GetScreenInfo(goTmpself, goTmpbrowser, goTmpscreen_info)
		*screen_info = C.cef_screen_info_t(goTmpscreen_infoOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.14: get_screen_info: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

	return cRet
}

///
// Called when the browser wants to show or hide the popup widget. The popup
// should be shown if |show| is true (1) and hidden if |show| is false (0).
///
//export cefingo_render_handler_on_popup_show
func cefingo_render_handler_on_popup_show(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	show C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.15:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_show_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpshow := (int)(show)

		f.OnPopupShow(goTmpself, goTmpbrowser, goTmpshow)

	} else {
		Logf("T177.16: on_popup_show: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the browser wants to move or resize the popup widget. |rect|
// contains the new location and size in view coordinates.
///
//export cefingo_render_handler_on_popup_size
func cefingo_render_handler_on_popup_size(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.17:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_size_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmprect := (*CRectT)(rect)

		f.OnPopupSize(goTmpself, goTmpbrowser, goTmprect)

	} else {
		Logf("T177.18: on_popup_size: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when an element should be painted. Pixel values passed to this
// function are scaled relative to view coordinates based on the value of
// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
// indicates whether the element is the view or the popup widget. |buffer|
// contains the pixel data for the whole image. |dirtyRects| contains the set
// of rectangles in pixel coordinates that need to be repainted. |buffer| will
// be |width|*|height|*4 bytes in size and represents a BGRA image with an
// upper-left origin. This function is only called when
// cef_window_tInfo::shared_texture_enabled is set to false (0).
///
//export cefingo_render_handler_on_paint
func cefingo_render_handler_on_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	buffer C.VOIDP,
	width C.int,
	height C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.19:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_paint_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmptype := CPaintElementTypeT(ctype)
		// !p.IsOutParam
		// !p.IsOutParam
		// p.IsSliceParam
		slice := (*[1 << 30](C.cef_rect_t))(unsafe.Pointer(dirtyRects))[:dirtyRectsCount:dirtyRectsCount]
		goTmpdirtyRects := make([]CRectT, dirtyRectsCount)
		for i, v := range slice {
			goTmpdirtyRects[i] = (CRectT)(v)
		}
		// !p.IsOutParam
		goTmpbuffer := unsafe.Pointer(buffer)
		// !p.IsOutParam
		goTmpwidth := (int)(width)
		// !p.IsOutParam
		goTmpheight := (int)(height)

		f.OnPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRects, goTmpbuffer, goTmpwidth, goTmpheight)

	} else {
		Logf("T177.20: on_paint: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when an element has been rendered to the shared texture handle.
// |type| indicates whether the element is the view or the popup widget.
// |dirtyRects| contains the set of rectangles in pixel coordinates that need
// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
// can be accessed via ID3D11Device using the OpenSharedResource function.
// This function is only called when cef_window_tInfo::shared_texture_enabled
// is set to true (1), and is currently only supported on Windows.
///
//export cefingo_render_handler_on_accelerated_paint
func cefingo_render_handler_on_accelerated_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	shared_handle C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.21:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_accelerated_paint_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmptype := CPaintElementTypeT(ctype)
		// !p.IsOutParam
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		// !p.IsOutParam
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		// !p.IsOutParam
		goTmpshared_handle := unsafe.Pointer(shared_handle)

		f.OnAcceleratedPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRectsCount, goTmpdirtyRects, goTmpshared_handle)

	} else {
		Logf("T177.22: on_accelerated_paint: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the user starts dragging content in the web view. Contextual
// information about the dragged content is supplied by |drag_data|. (|x|,
// |y|) is the drag start location in screen coordinates. OS APIs that run a
// system message loop may be used within the StartDragging call.
//
// Return false (0) to abort the drag operation. Don&#39;t call any of
// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
//
// Return true (1) to handle the drag operation. Call
// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
// synchronously or asynchronously to inform the web view that the drag
// operation has ended.
///
//export cefingo_render_handler_start_dragging
func cefingo_render_handler_start_dragging(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	drag_data *C.cef_drag_data_t,
	allowed_ops C.cef_drag_operations_mask_t,
	x C.int,
	y C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.23:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.start_dragging_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpdrag_data := newCDragDataT(drag_data, byApi)
		// !p.IsOutParam
		goTmpallowed_ops := CDragOperationsMaskT(allowed_ops)
		// !p.IsOutParam
		goTmpx := (int)(x)
		// !p.IsOutParam
		goTmpy := (int)(y)

		goRet := f.StartDragging(goTmpself, goTmpbrowser, goTmpdrag_data, goTmpallowed_ops, goTmpx, goTmpy)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.24: start_dragging: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))    // byApi
	BaseRelease((*cCDragDataT)(drag_data)) // byApi

	return cRet
}

///
// Called when the web view wants to update the mouse cursor during a drag &amp;
// drop operation. |operation| describes the allowed operation (none, move,
// copy, link).
///
//export cefingo_render_handler_update_drag_cursor
func cefingo_render_handler_update_drag_cursor(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	operation C.cef_drag_operations_mask_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.25:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.update_drag_cursor_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpoperation := CDragOperationsMaskT(operation)

		f.UpdateDragCursor(goTmpself, goTmpbrowser, goTmpoperation)

	} else {
		Logf("T177.26: update_drag_cursor: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the scroll offset has changed.
///
//export cefingo_render_handler_on_scroll_offset_changed
func cefingo_render_handler_on_scroll_offset_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	x C.double,
	y C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.27:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_scroll_offset_changed_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpx := (float64)(x)
		// !p.IsOutParam
		goTmpy := (float64)(y)

		f.OnScrollOffsetChanged(goTmpself, goTmpbrowser, goTmpx, goTmpy)

	} else {
		Logf("T177.28: on_scroll_offset_changed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when the IME composition range has changed. |selected_range| is the
// range of characters that have been selected. |character_bounds| is the
// bounds of each character in view coordinates.
///
//export cefingo_render_handler_on_ime_composition_range_changed
func cefingo_render_handler_on_ime_composition_range_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_range *C.cef_range_t,
	character_boundsCount C.size_t,
	character_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.29:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_ime_composition_range_changed_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpselected_range := (*CRangeT)(selected_range)
		// !p.IsOutParam
		goTmpcharacter_boundsCount := (int64)(character_boundsCount)
		// !p.IsOutParam
		goTmpcharacter_bounds := (*CRectT)(character_bounds)

		f.OnImeCompositionRangeChanged(goTmpself, goTmpbrowser, goTmpselected_range, goTmpcharacter_boundsCount, goTmpcharacter_bounds)

	} else {
		Logf("T177.30: on_ime_composition_range_changed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when text selection has changed for the specified |browser|.
// |selected_text| is the currently selected text and |selected_range| is the
// character range.
///
//export cefingo_render_handler_on_text_selection_changed
func cefingo_render_handler_on_text_selection_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_text *C.cef_string_t,
	selected_range *C.cef_range_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.31:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_text_selection_changed_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpselected_text := string_from_cef_string(selected_text)
		// !p.IsOutParam
		goTmpselected_range := (*CRangeT)(selected_range)

		f.OnTextSelectionChanged(goTmpself, goTmpbrowser, goTmpselected_text, goTmpselected_range)

	} else {
		Logf("T177.32: on_text_selection_changed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called when an on-screen keyboard should be shown or hidden for the
// specified |browser|. |input_mode| specifies what kind of keyboard should be
// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
// for this browser should be hidden.
///
//export cefingo_render_handler_on_virtual_keyboard_requested
func cefingo_render_handler_on_virtual_keyboard_requested(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	input_mode C.cef_text_input_mode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.33:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_virtual_keyboard_requested_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpinput_mode := CTextInputModeT(input_mode)

		f.OnVirtualKeyboardRequested(goTmpself, goTmpbrowser, goTmpinput_mode)

	} else {
		Logf("T177.34: on_virtual_keyboard_requested: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called after WebKit has been initialized.
///
//export cefingo_render_process_handler_on_web_kit_initialized
func cefingo_render_process_handler_on_web_kit_initialized(
	self *C.cef_render_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.5:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_web_kit_initialized_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)

		f.OnWebKitInitialized(goTmpself)

	} else {
		Logf("T178.6: on_web_kit_initialized: Noo!")
	}

}

///
// Called after a browser has been created. When browsing cross-origin a new
// browser will be created before the old browser with the same identifier is
// destroyed. |extra_info| is an optional read-only value originating from
// cef_browser_host_t::cef_browser_host_create_browser(),
// cef_browser_host_t::cef_browser_host_create_browser_sync(),
// cef_life_span_handler_t::on_before_popup() or
// cef_browser_view_t::cef_browser_view_create().
///
//export cefingo_render_process_handler_on_browser_created
func cefingo_render_process_handler_on_browser_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	extra_info *C.cef_dictionary_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.7:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_created_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpextra_info := newCDictionaryValueT(extra_info, byApi)

		f.OnBrowserCreated(goTmpself, goTmpbrowser, goTmpextra_info)

	} else {
		Logf("T178.8: on_browser_created: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))            // byApi
	BaseRelease((*cCDictionaryValueT)(extra_info)) // byApi

}

///
// Called before a browser is destroyed.
///
//export cefingo_render_process_handler_on_browser_destroyed
func cefingo_render_process_handler_on_browser_destroyed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.9:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_destroyed_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnBrowserDestroyed(goTmpself, goTmpbrowser)

	} else {
		Logf("T178.10: on_browser_destroyed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Return the handler for browser load status events.
///
//export cefingo_render_process_handler_get_load_handler
func cefingo_render_process_handler_get_load_handler(
	self *C.cef_render_process_handler_t,
) (cRet *C.cef_load_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.11:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.get_load_handler_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)

		goRet := f.GetLoadHandler(goTmpself)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_load_handler) // return GoObj
			}
			cRet = (*C.cef_load_handler_t)(goRet.pc_load_handler)
		}
	} else {
		Logf("T178.12: get_load_handler: Noo!")
	}

	return cRet
}

///
// Called immediately after the V8 context for a frame has been created. To
// retrieve the JavaScript &#39;window&#39; object use the
// cef_v8context_t::get_global() function. V8 handles can only be accessed
// from the thread on which they are created. A task runner for posting tasks
// on the associated thread can be retrieved via the
// cef_v8context_t::get_task_runner() function.
///
//export cefingo_render_process_handler_on_context_created
func cefingo_render_process_handler_on_context_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.13:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_created_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpcontext := newCV8contextT(context, byApi)

		f.OnContextCreated(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)

	} else {
		Logf("T178.14: on_context_created: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCV8contextT)(context)) // byApi

}

///
// Called immediately before the V8 context for a frame is released. No
// references to the context should be kept after this function is called.
///
//export cefingo_render_process_handler_on_context_released
func cefingo_render_process_handler_on_context_released(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.15:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_released_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpcontext := newCV8contextT(context, byApi)

		f.OnContextReleased(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)

	} else {
		Logf("T178.16: on_context_released: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCV8contextT)(context)) // byApi

}

///
// Called for global uncaught exceptions in a frame. Execution of this
// callback is disabled by default. To enable set
// CefSettings.uncaught_exception_stack_size &gt; 0.
///
//export cefingo_render_process_handler_on_uncaught_exception
func cefingo_render_process_handler_on_uncaught_exception(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
	exception *C.cef_v8exception_t,
	stackTrace *C.cef_v8stack_trace_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.17:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_uncaught_exception_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpcontext := newCV8contextT(context, byApi)
		// !p.IsOutParam
		goTmpexception := newCV8exceptionT(exception, byApi)
		// !p.IsOutParam
		goTmpstackTrace := newCV8stackTraceT(stackTrace, byApi)

		f.OnUncaughtException(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext, goTmpexception, goTmpstackTrace)

	} else {
		Logf("T178.18: on_uncaught_exception: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))         // byApi
	BaseRelease((*cCFrameT)(frame))             // byApi
	BaseRelease((*cCV8contextT)(context))       // byApi
	BaseRelease((*cCV8exceptionT)(exception))   // byApi
	BaseRelease((*cCV8stackTraceT)(stackTrace)) // byApi

}

///
// Called when a new node in the the browser gets focus. The |node| value may
// be NULL if no specific node has gained focus. The node object passed to
// this function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_render_process_handler_on_focused_node_changed
func cefingo_render_process_handler_on_focused_node_changed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	node *C.cef_domnode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.19:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_focused_node_changed_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpnode := newCDomnodeT(node, byApi)

		f.OnFocusedNodeChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpnode)

	} else {
		Logf("T178.20: on_focused_node_changed: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCDomnodeT)(node))    // byApi

}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. It is safe to keep a
// reference to |message| outside of this callback.
///
//export cefingo_render_process_handler_on_process_message_received
func cefingo_render_process_handler_on_process_message_received(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.21:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_process_message_received_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRenderProcessHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpsource_process := CProcessIdT(source_process)
		// !p.IsOutParam
		goTmpmessage := newCProcessMessageT(message, byApi)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T178.22: on_process_message_received: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))        // byApi
	BaseRelease((*cCFrameT)(frame))            // byApi
	BaseRelease((*cCProcessMessageT)(message)) // byApi

	return cRet
}

///
// Called on the browser process UI thread immediately after the request
// context has been initialized.
///
//export cefingo_request_context_handler_on_request_context_initialized
func cefingo_request_context_handler_on_request_context_initialized(
	self *C.cef_request_context_handler_t,
	request_context *C.cef_request_context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T185.5:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_request_context_initialized_handler[(*cCRequestContextHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestContextHandlerT(self, byApi)
		// !p.IsOutParam
		goTmprequest_context := newCRequestContextT(request_context, byApi)

		f.OnRequestContextInitialized(goTmpself, goTmprequest_context)

	} else {
		Logf("T185.6: on_request_context_initialized: Noo!")
	}
	BaseRelease((*cCRequestContextT)(request_context)) // byApi

}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request, and may be NULL for requests originating from service workers or
// cef_urlrequest_t. |request| represents the request contents and cannot be
// modified in this callback. |is_navigation| will be true (1) if the resource
// request is a navigation. |is_download| will be true (1) if the resource
// request is a download. |request_initiator| is the origin (scheme + domain)
// of the page that initiated the request. Set |disable_default_handling| to
// true (1) to disable default handling of the request, in which case it will
// need to be handled via cef_resource_request_handler_t::GetResourceHandler
// or it will be canceled. To allow the resource load to proceed with default
// handling return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. This function will not be called if
// the client associated with |browser| returns a non-NULL value from
// cef_request_handler_t::GetResourceRequestHandler for the same request
// (identified by cef_request_t::GetIdentifier).
///
//export cefingo_request_context_handler_get_resource_request_handler
func cefingo_request_context_handler_get_resource_request_handler(
	self *C.cef_request_context_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	is_navigation C.int,
	is_download C.int,
	request_initiator *C.cef_string_t,
	disable_default_handling *C.int,
) (cRet *C.cef_resource_request_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T185.7:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.get_resource_request_handler_handler[(*cCRequestContextHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestContextHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpis_navigation := (int)(is_navigation)
		// !p.IsOutParam
		goTmpis_download := (int)(is_download)
		// !p.IsOutParam
		goTmprequest_initiator := string_from_cef_string(request_initiator)

		goRet, goTmpdisable_default_handlingOut := f.GetResourceRequestHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpis_navigation, goTmpis_download, goTmprequest_initiator)
		*disable_default_handling = 0
		if goTmpdisable_default_handlingOut {
			*disable_default_handling = 1
		}

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_resource_request_handler) // return GoObj
			}
			cRet = (*C.cef_resource_request_handler_t)(goRet.pc_resource_request_handler)
		}
	} else {
		Logf("T185.8: get_resource_request_handler: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

	return cRet
}

///
// Called on the UI thread before browser navigation. Return true (1) to
// cancel the navigation or false (0) to allow the navigation to proceed. The
// |request| object cannot be modified in this callback.
// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
// If the navigation is allowed cef_load_handler_t::OnLoadStart and
// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event).
///
//export cefingo_request_handler_on_before_browse
func cefingo_request_handler_on_before_browse(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	user_gesture C.int,
	is_redirect C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.5:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_before_browse_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpuser_gesture := user_gesture != 0
		// !p.IsOutParam
		goTmpis_redirect := is_redirect != 0

		goRet := f.OnBeforeBrowse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpuser_gesture, goTmpis_redirect)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.6: on_before_browse: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

	return cRet
}

///
// Called on the UI thread before OnBeforeBrowse in certain limited cases
// where navigating a new or different browser might be desirable. This
// includes user-initiated navigation that might open in a special way (e.g.
// links clicked via middle-click or ctrl + left-click) and certain types of
// cross-origin navigation initiated from the renderer process (e.g.
// navigating the top-level frame to/from a file URL). The |browser| and
// |frame| values represent the source of the navigation. The
// |target_disposition| value indicates where the user intended to navigate
// the browser based on standard Chromium behaviors (e.g. current tab, new
// tab, etc). The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event). Return
// true (1) to cancel the navigation or false (0) to allow the navigation to
// proceed in the source browser&#39;s top-level frame.
///
//export cefingo_request_handler_on_open_urlfrom_tab
func cefingo_request_handler_on_open_urlfrom_tab(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.7:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_open_urlfrom_tab_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmptarget_url := string_from_cef_string(target_url)
		// !p.IsOutParam
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		// !p.IsOutParam
		goTmpuser_gesture := user_gesture != 0

		goRet := f.OnOpenUrlfromTab(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_disposition, goTmpuser_gesture)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.8: on_open_urlfrom_tab: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi

	return cRet
}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request. |request| represents the request contents and cannot be modified
// in this callback. |is_navigation| will be true (1) if the resource request
// is a navigation. |is_download| will be true (1) if the resource request is
// a download. |request_initiator| is the origin (scheme + domain) of the page
// that initiated the request. Set |disable_default_handling| to true (1) to
// disable default handling of the request, in which case it will need to be
// handled via cef_resource_request_handler_t::GetResourceHandler or it will
// be canceled. To allow the resource load to proceed with default handling
// return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. If this callback returns NULL the
// same function will be called on the associated
// cef_request_context_handler_t, if any.
///
//export cefingo_request_handler_get_resource_request_handler
func cefingo_request_handler_get_resource_request_handler(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	is_navigation C.int,
	is_download C.int,
	request_initiator *C.cef_string_t,
	disable_default_handling *C.int,
) (cRet *C.cef_resource_request_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.9:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.get_resource_request_handler_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpis_navigation := (int)(is_navigation)
		// !p.IsOutParam
		goTmpis_download := (int)(is_download)
		// !p.IsOutParam
		goTmprequest_initiator := string_from_cef_string(request_initiator)

		goRet, goTmpdisable_default_handlingOut := f.GetResourceRequestHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpis_navigation, goTmpis_download, goTmprequest_initiator)
		*disable_default_handling = 0
		if goTmpdisable_default_handlingOut {
			*disable_default_handling = 1
		}

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_resource_request_handler) // return GoObj
			}
			cRet = (*C.cef_resource_request_handler_t)(goRet.pc_resource_request_handler)
		}
	} else {
		Logf("T187.10: get_resource_request_handler: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

	return cRet
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |origin_url| is the origin making this authentication request. |isProxy|
// indicates whether the host is a proxy server. |host| contains the hostname
// and |port| contains the port number. |realm| is the realm of the challenge
// and may be NULL. |scheme| is the authentication scheme used, such as
// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
// FTP server. Return true (1) to continue the request and call
// cef_auth_callback_t::cont() either in this function or at a later time when
// the authentication information is available. Return false (0) to cancel the
// request immediately.
///
//export cefingo_request_handler_get_auth_credentials
func cefingo_request_handler_get_auth_credentials(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.11:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.get_auth_credentials_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmporigin_url := string_from_cef_string(origin_url)
		// !p.IsOutParam
		goTmpisProxy := (int)(isProxy)
		// !p.IsOutParam
		goTmphost := string_from_cef_string(host)
		// !p.IsOutParam
		goTmpport := (int)(port)
		// !p.IsOutParam
		goTmprealm := string_from_cef_string(realm)
		// !p.IsOutParam
		goTmpscheme := string_from_cef_string(scheme)
		// !p.IsOutParam
		goTmpcallback := newCAuthCallbackT(callback, byApi)

		goRet := f.GetAuthCredentials(goTmpself, goTmpbrowser, goTmporigin_url, goTmpisProxy, goTmphost, goTmpport, goTmprealm, goTmpscheme, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.12: get_auth_credentials: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))       // byApi
	BaseRelease((*cCAuthCallbackT)(callback)) // byApi

	return cRet
}

///
// Called on the IO thread when JavaScript requests a specific storage quota
// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
// origin of the page making the request. |new_size| is the requested quota
// size in bytes. Return true (1) to continue the request and call
// cef_callback_t functions either in this function or at a later time to
// grant or deny the request. Return false (0) to cancel the request
// immediately.
///
//export cefingo_request_handler_on_quota_request
func cefingo_request_handler_on_quota_request(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	new_size C.int64,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.13:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_quota_request_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmporigin_url := string_from_cef_string(origin_url)
		// !p.IsOutParam
		goTmpnew_size := (int64)(new_size)
		// !p.IsOutParam
		goTmpcallback := newCCallbackT(callback, byApi)

		goRet := f.OnQuotaRequest(goTmpself, goTmpbrowser, goTmporigin_url, goTmpnew_size, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.14: on_quota_request: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCCallbackT)(callback)) // byApi

	return cRet
}

///
// Called on the UI thread to handle requests for URLs with an invalid SSL
// certificate. Return true (1) and call cef_callback_t functions either in
// this function or at a later time to continue or cancel the request. Return
// false (0) to cancel the request immediately. If
// CefSettings.ignore_certificate_errors is set all invalid certificates will
// be accepted without calling this function.
///
//export cefingo_request_handler_on_certificate_error
func cefingo_request_handler_on_certificate_error(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	cert_error C.cef_errorcode_t,
	request_url *C.cef_string_t,
	ssl_info *C.cef_sslinfo_t,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.15:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_certificate_error_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpcert_error := CErrorcodeT(cert_error)
		// !p.IsOutParam
		goTmprequest_url := string_from_cef_string(request_url)
		// !p.IsOutParam
		goTmpssl_info := newCSslinfoT(ssl_info, byApi)
		// !p.IsOutParam
		goTmpcallback := newCCallbackT(callback, byApi)

		goRet := f.OnCertificateError(goTmpself, goTmpbrowser, goTmpcert_error, goTmprequest_url, goTmpssl_info, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.16: on_certificate_error: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCSslinfoT)(ssl_info))  // byApi
	BaseRelease((*cCCallbackT)(callback)) // byApi

	return cRet
}

///
// Called on the UI thread when a client certificate is being requested for
// authentication. Return false (0) to use the default behavior and
// automatically select the first certificate available. Return true (1) and
// call cef_select_client_certificate_callback_t::Select either in this
// function or at a later time to select a certificate. Do not call Select or
// call it with NULL to continue without using any certificate. |isProxy|
// indicates whether the host is an HTTPS proxy or the origin server. |host|
// and |port| contains the hostname and port of the SSL server. |certificates|
// is the list of certificates to choose from; this list has already been
// pruned by Chromium so that it only contains certificates from issuers that
// the server trusts.
///
//export cefingo_request_handler_on_select_client_certificate
func cefingo_request_handler_on_select_client_certificate(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	certificatesCount C.size_t,
	certificates **C.cef_x509certificate_t,
	callback *C.cef_select_client_certificate_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.17:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_select_client_certificate_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpisProxy := (int)(isProxy)
		// !p.IsOutParam
		goTmphost := string_from_cef_string(host)
		// !p.IsOutParam
		goTmpport := (int)(port)
		// !p.IsOutParam
		// !p.IsOutParam
		// p.IsSliceParam
		slice := (*[1 << 30](*C.cef_x509certificate_t))(unsafe.Pointer(certificates))[:certificatesCount:certificatesCount]
		goTmpcertificates := make([]*CX509certificateT, certificatesCount)
		for i, v := range slice {
			goTmpcertificates[i] = newCX509certificateT(v, byApi)
		}
		// !p.IsOutParam
		goTmpcallback := newCSelectClientCertificateCallbackT(callback, byApi)

		goRet := f.OnSelectClientCertificate(goTmpself, goTmpbrowser, goTmpisProxy, goTmphost, goTmpport, goTmpcertificates, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.18: on_select_client_certificate: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))                          // byApi
	BaseRelease((*cCSelectClientCertificateCallbackT)(callback)) // byApi

	return cRet
}

///
// Called on the browser process UI thread when the render view associated
// with |browser| is ready to receive/handle IPC messages in the render
// process.
///
//export cefingo_request_handler_on_render_view_ready
func cefingo_request_handler_on_render_view_ready(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.19:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_view_ready_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnRenderViewReady(goTmpself, goTmpbrowser)

	} else {
		Logf("T187.20: on_render_view_ready: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called on the browser process UI thread when the render process terminates
// unexpectedly. |status| indicates how the process terminated.
///
//export cefingo_request_handler_on_render_process_terminated
func cefingo_request_handler_on_render_process_terminated(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	status C.cef_termination_status_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.21:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_process_terminated_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpstatus := CTerminationStatusT(status)

		f.OnRenderProcessTerminated(goTmpself, goTmpbrowser, goTmpstatus)

	} else {
		Logf("T187.22: on_render_process_terminated: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called on the browser process UI thread when the window.document object of
// the main frame has been created.
///
//export cefingo_request_handler_on_document_available_in_main_frame
func cefingo_request_handler_on_document_available_in_main_frame(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.23:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_document_available_in_main_frame_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)

		f.OnDocumentAvailableInMainFrame(goTmpself, goTmpbrowser)

	} else {
		Logf("T187.24: on_document_available_in_main_frame: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi

}

///
// Called to retrieve a localized translation for the specified |string_id|.
// To provide the translation set |string| to the translation string and
// return true (1). To use the default translation return false (0). Include
// cef_pack_strings.h for a listing of valid string ID values.
///
//export cefingo_resource_bundle_handler_get_localized_string
func cefingo_resource_bundle_handler_get_localized_string(
	self *C.cef_resource_bundle_handler_t,
	string_id C.int,
	cstring *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T188.5:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_localized_string_handler[(*cCResourceBundleHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceBundleHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpstring_id := (int)(string_id)

		goRet, goTmpstringOut := f.GetLocalizedString(goTmpself, goTmpstring_id)
		set_cef_string(cstring, goTmpstringOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T188.6: get_localized_string: Noo!")
	}

	return cRet
}

///
// Called to retrieve data for the specified scale independent |resource_id|.
// To provide the resource data set |data| and |data_size| to the data pointer
// and size respectively and return true (1). To use the default resource data
// return false (0). The resource data will not be copied and must remain
// resident in memory. Include cef_pack_resources.h for a listing of valid
// resource ID values.
///
//export cefingo_resource_bundle_handler_get_data_resource
func cefingo_resource_bundle_handler_get_data_resource(
	self *C.cef_resource_bundle_handler_t,
	resource_id C.int,
	data *C.VOIDP,
	data_size *C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T188.7:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_data_resource_handler[(*cCResourceBundleHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceBundleHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpresource_id := (int)(resource_id)

		goRet, goTmpdataOut := f.GetDataResource(goTmpself, goTmpresource_id)
		*data_size = C.size_t(len(goTmpdataOut))
		*data = (C.VOIDP)(c_calloc(*data_size, 1, "T188.8:cef_resource_bundle_handler_t::get_data_resource::data"))
		target := (*[1 << 30]byte)(unsafe.Pointer(*data))[:*data_size:*data_size]
		copy(target, goTmpdataOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T188.9: get_data_resource: Noo!")
	}

	return cRet
}

///
// Called to retrieve data for the specified |resource_id| nearest the scale
// factor |scale_factor|. To provide the resource data set |data| and
// |data_size| to the data pointer and size respectively and return true (1).
// To use the default resource data return false (0). The resource data will
// not be copied and must remain resident in memory. Include
// cef_pack_resources.h for a listing of valid resource ID values.
///
//export cefingo_resource_bundle_handler_get_data_resource_for_scale
func cefingo_resource_bundle_handler_get_data_resource_for_scale(
	self *C.cef_resource_bundle_handler_t,
	resource_id C.int,
	scale_factor C.cef_scale_factor_t,
	data *C.VOIDP,
	data_size *C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T188.10:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_data_resource_for_scale_handler[(*cCResourceBundleHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceBundleHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpresource_id := (int)(resource_id)
		// !p.IsOutParam
		goTmpscale_factor := CScaleFactorT(scale_factor)

		goRet, goTmpdataOut := f.GetDataResourceForScale(goTmpself, goTmpresource_id, goTmpscale_factor)
		*data_size = C.size_t(len(goTmpdataOut))
		*data = (C.VOIDP)(c_calloc(*data_size, 1, "T188.11:cef_resource_bundle_handler_t::get_data_resource_for_scale::data"))
		target := (*[1 << 30]byte)(unsafe.Pointer(*data))[:*data_size:*data_size]
		copy(target, goTmpdataOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T188.12: get_data_resource_for_scale: Noo!")
	}

	return cRet
}

///
// Open the response stream. To handle the request immediately set
// |handle_request| to true (1) and return true (1). To decide at a later time
// set |handle_request| to false (0), return true (1), and execute |callback|
// to continue or cancel the request. To cancel the request immediately set
// |handle_request| to true (1) and return false (0). This function will be
// called in sequence but not from a dedicated thread. For backwards
// compatibility set |handle_request| to false (0) and return false (0) and
// the ProcessRequest function will be called.
///
//export cefingo_resource_handler_open
func cefingo_resource_handler_open(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	handle_request *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.5:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.open_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceHandlerT(self, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpcallback := newCCallbackT(callback, byApi)

		goRet, goTmphandle_requestOut := f.Open(goTmpself, goTmprequest, goTmpcallback)
		*handle_request = 0
		if goTmphandle_requestOut {
			*handle_request = 1
		}

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.6: open: Noo!")
	}
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCCallbackT)(callback)) // byApi

	return cRet
}

///
// Begin processing the request. To handle the request return true (1) and
// call cef_callback_t::cont() once the response header information is
// available (cef_callback_t::cont() can also be called from inside this
// function if header information is available immediately). To cancel the
// request return false (0).
//
// WARNING: This function is deprecated. Use Open instead.
///
//export cefingo_resource_handler_process_request
func cefingo_resource_handler_process_request(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.7:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.process_request_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceHandlerT(self, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpcallback := newCCallbackT(callback, byApi)

		goRet := f.ProcessRequest(goTmpself, goTmprequest, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.8: process_request: Noo!")
	}
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCCallbackT)(callback)) // byApi

	return cRet
}

///
// Retrieve response header information. If the response length is not known
// set |response_length| to -1 and read_response() will be called until it
// returns false (0). If the response length is known set |response_length| to
// a positive value and read_response() will be called until it returns false
// (0) or the specified number of bytes have been read. Use the |response|
// object to set the mime type, http status code and other optional header
// values. To redirect the request to a new URL set |redirectUrl| to the new
// URL. |redirectUrl| can be either a relative or fully qualified URL. It is
// also possible to set |response| to a redirect http status code and pass the
// new URL via a Location header. Likewise with |redirectUrl| it is valid to
// set a relative or fully qualified URL as the Location header value. If an
// error occured while setting up the request you can call set_error() on
// |response| to indicate the error condition.
///
//export cefingo_resource_handler_get_response_headers
func cefingo_resource_handler_get_response_headers(
	self *C.cef_resource_handler_t,
	response *C.cef_response_t,
	response_length *C.int64,
	redirectUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.9:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.get_response_headers_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpresponse := newCResponseT(response, byApi)

		goTmpresponse_lengthOut, goTmpredirectUrlOut := f.GetResponseHeaders(goTmpself, goTmpresponse)
		*response_length = (C.int64)(goTmpresponse_lengthOut)
		set_cef_string(redirectUrl, goTmpredirectUrlOut)

	} else {
		Logf("T191.10: get_response_headers: Noo!")
	}
	BaseRelease((*cCResponseT)(response)) // byApi

}

///
// Skip response data when requested by a Range header. Skip over and discard
// |bytes_to_skip| bytes of response data. If data is available immediately
// set |bytes_skipped| to the number of bytes skipped and return true (1). To
// read the data at a later time set |bytes_skipped| to 0, return true (1) and
// execute |callback| when the data is available. To indicate failure set
// |bytes_skipped| to &lt; 0 (e.g. -2 for ERR_FAILED) and return false (0). This
// function will be called in sequence but not from a dedicated thread.
///
//export cefingo_resource_handler_skip
func cefingo_resource_handler_skip(
	self *C.cef_resource_handler_t,
	bytes_to_skip C.int64,
	bytes_skipped *C.int64,
	callback *C.cef_resource_skip_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.11:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.skip_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbytes_to_skip := (int64)(bytes_to_skip)
		// !p.IsOutParam
		goTmpcallback := newCResourceSkipCallbackT(callback, byApi)

		goRet, goTmpbytes_skippedOut := f.Skip(goTmpself, goTmpbytes_to_skip, goTmpcallback)
		*bytes_skipped = (C.int64)(goTmpbytes_skippedOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.12: skip: Noo!")
	}
	BaseRelease((*cCResourceSkipCallbackT)(callback)) // byApi

	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time keep a
// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
// |callback| when the data is available (|data_out| will remain valid until
// the callback is executed). To indicate response completion set |bytes_read|
// to 0 and return false (0). To indicate failure set |bytes_read| to &lt; 0
// (e.g. -2 for ERR_FAILED) and return false (0). This function will be called
// in sequence but not from a dedicated thread. For backwards compatibility
// set |bytes_read| to -1 and return false (0) and the ReadResponse function
// will be called.
///
//export cefingo_resource_handler_read
func cefingo_resource_handler_read(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_resource_read_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.13:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		// !p.IsOutParam
		goTmpcallback := newCResourceReadCallbackT(callback, byApi)

		goRet, goTmpbytes_readOut := f.Read(goTmpself, goTmpdata_out, goTmpcallback)
		*bytes_read = (C.int)(goTmpbytes_readOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.14: read: Noo!")
	}
	BaseRelease((*cCResourceReadCallbackT)(callback)) // byApi

	return cRet
}

///
// Request processing has been canceled.
///
//export cefingo_resource_handler_cancel
func cefingo_resource_handler_cancel(
	self *C.cef_resource_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.15:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.cancel_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceHandlerT(self, byApi)

		f.Cancel(goTmpself)

	} else {
		Logf("T191.16: cancel: Noo!")
	}

}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To
// optionally filter cookies for the request return a
// cef_cookie_access_filter_t object. The |request| object cannot not be
// modified in this callback.
///
//export cefingo_resource_request_handler_get_cookie_access_filter
func cefingo_resource_request_handler_get_cookie_access_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_cookie_access_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.5:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_cookie_access_filter_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)

		goRet := f.GetCookieAccessFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_cookie_access_filter) // return GoObj
			}
			cRet = (*C.cef_cookie_access_filter_t)(goRet.pc_cookie_access_filter)
		}
	} else {
		Logf("T192.6: get_cookie_access_filter: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

	return cRet
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To redirect
// or change the resource load optionally modify |request|. Modification of
// the request URL will be treated as a redirect. Return RV_CONTINUE to
// continue the request immediately. Return RV_CONTINUE_ASYNC and call
// cef_callback_t functions at a later time to continue or cancel the request
// asynchronously. Return RV_CANCEL to cancel the request immediately.
//
///
//export cefingo_resource_request_handler_on_before_resource_load
func cefingo_resource_request_handler_on_before_resource_load(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	callback *C.cef_callback_t,
) (cRet C.cef_return_value_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.7:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_before_resource_load_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpcallback := newCCallbackT(callback, byApi)

		goRet := f.OnBeforeResourceLoad(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpcallback)

		cRet = (C.cef_return_value_t)(goRet)
	} else {
		Logf("T192.8: on_before_resource_load: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCCallbackT)(callback)) // byApi

	return cRet
}

///
// Called on the IO thread before a resource is loaded. The |browser| and
// |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource to load using the default network loader return NULL. To specify a
// handler for the resource return a cef_resource_handler_t object. The
// |request| object cannot not be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_handler
func cefingo_resource_request_handler_get_resource_handler(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.9:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_handler_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)

		goRet := f.GetResourceHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_resource_handler) // return GoObj
			}
			cRet = (*C.cef_resource_handler_t)(goRet.pc_resource_handler)
		}
	} else {
		Logf("T192.10: get_resource_handler: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

	return cRet
}

///
// Called on the IO thread when a resource load is redirected. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. The
// |request| parameter will contain the old URL and other request-related
// information. The |response| parameter will contain the response that
// resulted in the redirect. The |new_url| parameter will contain the new URL
// and can be changed if desired. The |request| and |response| objects cannot
// be modified in this callback.
///
//export cefingo_resource_request_handler_on_resource_redirect
func cefingo_resource_request_handler_on_resource_redirect(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	new_url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.11:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_redirect_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpresponse := newCResponseT(response, byApi)

		goTmpnew_urlOut := f.OnResourceRedirect(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		set_cef_string(new_url, goTmpnew_urlOut)

	} else {
		Logf("T192.12: on_resource_redirect: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCResponseT)(response)) // byApi

}

///
// Called on the IO thread when a resource response is received. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource load to proceed without modification return false (0). To redirect
// or retry the resource load optionally modify |request| and return true (1).
// Modification of the request URL will be treated as a redirect. Requests
// handled using the default network loader cannot be redirected in this
// callback. The |response| object cannot be modified in this callback.
//
// WARNING: Redirecting using this function is deprecated. Use
// OnBeforeResourceLoad or GetResourceHandler to perform redirects.
///
//export cefingo_resource_request_handler_on_resource_response
func cefingo_resource_request_handler_on_resource_response(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.13:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_response_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpresponse := newCResponseT(response, byApi)

		goRet := f.OnResourceResponse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T192.14: on_resource_response: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCResponseT)(response)) // byApi

	return cRet
}

///
// Called on the IO thread to optionally filter resource response content. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| and |response| represent the request and response respectively
// and cannot be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_response_filter
func cefingo_resource_request_handler_get_resource_response_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet *C.cef_response_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.15:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_response_filter_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpresponse := newCResponseT(response, byApi)

		goRet := f.GetResourceResponseFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_response_filter) // return GoObj
			}
			cRet = (*C.cef_response_filter_t)(goRet.pc_response_filter)
		}
	} else {
		Logf("T192.16: get_resource_response_filter: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCResponseT)(response)) // byApi

	return cRet
}

///
// Called on the IO thread when a resource load has completed. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// and |response| represent the request and response respectively and cannot
// be modified in this callback. |status| indicates the load completion
// status. |received_content_length| is the number of response bytes actually
// read. This function will be called for all requests, including requests
// that are aborted due to CEF shutdown or destruction of the associated
// browser. In cases where the associated browser is destroyed this callback
// may arrive after the cef_life_span_handler_t::OnBeforeClose callback for
// that browser. The cef_frame_t::IsValid function can be used to test for
// this situation, and care should be taken not to call |browser| or |frame|
// functions that modify state (like LoadURL, SendProcessMessage, etc.) if the
// frame is invalid.
///
//export cefingo_resource_request_handler_on_resource_load_complete
func cefingo_resource_request_handler_on_resource_load_complete(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	status C.cef_urlrequest_status_t,
	received_content_length C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.17:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_load_complete_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpresponse := newCResponseT(response, byApi)
		// !p.IsOutParam
		goTmpstatus := CUrlrequestStatusT(status)
		// !p.IsOutParam
		goTmpreceived_content_length := (int64)(received_content_length)

		f.OnResourceLoadComplete(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse, goTmpstatus, goTmpreceived_content_length)

	} else {
		Logf("T192.18: on_resource_load_complete: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCResponseT)(response)) // byApi

}

///
// Called on the IO thread to handle requests for URLs with an unknown
// protocol component. The |browser| and |frame| values represent the source
// of the request, and may be NULL for requests originating from service
// workers or cef_urlrequest_t. |request| cannot be modified in this callback.
// Set |allow_os_execution| to true (1) to attempt execution via the
// registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD USE
// THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL
// ANALYSIS BEFORE ALLOWING OS EXECUTION.
///
//export cefingo_resource_request_handler_on_protocol_execution
func cefingo_resource_request_handler_on_protocol_execution(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	allow_os_execution *C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.19:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_protocol_execution_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResourceRequestHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)

		goTmpallow_os_executionOut := f.OnProtocolExecution(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		*allow_os_execution = (C.int)(goTmpallow_os_executionOut)

	} else {
		Logf("T192.20: on_protocol_execution: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

}

///
// Called on the IO thread before a resource request is sent. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// cannot be modified in this callback. Return true (1) if the specified
// cookie can be sent with the request or false (0) otherwise.
///
//export cefingo_cookie_access_filter_can_send_cookie
func cefingo_cookie_access_filter_can_send_cookie(
	self *C.cef_cookie_access_filter_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	cookie *C.cef_cookie_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T193.5:")
	cefingoIfaceAccess.Lock()
	f := cookie_access_filter_handlers.can_send_cookie_handler[(*cCCookieAccessFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCCookieAccessFilterT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpcookie := (*CCookieT)(cookie)

		goRet := f.CanSendCookie(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpcookie)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T193.6: can_send_cookie: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

	return cRet
}

///
// Called on the IO thread after a resource response is received. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| cannot be modified in this callback. Return true (1) if the
// specified cookie returned with the response can be saved or false (0)
// otherwise.
///
//export cefingo_cookie_access_filter_can_save_cookie
func cefingo_cookie_access_filter_can_save_cookie(
	self *C.cef_cookie_access_filter_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	cookie *C.cef_cookie_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T193.7:")
	cefingoIfaceAccess.Lock()
	f := cookie_access_filter_handlers.can_save_cookie_handler[(*cCCookieAccessFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCCookieAccessFilterT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)
		// !p.IsOutParam
		goTmpresponse := newCResponseT(response, byApi)
		// !p.IsOutParam
		goTmpcookie := (*CCookieT)(cookie)

		goRet := f.CanSaveCookie(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse, goTmpcookie)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T193.8: can_save_cookie: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser))   // byApi
	BaseRelease((*cCFrameT)(frame))       // byApi
	BaseRelease((*cCRequestT)(request))   // byApi
	BaseRelease((*cCResponseT)(response)) // byApi

	return cRet
}

///
// Initialize the response filter. Will only be called a single time. The
// filter will not be installed if this function returns false (0).
///
//export cefingo_response_filter_init_filter
func cefingo_response_filter_init_filter(
	self *C.cef_response_filter_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T195.5:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.init_filter_handler[(*cCResponseFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResponseFilterT(self, byApi)

		goRet := f.InitFilter(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T195.6: init_filter: Noo!")
	}

	return cRet
}

///
// Called to filter a chunk of data. Expected usage is as follows:
//
//  A. Read input data from |data_in| and set |data_in_read| to the number of
//     bytes that were read up to a maximum of |data_in_size|. |data_in| will
//     be NULL if |data_in_size| is zero.
//  B. Write filtered output data to |data_out| and set |data_out_written| to
//     the number of bytes that were written up to a maximum of
//     |data_out_size|. If no output data was written then all data must be
//     read from |data_in| (user must set |data_in_read| = |data_in_size|).
//  C. Return RESPONSE_FILTER_DONE if all output data was written or
//     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
//
// This function will be called repeatedly until the input buffer has been
// fully read (user sets |data_in_read| = |data_in_size|) and there is no more
// input data to filter (the resource response is complete). This function may
// then be called an additional time with an NULL input buffer if the user
// filled the output buffer (set |data_out_written| = |data_out_size|) and
// returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is
// still pending.
//
// Calls to this function will stop when one of the following conditions is
// met:
//
//  A. There is no more input data to filter (the resource response is
//     complete) and the user sets |data_out_written| = 0 or returns
//     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
//  B. The user returns RESPONSE_FILTER_ERROR to indicate an error.
//
// Do not keep a reference to the buffers passed to this function.
///
//export cefingo_response_filter_filter
func cefingo_response_filter_filter(
	self *C.cef_response_filter_t,
	data_in C.VOIDP,
	data_in_size C.size_t,
	data_in_read *C.size_t,
	data_out C.VOIDP,
	data_out_size C.size_t,
	data_out_written *C.size_t,
) (cRet C.cef_response_filter_status_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T195.7:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.filter_handler[(*cCResponseFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCResponseFilterT(self, byApi)
		// !p.IsOutParam
		goTmpdata_in := (*[1 << 30]byte)(data_in)[:data_in_size:data_in_size]
		// !p.IsOutParam
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:data_out_size:data_out_size]

		goRet, goTmpdata_in_readOut, goTmpdata_out_writtenOut := f.Filter(goTmpself, goTmpdata_in, goTmpdata_out)
		*data_in_read = (C.size_t)(goTmpdata_in_readOut)
		*data_out_written = (C.size_t)(goTmpdata_out_writtenOut)

		cRet = (C.cef_response_filter_status_t)(goRet)
	} else {
		Logf("T195.8: filter: Noo!")
	}

	return cRet
}

///
// Return a new resource handler instance to handle the request or an NULL
// reference to allow default handling of the request. |browser| and |frame|
// will be the browser window and frame respectively that originated the
// request or NULL if the request did not originate from a browser window (for
// example, if the request came from cef_urlrequest_t). The |request| object
// passed to this function cannot be modified.
///
//export cefingo_scheme_handler_factory_create
func cefingo_scheme_handler_factory_create(
	self *C.cef_scheme_handler_factory_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	scheme_name *C.cef_string_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T197.5:")
	cefingoIfaceAccess.Lock()
	f := scheme_handler_factory_handlers.create_handler[(*cCSchemeHandlerFactoryT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCSchemeHandlerFactoryT(self, byApi)
		// !p.IsOutParam
		goTmpbrowser := newCBrowserT(browser, byApi)
		// !p.IsOutParam
		goTmpframe := newCFrameT(frame, byApi)
		// !p.IsOutParam
		goTmpscheme_name := string_from_cef_string(scheme_name)
		// !p.IsOutParam
		goTmprequest := newCRequestT(request, byApi)

		goRet := f.Create(goTmpself, goTmpbrowser, goTmpframe, goTmpscheme_name, goTmprequest)

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_resource_handler) // return GoObj
			}
			cRet = (*C.cef_resource_handler_t)(goRet.pc_resource_handler)
		}
	} else {
		Logf("T197.6: create: Noo!")
	}
	BaseRelease((*cCBrowserT)(browser)) // byApi
	BaseRelease((*cCFrameT)(frame))     // byApi
	BaseRelease((*cCRequestT)(request)) // byApi

	return cRet
}

///
// Read raw binary data.
///
//export cefingo_read_handler_read
func cefingo_read_handler_read(
	self *C.cef_read_handler_t,
	ptr C.VOIDP,
	size C.size_t,
	n C.size_t,
) (cRet C.size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.5:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.read_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCReadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpptr := (*[1 << 30]byte)(ptr)[: size*n : size*n]
		// !p.IsOutParam
		goTmpsize := (int64)(size)
		// !p.IsOutParam
		goTmpn := (int64)(n)

		goRet := f.Read(goTmpself, goTmpptr, goTmpsize, goTmpn)

		cRet = (C.size_t)(goRet)
	} else {
		Logf("T201.6: read: Noo!")
	}

	return cRet
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
//export cefingo_read_handler_seek
func cefingo_read_handler_seek(
	self *C.cef_read_handler_t,
	offset C.int64,
	whence C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.7:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.seek_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCReadHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpoffset := (int64)(offset)
		// !p.IsOutParam
		goTmpwhence := (int)(whence)

		goRet := f.Seek(goTmpself, goTmpoffset, goTmpwhence)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T201.8: seek: Noo!")
	}

	return cRet
}

///
// Return the current offset position.
///
//export cefingo_read_handler_tell
func cefingo_read_handler_tell(
	self *C.cef_read_handler_t,
) (cRet C.int64) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.9:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.tell_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCReadHandlerT(self, byApi)

		goRet := f.Tell(goTmpself)

		cRet = (C.int64)(goRet)
	} else {
		Logf("T201.10: tell: Noo!")
	}

	return cRet
}

///
// Return non-zero if at end of file.
///
//export cefingo_read_handler_eof
func cefingo_read_handler_eof(
	self *C.cef_read_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.11:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.eof_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCReadHandlerT(self, byApi)

		goRet := f.Eof(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T201.12: eof: Noo!")
	}

	return cRet
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
//export cefingo_read_handler_may_block
func cefingo_read_handler_may_block(
	self *C.cef_read_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.13:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.may_block_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCReadHandlerT(self, byApi)

		goRet := f.MayBlock(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T201.14: may_block: Noo!")
	}

	return cRet
}

///
// Write raw binary data.
///
//export cefingo_write_handler_write
func cefingo_write_handler_write(
	self *C.cef_write_handler_t,
	ptr C.VOIDP,
	size C.size_t,
	n C.size_t,
) (cRet C.size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.5:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.write_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWriteHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpptr := (*[1 << 30]byte)(ptr)[: size*n : size*n]
		// !p.IsOutParam
		goTmpsize := (int64)(size)
		// !p.IsOutParam
		goTmpn := (int64)(n)

		goRet := f.Write(goTmpself, goTmpptr, goTmpsize, goTmpn)

		cRet = (C.size_t)(goRet)
	} else {
		Logf("T203.6: write: Noo!")
	}

	return cRet
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
//export cefingo_write_handler_seek
func cefingo_write_handler_seek(
	self *C.cef_write_handler_t,
	offset C.int64,
	whence C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.7:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.seek_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWriteHandlerT(self, byApi)
		// !p.IsOutParam
		goTmpoffset := (int64)(offset)
		// !p.IsOutParam
		goTmpwhence := (int)(whence)

		goRet := f.Seek(goTmpself, goTmpoffset, goTmpwhence)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T203.8: seek: Noo!")
	}

	return cRet
}

///
// Return the current offset position.
///
//export cefingo_write_handler_tell
func cefingo_write_handler_tell(
	self *C.cef_write_handler_t,
) (cRet C.int64) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.9:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.tell_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWriteHandlerT(self, byApi)

		goRet := f.Tell(goTmpself)

		cRet = (C.int64)(goRet)
	} else {
		Logf("T203.10: tell: Noo!")
	}

	return cRet
}

///
// Flush the stream.
///
//export cefingo_write_handler_flush
func cefingo_write_handler_flush(
	self *C.cef_write_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.11:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.flush_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWriteHandlerT(self, byApi)

		goRet := f.Flush(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T203.12: flush: Noo!")
	}

	return cRet
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
//export cefingo_write_handler_may_block
func cefingo_write_handler_may_block(
	self *C.cef_write_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.13:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.may_block_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWriteHandlerT(self, byApi)

		goRet := f.MayBlock(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T203.14: may_block: Noo!")
	}

	return cRet
}

///
// Method that will be executed.
///
//export cefingo_string_visitor_visit
func cefingo_string_visitor_visit(
	self *C.cef_string_visitor_t,
	cstring *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T205.5:")
	cefingoIfaceAccess.Lock()
	f := string_visitor_handlers.visit_handler[(*cCStringVisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCStringVisitorT(self, byApi)
		// !p.IsOutParam
		goTmpstring := string_from_cef_string(cstring)

		f.Visit(goTmpself, goTmpstring)

	} else {
		Logf("T205.6: visit: Noo!")
	}

}

///
// Method that will be executed on the target thread.
///
//export cefingo_task_execute
func cefingo_task_execute(
	self *C.cef_task_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T206.5:")
	cefingoIfaceAccess.Lock()
	f := task_handlers.execute_handler[(*cCTaskT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCTaskT(self, byApi)

		f.Execute(goTmpself)

	} else {
		Logf("T206.6: execute: Noo!")
	}

}

///
// Called when |textfield| recieves a keyboard event. |event| contains
// information about the keyboard event. Return true (1) if the keyboard event
// was handled or false (0) otherwise for default handling.
///
//export cefingo_textfield_delegate_on_key_event
func cefingo_textfield_delegate_on_key_event(
	self *C.cef_textfield_delegate_t,
	textfield *C.cef_textfield_t,
	event *C.cef_key_event_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.5:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_key_event_handler[(*cCTextfieldDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCTextfieldDelegateT(self, byApi)
		// !p.IsOutParam
		goTmptextfield := newCTextfieldT(textfield, byApi)
		// !p.IsOutParam
		goTmpevent := (*CKeyEventT)(event)

		goRet := f.OnKeyEvent(goTmpself, goTmptextfield, goTmpevent)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T209.6: on_key_event: Noo!")
	}
	BaseRelease((*cCTextfieldT)(textfield)) // byApi

	return cRet
}

///
// Called after performing a user action that may change |textfield|.
///
//export cefingo_textfield_delegate_on_after_user_action
func cefingo_textfield_delegate_on_after_user_action(
	self *C.cef_textfield_delegate_t,
	textfield *C.cef_textfield_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.7:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_after_user_action_handler[(*cCTextfieldDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCTextfieldDelegateT(self, byApi)
		// !p.IsOutParam
		goTmptextfield := newCTextfieldT(textfield, byApi)

		f.OnAfterUserAction(goTmpself, goTmptextfield)

	} else {
		Logf("T209.8: on_after_user_action: Noo!")
	}
	BaseRelease((*cCTextfieldT)(textfield)) // byApi

}

//export cefingo_textfield_delegate_get_preferred_size
func cefingo_textfield_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.9:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_preferred_size_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T209.10: get_preferred_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_textfield_delegate_get_minimum_size
func cefingo_textfield_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.11:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_minimum_size_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T209.12: get_minimum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_textfield_delegate_get_maximum_size
func cefingo_textfield_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.13:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_maximum_size_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T209.14: get_maximum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_textfield_delegate_get_height_for_width
func cefingo_textfield_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.15:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_height_for_width_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T209.16: get_height_for_width: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

//export cefingo_textfield_delegate_on_parent_view_changed
func cefingo_textfield_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.17:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_parent_view_changed_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpparent := newCViewT(parent, byApi)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)

	} else {
		Logf("T209.18: on_parent_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))   // byApi
	BaseRelease((*cCViewT)(parent)) // byApi

}

//export cefingo_textfield_delegate_on_child_view_changed
func cefingo_textfield_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.19:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_child_view_changed_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpchild := newCViewT(child, byApi)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)

	} else {
		Logf("T209.20: on_child_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))  // byApi
	BaseRelease((*cCViewT)(child)) // byApi

}

//export cefingo_textfield_delegate_on_window_changed
func cefingo_textfield_delegate_on_window_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.21:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_window_changed_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)

		f.OnWindowChanged(goTmpself, goTmpview, goTmpadded)

	} else {
		Logf("T209.22: on_window_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_textfield_delegate_on_layout_changed
func cefingo_textfield_delegate_on_layout_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	new_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.23:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_layout_changed_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpnew_bounds := (*CRectT)(new_bounds)

		f.OnLayoutChanged(goTmpself, goTmpview, goTmpnew_bounds)

	} else {
		Logf("T209.24: on_layout_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_textfield_delegate_on_focus
func cefingo_textfield_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.25:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_focus_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnFocus(goTmpself, goTmpview)

	} else {
		Logf("T209.26: on_focus: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

//export cefingo_textfield_delegate_on_blur
func cefingo_textfield_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.27:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_blur_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnBlur(goTmpself, goTmpview)

	} else {
		Logf("T209.28: on_blur: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called after all processes have sent their trace data. |tracing_file| is
// the path at which tracing data was written. The client is responsible for
// deleting |tracing_file|.
///
//export cefingo_end_tracing_callback_on_end_tracing_complete
func cefingo_end_tracing_callback_on_end_tracing_complete(
	self *C.cef_end_tracing_callback_t,
	tracing_file *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T381.5:")
	cefingoIfaceAccess.Lock()
	f := end_tracing_callback_handlers.on_end_tracing_complete_handler[(*cCEndTracingCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCEndTracingCallbackT(self, byApi)
		// !p.IsOutParam
		goTmptracing_file := string_from_cef_string(tracing_file)

		f.OnEndTracingComplete(goTmpself, goTmptracing_file)

	} else {
		Logf("T381.6: on_end_tracing_complete: Noo!")
	}

}

///
// Notifies the client that the request has completed. Use the
// cef_urlrequest_t::GetRequestStatus function to determine if the request was
// successful or not.
///
//export cefingo_urlrequest_client_on_request_complete
func cefingo_urlrequest_client_on_request_complete(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.5:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_request_complete_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCUrlrequestClientT(self, byApi)
		// !p.IsOutParam
		goTmprequest := newCUrlrequestT(request, byApi)

		f.OnRequestComplete(goTmpself, goTmprequest)

	} else {
		Logf("T211.6: on_request_complete: Noo!")
	}
	BaseRelease((*cCUrlrequestT)(request)) // byApi

}

///
// Notifies the client of upload progress. |current| denotes the number of
// bytes sent so far and |total| is the total size of uploading data (or -1 if
// chunked upload is enabled). This function will only be called if the
// UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request.
///
//export cefingo_urlrequest_client_on_upload_progress
func cefingo_urlrequest_client_on_upload_progress(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	current C.int64,
	total C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.7:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_upload_progress_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCUrlrequestClientT(self, byApi)
		// !p.IsOutParam
		goTmprequest := newCUrlrequestT(request, byApi)
		// !p.IsOutParam
		goTmpcurrent := (int64)(current)
		// !p.IsOutParam
		goTmptotal := (int64)(total)

		f.OnUploadProgress(goTmpself, goTmprequest, goTmpcurrent, goTmptotal)

	} else {
		Logf("T211.8: on_upload_progress: Noo!")
	}
	BaseRelease((*cCUrlrequestT)(request)) // byApi

}

///
// Notifies the client of download progress. |current| denotes the number of
// bytes received up to the call and |total| is the expected total size of the
// response (or -1 if not determined).
///
//export cefingo_urlrequest_client_on_download_progress
func cefingo_urlrequest_client_on_download_progress(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	current C.int64,
	total C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.9:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_download_progress_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCUrlrequestClientT(self, byApi)
		// !p.IsOutParam
		goTmprequest := newCUrlrequestT(request, byApi)
		// !p.IsOutParam
		goTmpcurrent := (int64)(current)
		// !p.IsOutParam
		goTmptotal := (int64)(total)

		f.OnDownloadProgress(goTmpself, goTmprequest, goTmpcurrent, goTmptotal)

	} else {
		Logf("T211.10: on_download_progress: Noo!")
	}
	BaseRelease((*cCUrlrequestT)(request)) // byApi

}

///
// Called when some part of the response is read. |data| contains the current
// bytes received since the last call. This function will not be called if the
// UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request.
///
//export cefingo_urlrequest_client_on_download_data
func cefingo_urlrequest_client_on_download_data(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	data C.VOIDP,
	data_length C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.11:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_download_data_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCUrlrequestClientT(self, byApi)
		// !p.IsOutParam
		goTmprequest := newCUrlrequestT(request, byApi)
		// !p.IsOutParam
		goTmpdata := (*[1 << 30]byte)(data)[:data_length:data_length]

		f.OnDownloadData(goTmpself, goTmprequest, goTmpdata)

	} else {
		Logf("T211.12: on_download_data: Noo!")
	}
	BaseRelease((*cCUrlrequestT)(request)) // byApi

}

///
// Called on the IO thread when the browser needs credentials from the user.
// |isProxy| indicates whether the host is a proxy server. |host| contains the
// hostname and |port| contains the port number. Return true (1) to continue
// the request and call cef_auth_callback_t::cont() when the authentication
// information is available. If the request has an associated browser/frame
// then returning false (0) will result in a call to GetAuthCredentials on the
// cef_request_handler_t associated with that browser, if any. Otherwise,
// returning false (0) will cancel the request immediately. This function will
// only be called for requests initiated from the browser process.
///
//export cefingo_urlrequest_client_get_auth_credentials
func cefingo_urlrequest_client_get_auth_credentials(
	self *C.cef_urlrequest_client_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.13:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.get_auth_credentials_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCUrlrequestClientT(self, byApi)
		// !p.IsOutParam
		goTmpisProxy := (int)(isProxy)
		// !p.IsOutParam
		goTmphost := string_from_cef_string(host)
		// !p.IsOutParam
		goTmpport := (int)(port)
		// !p.IsOutParam
		goTmprealm := string_from_cef_string(realm)
		// !p.IsOutParam
		goTmpscheme := string_from_cef_string(scheme)
		// !p.IsOutParam
		goTmpcallback := newCAuthCallbackT(callback, byApi)

		goRet := f.GetAuthCredentials(goTmpself, goTmpisProxy, goTmphost, goTmpport, goTmprealm, goTmpscheme, goTmpcallback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T211.14: get_auth_credentials: Noo!")
	}
	BaseRelease((*cCAuthCallbackT)(callback)) // byApi

	return cRet
}

///
// Handle execution of the function identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the function. |arguments| is the list of
// arguments passed to the function. If execution succeeds set |retval| to the
// function return value. If execution fails set |exception| to the exception
// that will be thrown. Return true (1) if execution was handled.
///
//export cefingo_v8handler_execute
func cefingo_v8handler_execute(
	self *C.cef_v8handler_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	argumentsCount C.size_t,
	arguments **C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T213.5:")
	cefingoIfaceAccess.Lock()
	f := v8handler_handlers.execute_handler[(*cCV8handlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCV8handlerT(self, byApi)
		// !p.IsOutParam
		goTmpname := string_from_cef_string(name)
		// !p.IsOutParam
		goTmpobject := newCV8valueT(object, byApi)
		// !p.IsOutParam
		// !p.IsOutParam
		// p.IsSliceParam
		slice := (*[1 << 30](*C.cef_v8value_t))(unsafe.Pointer(arguments))[:argumentsCount:argumentsCount]
		goTmparguments := make([]*CV8valueT, argumentsCount)
		for i, v := range slice {
			goTmparguments[i] = newCV8valueT(v, byApi)
		}

		goRet, goTmpretvalOut, goTmpexceptionOut := f.Execute(goTmpself, goTmpname, goTmpobject, goTmparguments)
		if goTmpretvalOut != nil {
			if goTmpretvalOut.beUnrefed != byCef {
				BaseAddRef(goTmpretvalOut.pc_v8value) // Out Param
			}
			*retval = (*C.cef_v8value_t)(goTmpretvalOut.pc_v8value)
		}
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T213.6: execute: Noo!")
	}
	BaseRelease((*cCV8valueT)(object)) // byApi

	return cRet
}

///
// Handle retrieval the accessor value identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the accessor. If retrieval succeeds set
// |retval| to the return value. If retrieval fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor retrieval was
// handled.
///
//export cefingo_v8accessor_get
func cefingo_v8accessor_get(
	self *C.cef_v8accessor_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T214.5:")
	cefingoIfaceAccess.Lock()
	f := v8accessor_handlers.get_handler[(*cCV8accessorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCV8accessorT(self, byApi)
		// !p.IsOutParam
		goTmpname := string_from_cef_string(name)
		// !p.IsOutParam
		goTmpobject := newCV8valueT(object, byApi)

		goRet, goTmpretvalOut, goTmpexceptionOut := f.Get(goTmpself, goTmpname, goTmpobject)
		if goTmpretvalOut != nil {
			if goTmpretvalOut.beUnrefed != byCef {
				BaseAddRef(goTmpretvalOut.pc_v8value) // Out Param
			}
			*retval = (*C.cef_v8value_t)(goTmpretvalOut.pc_v8value)
		}
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T214.6: get: Noo!")
	}
	BaseRelease((*cCV8valueT)(object)) // byApi

	return cRet
}

///
// Handle assignment of the accessor value identified by |name|. |object| is
// the receiver (&#39;this&#39; object) of the accessor. |value| is the new value
// being assigned to the accessor. If assignment fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor assignment was
// handled.
///
//export cefingo_v8accessor_set
func cefingo_v8accessor_set(
	self *C.cef_v8accessor_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	value *C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T214.7:")
	cefingoIfaceAccess.Lock()
	f := v8accessor_handlers.set_handler[(*cCV8accessorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCV8accessorT(self, byApi)
		// !p.IsOutParam
		goTmpname := string_from_cef_string(name)
		// !p.IsOutParam
		goTmpobject := newCV8valueT(object, byApi)
		// !p.IsOutParam
		goTmpvalue := newCV8valueT(value, byApi)

		goRet, goTmpexceptionOut := f.Set(goTmpself, goTmpname, goTmpobject, goTmpvalue)
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T214.8: set: Noo!")
	}
	BaseRelease((*cCV8valueT)(object)) // byApi
	BaseRelease((*cCV8valueT)(value))  // byApi

	return cRet
}

///
// Called to release |buffer| when the ArrayBuffer JS object is garbage
// collected. |buffer| is the value that was passed to CreateArrayBuffer along
// with this object.
///
//export cefingo_v8array_buffer_release_callback_release_buffer
func cefingo_v8array_buffer_release_callback_release_buffer(
	self *C.cef_v8array_buffer_release_callback_t,
	buffer C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T217.5:")
	cefingoIfaceAccess.Lock()
	f := v8array_buffer_release_callback_handlers.release_buffer_handler[(*cCV8arrayBufferReleaseCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCV8arrayBufferReleaseCallbackT(self, byApi)
		// !p.IsOutParam
		goTmpbuffer := unsafe.Pointer(buffer)

		f.ReleaseBuffer(goTmpself, goTmpbuffer)

	} else {
		Logf("T217.6: release_buffer: Noo!")
	}

}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
//export cefingo_view_delegate_get_preferred_size
func cefingo_view_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.5:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_preferred_size_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T226.6: get_preferred_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Return the minimum size for |view|.
///
//export cefingo_view_delegate_get_minimum_size
func cefingo_view_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.7:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_minimum_size_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T226.8: get_minimum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Return the maximum size for |view|.
///
//export cefingo_view_delegate_get_maximum_size
func cefingo_view_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.9:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_maximum_size_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T226.10: get_maximum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
//export cefingo_view_delegate_get_height_for_width
func cefingo_view_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.11:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_height_for_width_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T226.12: get_height_for_width: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
//export cefingo_view_delegate_on_parent_view_changed
func cefingo_view_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.13:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_parent_view_changed_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpparent := newCViewT(parent, byApi)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)

	} else {
		Logf("T226.14: on_parent_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))   // byApi
	BaseRelease((*cCViewT)(parent)) // byApi

}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
//export cefingo_view_delegate_on_child_view_changed
func cefingo_view_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.15:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_child_view_changed_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpchild := newCViewT(child, byApi)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)

	} else {
		Logf("T226.16: on_child_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))  // byApi
	BaseRelease((*cCViewT)(child)) // byApi

}

///
// Called when |view| is added or removed from the cef_window_t.
///
//export cefingo_view_delegate_on_window_changed
func cefingo_view_delegate_on_window_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.17:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_window_changed_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)

		f.OnWindowChanged(goTmpself, goTmpview, goTmpadded)

	} else {
		Logf("T226.18: on_window_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when the layout of |view| has changed.
///
//export cefingo_view_delegate_on_layout_changed
func cefingo_view_delegate_on_layout_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	new_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.19:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_layout_changed_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpnew_bounds := (*CRectT)(new_bounds)

		f.OnLayoutChanged(goTmpself, goTmpview, goTmpnew_bounds)

	} else {
		Logf("T226.20: on_layout_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when |view| gains focus.
///
//export cefingo_view_delegate_on_focus
func cefingo_view_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.21:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_focus_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnFocus(goTmpself, goTmpview)

	} else {
		Logf("T226.22: on_focus: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when |view| loses focus.
///
//export cefingo_view_delegate_on_blur
func cefingo_view_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.23:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_blur_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnBlur(goTmpself, goTmpview)

	} else {
		Logf("T226.24: on_blur: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when |window| is created.
///
//export cefingo_window_delegate_on_window_created
func cefingo_window_delegate_on_window_created(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.5:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_window_created_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		f.OnWindowCreated(goTmpself, goTmpwindow)

	} else {
		Logf("T232.6: on_window_created: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

}

///
// Called when |window| is destroyed. Release all references to |window| and
// do not attempt to execute any functions on |window| after this callback
// returns.
///
//export cefingo_window_delegate_on_window_destroyed
func cefingo_window_delegate_on_window_destroyed(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.7:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_window_destroyed_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		f.OnWindowDestroyed(goTmpself, goTmpwindow)

	} else {
		Logf("T232.8: on_window_destroyed: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

}

///
// Return the parent for |window| or NULL if the |window| does not have a
// parent. Windows with parents will not get a taskbar button. Set |is_menu|
// to true (1) if |window| will be displayed as a menu, in which case it will
// not be clipped to the parent window bounds. Set |can_activate_menu| to
// false (0) if |is_menu| is true (1) and |window| should not be activated
// (given keyboard focus) when displayed.
///
//export cefingo_window_delegate_get_parent_window
func cefingo_window_delegate_get_parent_window(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	is_menu *C.int,
	can_activate_menu *C.int,
) (cRet *C.cef_window_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.9:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_parent_window_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet, goTmpis_menuOut, goTmpcan_activate_menuOut := f.GetParentWindow(goTmpself, goTmpwindow)
		*is_menu = 0
		if goTmpis_menuOut {
			*is_menu = 1
		}
		*can_activate_menu = 0
		if goTmpcan_activate_menuOut {
			*can_activate_menu = 1
		}

		if goRet != nil {
			if goRet.beUnrefed != byCef {
				BaseAddRef(goRet.pc_window) // return GoObj
			}
			cRet = (*C.cef_window_t)(goRet.pc_window)
		}
	} else {
		Logf("T232.10: get_parent_window: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return the initial bounds for |window| in density independent pixel (DIP)
// coordinates. If this function returns an NULL CefRect then
// get_preferred_size() will be called to retrieve the size, and the window
// will be placed on the screen with origin (0,0). This function can be used
// in combination with cef_view_t::get_bounds_in_screen() to restore the
// previous window bounds.
///
//export cefingo_window_delegate_get_initial_bounds
func cefingo_window_delegate_get_initial_bounds(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.cef_rect_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.11:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_initial_bounds_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet := f.GetInitialBounds(goTmpself, goTmpwindow)

		cRet = (C.cef_rect_t)(goRet)
	} else {
		Logf("T232.12: get_initial_bounds: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return the initial show state for |window|.
///
//export cefingo_window_delegate_get_initial_show_state
func cefingo_window_delegate_get_initial_show_state(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.cef_show_state_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.13:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_initial_show_state_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet := f.GetInitialShowState(goTmpself, goTmpwindow)

		cRet = (C.cef_show_state_t)(goRet)
	} else {
		Logf("T232.14: get_initial_show_state: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return true (1) if |window| should be created without a frame or title bar.
// The window will be resizable if can_resize() returns true (1). Use
// cef_window_t::set_draggable_regions() to specify draggable regions.
///
//export cefingo_window_delegate_is_frameless
func cefingo_window_delegate_is_frameless(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.15:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.is_frameless_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet := f.IsFrameless(goTmpself, goTmpwindow)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.16: is_frameless: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return true (1) if |window| can be resized.
///
//export cefingo_window_delegate_can_resize
func cefingo_window_delegate_can_resize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.17:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_resize_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet := f.CanResize(goTmpself, goTmpwindow)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.18: can_resize: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return true (1) if |window| can be maximized.
///
//export cefingo_window_delegate_can_maximize
func cefingo_window_delegate_can_maximize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.19:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_maximize_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet := f.CanMaximize(goTmpself, goTmpwindow)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.20: can_maximize: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return true (1) if |window| can be minimized.
///
//export cefingo_window_delegate_can_minimize
func cefingo_window_delegate_can_minimize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.21:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_minimize_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet := f.CanMinimize(goTmpself, goTmpwindow)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.22: can_minimize: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return true (1) if |window| can be closed. This will be called for user-
// initiated window close actions and when cef_window_t::close() is called.
///
//export cefingo_window_delegate_can_close
func cefingo_window_delegate_can_close(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.23:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_close_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)

		goRet := f.CanClose(goTmpself, goTmpwindow)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.24: can_close: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Called when a keyboard accelerator registered with
// cef_window_t::SetAccelerator is triggered. Return true (1) if the
// accelerator was handled or false (0) otherwise.
///
//export cefingo_window_delegate_on_accelerator
func cefingo_window_delegate_on_accelerator(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	command_id C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.25:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_accelerator_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)
		// !p.IsOutParam
		goTmpcommand_id := (int)(command_id)

		goRet := f.OnAccelerator(goTmpself, goTmpwindow, goTmpcommand_id)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.26: on_accelerator: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Called after all other controls in the window have had a chance to handle
// the event. |event| contains information about the keyboard event. Return
// true (1) if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_window_delegate_on_key_event
func cefingo_window_delegate_on_key_event(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	event *C.cef_key_event_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.27:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_key_event_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCWindowDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpwindow := newCWindowT(window, byApi)
		// !p.IsOutParam
		goTmpevent := (*CKeyEventT)(event)

		goRet := f.OnKeyEvent(goTmpself, goTmpwindow, goTmpevent)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.28: on_key_event: Noo!")
	}
	BaseRelease((*cCWindowT)(window)) // byApi

	return cRet
}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
//export cefingo_window_delegate_get_preferred_size
func cefingo_window_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.29:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_preferred_size_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T232.30: get_preferred_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Return the minimum size for |view|.
///
//export cefingo_window_delegate_get_minimum_size
func cefingo_window_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.31:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_minimum_size_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T232.32: get_minimum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Return the maximum size for |view|.
///
//export cefingo_window_delegate_get_maximum_size
func cefingo_window_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.33:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_maximum_size_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T232.34: get_maximum_size: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
//export cefingo_window_delegate_get_height_for_width
func cefingo_window_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.35:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_height_for_width_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.36: get_height_for_width: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

	return cRet
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
//export cefingo_window_delegate_on_parent_view_changed
func cefingo_window_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.37:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_parent_view_changed_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpparent := newCViewT(parent, byApi)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)

	} else {
		Logf("T232.38: on_parent_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))   // byApi
	BaseRelease((*cCViewT)(parent)) // byApi

}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
//export cefingo_window_delegate_on_child_view_changed
func cefingo_window_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.39:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_child_view_changed_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)
		// !p.IsOutParam
		goTmpchild := newCViewT(child, byApi)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)

	} else {
		Logf("T232.40: on_child_view_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view))  // byApi
	BaseRelease((*cCViewT)(child)) // byApi

}

///
// Called when |view| is added or removed from the cef_window_t.
///
//export cefingo_window_delegate_on_window_changed
func cefingo_window_delegate_on_window_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.41:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_window_changed_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpadded := (int)(added)

		f.OnWindowChanged(goTmpself, goTmpview, goTmpadded)

	} else {
		Logf("T232.42: on_window_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when the layout of |view| has changed.
///
//export cefingo_window_delegate_on_layout_changed
func cefingo_window_delegate_on_layout_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	new_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.43:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_layout_changed_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)
		// !p.IsOutParam
		goTmpnew_bounds := (*CRectT)(new_bounds)

		f.OnLayoutChanged(goTmpself, goTmpview, goTmpnew_bounds)

	} else {
		Logf("T232.44: on_layout_changed: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when |view| gains focus.
///
//export cefingo_window_delegate_on_focus
func cefingo_window_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.45:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_focus_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnFocus(goTmpself, goTmpview)

	} else {
		Logf("T232.46: on_focus: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}

///
// Called when |view| loses focus.
///
//export cefingo_window_delegate_on_blur
func cefingo_window_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.47:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_blur_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		// !p.IsOutParam
		goTmpself := newCViewDelegateT(self, byApi)
		// !p.IsOutParam
		goTmpview := newCViewT(view, byApi)

		f.OnBlur(goTmpself, goTmpview)

	} else {
		Logf("T232.48: on_blur: Noo!")
	}
	BaseRelease((*cCViewT)(view)) // byApi

}
