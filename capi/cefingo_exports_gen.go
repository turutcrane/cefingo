// Code generated by "gen-cefingo.go" DO NOT EDIT.
package capi

import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"

///
// Called after renderer process sends accessibility tree changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_tree_change
func cefingo_accessibility_handler_on_accessibility_tree_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T21:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_tree_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityTreeChange(goTmpself, goTmpvalue)
		BaseRelease(goTmpvalue.p_value)

	} else {
		Logf("T34: on_accessibility_tree_change: Noo!")
	}

}

///
// Called after renderer process sends accessibility location changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_location_change
func cefingo_accessibility_handler_on_accessibility_location_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T51:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_location_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityLocationChange(goTmpself, goTmpvalue)
		BaseRelease(goTmpvalue.p_value)

	} else {
		Logf("T64: on_accessibility_location_change: Noo!")
	}

}

//export cefingo_app_get_resource_bundle_handler
func cefingo_app_get_resource_bundle_handler(self *C.cef_app_t) (ch *C.cef_resource_bundle_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.resource_bundle_handler[self]
	if handler == nil {
		Logf("T79: get_resource_bundle_handler")
	} else {
		BaseAddRef(handler.p_resource_bundle_handler)
		ch = handler.p_resource_bundle_handler
	}
	return ch
}

//export cefingo_app_get_browser_process_handler
func cefingo_app_get_browser_process_handler(self *C.cef_app_t) (ch *C.cef_browser_process_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.browser_process_handler[self]
	if handler == nil {
		Logf("T94: get_browser_process_handler")
	} else {
		BaseAddRef(handler.p_browser_process_handler)
		ch = handler.p_browser_process_handler
	}
	return ch
}

//export cefingo_app_get_render_process_handler
func cefingo_app_get_render_process_handler(self *C.cef_app_t) (ch *C.cef_render_process_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.render_process_handler[self]
	if handler == nil {
		Logf("T109: get_render_process_handler")
	} else {
		BaseAddRef(handler.p_render_process_handler)
		ch = handler.p_render_process_handler
	}
	return ch
}

///
// Provides an opportunity to view and/or modify command-line arguments before
// processing by CEF and Chromium. The |process_type| value will be NULL for
// the browser process. Do not keep a reference to the cef_command_line_t
// object passed to this function. The CefSettings.command_line_args_disabled
// value can be used to start with an NULL command-line object. Any values
// specified in CefSettings that equate to command-line arguments will be set
// before this function is called. Be cautious when using this function to
// modify command-line arguments for non-browser processes as this may result
// in undefined behavior including crashes.
///
//export cefingo_app_on_before_command_line_processing
func cefingo_app_on_before_command_line_processing(
	self *C.cef_app_t,
	process_type *C.cef_string_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T134:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_before_command_line_processing_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpprocess_type := string_from_cef_string(process_type)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeCommandLineProcessing(goTmpself, goTmpprocess_type, goTmpcommand_line)
		BaseRelease(goTmpcommand_line.p_command_line)

	} else {
		Logf("T148: on_before_command_line_processing: Noo!")
	}

}

///
// Provides an opportunity to register custom schemes. Do not keep a reference
// to the |registrar| object. This function is called on the main thread for
// each process and the registered schemes should be the same across all
// processes.
///
//export cefingo_app_on_register_custom_schemes
func cefingo_app_on_register_custom_schemes(
	self *C.cef_app_t,
	registrar *C.cef_scheme_registrar_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_register_custom_schemes_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpregistrar := newCSchemeRegistrarT(registrar)

		f.OnRegisterCustomSchemes(goTmpself, goTmpregistrar)

	} else {
		Logf("T179: on_register_custom_schemes: Noo!")
	}

}

///
// Called asynchronously after the file dialog is dismissed.
// |selected_accept_filter| is the 0-based index of the value selected from
// the accept filters array passed to cef_browser_host_t::RunFileDialog.
// |file_paths| will be a single value or a list of values depending on the
// dialog mode. If the selection was cancelled |file_paths| will be NULL.
///
//export cefingo_run_file_dialog_callback_on_file_dialog_dismissed
func cefingo_run_file_dialog_callback_on_file_dialog_dismissed(
	self *C.cef_run_file_dialog_callback_t,
	selected_accept_filter C.int,
	file_paths C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T200:")
	cefingoIfaceAccess.Lock()
	f := run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRunFileDialogCallbackT(self)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpfile_paths := (CStringListT)(file_paths)

		f.OnFileDialogDismissed(goTmpself, goTmpselected_accept_filter, goTmpfile_paths)

	} else {
		Logf("T213: on_file_dialog_dismissed: Noo!")
	}

}

//export cefingo_browser_process_handler_get_print_handler
func cefingo_browser_process_handler_get_print_handler(self *C.cef_browser_process_handler_t) (ch *C.cef_print_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := browser_process_handler_handlers.print_handler[self]
	if handler == nil {
		Logf("T228: get_print_handler")
	} else {
		BaseAddRef(handler.p_print_handler)
		ch = handler.p_print_handler
	}
	return ch
}

///
// Called on the browser process UI thread immediately after the CEF context
// has been initialized.
///
//export cefingo_browser_process_handler_on_context_initialized
func cefingo_browser_process_handler_on_context_initialized(
	self *C.cef_browser_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T244:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_context_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)

		f.OnContextInitialized(goTmpself)

	} else {
		Logf("T255: on_context_initialized: Noo!")
	}

}

///
// Called before a child process is launched. Will be called on the browser
// process UI thread when launching a render process and on the browser
// process IO thread when launching a GPU or plugin process. Provides an
// opportunity to modify the child process command line. Do not keep a
// reference to |command_line| outside of this function.
///
//export cefingo_browser_process_handler_on_before_child_process_launch
func cefingo_browser_process_handler_on_before_child_process_launch(
	self *C.cef_browser_process_handler_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T275:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_before_child_process_launch_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeChildProcessLaunch(goTmpself, goTmpcommand_line)
		BaseRelease(goTmpcommand_line.p_command_line)

	} else {
		Logf("T288: on_before_child_process_launch: Noo!")
	}

}

///
// Called on the browser process IO thread after the main thread has been
// created for a new render process. Provides an opportunity to specify extra
// information that will be passed to
// cef_render_process_handler_t::on_render_thread_created() in the render
// process. Do not keep a reference to |extra_info| outside of this function.
///
//export cefingo_browser_process_handler_on_render_process_thread_created
func cefingo_browser_process_handler_on_render_process_thread_created(
	self *C.cef_browser_process_handler_t,
	extra_info *C.cef_list_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T308:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_render_process_thread_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpextra_info := newCListValueT(extra_info)

		f.OnRenderProcessThreadCreated(goTmpself, goTmpextra_info)
		BaseRelease(goTmpextra_info.p_list_value)

	} else {
		Logf("T321: on_render_process_thread_created: Noo!")
	}

}

///
// Called from any thread when work has been scheduled for the browser process
// main (UI) thread. This callback is used in combination with CefSettings.
// external_message_pump and cef_do_message_loop_work() in cases where the CEF
// message loop must be integrated into an existing application message loop
// (see additional comments and warnings on CefDoMessageLoopWork). This
// callback should schedule a cef_do_message_loop_work() call to happen on the
// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
// |delay_ms| is &lt;= 0 then the call should happen reasonably soon. If
// |delay_ms| is &gt; 0 then the call should be scheduled to happen after the
// specified delay and any currently pending scheduled call should be
// cancelled.
///
//export cefingo_browser_process_handler_on_schedule_message_pump_work
func cefingo_browser_process_handler_on_schedule_message_pump_work(
	self *C.cef_browser_process_handler_t,
	delay_ms C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T347:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_schedule_message_pump_work_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpdelay_ms := (int64)(delay_ms)

		f.OnScheduleMessagePumpWork(goTmpself, goTmpdelay_ms)

	} else {
		Logf("T359: on_schedule_message_pump_work: Noo!")
	}

}

///
// Called when |browser| associated with |browser_view| is created. This
// function will be called after cef_life_span_handler_t::on_after_created()
// is called for |browser| and before on_popup_browser_view_created() is
// called for |browser|&#39;s parent delegate if |browser| is a popup.
///
//export cefingo_browser_view_delegate_on_browser_created
func cefingo_browser_view_delegate_on_browser_created(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T379:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_browser_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserCreated(goTmpself, goTmpbrowser_view, goTmpbrowser)
		BaseRelease(goTmpbrowser_view.p_browser_view)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T394: on_browser_created: Noo!")
	}

}

///
// Called when |browser| associated with |browser_view| is destroyed. Release
// all references to |browser| and do not attempt to execute any functions on
// |browser| after this callback returns. This function will be called before
// cef_life_span_handler_t::on_before_close() is called for |browser|.
///
//export cefingo_browser_view_delegate_on_browser_destroyed
func cefingo_browser_view_delegate_on_browser_destroyed(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T414:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_browser_destroyed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserDestroyed(goTmpself, goTmpbrowser_view, goTmpbrowser)
		BaseRelease(goTmpbrowser_view.p_browser_view)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T429: on_browser_destroyed: Noo!")
	}

}

///
// Called before a new popup BrowserView is created. The popup originated from
// |browser_view|. |settings| and |client| are the values returned from
// cef_life_span_handler_t::on_before_popup(). |is_devtools| will be true (1)
// if the popup will be a DevTools browser. Return the delegate that will be
// used for the new popup BrowserView.
///
//export cefingo_browser_view_delegate_get_delegate_for_popup_browser_view
func cefingo_browser_view_delegate_get_delegate_for_popup_browser_view(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	settings *C.cef_browser_settings_t,
	client *C.cef_client_t,
	is_devtools C.int,
) (cRet *C.cef_browser_view_delegate_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T452:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmpsettings := (*CBrowserSettingsT)(settings)
		goTmpclient := newCClientT(client)
		goTmpis_devtools := (int)(is_devtools)

		goRet := f.GetDelegateForPopupBrowserView(goTmpself, goTmpbrowser_view, goTmpsettings, goTmpclient, goTmpis_devtools)
		BaseRelease(goTmpbrowser_view.p_browser_view)
		BaseRelease(goTmpclient.p_client)

		cRet = (*C.cef_browser_view_delegate_t)(goRet.p_browser_view_delegate)
		BaseAddRef(cRet)
	} else {
		Logf("T470: get_delegate_for_popup_browser_view: Noo!")
	}
	return cRet
}

///
// Called after |popup_browser_view| is created. This function will be called
// after cef_life_span_handler_t::on_after_created() and on_browser_created()
// are called for the new popup browser. The popup originated from
// |browser_view|. |is_devtools| will be true (1) if the popup is a DevTools
// browser. Optionally add |popup_browser_view| to the views hierarchy
// yourself and return true (1). Otherwise return false (0) and a default
// cef_window_t will be created for the popup.
///
//export cefingo_browser_view_delegate_on_popup_browser_view_created
func cefingo_browser_view_delegate_on_popup_browser_view_created(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	popup_browser_view *C.cef_browser_view_t,
	is_devtools C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T495:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_popup_browser_view_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmppopup_browser_view := newCBrowserViewT(popup_browser_view)
		goTmpis_devtools := (int)(is_devtools)

		goRet := f.OnPopupBrowserViewCreated(goTmpself, goTmpbrowser_view, goTmppopup_browser_view, goTmpis_devtools)
		BaseRelease(goTmpbrowser_view.p_browser_view)
		BaseRelease(goTmppopup_browser_view.p_browser_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T512: on_popup_browser_view_created: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_preferred_size
func cefingo_browser_view_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T525:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_preferred_size_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T539: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_minimum_size
func cefingo_browser_view_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T552:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_minimum_size_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T566: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_maximum_size
func cefingo_browser_view_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T579:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_maximum_size_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T593: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_height_for_width
func cefingo_browser_view_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T607:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_height_for_width_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.p_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T622: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_on_parent_view_changed
func cefingo_browser_view_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T637:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_parent_view_changed_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpparent.p_view)

	} else {
		Logf("T653: on_parent_view_changed: Noo!")
	}

}

//export cefingo_browser_view_delegate_on_child_view_changed
func cefingo_browser_view_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T668:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_child_view_changed_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpchild.p_view)

	} else {
		Logf("T684: on_child_view_changed: Noo!")
	}

}

//export cefingo_browser_view_delegate_on_focus
func cefingo_browser_view_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T697:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_focus_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T710: on_focus: Noo!")
	}

}

//export cefingo_browser_view_delegate_on_blur
func cefingo_browser_view_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T723:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_blur_handler[(*C.cef_browser_view_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T736: on_blur: Noo!")
	}

}

///
// Called when |button| is pressed.
///
//export cefingo_button_delegate_on_button_pressed
func cefingo_button_delegate_on_button_pressed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T752:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_button_pressed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonPressed(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.p_button)

	} else {
		Logf("T765: on_button_pressed: Noo!")
	}

}

///
// Called when the state of |button| changes.
///
//export cefingo_button_delegate_on_button_state_changed
func cefingo_button_delegate_on_button_state_changed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T781:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_button_state_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonStateChanged(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.p_button)

	} else {
		Logf("T794: on_button_state_changed: Noo!")
	}

}

//export cefingo_button_delegate_get_preferred_size
func cefingo_button_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T807:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_preferred_size_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T821: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_get_minimum_size
func cefingo_button_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T834:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_minimum_size_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T848: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_get_maximum_size
func cefingo_button_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T861:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_maximum_size_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T875: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_get_height_for_width
func cefingo_button_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T889:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_height_for_width_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.p_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T904: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_on_parent_view_changed
func cefingo_button_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T919:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_parent_view_changed_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpparent.p_view)

	} else {
		Logf("T935: on_parent_view_changed: Noo!")
	}

}

//export cefingo_button_delegate_on_child_view_changed
func cefingo_button_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T950:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_child_view_changed_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpchild.p_view)

	} else {
		Logf("T966: on_child_view_changed: Noo!")
	}

}

//export cefingo_button_delegate_on_focus
func cefingo_button_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T979:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_focus_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T992: on_focus: Noo!")
	}

}

//export cefingo_button_delegate_on_blur
func cefingo_button_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1005:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_blur_handler[(*C.cef_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T1018: on_blur: Noo!")
	}

}

//export cefingo_client_get_context_menu_handler
func cefingo_client_get_context_menu_handler(self *C.cef_client_t) (ch *C.cef_context_menu_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.context_menu_handler[self]
	if handler == nil {
		Logf("T1033: get_context_menu_handler")
	} else {
		BaseAddRef(handler.p_context_menu_handler)
		ch = handler.p_context_menu_handler
	}
	return ch
}

//export cefingo_client_get_dialog_handler
func cefingo_client_get_dialog_handler(self *C.cef_client_t) (ch *C.cef_dialog_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.dialog_handler[self]
	if handler == nil {
		Logf("T1048: get_dialog_handler")
	} else {
		BaseAddRef(handler.p_dialog_handler)
		ch = handler.p_dialog_handler
	}
	return ch
}

//export cefingo_client_get_display_handler
func cefingo_client_get_display_handler(self *C.cef_client_t) (ch *C.cef_display_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.display_handler[self]
	if handler == nil {
		Logf("T1063: get_display_handler")
	} else {
		BaseAddRef(handler.p_display_handler)
		ch = handler.p_display_handler
	}
	return ch
}

//export cefingo_client_get_download_handler
func cefingo_client_get_download_handler(self *C.cef_client_t) (ch *C.cef_download_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.download_handler[self]
	if handler == nil {
		Logf("T1078: get_download_handler")
	} else {
		BaseAddRef(handler.p_download_handler)
		ch = handler.p_download_handler
	}
	return ch
}

//export cefingo_client_get_drag_handler
func cefingo_client_get_drag_handler(self *C.cef_client_t) (ch *C.cef_drag_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.drag_handler[self]
	if handler == nil {
		Logf("T1093: get_drag_handler")
	} else {
		BaseAddRef(handler.p_drag_handler)
		ch = handler.p_drag_handler
	}
	return ch
}

//export cefingo_client_get_find_handler
func cefingo_client_get_find_handler(self *C.cef_client_t) (ch *C.cef_find_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.find_handler[self]
	if handler == nil {
		Logf("T1108: get_find_handler")
	} else {
		BaseAddRef(handler.p_find_handler)
		ch = handler.p_find_handler
	}
	return ch
}

//export cefingo_client_get_focus_handler
func cefingo_client_get_focus_handler(self *C.cef_client_t) (ch *C.cef_focus_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.focus_handler[self]
	if handler == nil {
		Logf("T1123: get_focus_handler")
	} else {
		BaseAddRef(handler.p_focus_handler)
		ch = handler.p_focus_handler
	}
	return ch
}

//export cefingo_client_get_jsdialog_handler
func cefingo_client_get_jsdialog_handler(self *C.cef_client_t) (ch *C.cef_jsdialog_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.jsdialog_handler[self]
	if handler == nil {
		Logf("T1138: get_jsdialog_handler")
	} else {
		BaseAddRef(handler.p_jsdialog_handler)
		ch = handler.p_jsdialog_handler
	}
	return ch
}

//export cefingo_client_get_keyboard_handler
func cefingo_client_get_keyboard_handler(self *C.cef_client_t) (ch *C.cef_keyboard_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.keyboard_handler[self]
	if handler == nil {
		Logf("T1153: get_keyboard_handler")
	} else {
		BaseAddRef(handler.p_keyboard_handler)
		ch = handler.p_keyboard_handler
	}
	return ch
}

//export cefingo_client_get_life_span_handler
func cefingo_client_get_life_span_handler(self *C.cef_client_t) (ch *C.cef_life_span_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.life_span_handler[self]
	if handler == nil {
		Logf("T1168: get_life_span_handler")
	} else {
		BaseAddRef(handler.p_life_span_handler)
		ch = handler.p_life_span_handler
	}
	return ch
}

//export cefingo_client_get_load_handler
func cefingo_client_get_load_handler(self *C.cef_client_t) (ch *C.cef_load_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.load_handler[self]
	if handler == nil {
		Logf("T1183: get_load_handler")
	} else {
		BaseAddRef(handler.p_load_handler)
		ch = handler.p_load_handler
	}
	return ch
}

//export cefingo_client_get_render_handler
func cefingo_client_get_render_handler(self *C.cef_client_t) (ch *C.cef_render_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.render_handler[self]
	if handler == nil {
		Logf("T1198: get_render_handler")
	} else {
		BaseAddRef(handler.p_render_handler)
		ch = handler.p_render_handler
	}
	return ch
}

//export cefingo_client_get_request_handler
func cefingo_client_get_request_handler(self *C.cef_client_t) (ch *C.cef_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.request_handler[self]
	if handler == nil {
		Logf("T1213: get_request_handler")
	} else {
		BaseAddRef(handler.p_request_handler)
		ch = handler.p_request_handler
	}
	return ch
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_client_on_process_message_received
func cefingo_client_on_process_message_received(
	self *C.cef_client_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1234:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.on_process_message_received_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpmessage.p_process_message)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1253: on_process_message_received: Noo!")
	}
	return cRet
}

///
// Called before a context menu is displayed. |params| provides information
// about the context menu state. |model| initially contains the default
// context menu. The |model| can be cleared to show no context menu or
// modified to show a custom menu. Do not keep references to |params| or
// |model| outside of this callback.
///
//export cefingo_context_menu_handler_on_before_context_menu
func cefingo_context_menu_handler_on_before_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1276:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_before_context_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)

		f.OnBeforeContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)
		BaseRelease(goTmpmodel.p_menu_model)

	} else {
		Logf("T1295: on_before_context_menu: Noo!")
	}

}

///
// Called to allow custom display of the context menu. |params| provides
// information about the context menu state. |model| contains the context menu
// model resulting from OnBeforeContextMenu. For custom display return true
// (1) and execute |callback| either synchronously or asynchronously with the
// selected command ID. For default display return false (0). Do not keep
// references to |params| or |model| outside of this callback.
///
//export cefingo_context_menu_handler_run_context_menu
func cefingo_context_menu_handler_run_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
	callback *C.cef_run_context_menu_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1320:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.run_context_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)
		goTmpcallback := newCRunContextMenuCallbackT(callback)

		goRet := f.RunContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)
		BaseRelease(goTmpmodel.p_menu_model)
		BaseRelease(goTmpcallback.p_run_context_menu_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1342: run_context_menu: Noo!")
	}
	return cRet
}

///
// Called to execute a command selected from the context menu. Return true (1)
// if the command was handled or false (0) for the default implementation. See
// cef_menu_id_t for the command ids that have default implementations. All
// user-defined command ids should be between MENU_ID_USER_FIRST and
// MENU_ID_USER_LAST. |params| will have the same values as what was passed to
// on_before_context_menu(). Do not keep a reference to |params| outside of
// this callback.
///
//export cefingo_context_menu_handler_on_context_menu_command
func cefingo_context_menu_handler_on_context_menu_command(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1368:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_command_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		goRet := f.OnContextMenuCommand(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpcommand_id, goTmpevent_flags)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1388: on_context_menu_command: Noo!")
	}
	return cRet
}

///
// Called when the context menu is dismissed irregardless of whether the menu
// was NULL or a command was selected.
///
//export cefingo_context_menu_handler_on_context_menu_dismissed
func cefingo_context_menu_handler_on_context_menu_dismissed(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1406:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_dismissed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)

		f.OnContextMenuDismissed(goTmpself, goTmpbrowser, goTmpframe)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T1421: on_context_menu_dismissed: Noo!")
	}

}

///
// Method that will be called once for each cookie. |count| is the 0-based
// index for the current cookie. |total| is the total number of cookies. Set
// |deleteCookie| to true (1) to delete the cookie currently being visited.
// Return false (0) to stop visiting cookies. This function may never be
// called if no cookies are found.
///
//export cefingo_cookie_visitor_visit
func cefingo_cookie_visitor_visit(
	self *C.cef_cookie_visitor_t,
	cookie *C.cef_cookie_t,
	count C.int,
	total C.int,
	deleteCookie *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1444:")
	cefingoIfaceAccess.Lock()
	f := cookie_visitor_handlers.visit_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCCookieVisitorT(self)
		goTmpcookie := (*CCookieT)(cookie)
		goTmpcount := (int)(count)
		goTmptotal := (int)(total)

		goRet, goTmpdeleteCookieOut := f.Visit(goTmpself, goTmpcookie, goTmpcount, goTmptotal)
		*deleteCookie = (C.int)(goTmpdeleteCookieOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1460: visit: Noo!")
	}
	return cRet
}

///
// Method that will be called upon completion. |success| will be true (1) if
// the cookie was set successfully.
///
//export cefingo_set_cookie_callback_on_complete
func cefingo_set_cookie_callback_on_complete(
	self *C.cef_set_cookie_callback_t,
	success C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1477:")
	cefingoIfaceAccess.Lock()
	f := set_cookie_callback_handlers.on_complete_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCSetCookieCallbackT(self)
		goTmpsuccess := (int)(success)

		f.OnComplete(goTmpself, goTmpsuccess)

	} else {
		Logf("T1489: on_complete: Noo!")
	}

}

///
// Method that will be called upon completion. |num_deleted| will be the
// number of cookies that were deleted.
///
//export cefingo_delete_cookies_callback_on_complete
func cefingo_delete_cookies_callback_on_complete(
	self *C.cef_delete_cookies_callback_t,
	num_deleted C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1506:")
	cefingoIfaceAccess.Lock()
	f := delete_cookies_callback_handlers.on_complete_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDeleteCookiesCallbackT(self)
		goTmpnum_deleted := (int)(num_deleted)

		f.OnComplete(goTmpself, goTmpnum_deleted)

	} else {
		Logf("T1518: on_complete: Noo!")
	}

}

///
// Called to run a file chooser dialog. |mode| represents the type of dialog
// to display. |title| to the title to be used for the dialog and may be NULL
// to show the default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode).
// |default_file_path| is the path with optional directory and/or file name
// component that should be initially selected in the dialog. |accept_filters|
// are used to restrict the selectable file types and may any combination of
// (a) valid lower-cased MIME types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b)
// individual file extensions (e.g. &quot;.txt&quot; or &quot;.png&quot;), or (c) combined
// description and file extension delimited using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image
// Types|.png;.gif;.jpg&quot;). |selected_accept_filter| is the 0-based index of
// the filter that should be selected by default. To display a custom dialog
// return true (1) and execute |callback| either inline or at a later time. To
// display the default dialog return false (0).
///
//export cefingo_dialog_handler_on_file_dialog
func cefingo_dialog_handler_on_file_dialog(
	self *C.cef_dialog_handler_t,
	browser *C.cef_browser_t,
	mode C.cef_file_dialog_mode_t,
	title *C.cef_string_t,
	default_file_path *C.cef_string_t,
	accept_filters C.cef_string_list_t,
	selected_accept_filter C.int,
	callback *C.cef_file_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1552:")
	cefingoIfaceAccess.Lock()
	f := dialog_handler_handlers.on_file_dialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmode := CFileDialogModeT(mode)
		goTmptitle := string_from_cef_string(title)
		goTmpdefault_file_path := string_from_cef_string(default_file_path)
		goTmpaccept_filters := (CStringListT)(accept_filters)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpcallback := newCFileDialogCallbackT(callback)

		goRet := f.OnFileDialog(goTmpself, goTmpbrowser, goTmpmode, goTmptitle, goTmpdefault_file_path, goTmpaccept_filters, goTmpselected_accept_filter, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_file_dialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1573: on_file_dialog: Noo!")
	}
	return cRet
}

///
// Called when a frame&#39;s address has changed.
///
//export cefingo_display_handler_on_address_change
func cefingo_display_handler_on_address_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1591:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_address_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpurl := string_from_cef_string(url)

		f.OnAddressChange(goTmpself, goTmpbrowser, goTmpframe, goTmpurl)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T1607: on_address_change: Noo!")
	}

}

///
// Called when the page title changes.
///
//export cefingo_display_handler_on_title_change
func cefingo_display_handler_on_title_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	title *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1624:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_title_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptitle := string_from_cef_string(title)

		f.OnTitleChange(goTmpself, goTmpbrowser, goTmptitle)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1638: on_title_change: Noo!")
	}

}

///
// Called when the page icon changes.
///
//export cefingo_display_handler_on_favicon_urlchange
func cefingo_display_handler_on_favicon_urlchange(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	icon_urls C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1655:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_favicon_urlchange_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpicon_urls := (CStringListT)(icon_urls)

		f.OnFaviconUrlchange(goTmpself, goTmpbrowser, goTmpicon_urls)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1669: on_favicon_urlchange: Noo!")
	}

}

///
// Called when web content in the page has toggled fullscreen mode. If
// |fullscreen| is true (1) the content will automatically be sized to fill
// the browser content area. If |fullscreen| is false (0) the content will
// automatically return to its original size and position. The client is
// responsible for resizing the browser if desired.
///
//export cefingo_display_handler_on_fullscreen_mode_change
func cefingo_display_handler_on_fullscreen_mode_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	fullscreen C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1690:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_fullscreen_mode_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfullscreen := (int)(fullscreen)

		f.OnFullscreenModeChange(goTmpself, goTmpbrowser, goTmpfullscreen)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1704: on_fullscreen_mode_change: Noo!")
	}

}

///
// Called when the browser is about to display a tooltip. |text| contains the
// text that will be displayed in the tooltip. To handle the display of the
// tooltip yourself return true (1). Otherwise, you can optionally modify
// |text| and then return false (0) to allow the browser to display the
// tooltip. When window rendering is disabled the application is responsible
// for drawing tooltips and the return value is ignored.
///
//export cefingo_display_handler_on_tooltip
func cefingo_display_handler_on_tooltip(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	text *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1726:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_tooltip_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptext := string_from_cef_string(text)

		goRet, goTmptextOut := f.OnTooltip(goTmpself, goTmpbrowser, goTmptext)
		BaseRelease(goTmpbrowser.p_browser)
		set_cef_string(text, goTmptextOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1741: on_tooltip: Noo!")
	}
	return cRet
}

///
// Called when the browser receives a status message. |value| contains the
// text that will be displayed in the status message.
///
//export cefingo_display_handler_on_status_message
func cefingo_display_handler_on_status_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	value *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1760:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_status_message_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpvalue := string_from_cef_string(value)

		f.OnStatusMessage(goTmpself, goTmpbrowser, goTmpvalue)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1774: on_status_message: Noo!")
	}

}

///
// Called to display a console message. Return true (1) to stop the message
// from being output to the console.
///
//export cefingo_display_handler_on_console_message
func cefingo_display_handler_on_console_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	level C.cef_log_severity_t,
	message *C.cef_string_t,
	source *C.cef_string_t,
	line C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1795:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_console_message_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmplevel := CLogSeverityT(level)
		goTmpmessage := string_from_cef_string(message)
		goTmpsource := string_from_cef_string(source)
		goTmpline := (int)(line)

		goRet := f.OnConsoleMessage(goTmpself, goTmpbrowser, goTmplevel, goTmpmessage, goTmpsource, goTmpline)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1813: on_console_message: Noo!")
	}
	return cRet
}

///
// Called when auto-resize is enabled via
// cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-
// resized. |new_size| will be the desired size in view coordinates. Return
// true (1) if the resize was handled or false (0) for default handling.
///
//export cefingo_display_handler_on_auto_resize
func cefingo_display_handler_on_auto_resize(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	new_size *C.cef_size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1833:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_auto_resize_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnew_size := (*CSizeT)(new_size)

		goRet := f.OnAutoResize(goTmpself, goTmpbrowser, goTmpnew_size)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1848: on_auto_resize: Noo!")
	}
	return cRet
}

///
// Called when the overall page loading progress has changed. |progress|
// ranges from 0.0 to 1.0.
///
//export cefingo_display_handler_on_loading_progress_change
func cefingo_display_handler_on_loading_progress_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	progress C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1866:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_loading_progress_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpprogress := (float64)(progress)

		f.OnLoadingProgressChange(goTmpself, goTmpbrowser, goTmpprogress)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1880: on_loading_progress_change: Noo!")
	}

}

///
// Method executed for visiting the DOM. The document object passed to this
// function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_domvisitor_visit
func cefingo_domvisitor_visit(
	self *C.cef_domvisitor_t,
	document *C.cef_domdocument_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1900:")
	cefingoIfaceAccess.Lock()
	f := domvisitor_handlers.visit_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDomvisitorT(self)
		goTmpdocument := newCDomdocumentT(document)

		f.Visit(goTmpself, goTmpdocument)
		BaseRelease(goTmpdocument.p_domdocument)

	} else {
		Logf("T1913: visit: Noo!")
	}

}

///
// Called before a download begins. |suggested_name| is the suggested name for
// the download file. By default the download will be canceled. Execute
// |callback| either asynchronously or in this function to continue the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_before_download
func cefingo_download_handler_on_before_download(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	suggested_name *C.cef_string_t,
	callback *C.cef_before_download_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1936:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_before_download_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpsuggested_name := string_from_cef_string(suggested_name)
		goTmpcallback := newCBeforeDownloadCallbackT(callback)

		f.OnBeforeDownload(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpsuggested_name, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdownload_item.p_download_item)
		BaseRelease(goTmpcallback.p_before_download_callback)

	} else {
		Logf("T1954: on_before_download: Noo!")
	}

}

///
// Called when a download&#39;s status or progress information has been updated.
// This may be called multiple times before and after on_before_download().
// Execute |callback| either asynchronously or in this function to cancel the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_download_updated
func cefingo_download_handler_on_download_updated(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	callback *C.cef_download_item_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1976:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_download_updated_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpcallback := newCDownloadItemCallbackT(callback)

		f.OnDownloadUpdated(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdownload_item.p_download_item)
		BaseRelease(goTmpcallback.p_download_item_callback)

	} else {
		Logf("T1993: on_download_updated: Noo!")
	}

}

///
// Called when an external drag event enters the browser window. |dragData|
// contains the drag event data and |mask| represents the type of drag
// operation. Return false (0) for default drag handling behavior or true (1)
// to cancel the drag event.
///
//export cefingo_drag_handler_on_drag_enter
func cefingo_drag_handler_on_drag_enter(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	dragData *C.cef_drag_data_t,
	mask C.cef_drag_operations_mask_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2014:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_drag_enter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdragData := newCDragDataT(dragData)
		goTmpmask := CDragOperationsMaskT(mask)

		goRet := f.OnDragEnter(goTmpself, goTmpbrowser, goTmpdragData, goTmpmask)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdragData.p_drag_data)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2031: on_drag_enter: Noo!")
	}
	return cRet
}

///
// Called whenever draggable regions for the browser window change. These can
// be specified using the &#39;-webkit-app-region: drag/no-drag&#39; CSS-property. If
// draggable regions are never defined in a document this function will also
// never be called. If the last draggable region is removed from a document
// this function will be called with an NULL vector.
///
//export cefingo_drag_handler_on_draggable_regions_changed
func cefingo_drag_handler_on_draggable_regions_changed(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	regionsCount C.size_t,
	regions *C.cef_draggable_region_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2054:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_draggable_regions_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpregionsCount := (int64)(regionsCount)
		goTmpregions := (*CDraggableRegionT)(regions)

		f.OnDraggableRegionsChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpregionsCount, goTmpregions)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T2071: on_draggable_regions_changed: Noo!")
	}

}

///
// Called if the cef_request_context_t::LoadExtension request fails. |result|
// will be the error code.
///
//export cefingo_extension_handler_on_extension_load_failed
func cefingo_extension_handler_on_extension_load_failed(
	self *C.cef_extension_handler_t,
	result C.cef_errorcode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2088:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_load_failed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpresult := CErrorcodeT(result)

		f.OnExtensionLoadFailed(goTmpself, goTmpresult)

	} else {
		Logf("T2100: on_extension_load_failed: Noo!")
	}

}

///
// Called if the cef_request_context_t::LoadExtension request succeeds.
// |extension| is the loaded extension.
///
//export cefingo_extension_handler_on_extension_loaded
func cefingo_extension_handler_on_extension_loaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2117:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_loaded_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionLoaded(goTmpself, goTmpextension)
		BaseRelease(goTmpextension.p_extension)

	} else {
		Logf("T2130: on_extension_loaded: Noo!")
	}

}

///
// Called after the cef_extension_t::Unload request has completed.
///
//export cefingo_extension_handler_on_extension_unloaded
func cefingo_extension_handler_on_extension_unloaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2146:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_unloaded_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionUnloaded(goTmpself, goTmpextension)
		BaseRelease(goTmpextension.p_extension)

	} else {
		Logf("T2159: on_extension_unloaded: Noo!")
	}

}

///
// Called when an extension needs a browser to host a background script
// specified via the &quot;background&quot; manifest key. The browser will have no
// visible window and cannot be displayed. |extension| is the extension that
// is loading the background script. |url| is an internally generated
// reference to an HTML page that will be used to load the background script
// via a &lt;script&gt; src attribute. To allow creation of the browser optionally
// modify |client| and |settings| and return false (0). To cancel creation of
// the browser (and consequently cancel load of the background script) return
// true (1). Successful creation will be indicated by a call to
// cef_life_span_handler_t::OnAfterCreated, and
// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
// browser. See https://developer.chrome.com/extensions/event_pages for more
// information about extension background script usage.
///
//export cefingo_extension_handler_on_before_background_browser
func cefingo_extension_handler_on_before_background_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	url *C.cef_string_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2190:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_background_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpurl := string_from_cef_string(url)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.p_client
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBackgroundBrowser(goTmpself, goTmpextension, goTmpurl, goTmpclient, goTmpsettings)
		BaseRelease(goTmpextension.p_extension)
		if cefp != goTmpclientOut.p_client {
			*client = goTmpclientOut.p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2206: on_before_background_browser: Noo!")
	}
	return cRet
}

///
// Called when an extension API (e.g. chrome.tabs.create) requests creation of
// a new browser. |extension| and |browser| are the source of the API call.
// |active_browser| may optionally be specified via the windowId property or
// returned via the get_active_browser() callback and provides the default
// |client| and |settings| values for the new browser. |index| is the position
// value optionally specified via the index property. |url| is the URL that
// will be loaded in the browser. |active| is true (1) if the new browser
// should be active when opened.  To allow creation of the browser optionally
// modify |windowInfo|, |client| and |settings| and return false (0). To
// cancel creation of the browser return true (1). Successful creation will be
// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
// modifications to |windowInfo| will be ignored if |active_browser| is
// wrapped in a cef_browser_view_t.
///
//export cefingo_extension_handler_on_before_browser
func cefingo_extension_handler_on_before_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	active_browser *C.cef_browser_t,
	index C.int,
	url *C.cef_string_t,
	active C.int,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2249:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpactive_browser := newCBrowserT(active_browser)
		goTmpindex := (int)(index)
		goTmpurl := string_from_cef_string(url)
		goTmpactive := (int)(active)
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.p_client
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpactive_browser, goTmpindex, goTmpurl, goTmpactive, goTmpwindowInfo, goTmpclient, goTmpsettings)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpactive_browser.p_browser)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.p_client {
			*client = goTmpclientOut.p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2271: on_before_browser: Noo!")
	}
	return cRet
}

///
// Called when no tabId is specified to an extension API call that accepts a
// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
// source of the API call. Return the browser that will be acted on by the API
// call or return NULL to act on |browser|. The returned browser must share
// the same cef_request_context_t as |browser|. Incognito browsers should not
// be considered unless the source extension has incognito access enabled, in
// which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_get_active_browser
func cefingo_extension_handler_get_active_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
) (cRet *C.cef_browser_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2304:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_active_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)

		goRet := f.GetActiveBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)

		cRet = (*C.cef_browser_t)(goRet.p_browser)
		BaseAddRef(cRet)
	} else {
		Logf("T2321: get_active_browser: Noo!")
	}
	return cRet
}

///
// Called when the tabId associated with |target_browser| is specified to an
// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
// |extension| and |browser| are the source of the API call. Return true (1)
// to allow access of false (0) to deny access. Access to incognito browsers
// should not be allowed unless the source extension has incognito access
// enabled, in which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_can_access_browser
func cefingo_extension_handler_can_access_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
	target_browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2346:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.can_access_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)
		goTmptarget_browser := newCBrowserT(target_browser)

		goRet := f.CanAccessBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito, goTmptarget_browser)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmptarget_browser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2365: can_access_browser: Noo!")
	}
	return cRet
}

///
// Called to retrieve an extension resource that would normally be loaded from
// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
// |extension| and |browser| are the source of the resource request. |file| is
// the requested relative file path. To handle the resource request return
// true (1) and execute |callback| either synchronously or asynchronously. For
// the default behavior which reads the resource from the extension directory
// on disk return false (0). Localization substitutions will not be applied to
// resources handled via this function.
///
//export cefingo_extension_handler_get_extension_resource
func cefingo_extension_handler_get_extension_resource(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	file *C.cef_string_t,
	callback *C.cef_get_extension_resource_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2391:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_extension_resource_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfile := string_from_cef_string(file)
		goTmpcallback := newCGetExtensionResourceCallbackT(callback)

		goRet := f.GetExtensionResource(goTmpself, goTmpextension, goTmpbrowser, goTmpfile, goTmpcallback)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_get_extension_resource_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2410: get_extension_resource: Noo!")
	}
	return cRet
}

///
// Called to report find results returned by cef_browser_host_t::find().
// |identifer| is the identifier passed to find(), |count| is the number of
// matches currently identified, |selectionRect| is the location of where the
// match was found (in window coordinates), |activeMatchOrdinal| is the
// current position in the search results, and |finalUpdate| is true (1) if
// this is the last find notification.
///
//export cefingo_find_handler_on_find_result
func cefingo_find_handler_on_find_result(
	self *C.cef_find_handler_t,
	browser *C.cef_browser_t,
	identifier C.int,
	count C.int,
	selectionRect *C.cef_rect_t,
	activeMatchOrdinal C.int,
	finalUpdate C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2436:")
	cefingoIfaceAccess.Lock()
	f := find_handler_handlers.on_find_result_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFindHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpidentifier := (int)(identifier)
		goTmpcount := (int)(count)
		goTmpselectionRect := (*CRectT)(selectionRect)
		goTmpactiveMatchOrdinal := (int)(activeMatchOrdinal)
		goTmpfinalUpdate := (int)(finalUpdate)

		f.OnFindResult(goTmpself, goTmpbrowser, goTmpidentifier, goTmpcount, goTmpselectionRect, goTmpactiveMatchOrdinal, goTmpfinalUpdate)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2454: on_find_result: Noo!")
	}

}

///
// Called when the browser component is about to loose focus. For instance, if
// focus was on the last HTML element and the user pressed the TAB key. |next|
// will be true (1) if the browser is giving focus to the next component and
// false (0) if the browser is giving focus to the previous component.
///
//export cefingo_focus_handler_on_take_focus
func cefingo_focus_handler_on_take_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	next C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2474:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_take_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnext := (int)(next)

		f.OnTakeFocus(goTmpself, goTmpbrowser, goTmpnext)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2488: on_take_focus: Noo!")
	}

}

///
// Called when the browser component is requesting focus. |source| indicates
// where the focus request is originating from. Return false (0) to allow the
// focus to be set or true (1) to cancel setting the focus.
///
//export cefingo_focus_handler_on_set_focus
func cefingo_focus_handler_on_set_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	source C.cef_focus_source_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2507:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_set_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpsource := CFocusSourceT(source)

		goRet := f.OnSetFocus(goTmpself, goTmpbrowser, goTmpsource)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2522: on_set_focus: Noo!")
	}
	return cRet
}

///
// Called when the browser component has received focus.
///
//export cefingo_focus_handler_on_got_focus
func cefingo_focus_handler_on_got_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2538:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_got_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnGotFocus(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2551: on_got_focus: Noo!")
	}

}

///
// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
// and user-friendly display string. The |default_prompt_text| value will be
// specified for prompt dialogs only. Set |suppress_message| to true (1) and
// return false (0) to suppress the message (suppressing messages is
// preferable to immediately executing the callback as this is used to detect
// presumably malicious behavior like spamming alert messages in
// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
// to use the default implementation (the default implementation will show one
// modal dialog at a time and suppress any additional dialog requests until
// the displayed dialog is dismissed). Return true (1) if the application will
// use a custom dialog or if the callback has been executed immediately.
// Custom dialogs may be either modal or modeless. If a custom dialog is used
// the application must execute |callback| once the custom dialog is
// dismissed.
///
//export cefingo_jsdialog_handler_on_jsdialog
func cefingo_jsdialog_handler_on_jsdialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	dialog_type C.cef_jsdialog_type_t,
	message_text *C.cef_string_t,
	default_prompt_text *C.cef_string_t,
	callback *C.cef_jsdialog_callback_t,
	suppress_message *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2587:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_jsdialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpdialog_type := CJsdialogTypeT(dialog_type)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpdefault_prompt_text := string_from_cef_string(default_prompt_text)
		goTmpcallback := newCJsdialogCallbackT(callback)

		goRet, goTmpsuppress_messageOut := f.OnJsdialog(goTmpself, goTmpbrowser, goTmporigin_url, goTmpdialog_type, goTmpmessage_text, goTmpdefault_prompt_text, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_jsdialog_callback)
		*suppress_message = (C.int)(goTmpsuppress_messageOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2608: on_jsdialog: Noo!")
	}
	return cRet
}

///
// Called to run a dialog asking the user if they want to leave a page. Return
// false (0) to use the default dialog implementation. Return true (1) if the
// application will use a custom dialog or if the callback has been executed
// immediately. Custom dialogs may be either modal or modeless. If a custom
// dialog is used the application must execute |callback| once the custom
// dialog is dismissed.
///
//export cefingo_jsdialog_handler_on_before_unload_dialog
func cefingo_jsdialog_handler_on_before_unload_dialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	message_text *C.cef_string_t,
	is_reload C.int,
	callback *C.cef_jsdialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2632:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_before_unload_dialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpis_reload := (int)(is_reload)
		goTmpcallback := newCJsdialogCallbackT(callback)

		goRet := f.OnBeforeUnloadDialog(goTmpself, goTmpbrowser, goTmpmessage_text, goTmpis_reload, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_jsdialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2650: on_before_unload_dialog: Noo!")
	}
	return cRet
}

///
// Called to cancel any pending dialogs and reset any saved dialog state. Will
// be called due to events like page navigation irregardless of whether any
// dialogs are currently pending.
///
//export cefingo_jsdialog_handler_on_reset_dialog_state
func cefingo_jsdialog_handler_on_reset_dialog_state(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2668:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_reset_dialog_state_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnResetDialogState(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2681: on_reset_dialog_state: Noo!")
	}

}

///
// Called when the default implementation dialog is closed.
///
//export cefingo_jsdialog_handler_on_dialog_closed
func cefingo_jsdialog_handler_on_dialog_closed(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2697:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_dialog_closed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnDialogClosed(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2710: on_dialog_closed: Noo!")
	}

}

///
// Called before a keyboard event is sent to the renderer. |event| contains
// information about the keyboard event. |os_event| is the operating system
// event message, if any. Return true (1) if the event was handled or false
// (0) otherwise. If the event will be handled in on_key_event() as a keyboard
// shortcut set |is_keyboard_shortcut| to true (1) and return false (0).
///
//export cefingo_keyboard_handler_on_pre_key_event
func cefingo_keyboard_handler_on_pre_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
	is_keyboard_shortcut *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2733:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_pre_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)

		goRet, goTmpis_keyboard_shortcutOut := f.OnPreKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)
		BaseRelease(goTmpbrowser.p_browser)
		*is_keyboard_shortcut = (C.int)(goTmpis_keyboard_shortcutOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2750: on_pre_key_event: Noo!")
	}
	return cRet
}

///
// Called after the renderer and JavaScript in the page has had a chance to
// handle the event. |event| contains information about the keyboard event.
// |os_event| is the operating system event message, if any. Return true (1)
// if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_keyboard_handler_on_key_event
func cefingo_keyboard_handler_on_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2771:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)

		goRet := f.OnKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2787: on_key_event: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before a new popup browser is created. The
// |browser| and |frame| values represent the source of the popup request. The
// |target_url| and |target_frame_name| values indicate where the popup
// browser should navigate and may be NULL if not specified with the request.
// The |target_disposition| value indicates where the user intended to open
// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
// be true (1) if the popup was opened via explicit user gesture (e.g.
// clicking a link) or false (0) if the popup opened automatically (e.g. via
// the DomContentLoaded event). The |popupFeatures| structure contains
// additional information about the requested popup window. To allow creation
// of the popup browser optionally modify |windowInfo|, |client|, |settings|
// and |no_javascript_access| and return false (0). To cancel creation of the
// popup browser return true (1). The |client| and |settings| values will
// default to the source browser&#39;s values. If the |no_javascript_access| value
// is set to false (0) the new browser will not be scriptable and may not be
// hosted in the same renderer process as the source browser. Any
// modifications to |windowInfo| will be ignored if the parent browser is
// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
// the parent browser is destroyed before the popup browser creation completes
// (indicated by a call to OnAfterCreated for the popup browser). The
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created popup browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
//export cefingo_life_span_handler_on_before_popup
func cefingo_life_span_handler_on_before_popup(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_frame_name *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
	popupFeatures *C.cef_popup_features_t,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
	extra_info **C.cef_dictionary_value_t,
	no_javascript_access *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2836:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_popup_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_frame_name := string_from_cef_string(target_frame_name)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := (int)(user_gesture)
		goTmppopupFeatures := (*CPopupFeaturesT)(popupFeatures)
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.p_client
		goTmpsettings := CBrowserSettingsT(*settings)
		goTmpno_javascript_access := int(*no_javascript_access)

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut, goTmpextra_infoOut, goTmpno_javascript_accessOut := f.OnBeforePopup(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_frame_name, goTmptarget_disposition, goTmpuser_gesture, goTmppopupFeatures, goTmpwindowInfo, goTmpclient, goTmpsettings, goTmpno_javascript_access)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.p_client {
			*client = goTmpclientOut.p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)
		if goTmpextra_infoOut != nil {
			*extra_info = goTmpextra_infoOut.p_dictionary_value
			BaseAddRef(*extra_info)
		}
		*no_javascript_access = C.int(goTmpno_javascript_accessOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2862: on_before_popup: Noo!")
	}
	return cRet
}

///
// Called after a new browser is created. This callback will be the first
// notification that references |browser|.
///
//export cefingo_life_span_handler_on_after_created
func cefingo_life_span_handler_on_after_created(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2890:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_after_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnAfterCreated(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2903: on_after_created: Noo!")
	}

}

///
// Called when a browser has recieved a request to close. This may result
// directly from a call to cef_browser_host_t::*close_browser() or indirectly
// if the browser is parented to a top-level window created by CEF and the
// user attempts to close that window (by clicking the &#39;X&#39;, for example). The
// do_close() function will be called after the JavaScript &#39;onunload&#39; event
// has been fired.
//
// An application should handle top-level owner window close notifications by
// calling cef_browser_host_t::try_close_browser() or
// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
// to close immediately (see the examples below). This gives CEF an
// opportunity to process the &#39;onbeforeunload&#39; event and optionally cancel the
// close before do_close() is called.
//
// When windowed rendering is enabled CEF will internally create a window or
// view to host the browser. In that case returning false (0) from do_close()
// will send the standard close notification to the browser&#39;s top-level owner
// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
// Linux or cef_window_delegate_t::can_close() callback from Views). If the
// browser&#39;s host window/view has already been destroyed (via view hierarchy
// tear-down, for example) then do_close() will not be called for that browser
// since is no longer possible to cancel the close.
//
// When windowed rendering is disabled returning false (0) from do_close()
// will cause the browser object to be destroyed immediately.
//
// If the browser&#39;s top-level owner window requires a non-standard close
// notification then send that notification from do_close() and return true
// (1).
//
// The cef_life_span_handler_t::on_before_close() function will be called
// after do_close() (if do_close() is called) and immediately before the
// browser object is destroyed. The application should only exit after
// on_before_close() has been called for all existing browsers.
//
// The below examples describe what should happen during window close when the
// browser is parented to an application-provided top-level window.
//
// Example 1: Using cef_browser_host_t::try_close_browser(). This is
// recommended for clients using standard close handling and windows created
// on the browser process UI thread. 1.  User clicks the window close button
// which sends a close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
//     TryCloseBrowser() returns false so the client cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// CEF sends a close notification to the application&#39;s top-level window
//     (because DoClose() returned false by default).
// 7.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
//     allows the window close.
// 8.  Application&#39;s top-level window is destroyed. 9.  Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 10. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
//
// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
// implementing the do_close() callback. This is recommended for clients using
// non-standard close handling or windows that were not created on the browser
// process UI thread. 1.  User clicks the window close button which sends a
// close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and:
//     A. Calls CefBrowserHost::CloseBrowser(false).
//     B. Cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// Application&#39;s do_close() handler is called. Application will:
//     A. Set a flag to indicate that the next close attempt will be allowed.
//     B. Return false.
// 7.  CEF sends an close notification to the application&#39;s top-level window.
// 8.  Application&#39;s top-level window receives the close notification and
//     allows the window to close based on the flag from #6B.
// 9.  Application&#39;s top-level window is destroyed. 10. Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 11. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
///
//export cefingo_life_span_handler_do_close
func cefingo_life_span_handler_do_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3005:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.do_close_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goRet := f.DoClose(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3019: do_close: Noo!")
	}
	return cRet
}

///
// Called just before a browser is destroyed. Release all references to the
// browser object and do not attempt to execute any functions on the browser
// object (other than GetIdentifier or IsSame) after this callback returns.
// This callback will be the last notification that references |browser| on
// the UI thread. Any in-progress network requests associated with |browser|
// will be aborted when the browser is destroyed, and
// cef_resource_request_handler_t callbacks related to those requests may
// still arrive on the IO thread after this function is called. See do_close()
// documentation for additional usage information.
///
//export cefingo_life_span_handler_on_before_close
func cefingo_life_span_handler_on_before_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3043:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_close_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBeforeClose(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3056: on_before_close: Noo!")
	}

}

///
// Called when the loading state has changed. This callback will be executed
// twice -- once when loading is initiated either programmatically or by user
// action, and once when loading is terminated due to completion, cancellation
// of failure. It will be called before any calls to OnLoadStart and after all
// calls to OnLoadError and/or OnLoadEnd.
///
//export cefingo_load_handler_on_loading_state_change
func cefingo_load_handler_on_loading_state_change(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	isLoading C.int,
	canGoBack C.int,
	canGoForward C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3079:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_loading_state_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisLoading := (int)(isLoading)
		goTmpcanGoBack := (int)(canGoBack)
		goTmpcanGoForward := (int)(canGoForward)

		f.OnLoadingStateChange(goTmpself, goTmpbrowser, goTmpisLoading, goTmpcanGoBack, goTmpcanGoForward)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3095: on_loading_state_change: Noo!")
	}

}

///
// Called after a navigation has been committed and before the browser begins
// loading contents in the frame. The |frame| value will never be NULL -- call
// the is_main() function to check if this frame is the main frame.
// |transition_type| provides information about the source of the navigation
// and an accurate value is only available in the browser process. Multiple
// frames may be loading at the same time. Sub-frames may start or continue
// loading after the main frame load has ended. This function will not be
// called for same page navigations (fragments, history state, etc.) or for
// navigations that fail or are canceled before commit. For notification of
// overall browser load status use OnLoadingStateChange instead.
///
//export cefingo_load_handler_on_load_start
func cefingo_load_handler_on_load_start(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	transition_type C.cef_transition_type_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3122:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_start_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptransition_type := CTransitionTypeT(transition_type)

		f.OnLoadStart(goTmpself, goTmpbrowser, goTmpframe, goTmptransition_type)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T3138: on_load_start: Noo!")
	}

}

///
// Called when the browser is done loading a frame. The |frame| value will
// never be NULL -- call the is_main() function to check if this frame is the
// main frame. Multiple frames may be loading at the same time. Sub-frames may
// start or continue loading after the main frame load has ended. This
// function will not be called for same page navigations (fragments, history
// state, etc.) or for navigations that fail or are canceled before commit.
// For notification of overall browser load status use OnLoadingStateChange
// instead.
///
//export cefingo_load_handler_on_load_end
func cefingo_load_handler_on_load_end(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	httpStatusCode C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3163:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_end_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmphttpStatusCode := (int)(httpStatusCode)

		f.OnLoadEnd(goTmpself, goTmpbrowser, goTmpframe, goTmphttpStatusCode)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T3179: on_load_end: Noo!")
	}

}

///
// Called when a navigation fails or is canceled. This function may be called
// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
// after commit. |errorCode| is the error code number, |errorText| is the
// error text and |failedUrl| is the URL that failed to load. See
// net\base\net_error_list.h for complete descriptions of the error codes.
///
//export cefingo_load_handler_on_load_error
func cefingo_load_handler_on_load_error(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	errorCode C.cef_errorcode_t,
	errorText *C.cef_string_t,
	failedUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3203:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_error_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmperrorCode := CErrorcodeT(errorCode)
		goTmperrorText := string_from_cef_string(errorText)
		goTmpfailedUrl := string_from_cef_string(failedUrl)

		f.OnLoadError(goTmpself, goTmpbrowser, goTmpframe, goTmperrorCode, goTmperrorText, goTmpfailedUrl)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T3221: on_load_error: Noo!")
	}

}

///
// The list of available media sinks has changed or
// cef_media_router_t::NotifyCurrentSinks was called.
///
//export cefingo_media_observer_on_sinks
func cefingo_media_observer_on_sinks(
	self *C.cef_media_observer_t,
	sinksCount C.size_t,
	sinks **C.cef_media_sink_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3239:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_sinks_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		slice := (*[1 << 30](*C.cef_media_sink_t))(unsafe.Pointer(sinks))[:sinksCount:sinksCount]
		goTmpsinks := make([]*CMediaSinkT, sinksCount)
		for i, v := range slice {
			goTmpsinks[i] = newCMediaSinkT(v)
		}

		f.OnSinks(goTmpself, goTmpsinks)

	} else {
		Logf("T3250: on_sinks: Noo!")
	}

}

///
// The list of available media routes has changed or
// cef_media_router_t::NotifyCurrentRoutes was called.
///
//export cefingo_media_observer_on_routes
func cefingo_media_observer_on_routes(
	self *C.cef_media_observer_t,
	routesCount C.size_t,
	routes **C.cef_media_route_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3273:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_routes_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		slice := (*[1 << 30](*C.cef_media_route_t))(unsafe.Pointer(routes))[:routesCount:routesCount]
		goTmproutes := make([]*CMediaRouteT, routesCount)
		for i, v := range slice {
			goTmproutes[i] = newCMediaRouteT(v)
		}

		f.OnRoutes(goTmpself, goTmproutes)

	} else {
		Logf("T3284: on_routes: Noo!")
	}

}

///
// The connection state of |route| has changed.
///
//export cefingo_media_observer_on_route_state_changed
func cefingo_media_observer_on_route_state_changed(
	self *C.cef_media_observer_t,
	route *C.cef_media_route_t,
	state C.cef_media_route_connection_state_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3306:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_route_state_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		goTmproute := newCMediaRouteT(route)
		goTmpstate := CMediaRouteConnectionStateT(state)

		f.OnRouteStateChanged(goTmpself, goTmproute, goTmpstate)
		BaseRelease(goTmproute.p_media_route)

	} else {
		Logf("T3320: on_route_state_changed: Noo!")
	}

}

///
// A message was recieved over |route|. |message| is only valid for the scope
// of this callback and should be copied if necessary.
///
//export cefingo_media_observer_on_route_message_received
func cefingo_media_observer_on_route_message_received(
	self *C.cef_media_observer_t,
	route *C.cef_media_route_t,
	message C.VOIDP,
	message_size C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3339:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_route_message_received_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		goTmproute := newCMediaRouteT(route)
		goTmpmessage := unsafe.Pointer(message)
		goTmpmessage_size := (int64)(message_size)

		f.OnRouteMessageReceived(goTmpself, goTmproute, goTmpmessage, goTmpmessage_size)
		BaseRelease(goTmproute.p_media_route)

	} else {
		Logf("T3354: on_route_message_received: Noo!")
	}

}

///
// Called when |button| is pressed. Call cef_menu_button_t::show_menu() to
// show a popup menu at |screen_point|. When showing a custom popup such as a
// window keep a reference to |button_pressed_lock| until the popup is hidden
// to maintain the pressed button state.
///
//export cefingo_menu_button_delegate_on_menu_button_pressed
func cefingo_menu_button_delegate_on_menu_button_pressed(
	self *C.cef_menu_button_delegate_t,
	menu_button *C.cef_menu_button_t,
	screen_point *C.cef_point_t,
	button_pressed_lock *C.cef_menu_button_pressed_lock_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3375:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_menu_button_pressed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuButtonDelegateT(self)
		goTmpmenu_button := newCMenuButtonT(menu_button)
		goTmpscreen_point := (*CPointT)(screen_point)
		goTmpbutton_pressed_lock := newCMenuButtonPressedLockT(button_pressed_lock)

		f.OnMenuButtonPressed(goTmpself, goTmpmenu_button, goTmpscreen_point, goTmpbutton_pressed_lock)
		BaseRelease(goTmpmenu_button.p_menu_button)
		BaseRelease(goTmpbutton_pressed_lock.p_menu_button_pressed_lock)

	} else {
		Logf("T3391: on_menu_button_pressed: Noo!")
	}

}

///
// Called when |button| is pressed.
///
//export cefingo_menu_button_delegate_on_button_pressed
func cefingo_menu_button_delegate_on_button_pressed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3407:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_button_pressed_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonPressed(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.p_button)

	} else {
		Logf("T3420: on_button_pressed: Noo!")
	}

}

///
// Called when the state of |button| changes.
///
//export cefingo_menu_button_delegate_on_button_state_changed
func cefingo_menu_button_delegate_on_button_state_changed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3436:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_button_state_changed_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonStateChanged(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.p_button)

	} else {
		Logf("T3449: on_button_state_changed: Noo!")
	}

}

//export cefingo_menu_button_delegate_get_preferred_size
func cefingo_menu_button_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3462:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_preferred_size_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T3476: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_get_minimum_size
func cefingo_menu_button_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3489:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_minimum_size_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T3503: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_get_maximum_size
func cefingo_menu_button_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3516:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_maximum_size_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T3530: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_get_height_for_width
func cefingo_menu_button_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3544:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_height_for_width_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.p_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3559: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_on_parent_view_changed
func cefingo_menu_button_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3574:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_parent_view_changed_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpparent.p_view)

	} else {
		Logf("T3590: on_parent_view_changed: Noo!")
	}

}

//export cefingo_menu_button_delegate_on_child_view_changed
func cefingo_menu_button_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3605:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_child_view_changed_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpchild.p_view)

	} else {
		Logf("T3621: on_child_view_changed: Noo!")
	}

}

//export cefingo_menu_button_delegate_on_focus
func cefingo_menu_button_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3634:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_focus_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T3647: on_focus: Noo!")
	}

}

//export cefingo_menu_button_delegate_on_blur
func cefingo_menu_button_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3660:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_blur_handler[(*C.cef_menu_button_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T3673: on_blur: Noo!")
	}

}

///
// Perform the action associated with the specified |command_id| and optional
// |event_flags|.
///
//export cefingo_menu_model_delegate_execute_command
func cefingo_menu_model_delegate_execute_command(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3692:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.execute_command_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		f.ExecuteCommand(goTmpself, goTmpmenu_model, goTmpcommand_id, goTmpevent_flags)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T3707: execute_command: Noo!")
	}

}

///
// Called when the user moves the mouse outside the menu and over the owning
// window.
///
//export cefingo_menu_model_delegate_mouse_outside_menu
func cefingo_menu_model_delegate_mouse_outside_menu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	screen_point *C.cef_point_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3725:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.mouse_outside_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpscreen_point := (*CPointT)(screen_point)

		f.MouseOutsideMenu(goTmpself, goTmpmenu_model, goTmpscreen_point)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T3739: mouse_outside_menu: Noo!")
	}

}

///
// Called on unhandled open submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_open_submenu
func cefingo_menu_model_delegate_unhandled_open_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3757:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_open_submenu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledOpenSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T3771: unhandled_open_submenu: Noo!")
	}

}

///
// Called on unhandled close submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_close_submenu
func cefingo_menu_model_delegate_unhandled_close_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3789:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_close_submenu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledCloseSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T3803: unhandled_close_submenu: Noo!")
	}

}

///
// The menu is about to show.
///
//export cefingo_menu_model_delegate_menu_will_show
func cefingo_menu_model_delegate_menu_will_show(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3819:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_will_show_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuWillShow(goTmpself, goTmpmenu_model)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T3832: menu_will_show: Noo!")
	}

}

///
// The menu has closed.
///
//export cefingo_menu_model_delegate_menu_closed
func cefingo_menu_model_delegate_menu_closed(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3848:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_closed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuClosed(goTmpself, goTmpmenu_model)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T3861: menu_closed: Noo!")
	}

}

///
// Optionally modify a menu item label. Return true (1) if |label| was
// modified.
///
//export cefingo_menu_model_delegate_format_label
func cefingo_menu_model_delegate_format_label(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	label *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3879:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.format_label_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmplabel := string_from_cef_string(label)

		goRet, goTmplabelOut := f.FormatLabel(goTmpself, goTmpmenu_model, goTmplabel)
		BaseRelease(goTmpmenu_model.p_menu_model)
		set_cef_string(label, goTmplabelOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3894: format_label: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_preferred_size
func cefingo_panel_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3908:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_preferred_size_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T3922: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_minimum_size
func cefingo_panel_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3935:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_minimum_size_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T3949: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_maximum_size
func cefingo_panel_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3962:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_maximum_size_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T3976: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_height_for_width
func cefingo_panel_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3990:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_height_for_width_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.p_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4005: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_on_parent_view_changed
func cefingo_panel_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4020:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_parent_view_changed_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpparent.p_view)

	} else {
		Logf("T4036: on_parent_view_changed: Noo!")
	}

}

//export cefingo_panel_delegate_on_child_view_changed
func cefingo_panel_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4051:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_child_view_changed_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpchild.p_view)

	} else {
		Logf("T4067: on_child_view_changed: Noo!")
	}

}

//export cefingo_panel_delegate_on_focus
func cefingo_panel_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4080:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_focus_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T4093: on_focus: Noo!")
	}

}

//export cefingo_panel_delegate_on_blur
func cefingo_panel_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4106:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_blur_handler[(*C.cef_panel_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T4119: on_blur: Noo!")
	}

}

///
// Called when printing has started for the specified |browser|. This function
// will be called before the other OnPrint*() functions and irrespective of
// how printing was initiated (e.g. cef_browser_host_t::print(), JavaScript
// window.print() or PDF extension print button).
///
//export cefingo_print_handler_on_print_start
func cefingo_print_handler_on_print_start(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4138:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_start_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnPrintStart(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4151: on_print_start: Noo!")
	}

}

///
// Synchronize |settings| with client state. If |get_defaults| is true (1)
// then populate |settings| with the default print settings. Do not keep a
// reference to |settings| outside of this callback.
///
//export cefingo_print_handler_on_print_settings
func cefingo_print_handler_on_print_settings(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	settings *C.cef_print_settings_t,
	get_defaults C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4171:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_settings_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpsettings := newCPrintSettingsT(settings)
		goTmpget_defaults := (int)(get_defaults)

		f.OnPrintSettings(goTmpself, goTmpbrowser, goTmpsettings, goTmpget_defaults)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpsettings.p_print_settings)

	} else {
		Logf("T4187: on_print_settings: Noo!")
	}

}

///
// Show the print dialog. Execute |callback| once the dialog is dismissed.
// Return true (1) if the dialog will be displayed or false (0) to cancel the
// printing immediately.
///
//export cefingo_print_handler_on_print_dialog
func cefingo_print_handler_on_print_dialog(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	has_selection C.int,
	callback *C.cef_print_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4207:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_dialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmphas_selection := (int)(has_selection)
		goTmpcallback := newCPrintDialogCallbackT(callback)

		goRet := f.OnPrintDialog(goTmpself, goTmpbrowser, goTmphas_selection, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_print_dialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4224: on_print_dialog: Noo!")
	}
	return cRet
}

///
// Send the print job to the printer. Execute |callback| once the job is
// completed. Return true (1) if the job will proceed or false (0) to cancel
// the job immediately.
///
//export cefingo_print_handler_on_print_job
func cefingo_print_handler_on_print_job(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	document_name *C.cef_string_t,
	pdf_file_path *C.cef_string_t,
	callback *C.cef_print_job_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4245:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_job_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdocument_name := string_from_cef_string(document_name)
		goTmppdf_file_path := string_from_cef_string(pdf_file_path)
		goTmpcallback := newCPrintJobCallbackT(callback)

		goRet := f.OnPrintJob(goTmpself, goTmpbrowser, goTmpdocument_name, goTmppdf_file_path, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_print_job_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4263: on_print_job: Noo!")
	}
	return cRet
}

///
// Reset client state related to printing.
///
//export cefingo_print_handler_on_print_reset
func cefingo_print_handler_on_print_reset(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4279:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_reset_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnPrintReset(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4292: on_print_reset: Noo!")
	}

}

///
// Return the PDF paper size in device units. Used in combination with
// cef_browser_host_t::print_to_pdf().
///
//export cefingo_print_handler_get_pdf_paper_size
func cefingo_print_handler_get_pdf_paper_size(
	self *C.cef_print_handler_t,
	device_units_per_inch C.int,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4309:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.get_pdf_paper_size_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpdevice_units_per_inch := (int)(device_units_per_inch)

		goRet := f.GetPdfPaperSize(goTmpself, goTmpdevice_units_per_inch)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T4322: get_pdf_paper_size: Noo!")
	}
	return cRet
}

//export cefingo_render_handler_get_accessibility_handler
func cefingo_render_handler_get_accessibility_handler(self *C.cef_render_handler_t) (ch *C.cef_accessibility_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := render_handler_handlers.accessibility_handler[self]
	if handler == nil {
		Logf("T4337: get_accessibility_handler")
	} else {
		BaseAddRef(handler.p_accessibility_handler)
		ch = handler.p_accessibility_handler
	}
	return ch
}

///
// Called to retrieve the root window rectangle in screen coordinates. Return
// true (1) if the rectangle was provided. If this function returns false (0)
// the rectangle from GetViewRect will be used.
///
//export cefingo_render_handler_get_root_screen_rect
func cefingo_render_handler_get_root_screen_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4356:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_root_screen_rect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goRet, goTmprectOut := f.GetRootScreenRect(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)
		*rect = (C.cef_rect_t)(goTmprectOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4371: get_root_screen_rect: Noo!")
	}
	return cRet
}

///
// Called to retrieve the view rectangle which is relative to screen
// coordinates. This function must always provide a non-NULL rectangle.
///
//export cefingo_render_handler_get_view_rect
func cefingo_render_handler_get_view_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4389:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_view_rect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goTmprectOut := f.GetViewRect(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)
		*rect = (C.cef_rect_t)(goTmprectOut)

	} else {
		Logf("T4403: get_view_rect: Noo!")
	}

}

///
// Called to retrieve the translation from view coordinates to actual screen
// coordinates. Return true (1) if the screen coordinates were provided.
///
//export cefingo_render_handler_get_screen_point
func cefingo_render_handler_get_screen_point(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	viewX C.int,
	viewY C.int,
	screenX *C.int,
	screenY *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4424:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_point_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpviewX := (int)(viewX)
		goTmpviewY := (int)(viewY)

		goRet, goTmpscreenXOut, goTmpscreenYOut := f.GetScreenPoint(goTmpself, goTmpbrowser, goTmpviewX, goTmpviewY)
		BaseRelease(goTmpbrowser.p_browser)
		*screenX = (C.int)(goTmpscreenXOut)
		*screenY = (C.int)(goTmpscreenYOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4442: get_screen_point: Noo!")
	}
	return cRet
}

///
// Called to allow the client to fill in the CefScreenInfo object with
// appropriate values. Return true (1) if the |screen_info| structure has been
// modified.
//
// If the screen info rectangle is left NULL the rectangle from GetViewRect
// will be used. If the rectangle is still NULL or invalid popups may not be
// drawn correctly.
///
//export cefingo_render_handler_get_screen_info
func cefingo_render_handler_get_screen_info(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	screen_info *C.cef_screen_info_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4465:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_info_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpscreen_info := (*CScreenInfoT)(screen_info)

		goRet := f.GetScreenInfo(goTmpself, goTmpbrowser, goTmpscreen_info)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4480: get_screen_info: Noo!")
	}
	return cRet
}

///
// Called when the browser wants to show or hide the popup widget. The popup
// should be shown if |show| is true (1) and hidden if |show| is false (0).
///
//export cefingo_render_handler_on_popup_show
func cefingo_render_handler_on_popup_show(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	show C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4498:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_show_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpshow := (int)(show)

		f.OnPopupShow(goTmpself, goTmpbrowser, goTmpshow)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4512: on_popup_show: Noo!")
	}

}

///
// Called when the browser wants to move or resize the popup widget. |rect|
// contains the new location and size in view coordinates.
///
//export cefingo_render_handler_on_popup_size
func cefingo_render_handler_on_popup_size(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4530:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_size_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		f.OnPopupSize(goTmpself, goTmpbrowser, goTmprect)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4544: on_popup_size: Noo!")
	}

}

///
// Called when an element should be painted. Pixel values passed to this
// function are scaled relative to view coordinates based on the value of
// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
// indicates whether the element is the view or the popup widget. |buffer|
// contains the pixel data for the whole image. |dirtyRects| contains the set
// of rectangles in pixel coordinates that need to be repainted. |buffer| will
// be |width|*|height|*4 bytes in size and represents a BGRA image with an
// upper-left origin. This function is only called when
// cef_window_tInfo::shared_texture_enabled is set to false (0).
///
//export cefingo_render_handler_on_paint
func cefingo_render_handler_on_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	buffer C.VOIDP,
	width C.int,
	height C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4574:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_paint_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		goTmpbuffer := unsafe.Pointer(buffer)
		goTmpwidth := (int)(width)
		goTmpheight := (int)(height)

		f.OnPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRectsCount, goTmpdirtyRects, goTmpbuffer, goTmpwidth, goTmpheight)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4593: on_paint: Noo!")
	}

}

///
// Called when an element has been rendered to the shared texture handle.
// |type| indicates whether the element is the view or the popup widget.
// |dirtyRects| contains the set of rectangles in pixel coordinates that need
// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
// can be accessed via ID3D11Device using the OpenSharedResource function.
// This function is only called when cef_window_tInfo::shared_texture_enabled
// is set to true (1), and is currently only supported on Windows.
///
//export cefingo_render_handler_on_accelerated_paint
func cefingo_render_handler_on_accelerated_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	shared_handle C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4619:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_accelerated_paint_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		goTmpshared_handle := unsafe.Pointer(shared_handle)

		f.OnAcceleratedPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRectsCount, goTmpdirtyRects, goTmpshared_handle)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4636: on_accelerated_paint: Noo!")
	}

}

///
// Called when the browser&#39;s cursor has changed. If |type| is CT_CUSTOM then
// |custom_cursor_info| will be populated with the custom cursor information.
///
//export cefingo_render_handler_on_cursor_change
func cefingo_render_handler_on_cursor_change(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	cursor C.HCURSOR,
	ctype C.cef_cursor_type_t,
	custom_cursor_info *C.cef_cursor_info_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4656:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_cursor_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcursor := (CCursorHandleT)(cursor)
		goTmptype := CCursorTypeT(ctype)
		goTmpcustom_cursor_info := (*CCursorInfoT)(custom_cursor_info)

		f.OnCursorChange(goTmpself, goTmpbrowser, goTmpcursor, goTmptype, goTmpcustom_cursor_info)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4672: on_cursor_change: Noo!")
	}

}

///
// Called when the user starts dragging content in the web view. Contextual
// information about the dragged content is supplied by |drag_data|. (|x|,
// |y|) is the drag start location in screen coordinates. OS APIs that run a
// system message loop may be used within the StartDragging call.
//
// Return false (0) to abort the drag operation. Don&#39;t call any of
// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
//
// Return true (1) to handle the drag operation. Call
// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
// synchronously or asynchronously to inform the web view that the drag
// operation has ended.
///
//export cefingo_render_handler_start_dragging
func cefingo_render_handler_start_dragging(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	drag_data *C.cef_drag_data_t,
	allowed_ops C.cef_drag_operations_mask_t,
	x C.int,
	y C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4703:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.start_dragging_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdrag_data := newCDragDataT(drag_data)
		goTmpallowed_ops := CDragOperationsMaskT(allowed_ops)
		goTmpx := (int)(x)
		goTmpy := (int)(y)

		goRet := f.StartDragging(goTmpself, goTmpbrowser, goTmpdrag_data, goTmpallowed_ops, goTmpx, goTmpy)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdrag_data.p_drag_data)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4722: start_dragging: Noo!")
	}
	return cRet
}

///
// Called when the web view wants to update the mouse cursor during a drag &amp;
// drop operation. |operation| describes the allowed operation (none, move,
// copy, link).
///
//export cefingo_render_handler_update_drag_cursor
func cefingo_render_handler_update_drag_cursor(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	operation C.cef_drag_operations_mask_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4741:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.update_drag_cursor_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpoperation := CDragOperationsMaskT(operation)

		f.UpdateDragCursor(goTmpself, goTmpbrowser, goTmpoperation)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4755: update_drag_cursor: Noo!")
	}

}

///
// Called when the scroll offset has changed.
///
//export cefingo_render_handler_on_scroll_offset_changed
func cefingo_render_handler_on_scroll_offset_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	x C.double,
	y C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4773:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_scroll_offset_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpx := (float64)(x)
		goTmpy := (float64)(y)

		f.OnScrollOffsetChanged(goTmpself, goTmpbrowser, goTmpx, goTmpy)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4788: on_scroll_offset_changed: Noo!")
	}

}

///
// Called when the IME composition range has changed. |selected_range| is the
// range of characters that have been selected. |character_bounds| is the
// bounds of each character in view coordinates.
///
//export cefingo_render_handler_on_ime_composition_range_changed
func cefingo_render_handler_on_ime_composition_range_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_range *C.cef_range_t,
	character_boundsCount C.size_t,
	character_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4809:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_ime_composition_range_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_range := (*CRangeT)(selected_range)
		goTmpcharacter_boundsCount := (int64)(character_boundsCount)
		goTmpcharacter_bounds := (*CRectT)(character_bounds)

		f.OnImeCompositionRangeChanged(goTmpself, goTmpbrowser, goTmpselected_range, goTmpcharacter_boundsCount, goTmpcharacter_bounds)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4825: on_ime_composition_range_changed: Noo!")
	}

}

///
// Called when text selection has changed for the specified |browser|.
// |selected_text| is the currently selected text and |selected_range| is the
// character range.
///
//export cefingo_render_handler_on_text_selection_changed
func cefingo_render_handler_on_text_selection_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_text *C.cef_string_t,
	selected_range *C.cef_range_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4845:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_text_selection_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_text := string_from_cef_string(selected_text)
		goTmpselected_range := (*CRangeT)(selected_range)

		f.OnTextSelectionChanged(goTmpself, goTmpbrowser, goTmpselected_text, goTmpselected_range)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4860: on_text_selection_changed: Noo!")
	}

}

///
// Called when an on-screen keyboard should be shown or hidden for the
// specified |browser|. |input_mode| specifies what kind of keyboard should be
// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
// for this browser should be hidden.
///
//export cefingo_render_handler_on_virtual_keyboard_requested
func cefingo_render_handler_on_virtual_keyboard_requested(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	input_mode C.cef_text_input_mode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4880:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_virtual_keyboard_requested_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinput_mode := CTextInputModeT(input_mode)

		f.OnVirtualKeyboardRequested(goTmpself, goTmpbrowser, goTmpinput_mode)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4894: on_virtual_keyboard_requested: Noo!")
	}

}

//export cefingo_render_process_handler_get_load_handler
func cefingo_render_process_handler_get_load_handler(self *C.cef_render_process_handler_t) (ch *C.cef_load_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := render_process_handler_handlers.load_handler[self]
	if handler == nil {
		Logf("T4909: get_load_handler")
	} else {
		BaseAddRef(handler.p_load_handler)
		ch = handler.p_load_handler
	}
	return ch
}

///
// Called after the render process main thread has been created. |extra_info|
// is a read-only value originating from
// cef_browser_process_handler_t::on_render_process_thread_created(). Do not
// keep a reference to |extra_info| outside of this function.
///
//export cefingo_render_process_handler_on_render_thread_created
func cefingo_render_process_handler_on_render_thread_created(
	self *C.cef_render_process_handler_t,
	extra_info *C.cef_list_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4928:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_render_thread_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpextra_info := newCListValueT(extra_info)

		f.OnRenderThreadCreated(goTmpself, goTmpextra_info)
		BaseRelease(goTmpextra_info.p_list_value)

	} else {
		Logf("T4941: on_render_thread_created: Noo!")
	}

}

///
// Called after WebKit has been initialized.
///
//export cefingo_render_process_handler_on_web_kit_initialized
func cefingo_render_process_handler_on_web_kit_initialized(
	self *C.cef_render_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4956:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_web_kit_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)

		f.OnWebKitInitialized(goTmpself)

	} else {
		Logf("T4967: on_web_kit_initialized: Noo!")
	}

}

///
// Called after a browser has been created. When browsing cross-origin a new
// browser will be created before the old browser with the same identifier is
// destroyed. |extra_info| is a read-only value originating from
// cef_browser_host_t::cef_browser_host_create_browser(),
// cef_browser_host_t::cef_browser_host_create_browser_sync(),
// cef_life_span_handler_t::on_before_popup() or
// cef_browser_view_t::cef_browser_view_create().
///
//export cefingo_render_process_handler_on_browser_created
func cefingo_render_process_handler_on_browser_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	extra_info *C.cef_dictionary_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4990:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpextra_info := newCDictionaryValueT(extra_info)

		f.OnBrowserCreated(goTmpself, goTmpbrowser, goTmpextra_info)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpextra_info.p_dictionary_value)

	} else {
		Logf("T5005: on_browser_created: Noo!")
	}

}

///
// Called before a browser is destroyed.
///
//export cefingo_render_process_handler_on_browser_destroyed
func cefingo_render_process_handler_on_browser_destroyed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5021:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_destroyed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserDestroyed(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T5034: on_browser_destroyed: Noo!")
	}

}

///
// Called immediately after the V8 context for a frame has been created. To
// retrieve the JavaScript &#39;window&#39; object use the
// cef_v8context_t::get_global() function. V8 handles can only be accessed
// from the thread on which they are created. A task runner for posting tasks
// on the associated thread can be retrieved via the
// cef_v8context_t::get_task_runner() function.
///
//export cefingo_render_process_handler_on_context_created
func cefingo_render_process_handler_on_context_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5057:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextCreated(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)

	} else {
		Logf("T5074: on_context_created: Noo!")
	}

}

///
// Called immediately before the V8 context for a frame is released. No
// references to the context should be kept after this function is called.
///
//export cefingo_render_process_handler_on_context_released
func cefingo_render_process_handler_on_context_released(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5093:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_released_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextReleased(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)

	} else {
		Logf("T5110: on_context_released: Noo!")
	}

}

///
// Called for global uncaught exceptions in a frame. Execution of this
// callback is disabled by default. To enable set
// CefSettings.uncaught_exception_stack_size &gt; 0.
///
//export cefingo_render_process_handler_on_uncaught_exception
func cefingo_render_process_handler_on_uncaught_exception(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
	exception *C.cef_v8exception_t,
	stackTrace *C.cef_v8stack_trace_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5132:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_uncaught_exception_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)
		goTmpexception := newCV8exceptionT(exception)
		goTmpstackTrace := newCV8stackTraceT(stackTrace)

		f.OnUncaughtException(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext, goTmpexception, goTmpstackTrace)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)
		BaseRelease(goTmpexception.p_v8exception)
		BaseRelease(goTmpstackTrace.p_v8stack_trace)

	} else {
		Logf("T5153: on_uncaught_exception: Noo!")
	}

}

///
// Called when a new node in the the browser gets focus. The |node| value may
// be NULL if no specific node has gained focus. The node object passed to
// this function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_render_process_handler_on_focused_node_changed
func cefingo_render_process_handler_on_focused_node_changed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	node *C.cef_domnode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5176:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_focused_node_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpnode := newCDomnodeT(node)

		f.OnFocusedNodeChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpnode)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpnode.p_domnode)

	} else {
		Logf("T5193: on_focused_node_changed: Noo!")
	}

}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_render_process_handler_on_process_message_received
func cefingo_render_process_handler_on_process_message_received(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5214:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_process_message_received_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpmessage.p_process_message)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5233: on_process_message_received: Noo!")
	}
	return cRet
}

//export cefingo_request_context_handler_get_resource_request_handler
func cefingo_request_context_handler_get_resource_request_handler(self *C.cef_request_context_handler_t) (ch *C.cef_resource_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := request_context_handler_handlers.resource_request_handler[self]
	if handler == nil {
		Logf("T5248: get_resource_request_handler")
	} else {
		BaseAddRef(handler.p_resource_request_handler)
		ch = handler.p_resource_request_handler
	}
	return ch
}

///
// Called on the browser process UI thread immediately after the request
// context has been initialized.
///
//export cefingo_request_context_handler_on_request_context_initialized
func cefingo_request_context_handler_on_request_context_initialized(
	self *C.cef_request_context_handler_t,
	request_context *C.cef_request_context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5265:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_request_context_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmprequest_context := newCRequestContextT(request_context)

		f.OnRequestContextInitialized(goTmpself, goTmprequest_context)
		BaseRelease(goTmprequest_context.p_request_context)

	} else {
		Logf("T5278: on_request_context_initialized: Noo!")
	}

}

///
// Called on multiple browser process threads before a plugin instance is
// loaded. |mime_type| is the mime type of the plugin that will be loaded.
// |plugin_url| is the content URL that the plugin will load and may be NULL.
// |is_main_frame| will be true (1) if the plugin is being loaded in the main
// (top-level) frame, |top_origin_url| is the URL for the top-level frame that
// contains the plugin when loading a specific plugin instance or NULL when
// building the initial list of enabled plugins for &#39;navigator.plugins&#39;
// JavaScript state. |plugin_info| includes additional information about the
// plugin that will be loaded. |plugin_policy| is the recommended policy.
// Modify |plugin_policy| and return true (1) to change the policy. Return
// false (0) to use the recommended policy. The default plugin policy can be
// set at runtime using the `--plugin-policy=[allow|detect|block]` command-
// line flag. Decisions to mark a plugin as disabled by setting
// |plugin_policy| to PLUGIN_POLICY_DISABLED may be cached when
// |top_origin_url| is NULL. To purge the plugin list cache and potentially
// trigger new calls to this function call
// cef_request_context_t::PurgePluginListCache.
///
//export cefingo_request_context_handler_on_before_plugin_load
func cefingo_request_context_handler_on_before_plugin_load(
	self *C.cef_request_context_handler_t,
	mime_type *C.cef_string_t,
	plugin_url *C.cef_string_t,
	is_main_frame C.int,
	top_origin_url *C.cef_string_t,
	plugin_info *C.cef_web_plugin_info_t,
	plugin_policy *C.cef_plugin_policy_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5315:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_before_plugin_load_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmpmime_type := string_from_cef_string(mime_type)
		goTmpplugin_url := string_from_cef_string(plugin_url)
		goTmpis_main_frame := (int)(is_main_frame)
		goTmptop_origin_url := string_from_cef_string(top_origin_url)
		goTmpplugin_info := newCWebPluginInfoT(plugin_info)

		goRet, goTmpplugin_policyOut := f.OnBeforePluginLoad(goTmpself, goTmpmime_type, goTmpplugin_url, goTmpis_main_frame, goTmptop_origin_url, goTmpplugin_info)
		BaseRelease(goTmpplugin_info.p_web_plugin_info)
		*plugin_policy = (C.cef_plugin_policy_t)(goTmpplugin_policyOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5334: on_before_plugin_load: Noo!")
	}
	return cRet
}

//export cefingo_request_handler_get_resource_request_handler
func cefingo_request_handler_get_resource_request_handler(self *C.cef_request_handler_t) (ch *C.cef_resource_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := request_handler_handlers.resource_request_handler[self]
	if handler == nil {
		Logf("T5349: get_resource_request_handler")
	} else {
		BaseAddRef(handler.p_resource_request_handler)
		ch = handler.p_resource_request_handler
	}
	return ch
}

///
// Called on the UI thread before browser navigation. Return true (1) to
// cancel the navigation or false (0) to allow the navigation to proceed. The
// |request| object cannot be modified in this callback.
// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
// If the navigation is allowed cef_load_handler_t::OnLoadStart and
// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event).
///
//export cefingo_request_handler_on_before_browse
func cefingo_request_handler_on_before_browse(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	user_gesture C.int,
	is_redirect C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5378:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_before_browse_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpuser_gesture := (int)(user_gesture)
		goTmpis_redirect := (int)(is_redirect)

		goRet := f.OnBeforeBrowse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpuser_gesture, goTmpis_redirect)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5398: on_before_browse: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before OnBeforeBrowse in certain limited cases
// where navigating a new or different browser might be desirable. This
// includes user-initiated navigation that might open in a special way (e.g.
// links clicked via middle-click or ctrl + left-click) and certain types of
// cross-origin navigation initiated from the renderer process (e.g.
// navigating the top-level frame to/from a file URL). The |browser| and
// |frame| values represent the source of the navigation. The
// |target_disposition| value indicates where the user intended to navigate
// the browser based on standard Chromium behaviors (e.g. current tab, new
// tab, etc). The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event). Return
// true (1) to cancel the navigation or false (0) to allow the navigation to
// proceed in the source browser&#39;s top-level frame.
///
//export cefingo_request_handler_on_open_urlfrom_tab
func cefingo_request_handler_on_open_urlfrom_tab(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5431:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_open_urlfrom_tab_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := (int)(user_gesture)

		goRet := f.OnOpenUrlfromTab(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_disposition, goTmpuser_gesture)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5450: on_open_urlfrom_tab: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |origin_url| is the origin making this authentication request. |isProxy|
// indicates whether the host is a proxy server. |host| contains the hostname
// and |port| contains the port number. |realm| is the realm of the challenge
// and may be NULL. |scheme| is the authentication scheme used, such as
// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
// FTP server. Return true (1) to continue the request and call
// cef_auth_callback_t::cont() either in this function or at a later time when
// the authentication information is available. Return false (0) to cancel the
// request immediately.
///
//export cefingo_request_handler_get_auth_credentials
func cefingo_request_handler_get_auth_credentials(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5482:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.get_auth_credentials_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		goTmprealm := string_from_cef_string(realm)
		goTmpscheme := string_from_cef_string(scheme)
		goTmpcallback := newCAuthCallbackT(callback)

		goRet := f.GetAuthCredentials(goTmpself, goTmpbrowser, goTmporigin_url, goTmpisProxy, goTmphost, goTmpport, goTmprealm, goTmpscheme, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_auth_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5504: get_auth_credentials: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when JavaScript requests a specific storage quota
// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
// origin of the page making the request. |new_size| is the requested quota
// size in bytes. Return true (1) to continue the request and call
// cef_request_callback_t::cont() either in this function or at a later time
// to grant or deny the request. Return false (0) to cancel the request
// immediately.
///
//export cefingo_request_handler_on_quota_request
func cefingo_request_handler_on_quota_request(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	new_size C.int64,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5529:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_quota_request_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpnew_size := (int64)(new_size)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnQuotaRequest(goTmpself, goTmpbrowser, goTmporigin_url, goTmpnew_size, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_request_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5547: on_quota_request: Noo!")
	}
	return cRet
}

///
// Called on the UI thread to handle requests for URLs with an invalid SSL
// certificate. Return true (1) and call cef_request_callback_t::cont() either
// in this function or at a later time to continue or cancel the request.
// Return false (0) to cancel the request immediately. If
// CefSettings.ignore_certificate_errors is set all invalid certificates will
// be accepted without calling this function.
///
//export cefingo_request_handler_on_certificate_error
func cefingo_request_handler_on_certificate_error(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	cert_error C.cef_errorcode_t,
	request_url *C.cef_string_t,
	ssl_info *C.cef_sslinfo_t,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5572:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_certificate_error_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcert_error := CErrorcodeT(cert_error)
		goTmprequest_url := string_from_cef_string(request_url)
		goTmpssl_info := newCSslinfoT(ssl_info)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnCertificateError(goTmpself, goTmpbrowser, goTmpcert_error, goTmprequest_url, goTmpssl_info, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpssl_info.p_sslinfo)
		BaseRelease(goTmpcallback.p_request_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5592: on_certificate_error: Noo!")
	}
	return cRet
}

///
// Called on the UI thread when a client certificate is being requested for
// authentication. Return false (0) to use the default behavior and
// automatically select the first certificate available. Return true (1) and
// call cef_select_client_certificate_callback_t::Select either in this
// function or at a later time to select a certificate. Do not call Select or
// call it with NULL to continue without using any certificate. |isProxy|
// indicates whether the host is an HTTPS proxy or the origin server. |host|
// and |port| contains the hostname and port of the SSL server. |certificates|
// is the list of certificates to choose from; this list has already been
// pruned by Chromium so that it only contains certificates from issuers that
// the server trusts.
///
//export cefingo_request_handler_on_select_client_certificate
func cefingo_request_handler_on_select_client_certificate(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	certificatesCount C.size_t,
	certificates **C.cef_x509certificate_t,
	callback *C.cef_select_client_certificate_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5624:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_select_client_certificate_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		slice := (*[1 << 30](*C.cef_x509certificate_t))(unsafe.Pointer(certificates))[:certificatesCount:certificatesCount]
		goTmpcertificates := make([]*CX509certificateT, certificatesCount)
		for i, v := range slice {
			goTmpcertificates[i] = newCX509certificateT(v)
		}
		goTmpcallback := newCSelectClientCertificateCallbackT(callback)

		goRet := f.OnSelectClientCertificate(goTmpself, goTmpbrowser, goTmpisProxy, goTmphost, goTmpport, goTmpcertificates, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_select_client_certificate_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5643: on_select_client_certificate: Noo!")
	}
	return cRet
}

///
// Called on the browser process UI thread when a plugin has crashed.
// |plugin_path| is the path of the plugin that crashed.
///
//export cefingo_request_handler_on_plugin_crashed
func cefingo_request_handler_on_plugin_crashed(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	plugin_path *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5666:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_plugin_crashed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpplugin_path := string_from_cef_string(plugin_path)

		f.OnPluginCrashed(goTmpself, goTmpbrowser, goTmpplugin_path)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T5680: on_plugin_crashed: Noo!")
	}

}

///
// Called on the browser process UI thread when the render view associated
// with |browser| is ready to receive/handle IPC messages in the render
// process.
///
//export cefingo_request_handler_on_render_view_ready
func cefingo_request_handler_on_render_view_ready(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5698:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_view_ready_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnRenderViewReady(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T5711: on_render_view_ready: Noo!")
	}

}

///
// Called on the browser process UI thread when the render process terminates
// unexpectedly. |status| indicates how the process terminated.
///
//export cefingo_request_handler_on_render_process_terminated
func cefingo_request_handler_on_render_process_terminated(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	status C.cef_termination_status_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5729:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_process_terminated_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpstatus := CTerminationStatusT(status)

		f.OnRenderProcessTerminated(goTmpself, goTmpbrowser, goTmpstatus)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T5743: on_render_process_terminated: Noo!")
	}

}

///
// Called to retrieve a localized translation for the specified |string_id|.
// To provide the translation set |string| to the translation string and
// return true (1). To use the default translation return false (0). Include
// cef_pack_strings.h for a listing of valid string ID values.
///
//export cefingo_resource_bundle_handler_get_localized_string
func cefingo_resource_bundle_handler_get_localized_string(
	self *C.cef_resource_bundle_handler_t,
	string_id C.int,
	cstring *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5763:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_localized_string_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpstring_id := (int)(string_id)

		goRet, goTmpstringOut := f.GetLocalizedString(goTmpself, goTmpstring_id)
		set_cef_string(cstring, goTmpstringOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5777: get_localized_string: Noo!")
	}
	return cRet
}

///
// Called to retrieve data for the specified scale independent |resource_id|.
// To provide the resource data set |data| and |data_size| to the data pointer
// and size respectively and return true (1). To use the default resource data
// return false (0). The resource data will not be copied and must remain
// resident in memory. Include cef_pack_resources.h for a listing of valid
// resource ID values.
///
//export cefingo_resource_bundle_handler_get_data_resource
func cefingo_resource_bundle_handler_get_data_resource(
	self *C.cef_resource_bundle_handler_t,
	resource_id C.int,
	data *C.VOIDP,
	data_size *C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5800:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_data_resource_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpresource_id := (int)(resource_id)

		goRet, goTmpdataOut := f.GetDataResource(goTmpself, goTmpresource_id)
		*data_size = (C.size_t)(len(goTmpdataOut))
		*data = (C.VOIDP)(C.calloc(1, C.size_t(len(goTmpdataOut))))
		target := (*[1 << 30]byte)(unsafe.Pointer(*data))[:*data_size:*data_size]
		copy(target, goTmpdataOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5814: get_data_resource: Noo!")
	}
	return cRet
}

///
// Called to retrieve data for the specified |resource_id| nearest the scale
// factor |scale_factor|. To provide the resource data set |data| and
// |data_size| to the data pointer and size respectively and return true (1).
// To use the default resource data return false (0). The resource data will
// not be copied and must remain resident in memory. Include
// cef_pack_resources.h for a listing of valid resource ID values.
///
//export cefingo_resource_bundle_handler_get_data_resource_for_scale
func cefingo_resource_bundle_handler_get_data_resource_for_scale(
	self *C.cef_resource_bundle_handler_t,
	resource_id C.int,
	scale_factor C.cef_scale_factor_t,
	data *C.VOIDP,
	data_size *C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5841:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_data_resource_for_scale_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpresource_id := (int)(resource_id)
		goTmpscale_factor := CScaleFactorT(scale_factor)

		goRet, goTmpdataOut := f.GetDataResourceForScale(goTmpself, goTmpresource_id, goTmpscale_factor)
		*data_size = (C.size_t)(len(goTmpdataOut))
		*data = (C.VOIDP)(C.calloc(1, C.size_t(len(goTmpdataOut))))
		target := (*[1 << 30]byte)(unsafe.Pointer(*data))[:*data_size:*data_size]
		copy(target, goTmpdataOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5856: get_data_resource_for_scale: Noo!")
	}
	return cRet
}

///
// Open the response stream. To handle the request immediately set
// |handle_request| to true (1) and return true (1). To decide at a later time
// set |handle_request| to false (0), return true (1), and execute |callback|
// to continue or cancel the request. To cancel the request immediately set
// |handle_request| to true (1) and return false (0). This function will be
// called in sequence but not from a dedicated thread. For backwards
// compatibility set |handle_request| to false (0) and return false (0) and
// the ProcessRequest function will be called.
///
//export cefingo_resource_handler_open
func cefingo_resource_handler_open(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	handle_request *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5884:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.open_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCCallbackT(callback)

		goRet, goTmphandle_requestOut := f.Open(goTmpself, goTmprequest, goTmpcallback)
		BaseRelease(goTmprequest.p_request)
		*handle_request = (C.int)(goTmphandle_requestOut)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5901: open: Noo!")
	}
	return cRet
}

///
// Begin processing the request. To handle the request return true (1) and
// call cef_callback_t::cont() once the response header information is
// available (cef_callback_t::cont() can also be called from inside this
// function if header information is available immediately). To cancel the
// request return false (0).
//
// WARNING: This function is deprecated. Use Open instead.
///
//export cefingo_resource_handler_process_request
func cefingo_resource_handler_process_request(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5924:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.process_request_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCCallbackT(callback)

		goRet := f.ProcessRequest(goTmpself, goTmprequest, goTmpcallback)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T5940: process_request: Noo!")
	}
	return cRet
}

///
// Retrieve response header information. If the response length is not known
// set |response_length| to -1 and read_response() will be called until it
// returns false (0). If the response length is known set |response_length| to
// a positive value and read_response() will be called until it returns false
// (0) or the specified number of bytes have been read. Use the |response|
// object to set the mime type, http status code and other optional header
// values. To redirect the request to a new URL set |redirectUrl| to the new
// URL. |redirectUrl| can be either a relative or fully qualified URL. It is
// also possible to set |response| to a redirect http status code and pass the
// new URL via a Location header. Likewise with |redirectUrl| it is valid to
// set a relative or fully qualified URL as the Location header value. If an
// error occured while setting up the request you can call set_error() on
// |response| to indicate the error condition.
///
//export cefingo_resource_handler_get_response_headers
func cefingo_resource_handler_get_response_headers(
	self *C.cef_resource_handler_t,
	response *C.cef_response_t,
	response_length *C.int64,
	redirectUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T5970:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.get_response_headers_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpresponse := newCResponseT(response)

		goTmpresponse_lengthOut, goTmpredirectUrlOut := f.GetResponseHeaders(goTmpself, goTmpresponse)
		BaseRelease(goTmpresponse.p_response)
		*response_length = (C.int64)(goTmpresponse_lengthOut)
		set_cef_string(redirectUrl, goTmpredirectUrlOut)

	} else {
		Logf("T5985: get_response_headers: Noo!")
	}

}

///
// Skip response data when requested by a Range header. Skip over and discard
// |bytes_to_skip| bytes of response data. If data is available immediately
// set |bytes_skipped| to the number of bytes skipped and return true (1). To
// read the data at a later time set |bytes_skipped| to 0, return true (1) and
// execute |callback| when the data is available. To indicate failure set
// |bytes_skipped| to &lt; 0 (e.g. -2 for ERR_FAILED) and return false (0). This
// function will be called in sequence but not from a dedicated thread.
///
//export cefingo_resource_handler_skip
func cefingo_resource_handler_skip(
	self *C.cef_resource_handler_t,
	bytes_to_skip C.int64,
	bytes_skipped *C.int64,
	callback *C.cef_resource_skip_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6009:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.skip_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpbytes_to_skip := (int64)(bytes_to_skip)
		goTmpcallback := newCResourceSkipCallbackT(callback)

		goRet, goTmpbytes_skippedOut := f.Skip(goTmpself, goTmpbytes_to_skip, goTmpcallback)
		*bytes_skipped = (C.int64)(goTmpbytes_skippedOut)
		BaseRelease(goTmpcallback.p_resource_skip_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6025: skip: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time keep a
// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
// |callback| when the data is available (|data_out| will remain valid until
// the callback is executed). To indicate response completion set |bytes_read|
// to 0 and return false (0). To indicate failure set |bytes_read| to &lt; 0
// (e.g. -2 for ERR_FAILED) and return false (0). This function will be called
// in sequence but not from a dedicated thread. For backwards compatibility
// set |bytes_read| to -1 and return false (0) and the ReadResponse function
// will be called.
///
//export cefingo_resource_handler_read
func cefingo_resource_handler_read(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_resource_read_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6054:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		goTmpcallback := newCResourceReadCallbackT(callback)

		goRet, goTmpbytes_readOut := f.Read(goTmpself, goTmpdata_out, goTmpcallback)
		*bytes_read = (C.int)(goTmpbytes_readOut)
		BaseRelease(goTmpcallback.p_resource_read_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6071: read: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time set
// |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when the
// data is available. To indicate response completion return false (0).
//
// WARNING: This function is deprecated. Use Skip and Read instead.
///
//export cefingo_resource_handler_read_response
func cefingo_resource_handler_read_response(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6095:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_response_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		goTmpcallback := newCCallbackT(callback)

		goRet, goTmpbytes_readOut := f.ReadResponse(goTmpself, goTmpdata_out, goTmpcallback)
		*bytes_read = (C.int)(goTmpbytes_readOut)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6112: read_response: Noo!")
	}
	return cRet
}

///
// Request processing has been canceled.
///
//export cefingo_resource_handler_cancel
func cefingo_resource_handler_cancel(
	self *C.cef_resource_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6126:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.cancel_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)

		f.Cancel(goTmpself)

	} else {
		Logf("T6137: cancel: Noo!")
	}

}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To
// optionally filter cookies for the request return a
// cef_cookie_access_filter_t object. The |request| object cannot not be
// modified in this callback.
///
//export cefingo_resource_request_handler_get_cookie_access_filter
func cefingo_resource_request_handler_get_cookie_access_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_cookie_access_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6160:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_cookie_access_filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goRet := f.GetCookieAccessFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		cRet = (*C.cef_cookie_access_filter_t)(goRet.p_cookie_access_filter)
		BaseAddRef(cRet)
	} else {
		Logf("T6178: get_cookie_access_filter: Noo!")
	}
	return cRet
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To redirect
// or change the resource load optionally modify |request|. Modification of
// the request URL will be treated as a redirect. Return RV_CONTINUE to
// continue the request immediately. Return RV_CONTINUE_ASYNC and call
// cef_request_callback_t:: cont() at a later time to continue or cancel the
// request asynchronously. Return RV_CANCEL to cancel the request immediately.
//
///
//export cefingo_resource_request_handler_on_before_resource_load
func cefingo_resource_request_handler_on_before_resource_load(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	callback *C.cef_request_callback_t,
) (cRet C.cef_return_value_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6206:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_before_resource_load_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnBeforeResourceLoad(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpcallback.p_request_callback)

		cRet = (C.cef_return_value_t)(goRet)
	} else {
		Logf("T6226: on_before_resource_load: Noo!")
	}
	return cRet
}

///
// Called on the IO thread before a resource is loaded. The |browser| and
// |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource to load using the default network loader return NULL. To specify a
// handler for the resource return a cef_resource_handler_t object. The
// |request| object cannot not be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_handler
func cefingo_resource_request_handler_get_resource_handler(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6249:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_handler_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goRet := f.GetResourceHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		cRet = (*C.cef_resource_handler_t)(goRet.p_resource_handler)
		BaseAddRef(cRet)
	} else {
		Logf("T6267: get_resource_handler: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when a resource load is redirected. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. The
// |request| parameter will contain the old URL and other request-related
// information. The |response| parameter will contain the response that
// resulted in the redirect. The |new_url| parameter will contain the new URL
// and can be changed if desired. The |request| and |response| objects cannot
// be modified in this callback.
///
//export cefingo_resource_request_handler_on_resource_redirect
func cefingo_resource_request_handler_on_resource_redirect(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	new_url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6295:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_redirect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goTmpnew_urlOut := f.OnResourceRedirect(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)
		set_cef_string(new_url, goTmpnew_urlOut)

	} else {
		Logf("T6315: on_resource_redirect: Noo!")
	}

}

///
// Called on the IO thread when a resource response is received. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource load to proceed without modification return false (0). To redirect
// or retry the resource load optionally modify |request| and return true (1).
// Modification of the request URL will be treated as a redirect. Requests
// handled using the default network loader cannot be redirected in this
// callback. The |response| object cannot be modified in this callback.
//
// WARNING: Redirecting using this function is deprecated. Use
// OnBeforeResourceLoad or GetResourceHandler to perform redirects.
///
//export cefingo_resource_request_handler_on_resource_response
func cefingo_resource_request_handler_on_resource_response(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6344:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_response_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goRet := f.OnResourceResponse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6364: on_resource_response: Noo!")
	}
	return cRet
}

///
// Called on the IO thread to optionally filter resource response content. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| and |response| represent the request and response respectively
// and cannot be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_response_filter
func cefingo_resource_request_handler_get_resource_response_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet *C.cef_response_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6387:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_response_filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goRet := f.GetResourceResponseFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)

		cRet = (*C.cef_response_filter_t)(goRet.p_response_filter)
		BaseAddRef(cRet)
	} else {
		Logf("T6407: get_resource_response_filter: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when a resource load has completed. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// and |response| represent the request and response respectively and cannot
// be modified in this callback. |status| indicates the load completion
// status. |received_content_length| is the number of response bytes actually
// read. This function will be called for all requests, including requests
// that are aborted due to CEF shutdown or destruction of the associated
// browser. In cases where the associated browser is destroyed this callback
// may arrive after the cef_life_span_handler_t::OnBeforeClose callback for
// that browser. The cef_frame_t::IsValid function can be used to test for
// this situation, and care should be taken not to call |browser| or |frame|
// functions that modify state (like LoadURL, SendProcessMessage, etc.) if the
// frame is invalid.
///
//export cefingo_resource_request_handler_on_resource_load_complete
func cefingo_resource_request_handler_on_resource_load_complete(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	status C.cef_urlrequest_status_t,
	received_content_length C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6442:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_load_complete_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)
		goTmpstatus := CUrlrequestStatusT(status)
		goTmpreceived_content_length := (int64)(received_content_length)

		f.OnResourceLoadComplete(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse, goTmpstatus, goTmpreceived_content_length)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)

	} else {
		Logf("T6463: on_resource_load_complete: Noo!")
	}

}

///
// Called on the IO thread to handle requests for URLs with an unknown
// protocol component. The |browser| and |frame| values represent the source
// of the request, and may be NULL for requests originating from service
// workers or cef_urlrequest_t. |request| cannot be modified in this callback.
// Set |allow_os_execution| to true (1) to attempt execution via the
// registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD USE
// THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL
// ANALYSIS BEFORE ALLOWING OS EXECUTION.
///
//export cefingo_resource_request_handler_on_protocol_execution
func cefingo_resource_request_handler_on_protocol_execution(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	allow_os_execution *C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6489:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_protocol_execution_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goTmpallow_os_executionOut := f.OnProtocolExecution(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		*allow_os_execution = (C.int)(goTmpallow_os_executionOut)

	} else {
		Logf("T6507: on_protocol_execution: Noo!")
	}

}

///
// Called on the IO thread before a resource request is sent. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// cannot be modified in this callback. Return true (1) if the specified
// cookie can be sent with the request or false (0) otherwise.
///
//export cefingo_cookie_access_filter_can_send_cookie
func cefingo_cookie_access_filter_can_send_cookie(
	self *C.cef_cookie_access_filter_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	cookie *C.cef_cookie_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6530:")
	cefingoIfaceAccess.Lock()
	f := cookie_access_filter_handlers.can_send_cookie_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCCookieAccessFilterT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpcookie := (*CCookieT)(cookie)

		goRet := f.CanSendCookie(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpcookie)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6549: can_send_cookie: Noo!")
	}
	return cRet
}

///
// Called on the IO thread after a resource response is received. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| cannot be modified in this callback. Return true (1) if the
// specified cookie returned with the response can be saved or false (0)
// otherwise.
///
//export cefingo_cookie_access_filter_can_save_cookie
func cefingo_cookie_access_filter_can_save_cookie(
	self *C.cef_cookie_access_filter_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	cookie *C.cef_cookie_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6574:")
	cefingoIfaceAccess.Lock()
	f := cookie_access_filter_handlers.can_save_cookie_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCCookieAccessFilterT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)
		goTmpcookie := (*CCookieT)(cookie)

		goRet := f.CanSaveCookie(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse, goTmpcookie)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6595: can_save_cookie: Noo!")
	}
	return cRet
}

///
// Initialize the response filter. Will only be called a single time. The
// filter will not be installed if this function returns false (0).
///
//export cefingo_response_filter_init_filter
func cefingo_response_filter_init_filter(
	self *C.cef_response_filter_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6611:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.init_filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResponseFilterT(self)

		goRet := f.InitFilter(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6623: init_filter: Noo!")
	}
	return cRet
}

///
// Called to filter a chunk of data. Expected usage is as follows:
//
//  A. Read input data from |data_in| and set |data_in_read| to the number of
//     bytes that were read up to a maximum of |data_in_size|. |data_in| will
//     be NULL if |data_in_size| is zero.
//  B. Write filtered output data to |data_out| and set |data_out_written| to
//     the number of bytes that were written up to a maximum of
//     |data_out_size|. If no output data was written then all data must be
//     read from |data_in| (user must set |data_in_read| = |data_in_size|).
//  C. Return RESPONSE_FILTER_DONE if all output data was written or
//     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
//
// This function will be called repeatedly until the input buffer has been
// fully read (user sets |data_in_read| = |data_in_size|) and there is no more
// input data to filter (the resource response is complete). This function may
// then be called an additional time with an NULL input buffer if the user
// filled the output buffer (set |data_out_written| = |data_out_size|) and
// returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is
// still pending.
//
// Calls to this function will stop when one of the following conditions is
// met:
//
//  A. There is no more input data to filter (the resource response is
//     complete) and the user sets |data_out_written| = 0 or returns
//     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
//  B. The user returns RESPONSE_FILTER_ERROR to indicate an error.
//
// Do not keep a reference to the buffers passed to this function.
///
//export cefingo_response_filter_filter
func cefingo_response_filter_filter(
	self *C.cef_response_filter_t,
	data_in C.VOIDP,
	data_in_size C.size_t,
	data_in_read *C.size_t,
	data_out C.VOIDP,
	data_out_size C.size_t,
	data_out_written *C.size_t,
) (cRet C.cef_response_filter_status_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6672:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResponseFilterT(self)
		goTmpdata_in := (*[1 << 30]byte)(data_in)[:data_in_size:data_in_size]
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:data_out_size:data_out_size]

		goRet, goTmpdata_in_readOut, goTmpdata_out_writtenOut := f.Filter(goTmpself, goTmpdata_in, goTmpdata_out)
		*data_in_read = (C.size_t)(goTmpdata_in_readOut)
		*data_out_written = (C.size_t)(goTmpdata_out_writtenOut)

		cRet = (C.cef_response_filter_status_t)(goRet)
	} else {
		Logf("T6690: filter: Noo!")
	}
	return cRet
}

///
// Return a new resource handler instance to handle the request or an NULL
// reference to allow default handling of the request. |browser| and |frame|
// will be the browser window and frame respectively that originated the
// request or NULL if the request did not originate from a browser window (for
// example, if the request came from cef_urlrequest_t). The |request| object
// passed to this function cannot be modified.
///
//export cefingo_scheme_handler_factory_create
func cefingo_scheme_handler_factory_create(
	self *C.cef_scheme_handler_factory_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	scheme_name *C.cef_string_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6712:")
	cefingoIfaceAccess.Lock()
	f := scheme_handler_factory_handlers.create_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCSchemeHandlerFactoryT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpscheme_name := string_from_cef_string(scheme_name)
		goTmprequest := newCRequestT(request)

		goRet := f.Create(goTmpself, goTmpbrowser, goTmpframe, goTmpscheme_name, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		cRet = (*C.cef_resource_handler_t)(goRet.p_resource_handler)
		BaseAddRef(cRet)
	} else {
		Logf("T6731: create: Noo!")
	}
	return cRet
}

///
// Read raw binary data.
///
//export cefingo_read_handler_read
func cefingo_read_handler_read(
	self *C.cef_read_handler_t,
	ptr C.VOIDP,
	size C.size_t,
	n C.size_t,
) (cRet C.size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6750:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.read_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)
		goTmpptr := unsafe.Pointer(ptr)
		goTmpsize := (int64)(size)
		goTmpn := (int64)(n)

		goRet := f.Read(goTmpself, goTmpptr, goTmpsize, goTmpn)

		cRet = (C.size_t)(goRet)
	} else {
		Logf("T6765: read: Noo!")
	}
	return cRet
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
//export cefingo_read_handler_seek
func cefingo_read_handler_seek(
	self *C.cef_read_handler_t,
	offset C.int64,
	whence C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6783:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.seek_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)
		goTmpoffset := (int64)(offset)
		goTmpwhence := (int)(whence)

		goRet := f.Seek(goTmpself, goTmpoffset, goTmpwhence)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6797: seek: Noo!")
	}
	return cRet
}

///
// Return the current offset position.
///
//export cefingo_read_handler_tell
func cefingo_read_handler_tell(
	self *C.cef_read_handler_t,
) (cRet C.int64) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6812:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.tell_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)

		goRet := f.Tell(goTmpself)

		cRet = (C.int64)(goRet)
	} else {
		Logf("T6824: tell: Noo!")
	}
	return cRet
}

///
// Return non-zero if at end of file.
///
//export cefingo_read_handler_eof
func cefingo_read_handler_eof(
	self *C.cef_read_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6839:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.eof_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)

		goRet := f.Eof(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6851: eof: Noo!")
	}
	return cRet
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
//export cefingo_read_handler_may_block
func cefingo_read_handler_may_block(
	self *C.cef_read_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6868:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.may_block_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)

		goRet := f.MayBlock(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6880: may_block: Noo!")
	}
	return cRet
}

///
// Write raw binary data.
///
//export cefingo_write_handler_write
func cefingo_write_handler_write(
	self *C.cef_write_handler_t,
	ptr C.VOIDP,
	size C.size_t,
	n C.size_t,
) (cRet C.size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6898:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.write_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)
		goTmpptr := unsafe.Pointer(ptr)
		goTmpsize := (int64)(size)
		goTmpn := (int64)(n)

		goRet := f.Write(goTmpself, goTmpptr, goTmpsize, goTmpn)

		cRet = (C.size_t)(goRet)
	} else {
		Logf("T6913: write: Noo!")
	}
	return cRet
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
//export cefingo_write_handler_seek
func cefingo_write_handler_seek(
	self *C.cef_write_handler_t,
	offset C.int64,
	whence C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6931:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.seek_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)
		goTmpoffset := (int64)(offset)
		goTmpwhence := (int)(whence)

		goRet := f.Seek(goTmpself, goTmpoffset, goTmpwhence)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6945: seek: Noo!")
	}
	return cRet
}

///
// Return the current offset position.
///
//export cefingo_write_handler_tell
func cefingo_write_handler_tell(
	self *C.cef_write_handler_t,
) (cRet C.int64) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6960:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.tell_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)

		goRet := f.Tell(goTmpself)

		cRet = (C.int64)(goRet)
	} else {
		Logf("T6972: tell: Noo!")
	}
	return cRet
}

///
// Flush the stream.
///
//export cefingo_write_handler_flush
func cefingo_write_handler_flush(
	self *C.cef_write_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T6987:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.flush_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)

		goRet := f.Flush(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T6999: flush: Noo!")
	}
	return cRet
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
//export cefingo_write_handler_may_block
func cefingo_write_handler_may_block(
	self *C.cef_write_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7016:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.may_block_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)

		goRet := f.MayBlock(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7028: may_block: Noo!")
	}
	return cRet
}

///
// Method that will be executed.
///
//export cefingo_string_visitor_visit
func cefingo_string_visitor_visit(
	self *C.cef_string_visitor_t,
	cstring *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7044:")
	cefingoIfaceAccess.Lock()
	f := string_visitor_handlers.visit_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCStringVisitorT(self)
		goTmpstring := string_from_cef_string(cstring)

		f.Visit(goTmpself, goTmpstring)

	} else {
		Logf("T7056: visit: Noo!")
	}

}

///
// Method that will be executed on the target thread.
///
//export cefingo_task_execute
func cefingo_task_execute(
	self *C.cef_task_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7071:")
	cefingoIfaceAccess.Lock()
	f := task_handlers.execute_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCTaskT(self)

		f.Execute(goTmpself)

	} else {
		Logf("T7082: execute: Noo!")
	}

}

///
// Called when |textfield| recieves a keyboard event. |event| contains
// information about the keyboard event. Return true (1) if the keyboard event
// was handled or false (0) otherwise for default handling.
///
//export cefingo_textfield_delegate_on_key_event
func cefingo_textfield_delegate_on_key_event(
	self *C.cef_textfield_delegate_t,
	textfield *C.cef_textfield_t,
	event *C.cef_key_event_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7101:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCTextfieldDelegateT(self)
		goTmptextfield := newCTextfieldT(textfield)
		goTmpevent := (*CKeyEventT)(event)

		goRet := f.OnKeyEvent(goTmpself, goTmptextfield, goTmpevent)
		BaseRelease(goTmptextfield.p_textfield)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7116: on_key_event: Noo!")
	}
	return cRet
}

///
// Called after performing a user action that may change |textfield|.
///
//export cefingo_textfield_delegate_on_after_user_action
func cefingo_textfield_delegate_on_after_user_action(
	self *C.cef_textfield_delegate_t,
	textfield *C.cef_textfield_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7132:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_after_user_action_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCTextfieldDelegateT(self)
		goTmptextfield := newCTextfieldT(textfield)

		f.OnAfterUserAction(goTmpself, goTmptextfield)
		BaseRelease(goTmptextfield.p_textfield)

	} else {
		Logf("T7145: on_after_user_action: Noo!")
	}

}

//export cefingo_textfield_delegate_get_preferred_size
func cefingo_textfield_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7158:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_preferred_size_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T7172: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_get_minimum_size
func cefingo_textfield_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7185:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_minimum_size_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T7199: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_get_maximum_size
func cefingo_textfield_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7212:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_maximum_size_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T7226: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_get_height_for_width
func cefingo_textfield_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7240:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_height_for_width_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.p_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7255: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_on_parent_view_changed
func cefingo_textfield_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7270:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_parent_view_changed_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpparent.p_view)

	} else {
		Logf("T7286: on_parent_view_changed: Noo!")
	}

}

//export cefingo_textfield_delegate_on_child_view_changed
func cefingo_textfield_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7301:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_child_view_changed_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpchild.p_view)

	} else {
		Logf("T7317: on_child_view_changed: Noo!")
	}

}

//export cefingo_textfield_delegate_on_focus
func cefingo_textfield_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7330:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_focus_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T7343: on_focus: Noo!")
	}

}

//export cefingo_textfield_delegate_on_blur
func cefingo_textfield_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7356:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_blur_handler[(*C.cef_textfield_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T7369: on_blur: Noo!")
	}

}

///
// Notifies the client that the request has completed. Use the
// cef_urlrequest_t::GetRequestStatus function to determine if the request was
// successful or not.
///
//export cefingo_urlrequest_client_on_request_complete
func cefingo_urlrequest_client_on_request_complete(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7387:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_request_complete_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)

		f.OnRequestComplete(goTmpself, goTmprequest)
		BaseRelease(goTmprequest.p_urlrequest)

	} else {
		Logf("T7400: on_request_complete: Noo!")
	}

}

///
// Notifies the client of upload progress. |current| denotes the number of
// bytes sent so far and |total| is the total size of uploading data (or -1 if
// chunked upload is enabled). This function will only be called if the
// UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request.
///
//export cefingo_urlrequest_client_on_upload_progress
func cefingo_urlrequest_client_on_upload_progress(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	current C.int64,
	total C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7421:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_upload_progress_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)
		goTmpcurrent := (int64)(current)
		goTmptotal := (int64)(total)

		f.OnUploadProgress(goTmpself, goTmprequest, goTmpcurrent, goTmptotal)
		BaseRelease(goTmprequest.p_urlrequest)

	} else {
		Logf("T7436: on_upload_progress: Noo!")
	}

}

///
// Notifies the client of download progress. |current| denotes the number of
// bytes received up to the call and |total| is the expected total size of the
// response (or -1 if not determined).
///
//export cefingo_urlrequest_client_on_download_progress
func cefingo_urlrequest_client_on_download_progress(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	current C.int64,
	total C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7456:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_download_progress_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)
		goTmpcurrent := (int64)(current)
		goTmptotal := (int64)(total)

		f.OnDownloadProgress(goTmpself, goTmprequest, goTmpcurrent, goTmptotal)
		BaseRelease(goTmprequest.p_urlrequest)

	} else {
		Logf("T7471: on_download_progress: Noo!")
	}

}

///
// Called when some part of the response is read. |data| contains the current
// bytes received since the last call. This function will not be called if the
// UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request.
///
//export cefingo_urlrequest_client_on_download_data
func cefingo_urlrequest_client_on_download_data(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	data C.VOIDP,
	data_length C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7491:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_download_data_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)
		goTmpdata := unsafe.Pointer(data)
		goTmpdata_length := (int64)(data_length)

		f.OnDownloadData(goTmpself, goTmprequest, goTmpdata, goTmpdata_length)
		BaseRelease(goTmprequest.p_urlrequest)

	} else {
		Logf("T7506: on_download_data: Noo!")
	}

}

///
// Called on the IO thread when the browser needs credentials from the user.
// |isProxy| indicates whether the host is a proxy server. |host| contains the
// hostname and |port| contains the port number. Return true (1) to continue
// the request and call cef_auth_callback_t::cont() when the authentication
// information is available. If the request has an associated browser/frame
// then returning false (0) will result in a call to GetAuthCredentials on the
// cef_request_handler_t associated with that browser, if any. Otherwise,
// returning false (0) will cancel the request immediately. This function will
// only be called for requests initiated from the browser process.
///
//export cefingo_urlrequest_client_get_auth_credentials
func cefingo_urlrequest_client_get_auth_credentials(
	self *C.cef_urlrequest_client_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7535:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.get_auth_credentials_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		goTmprealm := string_from_cef_string(realm)
		goTmpscheme := string_from_cef_string(scheme)
		goTmpcallback := newCAuthCallbackT(callback)

		goRet := f.GetAuthCredentials(goTmpself, goTmpisProxy, goTmphost, goTmpport, goTmprealm, goTmpscheme, goTmpcallback)
		BaseRelease(goTmpcallback.p_auth_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7554: get_auth_credentials: Noo!")
	}
	return cRet
}

///
// Handle execution of the function identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the function. |arguments| is the list of
// arguments passed to the function. If execution succeeds set |retval| to the
// function return value. If execution fails set |exception| to the exception
// that will be thrown. Return true (1) if execution was handled.
///
//export cefingo_v8handler_execute
func cefingo_v8handler_execute(
	self *C.cef_v8handler_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	argumentsCount C.size_t,
	arguments **C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7579:")
	cefingoIfaceAccess.Lock()
	f := v8handler_handlers.execute_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8handlerT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)
		slice := (*[1 << 30](*C.cef_v8value_t))(unsafe.Pointer(arguments))[:argumentsCount:argumentsCount]
		goTmparguments := make([]*CV8valueT, argumentsCount)
		for i, v := range slice {
			goTmparguments[i] = newCV8valueT(v)
		}

		goRet, goTmpretvalOut, goTmpexceptionOut := f.Execute(goTmpself, goTmpname, goTmpobject, goTmparguments)
		BaseRelease(goTmpobject.p_v8value)
		if goTmpretvalOut != nil {
			*retval = goTmpretvalOut.p_v8value
			BaseAddRef(*retval)
		}
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7599: execute: Noo!")
	}
	return cRet
}

///
// Handle retrieval the accessor value identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the accessor. If retrieval succeeds set
// |retval| to the return value. If retrieval fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor retrieval was
// handled.
///
//export cefingo_v8accessor_get
func cefingo_v8accessor_get(
	self *C.cef_v8accessor_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7627:")
	cefingoIfaceAccess.Lock()
	f := v8accessor_handlers.get_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8accessorT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)

		goRet, goTmpretvalOut, goTmpexceptionOut := f.Get(goTmpself, goTmpname, goTmpobject)
		BaseRelease(goTmpobject.p_v8value)
		if goTmpretvalOut != nil {
			*retval = goTmpretvalOut.p_v8value
			BaseAddRef(*retval)
		}
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7647: get: Noo!")
	}
	return cRet
}

///
// Handle assignment of the accessor value identified by |name|. |object| is
// the receiver (&#39;this&#39; object) of the accessor. |value| is the new value
// being assigned to the accessor. If assignment fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor assignment was
// handled.
///
//export cefingo_v8accessor_set
func cefingo_v8accessor_set(
	self *C.cef_v8accessor_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	value *C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7670:")
	cefingoIfaceAccess.Lock()
	f := v8accessor_handlers.set_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8accessorT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)
		goTmpvalue := newCV8valueT(value)

		goRet, goTmpexceptionOut := f.Set(goTmpself, goTmpname, goTmpobject, goTmpvalue)
		BaseRelease(goTmpobject.p_v8value)
		BaseRelease(goTmpvalue.p_v8value)
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7688: set: Noo!")
	}
	return cRet
}

///
// Called to release |buffer| when the ArrayBuffer JS object is garbage
// collected. |buffer| is the value that was passed to CreateArrayBuffer along
// with this object.
///
//export cefingo_v8array_buffer_release_callback_release_buffer
func cefingo_v8array_buffer_release_callback_release_buffer(
	self *C.cef_v8array_buffer_release_callback_t,
	buffer C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7706:")
	cefingoIfaceAccess.Lock()
	f := v8array_buffer_release_callback_handlers.release_buffer_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8arrayBufferReleaseCallbackT(self)
		goTmpbuffer := unsafe.Pointer(buffer)

		f.ReleaseBuffer(goTmpself, goTmpbuffer)

	} else {
		Logf("T7718: release_buffer: Noo!")
	}

}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
//export cefingo_view_delegate_get_preferred_size
func cefingo_view_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7735:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_preferred_size_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T7749: get_preferred_size: Noo!")
	}
	return cRet
}

///
// Return the minimum size for |view|.
///
//export cefingo_view_delegate_get_minimum_size
func cefingo_view_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7765:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_minimum_size_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T7779: get_minimum_size: Noo!")
	}
	return cRet
}

///
// Return the maximum size for |view|.
///
//export cefingo_view_delegate_get_maximum_size
func cefingo_view_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7795:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_maximum_size_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T7809: get_maximum_size: Noo!")
	}
	return cRet
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
//export cefingo_view_delegate_get_height_for_width
func cefingo_view_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7829:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_height_for_width_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.p_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T7844: get_height_for_width: Noo!")
	}
	return cRet
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
//export cefingo_view_delegate_on_parent_view_changed
func cefingo_view_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7866:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_parent_view_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpparent.p_view)

	} else {
		Logf("T7882: on_parent_view_changed: Noo!")
	}

}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
//export cefingo_view_delegate_on_child_view_changed
func cefingo_view_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7905:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_child_view_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpchild.p_view)

	} else {
		Logf("T7921: on_child_view_changed: Noo!")
	}

}

///
// Called when |view| gains focus.
///
//export cefingo_view_delegate_on_focus
func cefingo_view_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7937:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T7950: on_focus: Noo!")
	}

}

///
// Called when |view| loses focus.
///
//export cefingo_view_delegate_on_blur
func cefingo_view_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T7966:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_blur_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T7979: on_blur: Noo!")
	}

}

///
// Method that will be called once for each plugin. |count| is the 0-based
// index for the current plugin. |total| is the total number of plugins.
// Return false (0) to stop visiting plugins. This function may never be
// called if no plugins are found.
///
//export cefingo_web_plugin_info_visitor_visit
func cefingo_web_plugin_info_visitor_visit(
	self *C.cef_web_plugin_info_visitor_t,
	info *C.cef_web_plugin_info_t,
	count C.int,
	total C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8000:")
	cefingoIfaceAccess.Lock()
	f := web_plugin_info_visitor_handlers.visit_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWebPluginInfoVisitorT(self)
		goTmpinfo := newCWebPluginInfoT(info)
		goTmpcount := (int)(count)
		goTmptotal := (int)(total)

		goRet := f.Visit(goTmpself, goTmpinfo, goTmpcount, goTmptotal)
		BaseRelease(goTmpinfo.p_web_plugin_info)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8016: visit: Noo!")
	}
	return cRet
}

///
// Method that will be called for the requested plugin. |unstable| will be
// true (1) if the plugin has reached the crash count threshold of 3 times in
// 120 seconds.
///
//export cefingo_web_plugin_unstable_callback_is_unstable
func cefingo_web_plugin_unstable_callback_is_unstable(
	self *C.cef_web_plugin_unstable_callback_t,
	path *C.cef_string_t,
	unstable C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8035:")
	cefingoIfaceAccess.Lock()
	f := web_plugin_unstable_callback_handlers.is_unstable_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWebPluginUnstableCallbackT(self)
		goTmppath := string_from_cef_string(path)
		goTmpunstable := (int)(unstable)

		f.IsUnstable(goTmpself, goTmppath, goTmpunstable)

	} else {
		Logf("T8048: is_unstable: Noo!")
	}

}

///
// Method that will be called when CDM registration is complete. |result| will
// be CEF_CDM_REGISTRATION_ERROR_NONE if registration completed successfully.
// Otherwise, |result| and |error_message| will contain additional information
// about why registration failed.
///
//export cefingo_register_cdm_callback_on_cdm_registration_complete
func cefingo_register_cdm_callback_on_cdm_registration_complete(
	self *C.cef_register_cdm_callback_t,
	result C.cef_cdm_registration_error_t,
	error_message *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8068:")
	cefingoIfaceAccess.Lock()
	f := register_cdm_callback_handlers.on_cdm_registration_complete_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRegisterCdmCallbackT(self)
		goTmpresult := CCdmRegistrationErrorT(result)
		goTmperror_message := string_from_cef_string(error_message)

		f.OnCdmRegistrationComplete(goTmpself, goTmpresult, goTmperror_message)

	} else {
		Logf("T8081: on_cdm_registration_complete: Noo!")
	}

}

///
// Called when |window| is created.
///
//export cefingo_window_delegate_on_window_created
func cefingo_window_delegate_on_window_created(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8097:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_window_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		f.OnWindowCreated(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)

	} else {
		Logf("T8110: on_window_created: Noo!")
	}

}

///
// Called when |window| is destroyed. Release all references to |window| and
// do not attempt to execute any functions on |window| after this callback
// returns.
///
//export cefingo_window_delegate_on_window_destroyed
func cefingo_window_delegate_on_window_destroyed(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8128:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_window_destroyed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		f.OnWindowDestroyed(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)

	} else {
		Logf("T8141: on_window_destroyed: Noo!")
	}

}

///
// Return the parent for |window| or NULL if the |window| does not have a
// parent. Windows with parents will not get a taskbar button. Set |is_menu|
// to true (1) if |window| will be displayed as a menu, in which case it will
// not be clipped to the parent window bounds. Set |can_activate_menu| to
// false (0) if |is_menu| is true (1) and |window| should not be activated
// (given keyboard focus) when displayed.
///
//export cefingo_window_delegate_get_parent_window
func cefingo_window_delegate_get_parent_window(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	is_menu *C.int,
	can_activate_menu *C.int,
) (cRet *C.cef_window_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8164:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_parent_window_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet, goTmpis_menuOut, goTmpcan_activate_menuOut := f.GetParentWindow(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)
		*is_menu = 0
		if goTmpis_menuOut {
			*is_menu = 1
		}
		*can_activate_menu = 0
		if goTmpcan_activate_menuOut {
			*can_activate_menu = 1
		}

		cRet = (*C.cef_window_t)(goRet.p_window)
		BaseAddRef(cRet)
	} else {
		Logf("T8178: get_parent_window: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| should be created without a frame or title bar.
// The window will be resizable if can_resize() returns true (1). Use
// cef_window_t::set_draggable_regions() to specify draggable regions.
///
//export cefingo_window_delegate_is_frameless
func cefingo_window_delegate_is_frameless(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8205:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.is_frameless_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.IsFrameless(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8219: is_frameless: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be resized.
///
//export cefingo_window_delegate_can_resize
func cefingo_window_delegate_can_resize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8235:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_resize_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanResize(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8249: can_resize: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be maximized.
///
//export cefingo_window_delegate_can_maximize
func cefingo_window_delegate_can_maximize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8265:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_maximize_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanMaximize(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8279: can_maximize: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be minimized.
///
//export cefingo_window_delegate_can_minimize
func cefingo_window_delegate_can_minimize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8295:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_minimize_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanMinimize(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8309: can_minimize: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be closed. This will be called for user-
// initiated window close actions and when cef_window_t::close() is called.
///
//export cefingo_window_delegate_can_close
func cefingo_window_delegate_can_close(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8326:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_close_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanClose(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.p_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8340: can_close: Noo!")
	}
	return cRet
}

///
// Called when a keyboard accelerator registered with
// cef_window_t::SetAccelerator is triggered. Return true (1) if the
// accelerator was handled or false (0) otherwise.
///
//export cefingo_window_delegate_on_accelerator
func cefingo_window_delegate_on_accelerator(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	command_id C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8359:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_accelerator_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)
		goTmpcommand_id := (int)(command_id)

		goRet := f.OnAccelerator(goTmpself, goTmpwindow, goTmpcommand_id)
		BaseRelease(goTmpwindow.p_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8374: on_accelerator: Noo!")
	}
	return cRet
}

///
// Called after all other controls in the window have had a chance to handle
// the event. |event| contains information about the keyboard event. Return
// true (1) if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_window_delegate_on_key_event
func cefingo_window_delegate_on_key_event(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	event *C.cef_key_event_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8393:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)
		goTmpevent := (*CKeyEventT)(event)

		goRet := f.OnKeyEvent(goTmpself, goTmpwindow, goTmpevent)
		BaseRelease(goTmpwindow.p_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8408: on_key_event: Noo!")
	}
	return cRet
}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
//export cefingo_window_delegate_get_preferred_size
func cefingo_window_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8425:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_preferred_size_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T8439: get_preferred_size: Noo!")
	}
	return cRet
}

///
// Return the minimum size for |view|.
///
//export cefingo_window_delegate_get_minimum_size
func cefingo_window_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8455:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_minimum_size_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T8469: get_minimum_size: Noo!")
	}
	return cRet
}

///
// Return the maximum size for |view|.
///
//export cefingo_window_delegate_get_maximum_size
func cefingo_window_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8485:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_maximum_size_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T8499: get_maximum_size: Noo!")
	}
	return cRet
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
//export cefingo_window_delegate_get_height_for_width
func cefingo_window_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8519:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_height_for_width_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.p_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T8534: get_height_for_width: Noo!")
	}
	return cRet
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
//export cefingo_window_delegate_on_parent_view_changed
func cefingo_window_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8556:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_parent_view_changed_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpparent.p_view)

	} else {
		Logf("T8572: on_parent_view_changed: Noo!")
	}

}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
//export cefingo_window_delegate_on_child_view_changed
func cefingo_window_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8595:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_child_view_changed_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.p_view)
		BaseRelease(goTmpchild.p_view)

	} else {
		Logf("T8611: on_child_view_changed: Noo!")
	}

}

///
// Called when |view| gains focus.
///
//export cefingo_window_delegate_on_focus
func cefingo_window_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8627:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_focus_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T8640: on_focus: Noo!")
	}

}

///
// Called when |view| loses focus.
///
//export cefingo_window_delegate_on_blur
func cefingo_window_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T8656:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_blur_handler[(*C.cef_window_delegate_t)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.p_view)

	} else {
		Logf("T8669: on_blur: Noo!")
	}

}
