
// Code generated by "gen-cefingo.go" DO NOT EDIT.
package capi

import (
	"runtime"
	"unsafe"
)
// #include "cefingo.h"
import "C"

///
// Called after renderer process sends accessibility tree changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_tree_change
func cefingo_accessibility_handler_on_accessibility_tree_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T21:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_tree_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityTreeChange(goTmpself,goTmpvalue,)
		BaseRelease(goTmpvalue.p_value)

	} else {
		Logf("T34: on_accessibility_tree_change: Noo!")
	}
	
}

///
// Called after renderer process sends accessibility location changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_location_change
func cefingo_accessibility_handler_on_accessibility_location_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T51:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_location_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityLocationChange(goTmpself,goTmpvalue,)
		BaseRelease(goTmpvalue.p_value)

	} else {
		Logf("T64: on_accessibility_location_change: Noo!")
	}
	
}

//export cefingo_app_get_resource_bundle_handler
func cefingo_app_get_resource_bundle_handler(self *C.cef_app_t) (ch *C.cef_resource_bundle_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.resource_bundle_handler[self]
	if handler == nil {
		Logf("T79: get_resource_bundle_handler")
	} else {
		BaseAddRef(handler.p_resource_bundle_handler)
		ch = handler.p_resource_bundle_handler
	}
	return ch
}

//export cefingo_app_get_browser_process_handler
func cefingo_app_get_browser_process_handler(self *C.cef_app_t) (ch *C.cef_browser_process_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.browser_process_handler[self]
	if handler == nil {
		Logf("T94: get_browser_process_handler")
	} else {
		BaseAddRef(handler.p_browser_process_handler)
		ch = handler.p_browser_process_handler
	}
	return ch
}

//export cefingo_app_get_render_process_handler
func cefingo_app_get_render_process_handler(self *C.cef_app_t) (ch *C.cef_render_process_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.render_process_handler[self]
	if handler == nil {
		Logf("T109: get_render_process_handler")
	} else {
		BaseAddRef(handler.p_render_process_handler)
		ch = handler.p_render_process_handler
	}
	return ch
}

///
// Provides an opportunity to view and/or modify command-line arguments before
// processing by CEF and Chromium. The |process_type| value will be NULL for
// the browser process. Do not keep a reference to the cef_command_line_t
// object passed to this function. The CefSettings.command_line_args_disabled
// value can be used to start with an NULL command-line object. Any values
// specified in CefSettings that equate to command-line arguments will be set
// before this function is called. Be cautious when using this function to
// modify command-line arguments for non-browser processes as this may result
// in undefined behavior including crashes.
///
//export cefingo_app_on_before_command_line_processing
func cefingo_app_on_before_command_line_processing(
	self *C.cef_app_t,
	process_type *C.cef_string_t,
	command_line *C.cef_command_line_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T134:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_before_command_line_processing_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpprocess_type := string_from_cef_string(process_type)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeCommandLineProcessing(goTmpself,goTmpprocess_type,goTmpcommand_line,)
		BaseRelease(goTmpcommand_line.p_command_line)

	} else {
		Logf("T148: on_before_command_line_processing: Noo!")
	}
	
}

///
// Provides an opportunity to register custom schemes. Do not keep a reference
// to the |registrar| object. This function is called on the main thread for
// each process and the registered schemes should be the same across all
// processes.
///
//export cefingo_app_on_register_custom_schemes
func cefingo_app_on_register_custom_schemes(
	self *C.cef_app_t,
	registrar *C.cef_scheme_registrar_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_register_custom_schemes_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpregistrar := newCSchemeRegistrarT(registrar)

		f.OnRegisterCustomSchemes(goTmpself,goTmpregistrar,)

	} else {
		Logf("T179: on_register_custom_schemes: Noo!")
	}
	
}

///
// Called when the stream identified by |audio_stream_id| has started.
// |audio_stream_id| will uniquely identify the stream across all future
// cef_audio_handler_t callbacks. OnAudioSteamStopped will always be called
// after OnAudioStreamStarted; both functions may be called multiple times for
// the same stream. |channels| is the number of channels, |channel_layout| is
// the layout of the channels and |sample_rate| is the stream sample rate.
// |frames_per_buffer| is the maximum number of frames that will occur in the
// PCM packet passed to OnAudioStreamPacket.
///
//export cefingo_audio_handler_on_audio_stream_started
func cefingo_audio_handler_on_audio_stream_started(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	audio_stream_id C.int,
	channels C.int,
	channel_layout C.cef_channel_layout_t,
	sample_rate C.int,
	frames_per_buffer C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T207:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_started_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAudioHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpaudio_stream_id := (int)(audio_stream_id)
		goTmpchannels := (int)(channels)
		goTmpchannel_layout := CChannelLayoutT(channel_layout)
		goTmpsample_rate := (int)(sample_rate)
		goTmpframes_per_buffer := (int)(frames_per_buffer)

		f.OnAudioStreamStarted(goTmpself,goTmpbrowser,goTmpaudio_stream_id,goTmpchannels,goTmpchannel_layout,goTmpsample_rate,goTmpframes_per_buffer,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T225: on_audio_stream_started: Noo!")
	}
	
}

///
// Called when the stream identified by |audio_stream_id| has stopped.
// OnAudioSteamStopped will always be called after OnAudioStreamStarted; both
// functions may be called multiple times for the same stream.
///
//export cefingo_audio_handler_on_audio_stream_stopped
func cefingo_audio_handler_on_audio_stream_stopped(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	audio_stream_id C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T244:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_stopped_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAudioHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpaudio_stream_id := (int)(audio_stream_id)

		f.OnAudioStreamStopped(goTmpself,goTmpbrowser,goTmpaudio_stream_id,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T258: on_audio_stream_stopped: Noo!")
	}
	
}

///
// Called asynchronously after the file dialog is dismissed.
// |selected_accept_filter| is the 0-based index of the value selected from
// the accept filters array passed to cef_browser_host_t::RunFileDialog.
// |file_paths| will be a single value or a list of values depending on the
// dialog mode. If the selection was cancelled |file_paths| will be NULL.
///
//export cefingo_run_file_dialog_callback_on_file_dialog_dismissed
func cefingo_run_file_dialog_callback_on_file_dialog_dismissed(
	self *C.cef_run_file_dialog_callback_t,
	selected_accept_filter C.int,
	file_paths C.cef_string_list_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T279:")
	cefingoIfaceAccess.Lock()
	f := run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRunFileDialogCallbackT(self)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpfile_paths := (CStringListT)(file_paths)

		f.OnFileDialogDismissed(goTmpself,goTmpselected_accept_filter,goTmpfile_paths,)

	} else {
		Logf("T292: on_file_dialog_dismissed: Noo!")
	}
	
}

//export cefingo_browser_process_handler_get_print_handler
func cefingo_browser_process_handler_get_print_handler(self *C.cef_browser_process_handler_t) (ch *C.cef_print_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := browser_process_handler_handlers.print_handler[self]
	if handler == nil {
		Logf("T307: get_print_handler")
	} else {
		BaseAddRef(handler.p_print_handler)
		ch = handler.p_print_handler
	}
	return ch
}

///
// Called on the browser process UI thread immediately after the CEF context
// has been initialized.
///
//export cefingo_browser_process_handler_on_context_initialized
func cefingo_browser_process_handler_on_context_initialized(
	self *C.cef_browser_process_handler_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T323:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_context_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)

		f.OnContextInitialized(goTmpself,)

	} else {
		Logf("T334: on_context_initialized: Noo!")
	}
	
}

///
// Called before a child process is launched. Will be called on the browser
// process UI thread when launching a render process and on the browser
// process IO thread when launching a GPU or plugin process. Provides an
// opportunity to modify the child process command line. Do not keep a
// reference to |command_line| outside of this function.
///
//export cefingo_browser_process_handler_on_before_child_process_launch
func cefingo_browser_process_handler_on_before_child_process_launch(
	self *C.cef_browser_process_handler_t,
	command_line *C.cef_command_line_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T354:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_before_child_process_launch_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeChildProcessLaunch(goTmpself,goTmpcommand_line,)
		BaseRelease(goTmpcommand_line.p_command_line)

	} else {
		Logf("T367: on_before_child_process_launch: Noo!")
	}
	
}

///
// Called on the browser process IO thread after the main thread has been
// created for a new render process. Provides an opportunity to specify extra
// information that will be passed to
// cef_render_process_handler_t::on_render_thread_created() in the render
// process. Do not keep a reference to |extra_info| outside of this function.
///
//export cefingo_browser_process_handler_on_render_process_thread_created
func cefingo_browser_process_handler_on_render_process_thread_created(
	self *C.cef_browser_process_handler_t,
	extra_info *C.cef_list_value_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T387:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_render_process_thread_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpextra_info := newCListValueT(extra_info)

		f.OnRenderProcessThreadCreated(goTmpself,goTmpextra_info,)
		BaseRelease(goTmpextra_info.p_list_value)

	} else {
		Logf("T400: on_render_process_thread_created: Noo!")
	}
	
}

///
// Called from any thread when work has been scheduled for the browser process
// main (UI) thread. This callback is used in combination with CefSettings.
// external_message_pump and cef_do_message_loop_work() in cases where the CEF
// message loop must be integrated into an existing application message loop
// (see additional comments and warnings on CefDoMessageLoopWork). This
// callback should schedule a cef_do_message_loop_work() call to happen on the
// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
// |delay_ms| is &lt;= 0 then the call should happen reasonably soon. If
// |delay_ms| is &gt; 0 then the call should be scheduled to happen after the
// specified delay and any currently pending scheduled call should be
// cancelled.
///
//export cefingo_browser_process_handler_on_schedule_message_pump_work
func cefingo_browser_process_handler_on_schedule_message_pump_work(
	self *C.cef_browser_process_handler_t,
	delay_ms C.int64,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T426:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_schedule_message_pump_work_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpdelay_ms := (int64)(delay_ms)

		f.OnScheduleMessagePumpWork(goTmpself,goTmpdelay_ms,)

	} else {
		Logf("T438: on_schedule_message_pump_work: Noo!")
	}
	
}

//export cefingo_client_get_audio_handler
func cefingo_client_get_audio_handler(self *C.cef_client_t) (ch *C.cef_audio_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.audio_handler[self]
	if handler == nil {
		Logf("T453: get_audio_handler")
	} else {
		BaseAddRef(handler.p_audio_handler)
		ch = handler.p_audio_handler
	}
	return ch
}

//export cefingo_client_get_context_menu_handler
func cefingo_client_get_context_menu_handler(self *C.cef_client_t) (ch *C.cef_context_menu_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.context_menu_handler[self]
	if handler == nil {
		Logf("T468: get_context_menu_handler")
	} else {
		BaseAddRef(handler.p_context_menu_handler)
		ch = handler.p_context_menu_handler
	}
	return ch
}

//export cefingo_client_get_dialog_handler
func cefingo_client_get_dialog_handler(self *C.cef_client_t) (ch *C.cef_dialog_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.dialog_handler[self]
	if handler == nil {
		Logf("T483: get_dialog_handler")
	} else {
		BaseAddRef(handler.p_dialog_handler)
		ch = handler.p_dialog_handler
	}
	return ch
}

//export cefingo_client_get_display_handler
func cefingo_client_get_display_handler(self *C.cef_client_t) (ch *C.cef_display_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.display_handler[self]
	if handler == nil {
		Logf("T498: get_display_handler")
	} else {
		BaseAddRef(handler.p_display_handler)
		ch = handler.p_display_handler
	}
	return ch
}

//export cefingo_client_get_download_handler
func cefingo_client_get_download_handler(self *C.cef_client_t) (ch *C.cef_download_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.download_handler[self]
	if handler == nil {
		Logf("T513: get_download_handler")
	} else {
		BaseAddRef(handler.p_download_handler)
		ch = handler.p_download_handler
	}
	return ch
}

//export cefingo_client_get_drag_handler
func cefingo_client_get_drag_handler(self *C.cef_client_t) (ch *C.cef_drag_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.drag_handler[self]
	if handler == nil {
		Logf("T528: get_drag_handler")
	} else {
		BaseAddRef(handler.p_drag_handler)
		ch = handler.p_drag_handler
	}
	return ch
}

//export cefingo_client_get_find_handler
func cefingo_client_get_find_handler(self *C.cef_client_t) (ch *C.cef_find_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.find_handler[self]
	if handler == nil {
		Logf("T543: get_find_handler")
	} else {
		BaseAddRef(handler.p_find_handler)
		ch = handler.p_find_handler
	}
	return ch
}

//export cefingo_client_get_focus_handler
func cefingo_client_get_focus_handler(self *C.cef_client_t) (ch *C.cef_focus_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.focus_handler[self]
	if handler == nil {
		Logf("T558: get_focus_handler")
	} else {
		BaseAddRef(handler.p_focus_handler)
		ch = handler.p_focus_handler
	}
	return ch
}

//export cefingo_client_get_jsdialog_handler
func cefingo_client_get_jsdialog_handler(self *C.cef_client_t) (ch *C.cef_jsdialog_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.jsdialog_handler[self]
	if handler == nil {
		Logf("T573: get_jsdialog_handler")
	} else {
		BaseAddRef(handler.p_jsdialog_handler)
		ch = handler.p_jsdialog_handler
	}
	return ch
}

//export cefingo_client_get_keyboard_handler
func cefingo_client_get_keyboard_handler(self *C.cef_client_t) (ch *C.cef_keyboard_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.keyboard_handler[self]
	if handler == nil {
		Logf("T588: get_keyboard_handler")
	} else {
		BaseAddRef(handler.p_keyboard_handler)
		ch = handler.p_keyboard_handler
	}
	return ch
}

//export cefingo_client_get_life_span_handler
func cefingo_client_get_life_span_handler(self *C.cef_client_t) (ch *C.cef_life_span_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.life_span_handler[self]
	if handler == nil {
		Logf("T603: get_life_span_handler")
	} else {
		BaseAddRef(handler.p_life_span_handler)
		ch = handler.p_life_span_handler
	}
	return ch
}

//export cefingo_client_get_load_handler
func cefingo_client_get_load_handler(self *C.cef_client_t) (ch *C.cef_load_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.load_handler[self]
	if handler == nil {
		Logf("T618: get_load_handler")
	} else {
		BaseAddRef(handler.p_load_handler)
		ch = handler.p_load_handler
	}
	return ch
}

//export cefingo_client_get_render_handler
func cefingo_client_get_render_handler(self *C.cef_client_t) (ch *C.cef_render_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.render_handler[self]
	if handler == nil {
		Logf("T633: get_render_handler")
	} else {
		BaseAddRef(handler.p_render_handler)
		ch = handler.p_render_handler
	}
	return ch
}

//export cefingo_client_get_request_handler
func cefingo_client_get_request_handler(self *C.cef_client_t) (ch *C.cef_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.request_handler[self]
	if handler == nil {
		Logf("T648: get_request_handler")
	} else {
		BaseAddRef(handler.p_request_handler)
		ch = handler.p_request_handler
	}
	return ch
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_client_on_process_message_received
func cefingo_client_on_process_message_received(
	self *C.cef_client_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T669:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.on_process_message_received_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself,goTmpbrowser,goTmpframe,goTmpsource_process,goTmpmessage,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpmessage.p_process_message)

		if goRet {cRet = 1}
	} else {
		Logf("T688: on_process_message_received: Noo!")
	}
	return cRet
}

///
// Called before a context menu is displayed. |params| provides information
// about the context menu state. |model| initially contains the default
// context menu. The |model| can be cleared to show no context menu or
// modified to show a custom menu. Do not keep references to |params| or
// |model| outside of this callback.
///
//export cefingo_context_menu_handler_on_before_context_menu
func cefingo_context_menu_handler_on_before_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T711:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_before_context_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)

		f.OnBeforeContextMenu(goTmpself,goTmpbrowser,goTmpframe,goTmpparams,goTmpmodel,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)
		BaseRelease(goTmpmodel.p_menu_model)

	} else {
		Logf("T730: on_before_context_menu: Noo!")
	}
	
}

///
// Called to allow custom display of the context menu. |params| provides
// information about the context menu state. |model| contains the context menu
// model resulting from OnBeforeContextMenu. For custom display return true
// (1) and execute |callback| either synchronously or asynchronously with the
// selected command ID. For default display return false (0). Do not keep
// references to |params| or |model| outside of this callback.
///
//export cefingo_context_menu_handler_run_context_menu
func cefingo_context_menu_handler_run_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
	callback *C.cef_run_context_menu_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T755:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.run_context_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)
		goTmpcallback := newCRunContextMenuCallbackT(callback)

		goRet := f.RunContextMenu(goTmpself,goTmpbrowser,goTmpframe,goTmpparams,goTmpmodel,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)
		BaseRelease(goTmpmodel.p_menu_model)
		BaseRelease(goTmpcallback.p_run_context_menu_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T777: run_context_menu: Noo!")
	}
	return cRet
}

///
// Called to execute a command selected from the context menu. Return true (1)
// if the command was handled or false (0) for the default implementation. See
// cef_menu_id_t for the command ids that have default implementations. All
// user-defined command ids should be between MENU_ID_USER_FIRST and
// MENU_ID_USER_LAST. |params| will have the same values as what was passed to
// on_before_context_menu(). Do not keep a reference to |params| outside of
// this callback.
///
//export cefingo_context_menu_handler_on_context_menu_command
func cefingo_context_menu_handler_on_context_menu_command(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T803:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_command_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		goRet := f.OnContextMenuCommand(goTmpself,goTmpbrowser,goTmpframe,goTmpparams,goTmpcommand_id,goTmpevent_flags,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)

		if goRet {cRet = 1}
	} else {
		Logf("T823: on_context_menu_command: Noo!")
	}
	return cRet
}

///
// Called when the context menu is dismissed irregardless of whether the menu
// was NULL or a command was selected.
///
//export cefingo_context_menu_handler_on_context_menu_dismissed
func cefingo_context_menu_handler_on_context_menu_dismissed(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T841:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_dismissed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)

		f.OnContextMenuDismissed(goTmpself,goTmpbrowser,goTmpframe,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T856: on_context_menu_dismissed: Noo!")
	}
	
}

///
// Called to run a file chooser dialog. |mode| represents the type of dialog
// to display. |title| to the title to be used for the dialog and may be NULL
// to show the default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode).
// |default_file_path| is the path with optional directory and/or file name
// component that should be initially selected in the dialog. |accept_filters|
// are used to restrict the selectable file types and may any combination of
// (a) valid lower-cased MIME types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b)
// individual file extensions (e.g. &quot;.txt&quot; or &quot;.png&quot;), or (c) combined
// description and file extension delimited using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image
// Types|.png;.gif;.jpg&quot;). |selected_accept_filter| is the 0-based index of
// the filter that should be selected by default. To display a custom dialog
// return true (1) and execute |callback| either inline or at a later time. To
// display the default dialog return false (0).
///
//export cefingo_dialog_handler_on_file_dialog
func cefingo_dialog_handler_on_file_dialog(
	self *C.cef_dialog_handler_t,
	browser *C.cef_browser_t,
	mode C.cef_file_dialog_mode_t,
	title *C.cef_string_t,
	default_file_path *C.cef_string_t,
	accept_filters C.cef_string_list_t,
	selected_accept_filter C.int,
	callback *C.cef_file_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T890:")
	cefingoIfaceAccess.Lock()
	f := dialog_handler_handlers.on_file_dialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmode := CFileDialogModeT(mode)
		goTmptitle := string_from_cef_string(title)
		goTmpdefault_file_path := string_from_cef_string(default_file_path)
		goTmpaccept_filters := (CStringListT)(accept_filters)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpcallback := newCFileDialogCallbackT(callback)

		goRet := f.OnFileDialog(goTmpself,goTmpbrowser,goTmpmode,goTmptitle,goTmpdefault_file_path,goTmpaccept_filters,goTmpselected_accept_filter,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_file_dialog_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T911: on_file_dialog: Noo!")
	}
	return cRet
}

///
// Called when a frame&#39;s address has changed.
///
//export cefingo_display_handler_on_address_change
func cefingo_display_handler_on_address_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	url *C.cef_string_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T929:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_address_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpurl := string_from_cef_string(url)

		f.OnAddressChange(goTmpself,goTmpbrowser,goTmpframe,goTmpurl,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T945: on_address_change: Noo!")
	}
	
}

///
// Called when the page title changes.
///
//export cefingo_display_handler_on_title_change
func cefingo_display_handler_on_title_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	title *C.cef_string_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T962:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_title_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptitle := string_from_cef_string(title)

		f.OnTitleChange(goTmpself,goTmpbrowser,goTmptitle,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T976: on_title_change: Noo!")
	}
	
}

///
// Called when the page icon changes.
///
//export cefingo_display_handler_on_favicon_urlchange
func cefingo_display_handler_on_favicon_urlchange(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	icon_urls C.cef_string_list_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T993:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_favicon_urlchange_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpicon_urls := (CStringListT)(icon_urls)

		f.OnFaviconUrlchange(goTmpself,goTmpbrowser,goTmpicon_urls,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1007: on_favicon_urlchange: Noo!")
	}
	
}

///
// Called when web content in the page has toggled fullscreen mode. If
// |fullscreen| is true (1) the content will automatically be sized to fill
// the browser content area. If |fullscreen| is false (0) the content will
// automatically return to its original size and position. The client is
// responsible for resizing the browser if desired.
///
//export cefingo_display_handler_on_fullscreen_mode_change
func cefingo_display_handler_on_fullscreen_mode_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	fullscreen C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1028:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_fullscreen_mode_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfullscreen := (int)(fullscreen)

		f.OnFullscreenModeChange(goTmpself,goTmpbrowser,goTmpfullscreen,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1042: on_fullscreen_mode_change: Noo!")
	}
	
}

///
// Called when the browser is about to display a tooltip. |text| contains the
// text that will be displayed in the tooltip. To handle the display of the
// tooltip yourself return true (1). Otherwise, you can optionally modify
// |text| and then return false (0) to allow the browser to display the
// tooltip. When window rendering is disabled the application is responsible
// for drawing tooltips and the return value is ignored.
///
//export cefingo_display_handler_on_tooltip
func cefingo_display_handler_on_tooltip(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	text *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1064:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_tooltip_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		_text := string_from_cef_string(text)
		goTmptext := &_text

		goRet := f.OnTooltip(goTmpself,goTmpbrowser,goTmptext,)
		BaseRelease(goTmpbrowser.p_browser)
		set_cef_string(text, _text)
	
		if goRet {cRet = 1}
	} else {
		Logf("T1081: on_tooltip: Noo!")
	}
	return cRet
}

///
// Called when the browser receives a status message. |value| contains the
// text that will be displayed in the status message.
///
//export cefingo_display_handler_on_status_message
func cefingo_display_handler_on_status_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	value *C.cef_string_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1099:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_status_message_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpvalue := string_from_cef_string(value)

		f.OnStatusMessage(goTmpself,goTmpbrowser,goTmpvalue,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1113: on_status_message: Noo!")
	}
	
}

///
// Called to display a console message. Return true (1) to stop the message
// from being output to the console.
///
//export cefingo_display_handler_on_console_message
func cefingo_display_handler_on_console_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	level C.cef_log_severity_t,
	message *C.cef_string_t,
	source *C.cef_string_t,
	line C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1134:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_console_message_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmplevel := CLogSeverityT(level)
		goTmpmessage := string_from_cef_string(message)
		goTmpsource := string_from_cef_string(source)
		goTmpline := (int)(line)

		goRet := f.OnConsoleMessage(goTmpself,goTmpbrowser,goTmplevel,goTmpmessage,goTmpsource,goTmpline,)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T1152: on_console_message: Noo!")
	}
	return cRet
}

///
// Called when auto-resize is enabled via
// cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-
// resized. |new_size| will be the desired size in view coordinates. Return
// true (1) if the resize was handled or false (0) for default handling.
///
//export cefingo_display_handler_on_auto_resize
func cefingo_display_handler_on_auto_resize(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	new_size *C.cef_size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1172:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_auto_resize_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnew_size := (*CSizeT)(new_size)

		goRet := f.OnAutoResize(goTmpself,goTmpbrowser,goTmpnew_size,)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T1187: on_auto_resize: Noo!")
	}
	return cRet
}

///
// Called when the overall page loading progress has changed. |progress|
// ranges from 0.0 to 1.0.
///
//export cefingo_display_handler_on_loading_progress_change
func cefingo_display_handler_on_loading_progress_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	progress C.double,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1205:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_loading_progress_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpprogress := (float64)(progress)

		f.OnLoadingProgressChange(goTmpself,goTmpbrowser,goTmpprogress,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1219: on_loading_progress_change: Noo!")
	}
	
}

///
// Called before a download begins. |suggested_name| is the suggested name for
// the download file. By default the download will be canceled. Execute
// |callback| either asynchronously or in this function to continue the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_before_download
func cefingo_download_handler_on_before_download(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	suggested_name *C.cef_string_t,
	callback *C.cef_before_download_callback_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1242:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_before_download_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpsuggested_name := string_from_cef_string(suggested_name)
		goTmpcallback := newCBeforeDownloadCallbackT(callback)

		f.OnBeforeDownload(goTmpself,goTmpbrowser,goTmpdownload_item,goTmpsuggested_name,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdownload_item.p_download_item)
		BaseRelease(goTmpcallback.p_before_download_callback)

	} else {
		Logf("T1260: on_before_download: Noo!")
	}
	
}

///
// Called when a download&#39;s status or progress information has been updated.
// This may be called multiple times before and after on_before_download().
// Execute |callback| either asynchronously or in this function to cancel the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_download_updated
func cefingo_download_handler_on_download_updated(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	callback *C.cef_download_item_callback_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1282:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_download_updated_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpcallback := newCDownloadItemCallbackT(callback)

		f.OnDownloadUpdated(goTmpself,goTmpbrowser,goTmpdownload_item,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdownload_item.p_download_item)
		BaseRelease(goTmpcallback.p_download_item_callback)

	} else {
		Logf("T1299: on_download_updated: Noo!")
	}
	
}

///
// Called when an external drag event enters the browser window. |dragData|
// contains the drag event data and |mask| represents the type of drag
// operation. Return false (0) for default drag handling behavior or true (1)
// to cancel the drag event.
///
//export cefingo_drag_handler_on_drag_enter
func cefingo_drag_handler_on_drag_enter(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	dragData *C.cef_drag_data_t,
	mask C.cef_drag_operations_mask_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1320:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_drag_enter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdragData := newCDragDataT(dragData)
		goTmpmask := CDragOperationsMaskT(mask)

		goRet := f.OnDragEnter(goTmpself,goTmpbrowser,goTmpdragData,goTmpmask,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdragData.p_drag_data)

		if goRet {cRet = 1}
	} else {
		Logf("T1337: on_drag_enter: Noo!")
	}
	return cRet
}

///
// Called whenever draggable regions for the browser window change. These can
// be specified using the &#39;-webkit-app-region: drag/no-drag&#39; CSS-property. If
// draggable regions are never defined in a document this function will also
// never be called. If the last draggable region is removed from a document
// this function will be called with an NULL vector.
///
//export cefingo_drag_handler_on_draggable_regions_changed
func cefingo_drag_handler_on_draggable_regions_changed(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	regionsCount C.size_t,
	regions *C.cef_draggable_region_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1360:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_draggable_regions_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpregionsCount := (int64)(regionsCount)
		goTmpregions := (*CDraggableRegionT)(regions)

		f.OnDraggableRegionsChanged(goTmpself,goTmpbrowser,goTmpframe,goTmpregionsCount,goTmpregions,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T1377: on_draggable_regions_changed: Noo!")
	}
	
}

///
// Called if the cef_request_tContext::LoadExtension request fails. |result|
// will be the error code.
///
//export cefingo_extension_handler_on_extension_load_failed
func cefingo_extension_handler_on_extension_load_failed(
	self *C.cef_extension_handler_t,
	result C.cef_errorcode_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1394:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_load_failed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpresult := CErrorcodeT(result)

		f.OnExtensionLoadFailed(goTmpself,goTmpresult,)

	} else {
		Logf("T1406: on_extension_load_failed: Noo!")
	}
	
}

///
// Called if the cef_request_tContext::LoadExtension request succeeds.
// |extension| is the loaded extension.
///
//export cefingo_extension_handler_on_extension_loaded
func cefingo_extension_handler_on_extension_loaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1423:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_loaded_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionLoaded(goTmpself,goTmpextension,)
		BaseRelease(goTmpextension.p_extension)

	} else {
		Logf("T1436: on_extension_loaded: Noo!")
	}
	
}

///
// Called after the cef_extension_t::Unload request has completed.
///
//export cefingo_extension_handler_on_extension_unloaded
func cefingo_extension_handler_on_extension_unloaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1452:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_unloaded_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionUnloaded(goTmpself,goTmpextension,)
		BaseRelease(goTmpextension.p_extension)

	} else {
		Logf("T1465: on_extension_unloaded: Noo!")
	}
	
}

///
// Called when an extension needs a browser to host a background script
// specified via the &quot;background&quot; manifest key. The browser will have no
// visible window and cannot be displayed. |extension| is the extension that
// is loading the background script. |url| is an internally generated
// reference to an HTML page that will be used to load the background script
// via a &lt;script&gt; src attribute. To allow creation of the browser optionally
// modify |client| and |settings| and return false (0). To cancel creation of
// the browser (and consequently cancel load of the background script) return
// true (1). Successful creation will be indicated by a call to
// cef_life_span_handler_t::OnAfterCreated, and
// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
// browser. See https://developer.chrome.com/extensions/event_pages for more
// information about extension background script usage.
///
//export cefingo_extension_handler_on_before_background_browser
func cefingo_extension_handler_on_before_background_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	url *C.cef_string_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1496:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_background_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpurl := string_from_cef_string(url)
		_client := newCClientT(*client)
		cefp := _client.p_client
		goTmpclient := &_client
		_settings := CBrowserSettingsT(*settings)
		goTmpsettings := &_settings

		goRet := f.OnBeforeBackgroundBrowser(goTmpself,goTmpextension,goTmpurl,goTmpclient,goTmpsettings,)
		BaseRelease(goTmpextension.p_extension)
		if cefp != (*goTmpclient).p_client {
			*client = (*goTmpclient).p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(_settings)

		if goRet {cRet = 1}
	} else {
		Logf("T1512: on_before_background_browser: Noo!")
	}
	return cRet
}

///
// Called when an extension API (e.g. chrome.tabs.create) requests creation of
// a new browser. |extension| and |browser| are the source of the API call.
// |active_browser| may optionally be specified via the windowId property or
// returned via the get_active_browser() callback and provides the default
// |client| and |settings| values for the new browser. |index| is the position
// value optionally specified via the index property. |url| is the URL that
// will be loaded in the browser. |active| is true (1) if the new browser
// should be active when opened.  To allow creation of the browser optionally
// modify |windowInfo|, |client| and |settings| and return false (0). To
// cancel creation of the browser return true (1). Successful creation will be
// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
// modifications to |windowInfo| will be ignored if |active_browser| is
// wrapped in a cef_browser_view_t.
///
//export cefingo_extension_handler_on_before_browser
func cefingo_extension_handler_on_before_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	active_browser *C.cef_browser_t,
	index C.int,
	url *C.cef_string_t,
	active C.int,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1557:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpactive_browser := newCBrowserT(active_browser)
		goTmpindex := (int)(index)
		goTmpurl := string_from_cef_string(url)
		goTmpactive := (int)(active)
		_windowInfo := CWindowInfoT(*windowInfo)
		goTmpwindowInfo := &_windowInfo
		_client := newCClientT(*client)
		cefp := _client.p_client
		goTmpclient := &_client
		_settings := CBrowserSettingsT(*settings)
		goTmpsettings := &_settings

		goRet := f.OnBeforeBrowser(goTmpself,goTmpextension,goTmpbrowser,goTmpactive_browser,goTmpindex,goTmpurl,goTmpactive,goTmpwindowInfo,goTmpclient,goTmpsettings,)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpactive_browser.p_browser)
		*windowInfo = C.cef_window_info_t(_windowInfo)
		if cefp != (*goTmpclient).p_client {
			*client = (*goTmpclient).p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(_settings)

		if goRet {cRet = 1}
	} else {
		Logf("T1579: on_before_browser: Noo!")
	}
	return cRet
}

///
// Called when no tabId is specified to an extension API call that accepts a
// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
// source of the API call. Return the browser that will be acted on by the API
// call or return NULL to act on |browser|. The returned browser must share
// the same cef_request_tContext as |browser|. Incognito browsers should not
// be considered unless the source extension has incognito access enabled, in
// which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_get_active_browser
func cefingo_extension_handler_get_active_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
) (cRet *C.cef_browser_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1615:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_active_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)

		goRet := f.GetActiveBrowser(goTmpself,goTmpextension,goTmpbrowser,goTmpinclude_incognito,)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)

		cRet = (*C.cef_browser_t)(goRet.p_browser)
		BaseAddRef(cRet)
	} else {
		Logf("T1632: get_active_browser: Noo!")
	}
	return cRet
}

///
// Called when the tabId associated with |target_browser| is specified to an
// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
// |extension| and |browser| are the source of the API call. Return true (1)
// to allow access of false (0) to deny access. Access to incognito browsers
// should not be allowed unless the source extension has incognito access
// enabled, in which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_can_access_browser
func cefingo_extension_handler_can_access_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
	target_browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1657:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.can_access_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)
		goTmptarget_browser := newCBrowserT(target_browser)

		goRet := f.CanAccessBrowser(goTmpself,goTmpextension,goTmpbrowser,goTmpinclude_incognito,goTmptarget_browser,)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmptarget_browser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T1676: can_access_browser: Noo!")
	}
	return cRet
}

///
// Called to retrieve an extension resource that would normally be loaded from
// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
// |extension| and |browser| are the source of the resource request. |file| is
// the requested relative file path. To handle the resource request return
// true (1) and execute |callback| either synchronously or asynchronously. For
// the default behavior which reads the resource from the extension directory
// on disk return false (0). Localization substitutions will not be applied to
// resources handled via this function.
///
//export cefingo_extension_handler_get_extension_resource
func cefingo_extension_handler_get_extension_resource(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	file *C.cef_string_t,
	callback *C.cef_get_extension_resource_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1702:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_extension_resource_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfile := string_from_cef_string(file)
		goTmpcallback := newCGetExtensionResourceCallbackT(callback)

		goRet := f.GetExtensionResource(goTmpself,goTmpextension,goTmpbrowser,goTmpfile,goTmpcallback,)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_get_extension_resource_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T1721: get_extension_resource: Noo!")
	}
	return cRet
}

///
// Called to report find results returned by cef_browser_host_t::find().
// |identifer| is the identifier passed to find(), |count| is the number of
// matches currently identified, |selectionRect| is the location of where the
// match was found (in window coordinates), |activeMatchOrdinal| is the
// current position in the search results, and |finalUpdate| is true (1) if
// this is the last find notification.
///
//export cefingo_find_handler_on_find_result
func cefingo_find_handler_on_find_result(
	self *C.cef_find_handler_t,
	browser *C.cef_browser_t,
	identifier C.int,
	count C.int,
	selectionRect *C.cef_rect_t,
	activeMatchOrdinal C.int,
	finalUpdate C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1747:")
	cefingoIfaceAccess.Lock()
	f := find_handler_handlers.on_find_result_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFindHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpidentifier := (int)(identifier)
		goTmpcount := (int)(count)
		goTmpselectionRect := (*CRectT)(selectionRect)
		goTmpactiveMatchOrdinal := (int)(activeMatchOrdinal)
		goTmpfinalUpdate := (int)(finalUpdate)

		f.OnFindResult(goTmpself,goTmpbrowser,goTmpidentifier,goTmpcount,goTmpselectionRect,goTmpactiveMatchOrdinal,goTmpfinalUpdate,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1765: on_find_result: Noo!")
	}
	
}

///
// Called when the browser component is about to loose focus. For instance, if
// focus was on the last HTML element and the user pressed the TAB key. |next|
// will be true (1) if the browser is giving focus to the next component and
// false (0) if the browser is giving focus to the previous component.
///
//export cefingo_focus_handler_on_take_focus
func cefingo_focus_handler_on_take_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	next C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1785:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_take_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnext := (int)(next)

		f.OnTakeFocus(goTmpself,goTmpbrowser,goTmpnext,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1799: on_take_focus: Noo!")
	}
	
}

///
// Called when the browser component is requesting focus. |source| indicates
// where the focus request is originating from. Return false (0) to allow the
// focus to be set or true (1) to cancel setting the focus.
///
//export cefingo_focus_handler_on_set_focus
func cefingo_focus_handler_on_set_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	source C.cef_focus_source_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1818:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_set_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpsource := CFocusSourceT(source)

		goRet := f.OnSetFocus(goTmpself,goTmpbrowser,goTmpsource,)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T1833: on_set_focus: Noo!")
	}
	return cRet
}

///
// Called when the browser component has received focus.
///
//export cefingo_focus_handler_on_got_focus
func cefingo_focus_handler_on_got_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1849:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_got_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnGotFocus(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1862: on_got_focus: Noo!")
	}
	
}

///
// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
// and user-friendly display string. The |default_prompt_text| value will be
// specified for prompt dialogs only. Set |suppress_message| to true (1) and
// return false (0) to suppress the message (suppressing messages is
// preferable to immediately executing the callback as this is used to detect
// presumably malicious behavior like spamming alert messages in
// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
// to use the default implementation (the default implementation will show one
// modal dialog at a time and suppress any additional dialog requests until
// the displayed dialog is dismissed). Return true (1) if the application will
// use a custom dialog or if the callback has been executed immediately.
// Custom dialogs may be either modal or modeless. If a custom dialog is used
// the application must execute |callback| once the custom dialog is
// dismissed.
///
//export cefingo_jsdialog_handler_on_jsdialog
func cefingo_jsdialog_handler_on_jsdialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	dialog_type C.cef_jsdialog_type_t,
	message_text *C.cef_string_t,
	default_prompt_text *C.cef_string_t,
	callback *C.cef_jsdialog_callback_t,
	suppress_message *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1898:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_jsdialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpdialog_type := CJsdialogTypeT(dialog_type)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpdefault_prompt_text := string_from_cef_string(default_prompt_text)
		goTmpcallback := newCJsdialogCallbackT(callback)
		var _suppress_message int
		goTmpsuppress_message := &_suppress_message

		goRet := f.OnJsdialog(goTmpself,goTmpbrowser,goTmporigin_url,goTmpdialog_type,goTmpmessage_text,goTmpdefault_prompt_text,goTmpcallback,goTmpsuppress_message,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_jsdialog_callback)
		*suppress_message = (C.int)(_suppress_message)

		if goRet {cRet = 1}
	} else {
		Logf("T1921: on_jsdialog: Noo!")
	}
	return cRet
}

///
// Called to run a dialog asking the user if they want to leave a page. Return
// false (0) to use the default dialog implementation. Return true (1) if the
// application will use a custom dialog or if the callback has been executed
// immediately. Custom dialogs may be either modal or modeless. If a custom
// dialog is used the application must execute |callback| once the custom
// dialog is dismissed.
///
//export cefingo_jsdialog_handler_on_before_unload_dialog
func cefingo_jsdialog_handler_on_before_unload_dialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	message_text *C.cef_string_t,
	is_reload C.int,
	callback *C.cef_jsdialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1945:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_before_unload_dialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpis_reload := (int)(is_reload)
		goTmpcallback := newCJsdialogCallbackT(callback)

		goRet := f.OnBeforeUnloadDialog(goTmpself,goTmpbrowser,goTmpmessage_text,goTmpis_reload,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_jsdialog_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T1963: on_before_unload_dialog: Noo!")
	}
	return cRet
}

///
// Called to cancel any pending dialogs and reset any saved dialog state. Will
// be called due to events like page navigation irregardless of whether any
// dialogs are currently pending.
///
//export cefingo_jsdialog_handler_on_reset_dialog_state
func cefingo_jsdialog_handler_on_reset_dialog_state(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1981:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_reset_dialog_state_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnResetDialogState(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1994: on_reset_dialog_state: Noo!")
	}
	
}

///
// Called when the default implementation dialog is closed.
///
//export cefingo_jsdialog_handler_on_dialog_closed
func cefingo_jsdialog_handler_on_dialog_closed(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2010:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_dialog_closed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnDialogClosed(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2023: on_dialog_closed: Noo!")
	}
	
}

///
// Called before a keyboard event is sent to the renderer. |event| contains
// information about the keyboard event. |os_event| is the operating system
// event message, if any. Return true (1) if the event was handled or false
// (0) otherwise. If the event will be handled in on_key_event() as a keyboard
// shortcut set |is_keyboard_shortcut| to true (1) and return false (0).
///
//export cefingo_keyboard_handler_on_pre_key_event
func cefingo_keyboard_handler_on_pre_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
	is_keyboard_shortcut *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2046:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_pre_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)
		var _is_keyboard_shortcut int
		goTmpis_keyboard_shortcut := &_is_keyboard_shortcut

		goRet := f.OnPreKeyEvent(goTmpself,goTmpbrowser,goTmpevent,goTmpos_event,goTmpis_keyboard_shortcut,)
		BaseRelease(goTmpbrowser.p_browser)
		*is_keyboard_shortcut = (C.int)(_is_keyboard_shortcut)

		if goRet {cRet = 1}
	} else {
		Logf("T2065: on_pre_key_event: Noo!")
	}
	return cRet
}

///
// Called after the renderer and JavaScript in the page has had a chance to
// handle the event. |event| contains information about the keyboard event.
// |os_event| is the operating system event message, if any. Return true (1)
// if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_keyboard_handler_on_key_event
func cefingo_keyboard_handler_on_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2086:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)

		goRet := f.OnKeyEvent(goTmpself,goTmpbrowser,goTmpevent,goTmpos_event,)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T2102: on_key_event: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before a new popup browser is created. The
// |browser| and |frame| values represent the source of the popup request. The
// |target_url| and |target_frame_name| values indicate where the popup
// browser should navigate and may be NULL if not specified with the request.
// The |target_disposition| value indicates where the user intended to open
// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
// be true (1) if the popup was opened via explicit user gesture (e.g.
// clicking a link) or false (0) if the popup opened automatically (e.g. via
// the DomContentLoaded event). The |popupFeatures| structure contains
// additional information about the requested popup window. To allow creation
// of the popup browser optionally modify |windowInfo|, |client|, |settings|
// and |no_javascript_access| and return false (0). To cancel creation of the
// popup browser return true (1). The |client| and |settings| values will
// default to the source browser&#39;s values. If the |no_javascript_access| value
// is set to false (0) the new browser will not be scriptable and may not be
// hosted in the same renderer process as the source browser. Any
// modifications to |windowInfo| will be ignored if the parent browser is
// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
// the parent browser is destroyed before the popup browser creation completes
// (indicated by a call to OnAfterCreated for the popup browser). The
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created popup browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
//export cefingo_life_span_handler_on_before_popup
func cefingo_life_span_handler_on_before_popup(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_frame_name *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
	popupFeatures *C.cef_popup_features_t,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
	extra_info **C.cef_dictionary_value_t,
	no_javascript_access *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2151:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_popup_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_frame_name := string_from_cef_string(target_frame_name)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := (int)(user_gesture)
		goTmppopupFeatures := (*CPopupFeaturesT)(popupFeatures)
		_windowInfo := CWindowInfoT(*windowInfo)
		goTmpwindowInfo := &_windowInfo
		_client := newCClientT(*client)
		cefp := _client.p_client
		goTmpclient := &_client
		_settings := CBrowserSettingsT(*settings)
		goTmpsettings := &_settings
		var _extra_info *CDictionaryValueT
		goTmpextra_info := &_extra_info
		_no_javascript_access := int(*no_javascript_access)
		goTmpno_javascript_access := &_no_javascript_access

		goRet := f.OnBeforePopup(goTmpself,goTmpbrowser,goTmpframe,goTmptarget_url,goTmptarget_frame_name,goTmptarget_disposition,goTmpuser_gesture,goTmppopupFeatures,goTmpwindowInfo,goTmpclient,goTmpsettings,goTmpextra_info,goTmpno_javascript_access,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		*windowInfo = C.cef_window_info_t(_windowInfo)
		if cefp != (*goTmpclient).p_client {
			*client = (*goTmpclient).p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(_settings)
		if _extra_info != nil {
			*extra_info = _extra_info.p_dictionary_value
			BaseAddRef(*extra_info)
		}
		*no_javascript_access = C.int(_no_javascript_access)

		if goRet {cRet = 1}
	} else {
		Logf("T2179: on_before_popup: Noo!")
	}
	return cRet
}

///
// Called after a new browser is created. This callback will be the first
// notification that references |browser|.
///
//export cefingo_life_span_handler_on_after_created
func cefingo_life_span_handler_on_after_created(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2211:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_after_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnAfterCreated(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2224: on_after_created: Noo!")
	}
	
}

///
// Called when a browser has recieved a request to close. This may result
// directly from a call to cef_browser_host_t::*close_browser() or indirectly
// if the browser is parented to a top-level window created by CEF and the
// user attempts to close that window (by clicking the &#39;X&#39;, for example). The
// do_close() function will be called after the JavaScript &#39;onunload&#39; event
// has been fired.
//
// An application should handle top-level owner window close notifications by
// calling cef_browser_host_t::try_close_browser() or
// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
// to close immediately (see the examples below). This gives CEF an
// opportunity to process the &#39;onbeforeunload&#39; event and optionally cancel the
// close before do_close() is called.
//
// When windowed rendering is enabled CEF will internally create a window or
// view to host the browser. In that case returning false (0) from do_close()
// will send the standard close notification to the browser&#39;s top-level owner
// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
// Linux or cef_window_delegate_t::can_close() callback from Views). If the
// browser&#39;s host window/view has already been destroyed (via view hierarchy
// tear-down, for example) then do_close() will not be called for that browser
// since is no longer possible to cancel the close.
//
// When windowed rendering is disabled returning false (0) from do_close()
// will cause the browser object to be destroyed immediately.
//
// If the browser&#39;s top-level owner window requires a non-standard close
// notification then send that notification from do_close() and return true
// (1).
//
// The cef_life_span_handler_t::on_before_close() function will be called
// after do_close() (if do_close() is called) and immediately before the
// browser object is destroyed. The application should only exit after
// on_before_close() has been called for all existing browsers.
//
// The below examples describe what should happen during window close when the
// browser is parented to an application-provided top-level window.
//
// Example 1: Using cef_browser_host_t::try_close_browser(). This is
// recommended for clients using standard close handling and windows created
// on the browser process UI thread. 1.  User clicks the window close button
// which sends a close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
//     TryCloseBrowser() returns false so the client cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// CEF sends a close notification to the application&#39;s top-level window
//     (because DoClose() returned false by default).
// 7.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
//     allows the window close.
// 8.  Application&#39;s top-level window is destroyed. 9.  Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 10. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
//
// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
// implementing the do_close() callback. This is recommended for clients using
// non-standard close handling or windows that were not created on the browser
// process UI thread. 1.  User clicks the window close button which sends a
// close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and:
//     A. Calls CefBrowserHost::CloseBrowser(false).
//     B. Cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// Application&#39;s do_close() handler is called. Application will:
//     A. Set a flag to indicate that the next close attempt will be allowed.
//     B. Return false.
// 7.  CEF sends an close notification to the application&#39;s top-level window.
// 8.  Application&#39;s top-level window receives the close notification and
//     allows the window to close based on the flag from #6B.
// 9.  Application&#39;s top-level window is destroyed. 10. Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 11. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
///
//export cefingo_life_span_handler_do_close
func cefingo_life_span_handler_do_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2326:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.do_close_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goRet := f.DoClose(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T2340: do_close: Noo!")
	}
	return cRet
}

///
// Called just before a browser is destroyed. Release all references to the
// browser object and do not attempt to execute any functions on the browser
// object (other than GetIdentifier or IsSame) after this callback returns.
// This callback will be the last notification that references |browser| on
// the UI thread. Any in-progress network requests associated with |browser|
// will be aborted when the browser is destroyed, and
// cef_resource_request_handler_t callbacks related to those requests may
// still arrive on the IO thread after this function is called. See do_close()
// documentation for additional usage information.
///
//export cefingo_life_span_handler_on_before_close
func cefingo_life_span_handler_on_before_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2364:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_close_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBeforeClose(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2377: on_before_close: Noo!")
	}
	
}

///
// Called when the loading state has changed. This callback will be executed
// twice -- once when loading is initiated either programmatically or by user
// action, and once when loading is terminated due to completion, cancellation
// of failure. It will be called before any calls to OnLoadStart and after all
// calls to OnLoadError and/or OnLoadEnd.
///
//export cefingo_load_handler_on_loading_state_change
func cefingo_load_handler_on_loading_state_change(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	isLoading C.int,
	canGoBack C.int,
	canGoForward C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2400:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_loading_state_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisLoading := (int)(isLoading)
		goTmpcanGoBack := (int)(canGoBack)
		goTmpcanGoForward := (int)(canGoForward)

		f.OnLoadingStateChange(goTmpself,goTmpbrowser,goTmpisLoading,goTmpcanGoBack,goTmpcanGoForward,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2416: on_loading_state_change: Noo!")
	}
	
}

///
// Called after a navigation has been committed and before the browser begins
// loading contents in the frame. The |frame| value will never be NULL -- call
// the is_main() function to check if this frame is the main frame.
// |transition_type| provides information about the source of the navigation
// and an accurate value is only available in the browser process. Multiple
// frames may be loading at the same time. Sub-frames may start or continue
// loading after the main frame load has ended. This function will not be
// called for same page navigations (fragments, history state, etc.) or for
// navigations that fail or are canceled before commit. For notification of
// overall browser load status use OnLoadingStateChange instead.
///
//export cefingo_load_handler_on_load_start
func cefingo_load_handler_on_load_start(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	transition_type C.cef_transition_type_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2443:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_start_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptransition_type := CTransitionTypeT(transition_type)

		f.OnLoadStart(goTmpself,goTmpbrowser,goTmpframe,goTmptransition_type,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T2459: on_load_start: Noo!")
	}
	
}

///
// Called when the browser is done loading a frame. The |frame| value will
// never be NULL -- call the is_main() function to check if this frame is the
// main frame. Multiple frames may be loading at the same time. Sub-frames may
// start or continue loading after the main frame load has ended. This
// function will not be called for same page navigations (fragments, history
// state, etc.) or for navigations that fail or are canceled before commit.
// For notification of overall browser load status use OnLoadingStateChange
// instead.
///
//export cefingo_load_handler_on_load_end
func cefingo_load_handler_on_load_end(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	httpStatusCode C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2484:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_end_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmphttpStatusCode := (int)(httpStatusCode)

		f.OnLoadEnd(goTmpself,goTmpbrowser,goTmpframe,goTmphttpStatusCode,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T2500: on_load_end: Noo!")
	}
	
}

///
// Called when a navigation fails or is canceled. This function may be called
// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
// after commit. |errorCode| is the error code number, |errorText| is the
// error text and |failedUrl| is the URL that failed to load. See
// net\base\net_error_list.h for complete descriptions of the error codes.
///
//export cefingo_load_handler_on_load_error
func cefingo_load_handler_on_load_error(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	errorCode C.cef_errorcode_t,
	errorText *C.cef_string_t,
	failedUrl *C.cef_string_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2524:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_error_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmperrorCode := CErrorcodeT(errorCode)
		goTmperrorText := string_from_cef_string(errorText)
		goTmpfailedUrl := string_from_cef_string(failedUrl)

		f.OnLoadError(goTmpself,goTmpbrowser,goTmpframe,goTmperrorCode,goTmperrorText,goTmpfailedUrl,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T2542: on_load_error: Noo!")
	}
	
}

///
// Perform the action associated with the specified |command_id| and optional
// |event_flags|.
///
//export cefingo_menu_model_delegate_execute_command
func cefingo_menu_model_delegate_execute_command(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2561:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.execute_command_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		f.ExecuteCommand(goTmpself,goTmpmenu_model,goTmpcommand_id,goTmpevent_flags,)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2576: execute_command: Noo!")
	}
	
}

///
// Called when the user moves the mouse outside the menu and over the owning
// window.
///
//export cefingo_menu_model_delegate_mouse_outside_menu
func cefingo_menu_model_delegate_mouse_outside_menu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	screen_point *C.cef_point_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2594:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.mouse_outside_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpscreen_point := (*CPointT)(screen_point)

		f.MouseOutsideMenu(goTmpself,goTmpmenu_model,goTmpscreen_point,)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2608: mouse_outside_menu: Noo!")
	}
	
}

///
// Called on unhandled open submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_open_submenu
func cefingo_menu_model_delegate_unhandled_open_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2626:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_open_submenu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledOpenSubmenu(goTmpself,goTmpmenu_model,goTmpis_rtl,)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2640: unhandled_open_submenu: Noo!")
	}
	
}

///
// Called on unhandled close submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_close_submenu
func cefingo_menu_model_delegate_unhandled_close_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2658:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_close_submenu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledCloseSubmenu(goTmpself,goTmpmenu_model,goTmpis_rtl,)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2672: unhandled_close_submenu: Noo!")
	}
	
}

///
// The menu is about to show.
///
//export cefingo_menu_model_delegate_menu_will_show
func cefingo_menu_model_delegate_menu_will_show(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2688:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_will_show_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuWillShow(goTmpself,goTmpmenu_model,)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2701: menu_will_show: Noo!")
	}
	
}

///
// The menu has closed.
///
//export cefingo_menu_model_delegate_menu_closed
func cefingo_menu_model_delegate_menu_closed(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2717:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_closed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuClosed(goTmpself,goTmpmenu_model,)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2730: menu_closed: Noo!")
	}
	
}

///
// Optionally modify a menu item label. Return true (1) if |label| was
// modified.
///
//export cefingo_menu_model_delegate_format_label
func cefingo_menu_model_delegate_format_label(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	label *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2748:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.format_label_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		_label := string_from_cef_string(label)
		goTmplabel := &_label

		goRet := f.FormatLabel(goTmpself,goTmpmenu_model,goTmplabel,)
		BaseRelease(goTmpmenu_model.p_menu_model)
		set_cef_string(label, _label)
	
		if goRet {cRet = 1}
	} else {
		Logf("T2765: format_label: Noo!")
	}
	return cRet
}

//export cefingo_render_handler_get_accessibility_handler
func cefingo_render_handler_get_accessibility_handler(self *C.cef_render_handler_t) (ch *C.cef_accessibility_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := render_handler_handlers.accessibility_handler[self]
	if handler == nil {
		Logf("T2780: get_accessibility_handler")
	} else {
		BaseAddRef(handler.p_accessibility_handler)
		ch = handler.p_accessibility_handler
	}
	return ch
}

///
// Called to retrieve the root window rectangle in screen coordinates. Return
// true (1) if the rectangle was provided. If this function returns false (0)
// the rectangle from GetViewRect will be used.
///
//export cefingo_render_handler_get_root_screen_rect
func cefingo_render_handler_get_root_screen_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2799:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_root_screen_rect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		goRet := f.GetRootScreenRect(goTmpself,goTmpbrowser,goTmprect,)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T2814: get_root_screen_rect: Noo!")
	}
	return cRet
}

///
// Called to retrieve the view rectangle which is relative to screen
// coordinates. This function must always provide a non-NULL rectangle.
///
//export cefingo_render_handler_get_view_rect
func cefingo_render_handler_get_view_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2832:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_view_rect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		f.GetViewRect(goTmpself,goTmpbrowser,goTmprect,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2846: get_view_rect: Noo!")
	}
	
}

///
// Called to retrieve the translation from view coordinates to actual screen
// coordinates. Return true (1) if the screen coordinates were provided.
///
//export cefingo_render_handler_get_screen_point
func cefingo_render_handler_get_screen_point(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	viewX C.int,
	viewY C.int,
	screenX *C.int,
	screenY *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2867:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_point_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpviewX := (int)(viewX)
		goTmpviewY := (int)(viewY)
		var _screenX int
		goTmpscreenX := &_screenX
		var _screenY int
		goTmpscreenY := &_screenY

		goRet := f.GetScreenPoint(goTmpself,goTmpbrowser,goTmpviewX,goTmpviewY,goTmpscreenX,goTmpscreenY,)
		BaseRelease(goTmpbrowser.p_browser)
		*screenX = (C.int)(_screenX)
		*screenY = (C.int)(_screenY)

		if goRet {cRet = 1}
	} else {
		Logf("T2889: get_screen_point: Noo!")
	}
	return cRet
}

///
// Called to allow the client to fill in the CefScreenInfo object with
// appropriate values. Return true (1) if the |screen_info| structure has been
// modified.
//
// If the screen info rectangle is left NULL the rectangle from GetViewRect
// will be used. If the rectangle is still NULL or invalid popups may not be
// drawn correctly.
///
//export cefingo_render_handler_get_screen_info
func cefingo_render_handler_get_screen_info(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	screen_info *C.cef_screen_info_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2912:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_info_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpscreen_info := (*CScreenInfoT)(screen_info)

		goRet := f.GetScreenInfo(goTmpself,goTmpbrowser,goTmpscreen_info,)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {cRet = 1}
	} else {
		Logf("T2927: get_screen_info: Noo!")
	}
	return cRet
}

///
// Called when the browser wants to show or hide the popup widget. The popup
// should be shown if |show| is true (1) and hidden if |show| is false (0).
///
//export cefingo_render_handler_on_popup_show
func cefingo_render_handler_on_popup_show(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	show C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2945:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_show_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpshow := (int)(show)

		f.OnPopupShow(goTmpself,goTmpbrowser,goTmpshow,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2959: on_popup_show: Noo!")
	}
	
}

///
// Called when the browser wants to move or resize the popup widget. |rect|
// contains the new location and size in view coordinates.
///
//export cefingo_render_handler_on_popup_size
func cefingo_render_handler_on_popup_size(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2977:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_size_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		f.OnPopupSize(goTmpself,goTmpbrowser,goTmprect,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2991: on_popup_size: Noo!")
	}
	
}

///
// Called when an element should be painted. Pixel values passed to this
// function are scaled relative to view coordinates based on the value of
// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
// indicates whether the element is the view or the popup widget. |buffer|
// contains the pixel data for the whole image. |dirtyRects| contains the set
// of rectangles in pixel coordinates that need to be repainted. |buffer| will
// be |width|*|height|*4 bytes in size and represents a BGRA image with an
// upper-left origin. This function is only called when
// cef_window_tInfo::shared_texture_enabled is set to false (0).
///
//export cefingo_render_handler_on_paint
func cefingo_render_handler_on_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	buffer C.VOIDP,
	width C.int,
	height C.int,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3021:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_paint_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		goTmpbuffer := unsafe.Pointer(buffer)
		goTmpwidth := (int)(width)
		goTmpheight := (int)(height)

		f.OnPaint(goTmpself,goTmpbrowser,goTmptype,goTmpdirtyRectsCount,goTmpdirtyRects,goTmpbuffer,goTmpwidth,goTmpheight,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3040: on_paint: Noo!")
	}
	
}

///
// Called when an element has been rendered to the shared texture handle.
// |type| indicates whether the element is the view or the popup widget.
// |dirtyRects| contains the set of rectangles in pixel coordinates that need
// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
// can be accessed via ID3D11Device using the OpenSharedResource function.
// This function is only called when cef_window_tInfo::shared_texture_enabled
// is set to true (1), and is currently only supported on Windows.
///
//export cefingo_render_handler_on_accelerated_paint
func cefingo_render_handler_on_accelerated_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	shared_handle C.VOIDP,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3066:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_accelerated_paint_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		goTmpshared_handle := unsafe.Pointer(shared_handle)

		f.OnAcceleratedPaint(goTmpself,goTmpbrowser,goTmptype,goTmpdirtyRectsCount,goTmpdirtyRects,goTmpshared_handle,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3083: on_accelerated_paint: Noo!")
	}
	
}

///
// Called when the browser&#39;s cursor has changed. If |type| is CT_CUSTOM then
// |custom_cursor_info| will be populated with the custom cursor information.
///
//export cefingo_render_handler_on_cursor_change
func cefingo_render_handler_on_cursor_change(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	cursor C.HCURSOR,
	ctype C.cef_cursor_type_t,
	custom_cursor_info *C.cef_cursor_info_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3103:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_cursor_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcursor := (CCursorHandleT)(cursor)
		goTmptype := CCursorTypeT(ctype)
		goTmpcustom_cursor_info := (*CCursorInfoT)(custom_cursor_info)

		f.OnCursorChange(goTmpself,goTmpbrowser,goTmpcursor,goTmptype,goTmpcustom_cursor_info,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3119: on_cursor_change: Noo!")
	}
	
}

///
// Called when the user starts dragging content in the web view. Contextual
// information about the dragged content is supplied by |drag_data|. (|x|,
// |y|) is the drag start location in screen coordinates. OS APIs that run a
// system message loop may be used within the StartDragging call.
//
// Return false (0) to abort the drag operation. Don&#39;t call any of
// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
//
// Return true (1) to handle the drag operation. Call
// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
// synchronously or asynchronously to inform the web view that the drag
// operation has ended.
///
//export cefingo_render_handler_start_dragging
func cefingo_render_handler_start_dragging(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	drag_data *C.cef_drag_data_t,
	allowed_ops C.cef_drag_operations_mask_t,
	x C.int,
	y C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3150:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.start_dragging_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdrag_data := newCDragDataT(drag_data)
		goTmpallowed_ops := CDragOperationsMaskT(allowed_ops)
		goTmpx := (int)(x)
		goTmpy := (int)(y)

		goRet := f.StartDragging(goTmpself,goTmpbrowser,goTmpdrag_data,goTmpallowed_ops,goTmpx,goTmpy,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdrag_data.p_drag_data)

		if goRet {cRet = 1}
	} else {
		Logf("T3169: start_dragging: Noo!")
	}
	return cRet
}

///
// Called when the web view wants to update the mouse cursor during a drag &amp;
// drop operation. |operation| describes the allowed operation (none, move,
// copy, link).
///
//export cefingo_render_handler_update_drag_cursor
func cefingo_render_handler_update_drag_cursor(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	operation C.cef_drag_operations_mask_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3188:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.update_drag_cursor_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpoperation := CDragOperationsMaskT(operation)

		f.UpdateDragCursor(goTmpself,goTmpbrowser,goTmpoperation,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3202: update_drag_cursor: Noo!")
	}
	
}

///
// Called when the scroll offset has changed.
///
//export cefingo_render_handler_on_scroll_offset_changed
func cefingo_render_handler_on_scroll_offset_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	x C.double,
	y C.double,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3220:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_scroll_offset_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpx := (float64)(x)
		goTmpy := (float64)(y)

		f.OnScrollOffsetChanged(goTmpself,goTmpbrowser,goTmpx,goTmpy,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3235: on_scroll_offset_changed: Noo!")
	}
	
}

///
// Called when the IME composition range has changed. |selected_range| is the
// range of characters that have been selected. |character_bounds| is the
// bounds of each character in view coordinates.
///
//export cefingo_render_handler_on_ime_composition_range_changed
func cefingo_render_handler_on_ime_composition_range_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_range *C.cef_range_t,
	character_boundsCount C.size_t,
	character_bounds *C.cef_rect_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3256:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_ime_composition_range_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_range := (*CRangeT)(selected_range)
		goTmpcharacter_boundsCount := (int64)(character_boundsCount)
		goTmpcharacter_bounds := (*CRectT)(character_bounds)

		f.OnImeCompositionRangeChanged(goTmpself,goTmpbrowser,goTmpselected_range,goTmpcharacter_boundsCount,goTmpcharacter_bounds,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3272: on_ime_composition_range_changed: Noo!")
	}
	
}

///
// Called when text selection has changed for the specified |browser|.
// |selected_text| is the currently selected text and |selected_range| is the
// character range.
///
//export cefingo_render_handler_on_text_selection_changed
func cefingo_render_handler_on_text_selection_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_text *C.cef_string_t,
	selected_range *C.cef_range_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3292:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_text_selection_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_text := string_from_cef_string(selected_text)
		goTmpselected_range := (*CRangeT)(selected_range)

		f.OnTextSelectionChanged(goTmpself,goTmpbrowser,goTmpselected_text,goTmpselected_range,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3307: on_text_selection_changed: Noo!")
	}
	
}

///
// Called when an on-screen keyboard should be shown or hidden for the
// specified |browser|. |input_mode| specifies what kind of keyboard should be
// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
// for this browser should be hidden.
///
//export cefingo_render_handler_on_virtual_keyboard_requested
func cefingo_render_handler_on_virtual_keyboard_requested(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	input_mode C.cef_text_input_mode_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3327:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_virtual_keyboard_requested_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinput_mode := CTextInputModeT(input_mode)

		f.OnVirtualKeyboardRequested(goTmpself,goTmpbrowser,goTmpinput_mode,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3341: on_virtual_keyboard_requested: Noo!")
	}
	
}

//export cefingo_render_process_handler_get_load_handler
func cefingo_render_process_handler_get_load_handler(self *C.cef_render_process_handler_t) (ch *C.cef_load_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := render_process_handler_handlers.load_handler[self]
	if handler == nil {
		Logf("T3356: get_load_handler")
	} else {
		BaseAddRef(handler.p_load_handler)
		ch = handler.p_load_handler
	}
	return ch
}

///
// Called after the render process main thread has been created. |extra_info|
// is a read-only value originating from
// cef_browser_process_handler_t::on_render_process_thread_created(). Do not
// keep a reference to |extra_info| outside of this function.
///
//export cefingo_render_process_handler_on_render_thread_created
func cefingo_render_process_handler_on_render_thread_created(
	self *C.cef_render_process_handler_t,
	extra_info *C.cef_list_value_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3375:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_render_thread_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpextra_info := newCListValueT(extra_info)

		f.OnRenderThreadCreated(goTmpself,goTmpextra_info,)
		BaseRelease(goTmpextra_info.p_list_value)

	} else {
		Logf("T3388: on_render_thread_created: Noo!")
	}
	
}

///
// Called after WebKit has been initialized.
///
//export cefingo_render_process_handler_on_web_kit_initialized
func cefingo_render_process_handler_on_web_kit_initialized(
	self *C.cef_render_process_handler_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3403:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_web_kit_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)

		f.OnWebKitInitialized(goTmpself,)

	} else {
		Logf("T3414: on_web_kit_initialized: Noo!")
	}
	
}

///
// Called after a browser has been created. When browsing cross-origin a new
// browser will be created before the old browser with the same identifier is
// destroyed. |extra_info| is a read-only value originating from
// cef_browser_host_t::cef_browser_host_create_browser(),
// cef_browser_host_t::cef_browser_host_create_browser_sync(),
// cef_life_span_handler_t::on_before_popup() or
// cef_browser_view_t::cef_browser_view_create().
///
//export cefingo_render_process_handler_on_browser_created
func cefingo_render_process_handler_on_browser_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	extra_info *C.cef_dictionary_value_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3437:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpextra_info := newCDictionaryValueT(extra_info)

		f.OnBrowserCreated(goTmpself,goTmpbrowser,goTmpextra_info,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpextra_info.p_dictionary_value)

	} else {
		Logf("T3452: on_browser_created: Noo!")
	}
	
}

///
// Called before a browser is destroyed.
///
//export cefingo_render_process_handler_on_browser_destroyed
func cefingo_render_process_handler_on_browser_destroyed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3468:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_destroyed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserDestroyed(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3481: on_browser_destroyed: Noo!")
	}
	
}

///
// Called immediately after the V8 context for a frame has been created. To
// retrieve the JavaScript &#39;window&#39; object use the
// cef_v8context_t::get_global() function. V8 handles can only be accessed
// from the thread on which they are created. A task runner for posting tasks
// on the associated thread can be retrieved via the
// cef_v8context_t::get_task_runner() function.
///
//export cefingo_render_process_handler_on_context_created
func cefingo_render_process_handler_on_context_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3504:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextCreated(goTmpself,goTmpbrowser,goTmpframe,goTmpcontext,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)

	} else {
		Logf("T3521: on_context_created: Noo!")
	}
	
}

///
// Called immediately before the V8 context for a frame is released. No
// references to the context should be kept after this function is called.
///
//export cefingo_render_process_handler_on_context_released
func cefingo_render_process_handler_on_context_released(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3540:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_released_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextReleased(goTmpself,goTmpbrowser,goTmpframe,goTmpcontext,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)

	} else {
		Logf("T3557: on_context_released: Noo!")
	}
	
}

///
// Called for global uncaught exceptions in a frame. Execution of this
// callback is disabled by default. To enable set
// CefSettings.uncaught_exception_stack_size &gt; 0.
///
//export cefingo_render_process_handler_on_uncaught_exception
func cefingo_render_process_handler_on_uncaught_exception(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
	exception *C.cef_v8exception_t,
	stackTrace *C.cef_v8stack_trace_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3579:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_uncaught_exception_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)
		goTmpexception := newCV8exceptionT(exception)
		goTmpstackTrace := newCV8stackTraceT(stackTrace)

		f.OnUncaughtException(goTmpself,goTmpbrowser,goTmpframe,goTmpcontext,goTmpexception,goTmpstackTrace,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)
		BaseRelease(goTmpexception.p_v8exception)
		BaseRelease(goTmpstackTrace.p_v8stack_trace)

	} else {
		Logf("T3600: on_uncaught_exception: Noo!")
	}
	
}

///
// Called when a new node in the the browser gets focus. The |node| value may
// be NULL if no specific node has gained focus. The node object passed to
// this function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_render_process_handler_on_focused_node_changed
func cefingo_render_process_handler_on_focused_node_changed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	node *C.cef_domnode_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3623:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_focused_node_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpnode := newCDomnodeT(node)

		f.OnFocusedNodeChanged(goTmpself,goTmpbrowser,goTmpframe,goTmpnode,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpnode.p_domnode)

	} else {
		Logf("T3640: on_focused_node_changed: Noo!")
	}
	
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_render_process_handler_on_process_message_received
func cefingo_render_process_handler_on_process_message_received(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3661:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_process_message_received_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself,goTmpbrowser,goTmpframe,goTmpsource_process,goTmpmessage,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpmessage.p_process_message)

		if goRet {cRet = 1}
	} else {
		Logf("T3680: on_process_message_received: Noo!")
	}
	return cRet
}

//export cefingo_request_context_handler_get_resource_request_handler
func cefingo_request_context_handler_get_resource_request_handler(self *C.cef_request_context_handler_t) (ch *C.cef_resource_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := request_context_handler_handlers.resource_request_handler[self]
	if handler == nil {
		Logf("T3695: get_resource_request_handler")
	} else {
		BaseAddRef(handler.p_resource_request_handler)
		ch = handler.p_resource_request_handler
	}
	return ch
}

///
// Called on the browser process UI thread immediately after the request
// context has been initialized.
///
//export cefingo_request_context_handler_on_request_context_initialized
func cefingo_request_context_handler_on_request_context_initialized(
	self *C.cef_request_context_handler_t,
	request_context *C.cef_request_context_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3712:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_request_context_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmprequest_context := newCRequestContextT(request_context)

		f.OnRequestContextInitialized(goTmpself,goTmprequest_context,)
		BaseRelease(goTmprequest_context.p_request_context)

	} else {
		Logf("T3725: on_request_context_initialized: Noo!")
	}
	
}

///
// Called on multiple browser process threads before a plugin instance is
// loaded. |mime_type| is the mime type of the plugin that will be loaded.
// |plugin_url| is the content URL that the plugin will load and may be NULL.
// |is_main_frame| will be true (1) if the plugin is being loaded in the main
// (top-level) frame, |top_origin_url| is the URL for the top-level frame that
// contains the plugin when loading a specific plugin instance or NULL when
// building the initial list of enabled plugins for &#39;navigator.plugins&#39;
// JavaScript state. |plugin_info| includes additional information about the
// plugin that will be loaded. |plugin_policy| is the recommended policy.
// Modify |plugin_policy| and return true (1) to change the policy. Return
// false (0) to use the recommended policy. The default plugin policy can be
// set at runtime using the `--plugin-policy=[allow|detect|block]` command-
// line flag. Decisions to mark a plugin as disabled by setting
// |plugin_policy| to PLUGIN_POLICY_DISABLED may be cached when
// |top_origin_url| is NULL. To purge the plugin list cache and potentially
// trigger new calls to this function call
// cef_request_tContext::PurgePluginListCache.
///
//export cefingo_request_context_handler_on_before_plugin_load
func cefingo_request_context_handler_on_before_plugin_load(
	self *C.cef_request_context_handler_t,
	mime_type *C.cef_string_t,
	plugin_url *C.cef_string_t,
	is_main_frame C.int,
	top_origin_url *C.cef_string_t,
	plugin_info *C.cef_web_plugin_info_t,
	plugin_policy *C.cef_plugin_policy_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3762:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_before_plugin_load_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmpmime_type := string_from_cef_string(mime_type)
		goTmpplugin_url := string_from_cef_string(plugin_url)
		goTmpis_main_frame := (int)(is_main_frame)
		goTmptop_origin_url := string_from_cef_string(top_origin_url)
		goTmpplugin_info := newCWebPluginInfoT(plugin_info)
		var _plugin_policy CPluginPolicyT
		goTmpplugin_policy := &_plugin_policy

		goRet := f.OnBeforePluginLoad(goTmpself,goTmpmime_type,goTmpplugin_url,goTmpis_main_frame,goTmptop_origin_url,goTmpplugin_info,goTmpplugin_policy,)
		BaseRelease(goTmpplugin_info.p_web_plugin_info)
		*plugin_policy = (C.cef_plugin_policy_t)(_plugin_policy)

		if goRet {cRet = 1}
	} else {
		Logf("T3783: on_before_plugin_load: Noo!")
	}
	return cRet
}

//export cefingo_request_handler_get_resource_request_handler
func cefingo_request_handler_get_resource_request_handler(self *C.cef_request_handler_t) (ch *C.cef_resource_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := request_handler_handlers.resource_request_handler[self]
	if handler == nil {
		Logf("T3798: get_resource_request_handler")
	} else {
		BaseAddRef(handler.p_resource_request_handler)
		ch = handler.p_resource_request_handler
	}
	return ch
}

///
// Called on the UI thread before browser navigation. Return true (1) to
// cancel the navigation or false (0) to allow the navigation to proceed. The
// |request| object cannot be modified in this callback.
// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
// If the navigation is allowed cef_load_handler_t::OnLoadStart and
// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event).
///
//export cefingo_request_handler_on_before_browse
func cefingo_request_handler_on_before_browse(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	user_gesture C.int,
	is_redirect C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3827:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_before_browse_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpuser_gesture := (int)(user_gesture)
		goTmpis_redirect := (int)(is_redirect)

		goRet := f.OnBeforeBrowse(goTmpself,goTmpbrowser,goTmpframe,goTmprequest,goTmpuser_gesture,goTmpis_redirect,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		if goRet {cRet = 1}
	} else {
		Logf("T3847: on_before_browse: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before OnBeforeBrowse in certain limited cases
// where navigating a new or different browser might be desirable. This
// includes user-initiated navigation that might open in a special way (e.g.
// links clicked via middle-click or ctrl + left-click) and certain types of
// cross-origin navigation initiated from the renderer process (e.g.
// navigating the top-level frame to/from a file URL). The |browser| and
// |frame| values represent the source of the navigation. The
// |target_disposition| value indicates where the user intended to navigate
// the browser based on standard Chromium behaviors (e.g. current tab, new
// tab, etc). The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event). Return
// true (1) to cancel the navigation or false (0) to allow the navigation to
// proceed in the source browser&#39;s top-level frame.
///
//export cefingo_request_handler_on_open_urlfrom_tab
func cefingo_request_handler_on_open_urlfrom_tab(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3880:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_open_urlfrom_tab_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := (int)(user_gesture)

		goRet := f.OnOpenUrlfromTab(goTmpself,goTmpbrowser,goTmpframe,goTmptarget_url,goTmptarget_disposition,goTmpuser_gesture,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

		if goRet {cRet = 1}
	} else {
		Logf("T3899: on_open_urlfrom_tab: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |origin_url| is the origin making this authentication request. |isProxy|
// indicates whether the host is a proxy server. |host| contains the hostname
// and |port| contains the port number. |realm| is the realm of the challenge
// and may be NULL. |scheme| is the authentication scheme used, such as
// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
// FTP server. Return true (1) to continue the request and call
// cef_auth_callback_t::cont() either in this function or at a later time when
// the authentication information is available. Return false (0) to cancel the
// request immediately.
///
//export cefingo_request_handler_get_auth_credentials
func cefingo_request_handler_get_auth_credentials(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3931:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.get_auth_credentials_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		goTmprealm := string_from_cef_string(realm)
		goTmpscheme := string_from_cef_string(scheme)
		goTmpcallback := newCAuthCallbackT(callback)

		goRet := f.GetAuthCredentials(goTmpself,goTmpbrowser,goTmporigin_url,goTmpisProxy,goTmphost,goTmpport,goTmprealm,goTmpscheme,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_auth_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T3953: get_auth_credentials: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when JavaScript requests a specific storage quota
// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
// origin of the page making the request. |new_size| is the requested quota
// size in bytes. Return true (1) to continue the request and call
// cef_request_tCallback::cont() either in this function or at a later time to
// grant or deny the request. Return false (0) to cancel the request
// immediately.
///
//export cefingo_request_handler_on_quota_request
func cefingo_request_handler_on_quota_request(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	new_size C.int64,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3978:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_quota_request_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpnew_size := (int64)(new_size)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnQuotaRequest(goTmpself,goTmpbrowser,goTmporigin_url,goTmpnew_size,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_request_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T3996: on_quota_request: Noo!")
	}
	return cRet
}

///
// Called on the UI thread to handle requests for URLs with an invalid SSL
// certificate. Return true (1) and call cef_request_tCallback::cont() either
// in this function or at a later time to continue or cancel the request.
// Return false (0) to cancel the request immediately. If
// CefSettings.ignore_certificate_errors is set all invalid certificates will
// be accepted without calling this function.
///
//export cefingo_request_handler_on_certificate_error
func cefingo_request_handler_on_certificate_error(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	cert_error C.cef_errorcode_t,
	request_url *C.cef_string_t,
	ssl_info *C.cef_sslinfo_t,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4021:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_certificate_error_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcert_error := CErrorcodeT(cert_error)
		goTmprequest_url := string_from_cef_string(request_url)
		goTmpssl_info := newCSslinfoT(ssl_info)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnCertificateError(goTmpself,goTmpbrowser,goTmpcert_error,goTmprequest_url,goTmpssl_info,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpssl_info.p_sslinfo)
		BaseRelease(goTmpcallback.p_request_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T4041: on_certificate_error: Noo!")
	}
	return cRet
}

///
// Called on the UI thread when a client certificate is being requested for
// authentication. Return false (0) to use the default behavior and
// automatically select the first certificate available. Return true (1) and
// call cef_select_client_certificate_callback_t::Select either in this
// function or at a later time to select a certificate. Do not call Select or
// call it with NULL to continue without using any certificate. |isProxy|
// indicates whether the host is an HTTPS proxy or the origin server. |host|
// and |port| contains the hostname and port of the SSL server. |certificates|
// is the list of certificates to choose from; this list has already been
// pruned by Chromium so that it only contains certificates from issuers that
// the server trusts.
///
//export cefingo_request_handler_on_select_client_certificate
func cefingo_request_handler_on_select_client_certificate(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	certificatesCount C.size_t,
	certificates **C.cef_x509certificate_t,
	callback *C.cef_select_client_certificate_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4073:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_select_client_certificate_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		slice := (*[1 << 30](*C.cef_x509certificate_t))(unsafe.Pointer(certificates))[:certificatesCount:certificatesCount]
		goTmpcertificates := make([]*CX509certificateT, certificatesCount)
		for i, v := range slice {
			goTmpcertificates[i] = newCX509certificateT(v)
		}
		goTmpcallback := newCSelectClientCertificateCallbackT(callback)

		goRet := f.OnSelectClientCertificate(goTmpself,goTmpbrowser,goTmpisProxy,goTmphost,goTmpport,goTmpcertificates,goTmpcallback,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_select_client_certificate_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T4092: on_select_client_certificate: Noo!")
	}
	return cRet
}

///
// Called on the browser process UI thread when a plugin has crashed.
// |plugin_path| is the path of the plugin that crashed.
///
//export cefingo_request_handler_on_plugin_crashed
func cefingo_request_handler_on_plugin_crashed(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	plugin_path *C.cef_string_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4115:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_plugin_crashed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpplugin_path := string_from_cef_string(plugin_path)

		f.OnPluginCrashed(goTmpself,goTmpbrowser,goTmpplugin_path,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4129: on_plugin_crashed: Noo!")
	}
	
}

///
// Called on the browser process UI thread when the render view associated
// with |browser| is ready to receive/handle IPC messages in the render
// process.
///
//export cefingo_request_handler_on_render_view_ready
func cefingo_request_handler_on_render_view_ready(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4147:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_view_ready_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnRenderViewReady(goTmpself,goTmpbrowser,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4160: on_render_view_ready: Noo!")
	}
	
}

///
// Called on the browser process UI thread when the render process terminates
// unexpectedly. |status| indicates how the process terminated.
///
//export cefingo_request_handler_on_render_process_terminated
func cefingo_request_handler_on_render_process_terminated(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	status C.cef_termination_status_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4178:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_process_terminated_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpstatus := CTerminationStatusT(status)

		f.OnRenderProcessTerminated(goTmpself,goTmpbrowser,goTmpstatus,)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4192: on_render_process_terminated: Noo!")
	}
	
}

///
// Called to retrieve a localized translation for the specified |string_id|.
// To provide the translation set |string| to the translation string and
// return true (1). To use the default translation return false (0). Include
// cef_pack_strings.h for a listing of valid string ID values.
///
//export cefingo_resource_bundle_handler_get_localized_string
func cefingo_resource_bundle_handler_get_localized_string(
	self *C.cef_resource_bundle_handler_t,
	string_id C.int,
	cstring *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4212:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_localized_string_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpstring_id := (int)(string_id)
		var _string string
		goTmpstring := &_string

		goRet := f.GetLocalizedString(goTmpself,goTmpstring_id,goTmpstring,)
		set_cef_string(cstring, _string)

		if goRet {cRet = 1}
	} else {
		Logf("T4228: get_localized_string: Noo!")
	}
	return cRet
}

///
// Open the response stream. To handle the request immediately set
// |handle_request| to true (1) and return true (1). To decide at a later time
// set |handle_request| to false (0), return true (1), and execute |callback|
// to continue or cancel the request. To cancel the request immediately set
// |handle_request| to true (1) and return false (0). This function will be
// called in sequence but not from a dedicated thread. For backwards
// compatibility set |handle_request| to false (0) and return false (0) and
// the ProcessRequest function will be called.
///
//export cefingo_resource_handler_open
func cefingo_resource_handler_open(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	handle_request *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4253:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.open_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		var _handle_request int
		goTmphandle_request := &_handle_request
		goTmpcallback := newCCallbackT(callback)

		goRet := f.Open(goTmpself,goTmprequest,goTmphandle_request,goTmpcallback,)
		BaseRelease(goTmprequest.p_request)
		*handle_request = (C.int)(_handle_request)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T4272: open: Noo!")
	}
	return cRet
}

///
// Begin processing the request. To handle the request return true (1) and
// call cef_callback_t::cont() once the response header information is
// available (cef_callback_t::cont() can also be called from inside this
// function if header information is available immediately). To cancel the
// request return false (0).
//
// WARNING: This function is deprecated. Use Open instead.
///
//export cefingo_resource_handler_process_request
func cefingo_resource_handler_process_request(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4295:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.process_request_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCCallbackT(callback)

		goRet := f.ProcessRequest(goTmpself,goTmprequest,goTmpcallback,)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T4311: process_request: Noo!")
	}
	return cRet
}

///
// Retrieve response header information. If the response length is not known
// set |response_length| to -1 and read_response() will be called until it
// returns false (0). If the response length is known set |response_length| to
// a positive value and read_response() will be called until it returns false
// (0) or the specified number of bytes have been read. Use the |response|
// object to set the mime type, http status code and other optional header
// values. To redirect the request to a new URL set |redirectUrl| to the new
// URL. |redirectUrl| can be either a relative or fully qualified URL. It is
// also possible to set |response| to a redirect http status code and pass the
// new URL via a Location header. Likewise with |redirectUrl| it is valid to
// set a relative or fully qualified URL as the Location header value. If an
// error occured while setting up the request you can call set_error() on
// |response| to indicate the error condition.
///
//export cefingo_resource_handler_get_response_headers
func cefingo_resource_handler_get_response_headers(
	self *C.cef_resource_handler_t,
	response *C.cef_response_t,
	response_length *C.int64,
	redirectUrl *C.cef_string_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4341:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.get_response_headers_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpresponse := newCResponseT(response)
		goTmpresponse_length := (*int64)(response_length)
		var _redirectUrl string
		goTmpredirectUrl := &_redirectUrl

		f.GetResponseHeaders(goTmpself,goTmpresponse,goTmpresponse_length,goTmpredirectUrl,)
		BaseRelease(goTmpresponse.p_response)
		set_cef_string(redirectUrl, _redirectUrl)

	} else {
		Logf("T4358: get_response_headers: Noo!")
	}
	
}

///
// Skip response data when requested by a Range header. Skip over and discard
// |bytes_to_skip| bytes of response data. If data is available immediately
// set |bytes_skipped| to the number of bytes skipped and return true (1). To
// read the data at a later time set |bytes_skipped| to 0, return true (1) and
// execute |callback| when the data is available. To indicate failure set
// |bytes_skipped| to &lt; 0 (e.g. -2 for ERR_FAILED) and return false (0). This
// function will be called in sequence but not from a dedicated thread.
///
//export cefingo_resource_handler_skip
func cefingo_resource_handler_skip(
	self *C.cef_resource_handler_t,
	bytes_to_skip C.int64,
	bytes_skipped *C.int64,
	callback *C.cef_resource_skip_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4382:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.skip_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpbytes_to_skip := (int64)(bytes_to_skip)
		goTmpbytes_skipped := (*int64)(bytes_skipped)
		goTmpcallback := newCResourceSkipCallbackT(callback)

		goRet := f.Skip(goTmpself,goTmpbytes_to_skip,goTmpbytes_skipped,goTmpcallback,)
		BaseRelease(goTmpcallback.p_resource_skip_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T4398: skip: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time keep a
// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
// |callback| when the data is available (|data_out| will remain valid until
// the callback is executed). To indicate response completion set |bytes_read|
// to 0 and return false (0). To indicate failure set |bytes_read| to &lt; 0
// (e.g. -2 for ERR_FAILED) and return false (0). This function will be called
// in sequence but not from a dedicated thread. For backwards compatibility
// set |bytes_read| to -1 and return false (0) and the ReadResponse function
// will be called.
///
//export cefingo_resource_handler_read
func cefingo_resource_handler_read(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_resource_read_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4427:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		var _bytes_read int
		goTmpbytes_read := &_bytes_read
		goTmpcallback := newCResourceReadCallbackT(callback)

		goRet := f.Read(goTmpself,goTmpdata_out,goTmpbytes_read,goTmpcallback,)
		*bytes_read = (C.int)(_bytes_read)
		BaseRelease(goTmpcallback.p_resource_read_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T4446: read: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time set
// |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when the
// data is available. To indicate response completion return false (0).
//
// WARNING: This function is deprecated. Use Skip and Read instead.
///
//export cefingo_resource_handler_read_response
func cefingo_resource_handler_read_response(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4470:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_response_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		var _bytes_read int
		goTmpbytes_read := &_bytes_read
		goTmpcallback := newCCallbackT(callback)

		goRet := f.ReadResponse(goTmpself,goTmpdata_out,goTmpbytes_read,goTmpcallback,)
		*bytes_read = (C.int)(_bytes_read)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {cRet = 1}
	} else {
		Logf("T4489: read_response: Noo!")
	}
	return cRet
}

///
// Request processing has been canceled.
///
//export cefingo_resource_handler_cancel
func cefingo_resource_handler_cancel(
	self *C.cef_resource_handler_t,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4503:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.cancel_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)

		f.Cancel(goTmpself,)

	} else {
		Logf("T4514: cancel: Noo!")
	}
	
}

///
// Return a new resource handler instance to handle the request or an NULL
// reference to allow default handling of the request. |browser| and |frame|
// will be the browser window and frame respectively that originated the
// request or NULL if the request did not originate from a browser window (for
// example, if the request came from cef_urlrequest_t). The |request| object
// passed to this function cannot be modified.
///
//export cefingo_scheme_handler_factory_create
func cefingo_scheme_handler_factory_create(
	self *C.cef_scheme_handler_factory_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	scheme_name *C.cef_string_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4538:")
	cefingoIfaceAccess.Lock()
	f := scheme_handler_factory_handlers.create_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCSchemeHandlerFactoryT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpscheme_name := string_from_cef_string(scheme_name)
		goTmprequest := newCRequestT(request)

		goRet := f.Create(goTmpself,goTmpbrowser,goTmpframe,goTmpscheme_name,goTmprequest,)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		cRet = (*C.cef_resource_handler_t)(goRet.p_resource_handler)
		BaseAddRef(cRet)
	} else {
		Logf("T4557: create: Noo!")
	}
	return cRet
}

///
// Handle execution of the function identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the function. |arguments| is the list of
// arguments passed to the function. If execution succeeds set |retval| to the
// function return value. If execution fails set |exception| to the exception
// that will be thrown. Return true (1) if execution was handled.
///
//export cefingo_v8handler_execute
func cefingo_v8handler_execute(
	self *C.cef_v8handler_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	argumentsCount C.size_t,
	arguments **C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4583:")
	cefingoIfaceAccess.Lock()
	f := v8handler_handlers.execute_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8handlerT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)
		slice := (*[1 << 30](*C.cef_v8value_t))(unsafe.Pointer(arguments))[:argumentsCount:argumentsCount]
		goTmparguments := make([]*CV8valueT, argumentsCount)
		for i, v := range slice {
			goTmparguments[i] = newCV8valueT(v)
		}
		var _retval *CV8valueT
		goTmpretval := &_retval
		var _exception string
		goTmpexception := &_exception

		goRet := f.Execute(goTmpself,goTmpname,goTmpobject,goTmparguments,goTmpretval,goTmpexception,)
		BaseRelease(goTmpobject.p_v8value)
		if _retval != nil {
			*retval = _retval.p_v8value
			BaseAddRef(*retval)
		}
		set_cef_string(exception, _exception)

		if goRet {cRet = 1}
	} else {
		Logf("T4607: execute: Noo!")
	}
	return cRet
}

///
// Called to release |buffer| when the ArrayBuffer JS object is garbage
// collected. |buffer| is the value that was passed to CreateArrayBuffer along
// with this object.
///
//export cefingo_v8array_buffer_release_callback_release_buffer
func cefingo_v8array_buffer_release_callback_release_buffer(
	self *C.cef_v8array_buffer_release_callback_t,
	buffer C.VOIDP,
)  {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4630:")
	cefingoIfaceAccess.Lock()
	f := v8array_buffer_release_callback_handlers.release_buffer_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8arrayBufferReleaseCallbackT(self)
		goTmpbuffer := unsafe.Pointer(buffer)

		f.ReleaseBuffer(goTmpself,goTmpbuffer,)

	} else {
		Logf("T4642: release_buffer: Noo!")
	}
	
}
// Not Formatted.!