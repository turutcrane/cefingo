// Code generated by "gen-cefingo.go" DO NOT EDIT.

package capi

import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"

///
// Called after renderer process sends accessibility tree changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_tree_change
func cefingo_accessibility_handler_on_accessibility_tree_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T101.6:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_tree_change_handler[(*cCAccessibilityHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityTreeChange(goTmpself, goTmpvalue)
		BaseRelease(goTmpvalue.pc_value)

	} else {
		Logf("T101.7: on_accessibility_tree_change: Noo!")
	}

}

///
// Called after renderer process sends accessibility location changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_location_change
func cefingo_accessibility_handler_on_accessibility_location_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T101.8:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_location_change_handler[(*cCAccessibilityHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityLocationChange(goTmpself, goTmpvalue)
		BaseRelease(goTmpvalue.pc_value)

	} else {
		Logf("T101.9: on_accessibility_location_change: Noo!")
	}

}

///
// Provides an opportunity to view and/or modify command-line arguments before
// processing by CEF and Chromium. The |process_type| value will be NULL for
// the browser process. Do not keep a reference to the cef_command_line_t
// object passed to this function. The CefSettings.command_line_args_disabled
// value can be used to start with an NULL command-line object. Any values
// specified in CefSettings that equate to command-line arguments will be set
// before this function is called. Be cautious when using this function to
// modify command-line arguments for non-browser processes as this may result
// in undefined behavior including crashes.
///
//export cefingo_app_on_before_command_line_processing
func cefingo_app_on_before_command_line_processing(
	self *C.cef_app_t,
	process_type *C.cef_string_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.6:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_before_command_line_processing_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpprocess_type := string_from_cef_string(process_type)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeCommandLineProcessing(goTmpself, goTmpprocess_type, goTmpcommand_line)
		BaseRelease(goTmpcommand_line.pc_command_line)

	} else {
		Logf("T102.7: on_before_command_line_processing: Noo!")
	}

}

///
// Provides an opportunity to register custom schemes. Do not keep a reference
// to the |registrar| object. This function is called on the main thread for
// each process and the registered schemes should be the same across all
// processes.
///
//export cefingo_app_on_register_custom_schemes
func cefingo_app_on_register_custom_schemes(
	self *C.cef_app_t,
	registrar *C.cef_scheme_registrar_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.8:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_register_custom_schemes_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpregistrar := newCSchemeRegistrarT(registrar)

		f.OnRegisterCustomSchemes(goTmpself, goTmpregistrar)

	} else {
		Logf("T102.9: on_register_custom_schemes: Noo!")
	}

}

///
// Return the handler for resource bundle events. If
// CefSettings.pack_loading_disabled is true (1) a handler must be returned.
// If no handler is returned resources will be loaded from pack files. This
// function is called by the browser and render processes on multiple threads.
///
//export cefingo_app_get_resource_bundle_handler
func cefingo_app_get_resource_bundle_handler(
	self *C.cef_app_t,
) (cRet *C.cef_resource_bundle_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.10:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.get_resource_bundle_handler_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)

		goRet := f.GetResourceBundleHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_resource_bundle_handler)
			cRet = (*C.cef_resource_bundle_handler_t)(goRet.pc_resource_bundle_handler)
		}
	} else {
		Logf("T102.11: get_resource_bundle_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for functionality specific to the browser process. This
// function is called on multiple threads in the browser process.
///
//export cefingo_app_get_browser_process_handler
func cefingo_app_get_browser_process_handler(
	self *C.cef_app_t,
) (cRet *C.cef_browser_process_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.12:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.get_browser_process_handler_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)

		goRet := f.GetBrowserProcessHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_browser_process_handler)
			cRet = (*C.cef_browser_process_handler_t)(goRet.pc_browser_process_handler)
		}
	} else {
		Logf("T102.13: get_browser_process_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for functionality specific to the render process. This
// function is called on the render process main thread.
///
//export cefingo_app_get_render_process_handler
func cefingo_app_get_render_process_handler(
	self *C.cef_app_t,
) (cRet *C.cef_render_process_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T102.14:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.get_render_process_handler_handler[(*cCAppT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)

		goRet := f.GetRenderProcessHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_render_process_handler)
			cRet = (*C.cef_render_process_handler_t)(goRet.pc_render_process_handler)
		}
	} else {
		Logf("T102.15: get_render_process_handler: Noo!")
	}
	return cRet
}

///
// Called on the UI thread to allow configuration of audio stream parameters.
// Return true (1) to proceed with audio stream capture, or false (0) to
// cancel it. All members of |params| can optionally be configured here, but
// they are also pre-filled with some sensible defaults.
///
//export cefingo_audio_handler_get_audio_parameters
func cefingo_audio_handler_get_audio_parameters(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	params *C.cef_audio_parameters_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.6:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.get_audio_parameters_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAudioHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpparams := (*CAudioParametersT)(params)

		goRet := f.GetAudioParameters(goTmpself, goTmpbrowser, goTmpparams)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T103.7: get_audio_parameters: Noo!")
	}
	return cRet
}

///
// Called on a browser audio capture thread when the browser starts streaming
// audio. OnAudioSteamStopped will always be called after
// OnAudioStreamStarted; both functions may be called multiple times for the
// same browser. |params| contains the audio parameters like sample rate and
// channel layout. |channels| is the number of channels.
///
//export cefingo_audio_handler_on_audio_stream_started
func cefingo_audio_handler_on_audio_stream_started(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	params *C.cef_audio_parameters_t,
	channels C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.8:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_started_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAudioHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpparams := (*CAudioParametersT)(params)
		goTmpchannels := (int)(channels)

		f.OnAudioStreamStarted(goTmpself, goTmpbrowser, goTmpparams, goTmpchannels)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T103.9: on_audio_stream_started: Noo!")
	}

}

///
// Called on the UI thread when the stream has stopped. OnAudioSteamStopped
// will always be called after OnAudioStreamStarted; both functions may be
// called multiple times for the same stream.
///
//export cefingo_audio_handler_on_audio_stream_stopped
func cefingo_audio_handler_on_audio_stream_stopped(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.10:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_stopped_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAudioHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnAudioStreamStopped(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T103.11: on_audio_stream_stopped: Noo!")
	}

}

///
// Called on the UI or audio stream thread when an error occurred. During the
// stream creation phase this callback will be called on the UI thread while
// in the capturing phase it will be called on the audio stream thread. The
// stream will be stopped immediately.
///
//export cefingo_audio_handler_on_audio_stream_error
func cefingo_audio_handler_on_audio_stream_error(
	self *C.cef_audio_handler_t,
	browser *C.cef_browser_t,
	message *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T103.12:")
	cefingoIfaceAccess.Lock()
	f := audio_handler_handlers.on_audio_stream_error_handler[(*cCAudioHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAudioHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmessage := string_from_cef_string(message)

		f.OnAudioStreamError(goTmpself, goTmpbrowser, goTmpmessage)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T103.13: on_audio_stream_error: Noo!")
	}

}

///
// Called asynchronously after the file dialog is dismissed.
// |selected_accept_filter| is the 0-based index of the value selected from
// the accept filters array passed to cef_browser_host_t::RunFileDialog.
// |file_paths| will be a single value or a list of values depending on the
// dialog mode. If the selection was cancelled |file_paths| will be NULL.
///
//export cefingo_run_file_dialog_callback_on_file_dialog_dismissed
func cefingo_run_file_dialog_callback_on_file_dialog_dismissed(
	self *C.cef_run_file_dialog_callback_t,
	selected_accept_filter C.int,
	file_paths C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T107.6:")
	cefingoIfaceAccess.Lock()
	f := run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler[(*cCRunFileDialogCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRunFileDialogCallbackT(self)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpfile_paths := (CStringListT)(file_paths)

		f.OnFileDialogDismissed(goTmpself, goTmpselected_accept_filter, goTmpfile_paths)

	} else {
		Logf("T107.7: on_file_dialog_dismissed: Noo!")
	}

}

///
// Method that will be executed. Do not keep a reference to |entry| outside of
// this callback. Return true (1) to continue visiting entries or false (0) to
// stop. |current| is true (1) if this entry is the currently loaded
// navigation entry. |index| is the 0-based index of this entry and |total| is
// the total number of entries.
///
//export cefingo_navigation_entry_visitor_visit
func cefingo_navigation_entry_visitor_visit(
	self *C.cef_navigation_entry_visitor_t,
	entry *C.cef_navigation_entry_t,
	current C.int,
	index C.int,
	total C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T108.6:")
	cefingoIfaceAccess.Lock()
	f := navigation_entry_visitor_handlers.visit_handler[(*cCNavigationEntryVisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCNavigationEntryVisitorT(self)
		goTmpentry := newCNavigationEntryT(entry)
		goTmpcurrent := current != 0
		goTmpindex := (int)(index)
		goTmptotal := (int)(total)

		goRet := f.Visit(goTmpself, goTmpentry, goTmpcurrent, goTmpindex, goTmptotal)
		BaseRelease(goTmpentry.pc_navigation_entry)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T108.7: visit: Noo!")
	}
	return cRet
}

///
// Called on the browser process UI thread immediately after the CEF context
// has been initialized.
///
//export cefingo_browser_process_handler_on_context_initialized
func cefingo_browser_process_handler_on_context_initialized(
	self *C.cef_browser_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.6:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_context_initialized_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)

		f.OnContextInitialized(goTmpself)

	} else {
		Logf("T112.7: on_context_initialized: Noo!")
	}

}

///
// Called before a child process is launched. Will be called on the browser
// process UI thread when launching a render process and on the browser
// process IO thread when launching a GPU or plugin process. Provides an
// opportunity to modify the child process command line. Do not keep a
// reference to |command_line| outside of this function.
///
//export cefingo_browser_process_handler_on_before_child_process_launch
func cefingo_browser_process_handler_on_before_child_process_launch(
	self *C.cef_browser_process_handler_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.8:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_before_child_process_launch_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeChildProcessLaunch(goTmpself, goTmpcommand_line)
		BaseRelease(goTmpcommand_line.pc_command_line)

	} else {
		Logf("T112.9: on_before_child_process_launch: Noo!")
	}

}

///
// Return the handler for printing on Linux. If a print handler is not
// provided then printing will not be supported on the Linux platform.
///
//export cefingo_browser_process_handler_get_print_handler
func cefingo_browser_process_handler_get_print_handler(
	self *C.cef_browser_process_handler_t,
) (cRet *C.cef_print_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.10:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.get_print_handler_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)

		goRet := f.GetPrintHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_print_handler)
			cRet = (*C.cef_print_handler_t)(goRet.pc_print_handler)
		}
	} else {
		Logf("T112.11: get_print_handler: Noo!")
	}
	return cRet
}

///
// Called from any thread when work has been scheduled for the browser process
// main (UI) thread. This callback is used in combination with CefSettings.
// external_message_pump and cef_do_message_loop_work() in cases where the CEF
// message loop must be integrated into an existing application message loop
// (see additional comments and warnings on CefDoMessageLoopWork). This
// callback should schedule a cef_do_message_loop_work() call to happen on the
// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
// |delay_ms| is &lt;= 0 then the call should happen reasonably soon. If
// |delay_ms| is &gt; 0 then the call should be scheduled to happen after the
// specified delay and any currently pending scheduled call should be
// cancelled.
///
//export cefingo_browser_process_handler_on_schedule_message_pump_work
func cefingo_browser_process_handler_on_schedule_message_pump_work(
	self *C.cef_browser_process_handler_t,
	delay_ms C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T112.12:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_schedule_message_pump_work_handler[(*cCBrowserProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpdelay_ms := (int64)(delay_ms)

		f.OnScheduleMessagePumpWork(goTmpself, goTmpdelay_ms)

	} else {
		Logf("T112.13: on_schedule_message_pump_work: Noo!")
	}

}

///
// Called when |browser| associated with |browser_view| is created. This
// function will be called after cef_life_span_handler_t::on_after_created()
// is called for |browser| and before on_popup_browser_view_created() is
// called for |browser|&#39;s parent delegate if |browser| is a popup.
///
//export cefingo_browser_view_delegate_on_browser_created
func cefingo_browser_view_delegate_on_browser_created(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.6:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_browser_created_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserCreated(goTmpself, goTmpbrowser_view, goTmpbrowser)
		BaseRelease(goTmpbrowser_view.pc_browser_view)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T114.7: on_browser_created: Noo!")
	}

}

///
// Called when |browser| associated with |browser_view| is destroyed. Release
// all references to |browser| and do not attempt to execute any functions on
// |browser| after this callback returns. This function will be called before
// cef_life_span_handler_t::on_before_close() is called for |browser|.
///
//export cefingo_browser_view_delegate_on_browser_destroyed
func cefingo_browser_view_delegate_on_browser_destroyed(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.8:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_browser_destroyed_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserDestroyed(goTmpself, goTmpbrowser_view, goTmpbrowser)
		BaseRelease(goTmpbrowser_view.pc_browser_view)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T114.9: on_browser_destroyed: Noo!")
	}

}

///
// Called before a new popup BrowserView is created. The popup originated from
// |browser_view|. |settings| and |client| are the values returned from
// cef_life_span_handler_t::on_before_popup(). |is_devtools| will be true (1)
// if the popup will be a DevTools browser. Return the delegate that will be
// used for the new popup BrowserView.
///
//export cefingo_browser_view_delegate_get_delegate_for_popup_browser_view
func cefingo_browser_view_delegate_get_delegate_for_popup_browser_view(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	settings *C.cef_browser_settings_t,
	client *C.cef_client_t,
	is_devtools C.int,
) (cRet *C.cef_browser_view_delegate_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.10:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmpsettings := (*CBrowserSettingsT)(settings)
		goTmpclient := newCClientT(client)
		goTmpis_devtools := is_devtools != 0

		goRet := f.GetDelegateForPopupBrowserView(goTmpself, goTmpbrowser_view, goTmpsettings, goTmpclient, goTmpis_devtools)
		BaseRelease(goTmpbrowser_view.pc_browser_view)
		BaseRelease(goTmpclient.pc_client)

		if goRet != nil {
			BaseAddRef(goRet.pc_browser_view_delegate)
			cRet = (*C.cef_browser_view_delegate_t)(goRet.pc_browser_view_delegate)
		}
	} else {
		Logf("T114.11: get_delegate_for_popup_browser_view: Noo!")
	}
	return cRet
}

///
// Called after |popup_browser_view| is created. This function will be called
// after cef_life_span_handler_t::on_after_created() and on_browser_created()
// are called for the new popup browser. The popup originated from
// |browser_view|. |is_devtools| will be true (1) if the popup is a DevTools
// browser. Optionally add |popup_browser_view| to the views hierarchy
// yourself and return true (1). Otherwise return false (0) and a default
// cef_window_t will be created for the popup.
///
//export cefingo_browser_view_delegate_on_popup_browser_view_created
func cefingo_browser_view_delegate_on_popup_browser_view_created(
	self *C.cef_browser_view_delegate_t,
	browser_view *C.cef_browser_view_t,
	popup_browser_view *C.cef_browser_view_t,
	is_devtools C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.12:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_popup_browser_view_created_handler[(*cCBrowserViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserViewDelegateT(self)
		goTmpbrowser_view := newCBrowserViewT(browser_view)
		goTmppopup_browser_view := newCBrowserViewT(popup_browser_view)
		goTmpis_devtools := is_devtools != 0

		goRet := f.OnPopupBrowserViewCreated(goTmpself, goTmpbrowser_view, goTmppopup_browser_view, goTmpis_devtools)
		BaseRelease(goTmpbrowser_view.pc_browser_view)
		BaseRelease(goTmppopup_browser_view.pc_browser_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T114.13: on_popup_browser_view_created: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_preferred_size
func cefingo_browser_view_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.14:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_preferred_size_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T114.15: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_minimum_size
func cefingo_browser_view_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.16:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_minimum_size_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T114.17: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_maximum_size
func cefingo_browser_view_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.18:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_maximum_size_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T114.19: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_get_height_for_width
func cefingo_browser_view_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.20:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.get_height_for_width_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.pc_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T114.21: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_browser_view_delegate_on_parent_view_changed
func cefingo_browser_view_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.22:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_parent_view_changed_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpparent.pc_view)

	} else {
		Logf("T114.23: on_parent_view_changed: Noo!")
	}

}

//export cefingo_browser_view_delegate_on_child_view_changed
func cefingo_browser_view_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.24:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_child_view_changed_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpchild.pc_view)

	} else {
		Logf("T114.25: on_child_view_changed: Noo!")
	}

}

//export cefingo_browser_view_delegate_on_focus
func cefingo_browser_view_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.26:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_focus_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T114.27: on_focus: Noo!")
	}

}

//export cefingo_browser_view_delegate_on_blur
func cefingo_browser_view_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T114.28:")
	cefingoIfaceAccess.Lock()
	f := browser_view_delegate_handlers.on_blur_handler[(*cCBrowserViewDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T114.29: on_blur: Noo!")
	}

}

///
// Called when |button| is pressed.
///
//export cefingo_button_delegate_on_button_pressed
func cefingo_button_delegate_on_button_pressed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.6:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_button_pressed_handler[(*cCButtonDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonPressed(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.pc_button)

	} else {
		Logf("T116.7: on_button_pressed: Noo!")
	}

}

///
// Called when the state of |button| changes.
///
//export cefingo_button_delegate_on_button_state_changed
func cefingo_button_delegate_on_button_state_changed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.8:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_button_state_changed_handler[(*cCButtonDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonStateChanged(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.pc_button)

	} else {
		Logf("T116.9: on_button_state_changed: Noo!")
	}

}

//export cefingo_button_delegate_get_preferred_size
func cefingo_button_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.10:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_preferred_size_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T116.11: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_get_minimum_size
func cefingo_button_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.12:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_minimum_size_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T116.13: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_get_maximum_size
func cefingo_button_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.14:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_maximum_size_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T116.15: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_get_height_for_width
func cefingo_button_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.16:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.get_height_for_width_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.pc_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T116.17: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_button_delegate_on_parent_view_changed
func cefingo_button_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.18:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_parent_view_changed_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpparent.pc_view)

	} else {
		Logf("T116.19: on_parent_view_changed: Noo!")
	}

}

//export cefingo_button_delegate_on_child_view_changed
func cefingo_button_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.20:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_child_view_changed_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpchild.pc_view)

	} else {
		Logf("T116.21: on_child_view_changed: Noo!")
	}

}

//export cefingo_button_delegate_on_focus
func cefingo_button_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.22:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_focus_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T116.23: on_focus: Noo!")
	}

}

//export cefingo_button_delegate_on_blur
func cefingo_button_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T116.24:")
	cefingoIfaceAccess.Lock()
	f := button_delegate_handlers.on_blur_handler[(*cCButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T116.25: on_blur: Noo!")
	}

}

///
// Return the handler for audio rendering events.
///
//export cefingo_client_get_audio_handler
func cefingo_client_get_audio_handler(
	self *C.cef_client_t,
) (cRet *C.cef_audio_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.6:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_audio_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetAudioHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_audio_handler)
			cRet = (*C.cef_audio_handler_t)(goRet.pc_audio_handler)
		}
	} else {
		Logf("T119.7: get_audio_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for context menus. If no handler is provided the default
// implementation will be used.
///
//export cefingo_client_get_context_menu_handler
func cefingo_client_get_context_menu_handler(
	self *C.cef_client_t,
) (cRet *C.cef_context_menu_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.8:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_context_menu_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetContextMenuHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_context_menu_handler)
			cRet = (*C.cef_context_menu_handler_t)(goRet.pc_context_menu_handler)
		}
	} else {
		Logf("T119.9: get_context_menu_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for dialogs. If no handler is provided the default
// implementation will be used.
///
//export cefingo_client_get_dialog_handler
func cefingo_client_get_dialog_handler(
	self *C.cef_client_t,
) (cRet *C.cef_dialog_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.10:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_dialog_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetDialogHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_dialog_handler)
			cRet = (*C.cef_dialog_handler_t)(goRet.pc_dialog_handler)
		}
	} else {
		Logf("T119.11: get_dialog_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for browser display state events.
///
//export cefingo_client_get_display_handler
func cefingo_client_get_display_handler(
	self *C.cef_client_t,
) (cRet *C.cef_display_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.12:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_display_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetDisplayHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_display_handler)
			cRet = (*C.cef_display_handler_t)(goRet.pc_display_handler)
		}
	} else {
		Logf("T119.13: get_display_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for download events. If no handler is returned downloads
// will not be allowed.
///
//export cefingo_client_get_download_handler
func cefingo_client_get_download_handler(
	self *C.cef_client_t,
) (cRet *C.cef_download_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.14:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_download_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetDownloadHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_download_handler)
			cRet = (*C.cef_download_handler_t)(goRet.pc_download_handler)
		}
	} else {
		Logf("T119.15: get_download_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for drag events.
///
//export cefingo_client_get_drag_handler
func cefingo_client_get_drag_handler(
	self *C.cef_client_t,
) (cRet *C.cef_drag_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.16:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_drag_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetDragHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_drag_handler)
			cRet = (*C.cef_drag_handler_t)(goRet.pc_drag_handler)
		}
	} else {
		Logf("T119.17: get_drag_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for find result events.
///
//export cefingo_client_get_find_handler
func cefingo_client_get_find_handler(
	self *C.cef_client_t,
) (cRet *C.cef_find_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.18:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_find_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetFindHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_find_handler)
			cRet = (*C.cef_find_handler_t)(goRet.pc_find_handler)
		}
	} else {
		Logf("T119.19: get_find_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for focus events.
///
//export cefingo_client_get_focus_handler
func cefingo_client_get_focus_handler(
	self *C.cef_client_t,
) (cRet *C.cef_focus_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.20:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_focus_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetFocusHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_focus_handler)
			cRet = (*C.cef_focus_handler_t)(goRet.pc_focus_handler)
		}
	} else {
		Logf("T119.21: get_focus_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for JavaScript dialogs. If no handler is provided the
// default implementation will be used.
///
//export cefingo_client_get_jsdialog_handler
func cefingo_client_get_jsdialog_handler(
	self *C.cef_client_t,
) (cRet *C.cef_jsdialog_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.22:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_jsdialog_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetJsdialogHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_jsdialog_handler)
			cRet = (*C.cef_jsdialog_handler_t)(goRet.pc_jsdialog_handler)
		}
	} else {
		Logf("T119.23: get_jsdialog_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for keyboard events.
///
//export cefingo_client_get_keyboard_handler
func cefingo_client_get_keyboard_handler(
	self *C.cef_client_t,
) (cRet *C.cef_keyboard_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.24:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_keyboard_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetKeyboardHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_keyboard_handler)
			cRet = (*C.cef_keyboard_handler_t)(goRet.pc_keyboard_handler)
		}
	} else {
		Logf("T119.25: get_keyboard_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for browser life span events.
///
//export cefingo_client_get_life_span_handler
func cefingo_client_get_life_span_handler(
	self *C.cef_client_t,
) (cRet *C.cef_life_span_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.26:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_life_span_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetLifeSpanHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_life_span_handler)
			cRet = (*C.cef_life_span_handler_t)(goRet.pc_life_span_handler)
		}
	} else {
		Logf("T119.27: get_life_span_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for browser load status events.
///
//export cefingo_client_get_load_handler
func cefingo_client_get_load_handler(
	self *C.cef_client_t,
) (cRet *C.cef_load_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.28:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_load_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetLoadHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_load_handler)
			cRet = (*C.cef_load_handler_t)(goRet.pc_load_handler)
		}
	} else {
		Logf("T119.29: get_load_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for off-screen rendering events.
///
//export cefingo_client_get_render_handler
func cefingo_client_get_render_handler(
	self *C.cef_client_t,
) (cRet *C.cef_render_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.30:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_render_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetRenderHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_render_handler)
			cRet = (*C.cef_render_handler_t)(goRet.pc_render_handler)
		}
	} else {
		Logf("T119.31: get_render_handler: Noo!")
	}
	return cRet
}

///
// Return the handler for browser request events.
///
//export cefingo_client_get_request_handler
func cefingo_client_get_request_handler(
	self *C.cef_client_t,
) (cRet *C.cef_request_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.32:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.get_request_handler_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)

		goRet := f.GetRequestHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_request_handler)
			cRet = (*C.cef_request_handler_t)(goRet.pc_request_handler)
		}
	} else {
		Logf("T119.33: get_request_handler: Noo!")
	}
	return cRet
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_client_on_process_message_received
func cefingo_client_on_process_message_received(
	self *C.cef_client_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T119.34:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.on_process_message_received_handler[(*cCClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpmessage.pc_process_message)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T119.35: on_process_message_received: Noo!")
	}
	return cRet
}

///
// Called before a context menu is displayed. |params| provides information
// about the context menu state. |model| initially contains the default
// context menu. The |model| can be cleared to show no context menu or
// modified to show a custom menu. Do not keep references to |params| or
// |model| outside of this callback.
///
//export cefingo_context_menu_handler_on_before_context_menu
func cefingo_context_menu_handler_on_before_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.6:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_before_context_menu_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)

		f.OnBeforeContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpparams.pc_context_menu_params)
		BaseRelease(goTmpmodel.pc_menu_model)

	} else {
		Logf("T122.7: on_before_context_menu: Noo!")
	}

}

///
// Called to allow custom display of the context menu. |params| provides
// information about the context menu state. |model| contains the context menu
// model resulting from OnBeforeContextMenu. For custom display return true
// (1) and execute |callback| either synchronously or asynchronously with the
// selected command ID. For default display return false (0). Do not keep
// references to |params| or |model| outside of this callback.
///
//export cefingo_context_menu_handler_run_context_menu
func cefingo_context_menu_handler_run_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
	callback *C.cef_run_context_menu_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.8:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.run_context_menu_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)
		goTmpcallback := newCRunContextMenuCallbackT(callback)

		goRet := f.RunContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpparams.pc_context_menu_params)
		BaseRelease(goTmpmodel.pc_menu_model)
		BaseRelease(goTmpcallback.pc_run_context_menu_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T122.9: run_context_menu: Noo!")
	}
	return cRet
}

///
// Called to execute a command selected from the context menu. Return true (1)
// if the command was handled or false (0) for the default implementation. See
// cef_menu_id_t for the command ids that have default implementations. All
// user-defined command ids should be between MENU_ID_USER_FIRST and
// MENU_ID_USER_LAST. |params| will have the same values as what was passed to
// on_before_context_menu(). Do not keep a reference to |params| outside of
// this callback.
///
//export cefingo_context_menu_handler_on_context_menu_command
func cefingo_context_menu_handler_on_context_menu_command(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.10:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_command_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		goRet := f.OnContextMenuCommand(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpcommand_id, goTmpevent_flags)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpparams.pc_context_menu_params)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T122.11: on_context_menu_command: Noo!")
	}
	return cRet
}

///
// Called when the context menu is dismissed irregardless of whether the menu
// was NULL or a command was selected.
///
//export cefingo_context_menu_handler_on_context_menu_dismissed
func cefingo_context_menu_handler_on_context_menu_dismissed(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T122.12:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_dismissed_handler[(*cCContextMenuHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)

		f.OnContextMenuDismissed(goTmpself, goTmpbrowser, goTmpframe)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)

	} else {
		Logf("T122.13: on_context_menu_dismissed: Noo!")
	}

}

///
// Method that will be called once for each cookie. |count| is the 0-based
// index for the current cookie. |total| is the total number of cookies. Set
// |deleteCookie| to true (1) to delete the cookie currently being visited.
// Return false (0) to stop visiting cookies. This function may never be
// called if no cookies are found.
///
//export cefingo_cookie_visitor_visit
func cefingo_cookie_visitor_visit(
	self *C.cef_cookie_visitor_t,
	cookie *C.cef_cookie_t,
	count C.int,
	total C.int,
	deleteCookie *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T125.6:")
	cefingoIfaceAccess.Lock()
	f := cookie_visitor_handlers.visit_handler[(*cCCookieVisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCCookieVisitorT(self)
		goTmpcookie := (*CCookieT)(cookie)
		goTmpcount := (int)(count)
		goTmptotal := (int)(total)

		goRet, goTmpdeleteCookieOut := f.Visit(goTmpself, goTmpcookie, goTmpcount, goTmptotal)
		*deleteCookie = (C.int)(goTmpdeleteCookieOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T125.7: visit: Noo!")
	}
	return cRet
}

///
// Method that will be called upon completion. |success| will be true (1) if
// the cookie was set successfully.
///
//export cefingo_set_cookie_callback_on_complete
func cefingo_set_cookie_callback_on_complete(
	self *C.cef_set_cookie_callback_t,
	success C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T126.6:")
	cefingoIfaceAccess.Lock()
	f := set_cookie_callback_handlers.on_complete_handler[(*cCSetCookieCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCSetCookieCallbackT(self)
		goTmpsuccess := (int)(success)

		f.OnComplete(goTmpself, goTmpsuccess)

	} else {
		Logf("T126.7: on_complete: Noo!")
	}

}

///
// Method that will be called upon completion. |num_deleted| will be the
// number of cookies that were deleted.
///
//export cefingo_delete_cookies_callback_on_complete
func cefingo_delete_cookies_callback_on_complete(
	self *C.cef_delete_cookies_callback_t,
	num_deleted C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T127.6:")
	cefingoIfaceAccess.Lock()
	f := delete_cookies_callback_handlers.on_complete_handler[(*cCDeleteCookiesCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDeleteCookiesCallbackT(self)
		goTmpnum_deleted := (int)(num_deleted)

		f.OnComplete(goTmpself, goTmpnum_deleted)

	} else {
		Logf("T127.7: on_complete: Noo!")
	}

}

///
// Method that will be called on receipt of a DevTools protocol message.
// |browser| is the originating browser instance. |message| is a UTF8-encoded
// JSON dictionary representing either a function result or an event.
// |message| is only valid for the scope of this callback and should be copied
// if necessary. Return true (1) if the message was handled or false (0) if
// the message should be further processed and passed to the
// OnDevToolsMethodResult or OnDevToolsEvent functions as appropriate.
//
// Method result dictionaries include an &quot;id&quot; (int) value that identifies the
// orginating function call sent from cef_browser_host_t::SendDevToolsMessage,
// and optionally either a &quot;result&quot; (dictionary) or &quot;error&quot; (dictionary)
// value. The &quot;error&quot; dictionary will contain &quot;code&quot; (int) and &quot;message&quot;
// (string) values. Event dictionaries include a &quot;function&quot; (string) value and
// optionally a &quot;params&quot; (dictionary) value. See the DevTools protocol
// documentation at https://chromedevtools.github.io/devtools-protocol/ for
// details of supported function calls and the expected &quot;result&quot; or &quot;params&quot;
// dictionary contents. JSON dictionaries can be parsed using the CefParseJSON
// function if desired, however be aware of performance considerations when
// parsing large messages (some of which may exceed 1MB in size).
///
//export cefingo_dev_tools_message_observer_on_dev_tools_message
func cefingo_dev_tools_message_observer_on_dev_tools_message(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
	message C.VOIDP,
	message_size C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.6:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_message_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDevToolsMessageObserverT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmessage := (*[1 << 30]byte)(message)[:message_size:message_size]

		goRet := f.OnDevToolsMessage(goTmpself, goTmpbrowser, goTmpmessage)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T128.7: on_dev_tools_message: Noo!")
	}
	return cRet
}

///
// Method that will be called after attempted execution of a DevTools protocol
// function. |browser| is the originating browser instance. |message_id| is
// the &quot;id&quot; value that identifies the originating function call message. If
// the function succeeded |success| will be true (1) and |result| will be the
// UTF8-encoded JSON &quot;result&quot; dictionary value (which may be NULL). If the
// function failed |success| will be false (0) and |result| will be the
// UTF8-encoded JSON &quot;error&quot; dictionary value. |result| is only valid for the
// scope of this callback and should be copied if necessary. See the
// OnDevToolsMessage documentation for additional details on |result|
// contents.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_method_result
func cefingo_dev_tools_message_observer_on_dev_tools_method_result(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
	message_id C.int,
	success C.int,
	result C.VOIDP,
	result_size C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.8:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_method_result_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDevToolsMessageObserverT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmessage_id := (int)(message_id)
		goTmpsuccess := (int)(success)
		goTmpresult := (*[1 << 30]byte)(result)[:result_size:result_size]

		f.OnDevToolsMethodResult(goTmpself, goTmpbrowser, goTmpmessage_id, goTmpsuccess, goTmpresult)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T128.9: on_dev_tools_method_result: Noo!")
	}

}

///
// Method that will be called on receipt of a DevTools protocol event.
// |browser| is the originating browser instance. |function| is the &quot;function&quot;
// value. |params| is the UTF8-encoded JSON &quot;params&quot; dictionary value (which
// may be NULL). |params| is only valid for the scope of this callback and
// should be copied if necessary. See the OnDevToolsMessage documentation for
// additional details on |params| contents.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_event
func cefingo_dev_tools_message_observer_on_dev_tools_event(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
	method *C.cef_string_t,
	params C.VOIDP,
	params_size C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.10:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_event_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDevToolsMessageObserverT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmethod := string_from_cef_string(method)
		goTmpparams := (*[1 << 30]byte)(params)[:params_size:params_size]

		f.OnDevToolsEvent(goTmpself, goTmpbrowser, goTmpmethod, goTmpparams)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T128.11: on_dev_tools_event: Noo!")
	}

}

///
// Method that will be called when the DevTools agent has attached. |browser|
// is the originating browser instance. This will generally occur in response
// to the first message sent while the agent is detached.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_agent_attached
func cefingo_dev_tools_message_observer_on_dev_tools_agent_attached(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.12:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_agent_attached_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDevToolsMessageObserverT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnDevToolsAgentAttached(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T128.13: on_dev_tools_agent_attached: Noo!")
	}

}

///
// Method that will be called when the DevTools agent has detached. |browser|
// is the originating browser instance. Any function results that were pending
// before the agent became detached will not be delivered, and any active
// event subscriptions will be canceled.
///
//export cefingo_dev_tools_message_observer_on_dev_tools_agent_detached
func cefingo_dev_tools_message_observer_on_dev_tools_agent_detached(
	self *C.cef_dev_tools_message_observer_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T128.14:")
	cefingoIfaceAccess.Lock()
	f := dev_tools_message_observer_handlers.on_dev_tools_agent_detached_handler[(*cCDevToolsMessageObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDevToolsMessageObserverT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnDevToolsAgentDetached(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T128.15: on_dev_tools_agent_detached: Noo!")
	}

}

///
// Called to run a file chooser dialog. |mode| represents the type of dialog
// to display. |title| to the title to be used for the dialog and may be NULL
// to show the default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode).
// |default_file_path| is the path with optional directory and/or file name
// component that should be initially selected in the dialog. |accept_filters|
// are used to restrict the selectable file types and may any combination of
// (a) valid lower-cased MIME types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b)
// individual file extensions (e.g. &quot;.txt&quot; or &quot;.png&quot;), or (c) combined
// description and file extension delimited using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image
// Types|.png;.gif;.jpg&quot;). |selected_accept_filter| is the 0-based index of
// the filter that should be selected by default. To display a custom dialog
// return true (1) and execute |callback| either inline or at a later time. To
// display the default dialog return false (0).
///
//export cefingo_dialog_handler_on_file_dialog
func cefingo_dialog_handler_on_file_dialog(
	self *C.cef_dialog_handler_t,
	browser *C.cef_browser_t,
	mode C.cef_file_dialog_mode_t,
	title *C.cef_string_t,
	default_file_path *C.cef_string_t,
	accept_filters C.cef_string_list_t,
	selected_accept_filter C.int,
	callback *C.cef_file_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T130.6:")
	cefingoIfaceAccess.Lock()
	f := dialog_handler_handlers.on_file_dialog_handler[(*cCDialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmode := CFileDialogModeT(mode)
		goTmptitle := string_from_cef_string(title)
		goTmpdefault_file_path := string_from_cef_string(default_file_path)
		goTmpaccept_filters := (CStringListT)(accept_filters)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpcallback := newCFileDialogCallbackT(callback)

		goRet := f.OnFileDialog(goTmpself, goTmpbrowser, goTmpmode, goTmptitle, goTmpdefault_file_path, goTmpaccept_filters, goTmpselected_accept_filter, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_file_dialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T130.7: on_file_dialog: Noo!")
	}
	return cRet
}

///
// Called when a frame&#39;s address has changed.
///
//export cefingo_display_handler_on_address_change
func cefingo_display_handler_on_address_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.6:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_address_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpurl := string_from_cef_string(url)

		f.OnAddressChange(goTmpself, goTmpbrowser, goTmpframe, goTmpurl)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)

	} else {
		Logf("T132.7: on_address_change: Noo!")
	}

}

///
// Called when the page title changes.
///
//export cefingo_display_handler_on_title_change
func cefingo_display_handler_on_title_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	title *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.8:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_title_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptitle := string_from_cef_string(title)

		f.OnTitleChange(goTmpself, goTmpbrowser, goTmptitle)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T132.9: on_title_change: Noo!")
	}

}

///
// Called when the page icon changes.
///
//export cefingo_display_handler_on_favicon_urlchange
func cefingo_display_handler_on_favicon_urlchange(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	icon_urls C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.10:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_favicon_urlchange_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpicon_urls := (CStringListT)(icon_urls)

		f.OnFaviconUrlchange(goTmpself, goTmpbrowser, goTmpicon_urls)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T132.11: on_favicon_urlchange: Noo!")
	}

}

///
// Called when web content in the page has toggled fullscreen mode. If
// |fullscreen| is true (1) the content will automatically be sized to fill
// the browser content area. If |fullscreen| is false (0) the content will
// automatically return to its original size and position. The client is
// responsible for resizing the browser if desired.
///
//export cefingo_display_handler_on_fullscreen_mode_change
func cefingo_display_handler_on_fullscreen_mode_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	fullscreen C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.12:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_fullscreen_mode_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfullscreen := (int)(fullscreen)

		f.OnFullscreenModeChange(goTmpself, goTmpbrowser, goTmpfullscreen)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T132.13: on_fullscreen_mode_change: Noo!")
	}

}

///
// Called when the browser is about to display a tooltip. |text| contains the
// text that will be displayed in the tooltip. To handle the display of the
// tooltip yourself return true (1). Otherwise, you can optionally modify
// |text| and then return false (0) to allow the browser to display the
// tooltip. When window rendering is disabled the application is responsible
// for drawing tooltips and the return value is ignored.
///
//export cefingo_display_handler_on_tooltip
func cefingo_display_handler_on_tooltip(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	text *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.14:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_tooltip_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptext := string_from_cef_string(text)

		goRet, goTmptextOut := f.OnTooltip(goTmpself, goTmpbrowser, goTmptext)
		BaseRelease(goTmpbrowser.pc_browser)
		set_cef_string(text, goTmptextOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T132.15: on_tooltip: Noo!")
	}
	return cRet
}

///
// Called when the browser receives a status message. |value| contains the
// text that will be displayed in the status message.
///
//export cefingo_display_handler_on_status_message
func cefingo_display_handler_on_status_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	value *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.16:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_status_message_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpvalue := string_from_cef_string(value)

		f.OnStatusMessage(goTmpself, goTmpbrowser, goTmpvalue)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T132.17: on_status_message: Noo!")
	}

}

///
// Called to display a console message. Return true (1) to stop the message
// from being output to the console.
///
//export cefingo_display_handler_on_console_message
func cefingo_display_handler_on_console_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	level C.cef_log_severity_t,
	message *C.cef_string_t,
	source *C.cef_string_t,
	line C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.18:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_console_message_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmplevel := CLogSeverityT(level)
		goTmpmessage := string_from_cef_string(message)
		goTmpsource := string_from_cef_string(source)
		goTmpline := (int)(line)

		goRet := f.OnConsoleMessage(goTmpself, goTmpbrowser, goTmplevel, goTmpmessage, goTmpsource, goTmpline)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T132.19: on_console_message: Noo!")
	}
	return cRet
}

///
// Called when auto-resize is enabled via
// cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-
// resized. |new_size| will be the desired size in view coordinates. Return
// true (1) if the resize was handled or false (0) for default handling.
///
//export cefingo_display_handler_on_auto_resize
func cefingo_display_handler_on_auto_resize(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	new_size *C.cef_size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.20:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_auto_resize_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnew_size := (*CSizeT)(new_size)

		goRet := f.OnAutoResize(goTmpself, goTmpbrowser, goTmpnew_size)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T132.21: on_auto_resize: Noo!")
	}
	return cRet
}

///
// Called when the overall page loading progress has changed. |progress|
// ranges from 0.0 to 1.0.
///
//export cefingo_display_handler_on_loading_progress_change
func cefingo_display_handler_on_loading_progress_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	progress C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T132.22:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_loading_progress_change_handler[(*cCDisplayHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpprogress := (float64)(progress)

		f.OnLoadingProgressChange(goTmpself, goTmpbrowser, goTmpprogress)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T132.23: on_loading_progress_change: Noo!")
	}

}

///
// Method executed for visiting the DOM. The document object passed to this
// function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_domvisitor_visit
func cefingo_domvisitor_visit(
	self *C.cef_domvisitor_t,
	document *C.cef_domdocument_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T133.6:")
	cefingoIfaceAccess.Lock()
	f := domvisitor_handlers.visit_handler[(*cCDomvisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDomvisitorT(self)
		goTmpdocument := newCDomdocumentT(document)

		f.Visit(goTmpself, goTmpdocument)
		BaseRelease(goTmpdocument.pc_domdocument)

	} else {
		Logf("T133.7: visit: Noo!")
	}

}

///
// Called before a download begins. |suggested_name| is the suggested name for
// the download file. By default the download will be canceled. Execute
// |callback| either asynchronously or in this function to continue the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_before_download
func cefingo_download_handler_on_before_download(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	suggested_name *C.cef_string_t,
	callback *C.cef_before_download_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T138.6:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_before_download_handler[(*cCDownloadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpsuggested_name := string_from_cef_string(suggested_name)
		goTmpcallback := newCBeforeDownloadCallbackT(callback)

		f.OnBeforeDownload(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpsuggested_name, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpdownload_item.pc_download_item)
		BaseRelease(goTmpcallback.pc_before_download_callback)

	} else {
		Logf("T138.7: on_before_download: Noo!")
	}

}

///
// Called when a download&#39;s status or progress information has been updated.
// This may be called multiple times before and after on_before_download().
// Execute |callback| either asynchronously or in this function to cancel the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_download_updated
func cefingo_download_handler_on_download_updated(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	callback *C.cef_download_item_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T138.8:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_download_updated_handler[(*cCDownloadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpcallback := newCDownloadItemCallbackT(callback)

		f.OnDownloadUpdated(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpdownload_item.pc_download_item)
		BaseRelease(goTmpcallback.pc_download_item_callback)

	} else {
		Logf("T138.9: on_download_updated: Noo!")
	}

}

///
// Called when an external drag event enters the browser window. |dragData|
// contains the drag event data and |mask| represents the type of drag
// operation. Return false (0) for default drag handling behavior or true (1)
// to cancel the drag event.
///
//export cefingo_drag_handler_on_drag_enter
func cefingo_drag_handler_on_drag_enter(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	dragData *C.cef_drag_data_t,
	mask C.cef_drag_operations_mask_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T141.6:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_drag_enter_handler[(*cCDragHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdragData := newCDragDataT(dragData)
		goTmpmask := CDragOperationsMaskT(mask)

		goRet := f.OnDragEnter(goTmpself, goTmpbrowser, goTmpdragData, goTmpmask)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpdragData.pc_drag_data)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T141.7: on_drag_enter: Noo!")
	}
	return cRet
}

///
// Called whenever draggable regions for the browser window change. These can
// be specified using the &#39;-webkit-app-region: drag/no-drag&#39; CSS-property. If
// draggable regions are never defined in a document this function will also
// never be called. If the last draggable region is removed from a document
// this function will be called with an NULL vector.
///
//export cefingo_drag_handler_on_draggable_regions_changed
func cefingo_drag_handler_on_draggable_regions_changed(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	regionsCount C.size_t,
	regions *C.cef_draggable_region_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T141.8:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_draggable_regions_changed_handler[(*cCDragHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpregionsCount := (int64)(regionsCount)
		goTmpregions := (*CDraggableRegionT)(regions)

		f.OnDraggableRegionsChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpregionsCount, goTmpregions)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)

	} else {
		Logf("T141.9: on_draggable_regions_changed: Noo!")
	}

}

///
// Called if the cef_request_context_t::LoadExtension request fails. |result|
// will be the error code.
///
//export cefingo_extension_handler_on_extension_load_failed
func cefingo_extension_handler_on_extension_load_failed(
	self *C.cef_extension_handler_t,
	result C.cef_errorcode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.6:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_load_failed_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpresult := CErrorcodeT(result)

		f.OnExtensionLoadFailed(goTmpself, goTmpresult)

	} else {
		Logf("T144.7: on_extension_load_failed: Noo!")
	}

}

///
// Called if the cef_request_context_t::LoadExtension request succeeds.
// |extension| is the loaded extension.
///
//export cefingo_extension_handler_on_extension_loaded
func cefingo_extension_handler_on_extension_loaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.8:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_loaded_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionLoaded(goTmpself, goTmpextension)
		BaseRelease(goTmpextension.pc_extension)

	} else {
		Logf("T144.9: on_extension_loaded: Noo!")
	}

}

///
// Called after the cef_extension_t::Unload request has completed.
///
//export cefingo_extension_handler_on_extension_unloaded
func cefingo_extension_handler_on_extension_unloaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.10:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_unloaded_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionUnloaded(goTmpself, goTmpextension)
		BaseRelease(goTmpextension.pc_extension)

	} else {
		Logf("T144.11: on_extension_unloaded: Noo!")
	}

}

///
// Called when an extension needs a browser to host a background script
// specified via the &quot;background&quot; manifest key. The browser will have no
// visible window and cannot be displayed. |extension| is the extension that
// is loading the background script. |url| is an internally generated
// reference to an HTML page that will be used to load the background script
// via a &lt;script&gt; src attribute. To allow creation of the browser optionally
// modify |client| and |settings| and return false (0). To cancel creation of
// the browser (and consequently cancel load of the background script) return
// true (1). Successful creation will be indicated by a call to
// cef_life_span_handler_t::OnAfterCreated, and
// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
// browser. See https://developer.chrome.com/extensions/event_pages for more
// information about extension background script usage.
///
//export cefingo_extension_handler_on_before_background_browser
func cefingo_extension_handler_on_before_background_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	url *C.cef_string_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.12:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_background_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpurl := string_from_cef_string(url)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.pc_client
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBackgroundBrowser(goTmpself, goTmpextension, goTmpurl, goTmpclient, goTmpsettings)
		BaseRelease(goTmpextension.pc_extension)
		if cefp != goTmpclientOut.pc_client {
			BaseAddRef(goTmpclientOut.pc_client)
			*client = (*C.cef_client_t)(goTmpclientOut.pc_client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.13: on_before_background_browser: Noo!")
	}
	return cRet
}

///
// Called when an extension API (e.g. chrome.tabs.create) requests creation of
// a new browser. |extension| and |browser| are the source of the API call.
// |active_browser| may optionally be specified via the windowId property or
// returned via the get_active_browser() callback and provides the default
// |client| and |settings| values for the new browser. |index| is the position
// value optionally specified via the index property. |url| is the URL that
// will be loaded in the browser. |active| is true (1) if the new browser
// should be active when opened.  To allow creation of the browser optionally
// modify |windowInfo|, |client| and |settings| and return false (0). To
// cancel creation of the browser return true (1). Successful creation will be
// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
// modifications to |windowInfo| will be ignored if |active_browser| is
// wrapped in a cef_browser_view_t.
///
//export cefingo_extension_handler_on_before_browser
func cefingo_extension_handler_on_before_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	active_browser *C.cef_browser_t,
	index C.int,
	url *C.cef_string_t,
	active C.int,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.14:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpactive_browser := newCBrowserT(active_browser)
		goTmpindex := (int)(index)
		goTmpurl := string_from_cef_string(url)
		goTmpactive := (int)(active)
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.pc_client
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpactive_browser, goTmpindex, goTmpurl, goTmpactive, goTmpwindowInfo, goTmpclient, goTmpsettings)
		BaseRelease(goTmpextension.pc_extension)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpactive_browser.pc_browser)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.pc_client {
			BaseAddRef(goTmpclientOut.pc_client)
			*client = (*C.cef_client_t)(goTmpclientOut.pc_client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.15: on_before_browser: Noo!")
	}
	return cRet
}

///
// Called when no tabId is specified to an extension API call that accepts a
// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
// source of the API call. Return the browser that will be acted on by the API
// call or return NULL to act on |browser|. The returned browser must share
// the same cef_request_context_t as |browser|. Incognito browsers should not
// be considered unless the source extension has incognito access enabled, in
// which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_get_active_browser
func cefingo_extension_handler_get_active_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
) (cRet *C.cef_browser_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.16:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_active_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)

		goRet := f.GetActiveBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito)
		BaseRelease(goTmpextension.pc_extension)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet != nil {
			BaseAddRef(goRet.pc_browser)
			cRet = (*C.cef_browser_t)(goRet.pc_browser)
		}
	} else {
		Logf("T144.17: get_active_browser: Noo!")
	}
	return cRet
}

///
// Called when the tabId associated with |target_browser| is specified to an
// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
// |extension| and |browser| are the source of the API call. Return true (1)
// to allow access of false (0) to deny access. Access to incognito browsers
// should not be allowed unless the source extension has incognito access
// enabled, in which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_can_access_browser
func cefingo_extension_handler_can_access_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
	target_browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.18:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.can_access_browser_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)
		goTmptarget_browser := newCBrowserT(target_browser)

		goRet := f.CanAccessBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito, goTmptarget_browser)
		BaseRelease(goTmpextension.pc_extension)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmptarget_browser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.19: can_access_browser: Noo!")
	}
	return cRet
}

///
// Called to retrieve an extension resource that would normally be loaded from
// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
// |extension| and |browser| are the source of the resource request. |file| is
// the requested relative file path. To handle the resource request return
// true (1) and execute |callback| either synchronously or asynchronously. For
// the default behavior which reads the resource from the extension directory
// on disk return false (0). Localization substitutions will not be applied to
// resources handled via this function.
///
//export cefingo_extension_handler_get_extension_resource
func cefingo_extension_handler_get_extension_resource(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	file *C.cef_string_t,
	callback *C.cef_get_extension_resource_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T144.20:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_extension_resource_handler[(*cCExtensionHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfile := string_from_cef_string(file)
		goTmpcallback := newCGetExtensionResourceCallbackT(callback)

		goRet := f.GetExtensionResource(goTmpself, goTmpextension, goTmpbrowser, goTmpfile, goTmpcallback)
		BaseRelease(goTmpextension.pc_extension)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_get_extension_resource_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T144.21: get_extension_resource: Noo!")
	}
	return cRet
}

///
// Called to report find results returned by cef_browser_host_t::find().
// |identifer| is the identifier passed to find(), |count| is the number of
// matches currently identified, |selectionRect| is the location of where the
// match was found (in window coordinates), |activeMatchOrdinal| is the
// current position in the search results, and |finalUpdate| is true (1) if
// this is the last find notification.
///
//export cefingo_find_handler_on_find_result
func cefingo_find_handler_on_find_result(
	self *C.cef_find_handler_t,
	browser *C.cef_browser_t,
	identifier C.int,
	count C.int,
	selectionRect *C.cef_rect_t,
	activeMatchOrdinal C.int,
	finalUpdate C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T146.6:")
	cefingoIfaceAccess.Lock()
	f := find_handler_handlers.on_find_result_handler[(*cCFindHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFindHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpidentifier := (int)(identifier)
		goTmpcount := (int)(count)
		goTmpselectionRect := (*CRectT)(selectionRect)
		goTmpactiveMatchOrdinal := (int)(activeMatchOrdinal)
		goTmpfinalUpdate := (int)(finalUpdate)

		f.OnFindResult(goTmpself, goTmpbrowser, goTmpidentifier, goTmpcount, goTmpselectionRect, goTmpactiveMatchOrdinal, goTmpfinalUpdate)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T146.7: on_find_result: Noo!")
	}

}

///
// Called when the browser component is about to loose focus. For instance, if
// focus was on the last HTML element and the user pressed the TAB key. |next|
// will be true (1) if the browser is giving focus to the next component and
// false (0) if the browser is giving focus to the previous component.
///
//export cefingo_focus_handler_on_take_focus
func cefingo_focus_handler_on_take_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	next C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T147.6:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_take_focus_handler[(*cCFocusHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnext := (int)(next)

		f.OnTakeFocus(goTmpself, goTmpbrowser, goTmpnext)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T147.7: on_take_focus: Noo!")
	}

}

///
// Called when the browser component is requesting focus. |source| indicates
// where the focus request is originating from. Return false (0) to allow the
// focus to be set or true (1) to cancel setting the focus.
///
//export cefingo_focus_handler_on_set_focus
func cefingo_focus_handler_on_set_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	source C.cef_focus_source_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T147.8:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_set_focus_handler[(*cCFocusHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpsource := CFocusSourceT(source)

		goRet := f.OnSetFocus(goTmpself, goTmpbrowser, goTmpsource)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T147.9: on_set_focus: Noo!")
	}
	return cRet
}

///
// Called when the browser component has received focus.
///
//export cefingo_focus_handler_on_got_focus
func cefingo_focus_handler_on_got_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T147.10:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_got_focus_handler[(*cCFocusHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnGotFocus(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T147.11: on_got_focus: Noo!")
	}

}

///
// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
// and user-friendly display string. The |default_prompt_text| value will be
// specified for prompt dialogs only. Set |suppress_message| to true (1) and
// return false (0) to suppress the message (suppressing messages is
// preferable to immediately executing the callback as this is used to detect
// presumably malicious behavior like spamming alert messages in
// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
// to use the default implementation (the default implementation will show one
// modal dialog at a time and suppress any additional dialog requests until
// the displayed dialog is dismissed). Return true (1) if the application will
// use a custom dialog or if the callback has been executed immediately.
// Custom dialogs may be either modal or modeless. If a custom dialog is used
// the application must execute |callback| once the custom dialog is
// dismissed.
///
//export cefingo_jsdialog_handler_on_jsdialog
func cefingo_jsdialog_handler_on_jsdialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	dialog_type C.cef_jsdialog_type_t,
	message_text *C.cef_string_t,
	default_prompt_text *C.cef_string_t,
	callback *C.cef_jsdialog_callback_t,
	suppress_message *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.6:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_jsdialog_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpdialog_type := CJsdialogTypeT(dialog_type)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpdefault_prompt_text := string_from_cef_string(default_prompt_text)
		goTmpcallback := newCJsdialogCallbackT(callback)

		goRet, goTmpsuppress_messageOut := f.OnJsdialog(goTmpself, goTmpbrowser, goTmporigin_url, goTmpdialog_type, goTmpmessage_text, goTmpdefault_prompt_text, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_jsdialog_callback)
		*suppress_message = (C.int)(goTmpsuppress_messageOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T151.7: on_jsdialog: Noo!")
	}
	return cRet
}

///
// Called to run a dialog asking the user if they want to leave a page. Return
// false (0) to use the default dialog implementation. Return true (1) if the
// application will use a custom dialog or if the callback has been executed
// immediately. Custom dialogs may be either modal or modeless. If a custom
// dialog is used the application must execute |callback| once the custom
// dialog is dismissed.
///
//export cefingo_jsdialog_handler_on_before_unload_dialog
func cefingo_jsdialog_handler_on_before_unload_dialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	message_text *C.cef_string_t,
	is_reload C.int,
	callback *C.cef_jsdialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.8:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_before_unload_dialog_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpis_reload := (int)(is_reload)
		goTmpcallback := newCJsdialogCallbackT(callback)

		goRet := f.OnBeforeUnloadDialog(goTmpself, goTmpbrowser, goTmpmessage_text, goTmpis_reload, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_jsdialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T151.9: on_before_unload_dialog: Noo!")
	}
	return cRet
}

///
// Called to cancel any pending dialogs and reset any saved dialog state. Will
// be called due to events like page navigation irregardless of whether any
// dialogs are currently pending.
///
//export cefingo_jsdialog_handler_on_reset_dialog_state
func cefingo_jsdialog_handler_on_reset_dialog_state(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.10:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_reset_dialog_state_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnResetDialogState(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T151.11: on_reset_dialog_state: Noo!")
	}

}

///
// Called when the default implementation dialog is closed.
///
//export cefingo_jsdialog_handler_on_dialog_closed
func cefingo_jsdialog_handler_on_dialog_closed(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T151.12:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_dialog_closed_handler[(*cCJsdialogHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnDialogClosed(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T151.13: on_dialog_closed: Noo!")
	}

}

///
// Called before a keyboard event is sent to the renderer. |event| contains
// information about the keyboard event. |os_event| is the operating system
// event message, if any. Return true (1) if the event was handled or false
// (0) otherwise. If the event will be handled in on_key_event() as a keyboard
// shortcut set |is_keyboard_shortcut| to true (1) and return false (0).
///
//export cefingo_keyboard_handler_on_pre_key_event
func cefingo_keyboard_handler_on_pre_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
	is_keyboard_shortcut *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T152.6:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_pre_key_event_handler[(*cCKeyboardHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)

		goRet, goTmpis_keyboard_shortcutOut := f.OnPreKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)
		BaseRelease(goTmpbrowser.pc_browser)
		*is_keyboard_shortcut = (C.int)(goTmpis_keyboard_shortcutOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T152.7: on_pre_key_event: Noo!")
	}
	return cRet
}

///
// Called after the renderer and JavaScript in the page has had a chance to
// handle the event. |event| contains information about the keyboard event.
// |os_event| is the operating system event message, if any. Return true (1)
// if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_keyboard_handler_on_key_event
func cefingo_keyboard_handler_on_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T152.8:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_key_event_handler[(*cCKeyboardHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)

		goRet := f.OnKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T152.9: on_key_event: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before a new popup browser is created. The
// |browser| and |frame| values represent the source of the popup request. The
// |target_url| and |target_frame_name| values indicate where the popup
// browser should navigate and may be NULL if not specified with the request.
// The |target_disposition| value indicates where the user intended to open
// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
// be true (1) if the popup was opened via explicit user gesture (e.g.
// clicking a link) or false (0) if the popup opened automatically (e.g. via
// the DomContentLoaded event). The |popupFeatures| structure contains
// additional information about the requested popup window. To allow creation
// of the popup browser optionally modify |windowInfo|, |client|, |settings|
// and |no_javascript_access| and return false (0). To cancel creation of the
// popup browser return true (1). The |client| and |settings| values will
// default to the source browser&#39;s values. If the |no_javascript_access| value
// is set to false (0) the new browser will not be scriptable and may not be
// hosted in the same renderer process as the source browser. Any
// modifications to |windowInfo| will be ignored if the parent browser is
// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
// the parent browser is destroyed before the popup browser creation completes
// (indicated by a call to OnAfterCreated for the popup browser). The
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created popup browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
//export cefingo_life_span_handler_on_before_popup
func cefingo_life_span_handler_on_before_popup(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_frame_name *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
	popupFeatures *C.cef_popup_features_t,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
	extra_info **C.cef_dictionary_value_t,
	no_javascript_access *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.6:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_popup_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_frame_name := string_from_cef_string(target_frame_name)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := (int)(user_gesture)
		goTmppopupFeatures := (*CPopupFeaturesT)(popupFeatures)
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.pc_client
		goTmpsettings := CBrowserSettingsT(*settings)
		goTmpno_javascript_access := (*no_javascript_access) != 0

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut, goTmpextra_infoOut, goTmpno_javascript_accessOut := f.OnBeforePopup(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_frame_name, goTmptarget_disposition, goTmpuser_gesture, goTmppopupFeatures, goTmpwindowInfo, goTmpclient, goTmpsettings, goTmpno_javascript_access)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.pc_client {
			BaseAddRef(goTmpclientOut.pc_client)
			*client = (*C.cef_client_t)(goTmpclientOut.pc_client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)
		if goTmpextra_infoOut != nil {
			BaseAddRef(goTmpextra_infoOut.pc_dictionary_value)
			*extra_info = (*C.cef_dictionary_value_t)(goTmpextra_infoOut.pc_dictionary_value)
		}
		*no_javascript_access = 0
		if goTmpno_javascript_accessOut {
			*no_javascript_access = 1
		}

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T155.7: on_before_popup: Noo!")
	}
	return cRet
}

///
// Called after a new browser is created. This callback will be the first
// notification that references |browser|.
///
//export cefingo_life_span_handler_on_after_created
func cefingo_life_span_handler_on_after_created(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.8:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_after_created_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnAfterCreated(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T155.9: on_after_created: Noo!")
	}

}

///
// Called when a browser has recieved a request to close. This may result
// directly from a call to cef_browser_host_t::*close_browser() or indirectly
// if the browser is parented to a top-level window created by CEF and the
// user attempts to close that window (by clicking the &#39;X&#39;, for example). The
// do_close() function will be called after the JavaScript &#39;onunload&#39; event
// has been fired.
//
// An application should handle top-level owner window close notifications by
// calling cef_browser_host_t::try_close_browser() or
// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
// to close immediately (see the examples below). This gives CEF an
// opportunity to process the &#39;onbeforeunload&#39; event and optionally cancel the
// close before do_close() is called.
//
// When windowed rendering is enabled CEF will internally create a window or
// view to host the browser. In that case returning false (0) from do_close()
// will send the standard close notification to the browser&#39;s top-level owner
// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
// Linux or cef_window_delegate_t::can_close() callback from Views). If the
// browser&#39;s host window/view has already been destroyed (via view hierarchy
// tear-down, for example) then do_close() will not be called for that browser
// since is no longer possible to cancel the close.
//
// When windowed rendering is disabled returning false (0) from do_close()
// will cause the browser object to be destroyed immediately.
//
// If the browser&#39;s top-level owner window requires a non-standard close
// notification then send that notification from do_close() and return true
// (1).
//
// The cef_life_span_handler_t::on_before_close() function will be called
// after do_close() (if do_close() is called) and immediately before the
// browser object is destroyed. The application should only exit after
// on_before_close() has been called for all existing browsers.
//
// The below examples describe what should happen during window close when the
// browser is parented to an application-provided top-level window.
//
// Example 1: Using cef_browser_host_t::try_close_browser(). This is
// recommended for clients using standard close handling and windows created
// on the browser process UI thread. 1.  User clicks the window close button
// which sends a close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
//     TryCloseBrowser() returns false so the client cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// CEF sends a close notification to the application&#39;s top-level window
//     (because DoClose() returned false by default).
// 7.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
//     allows the window close.
// 8.  Application&#39;s top-level window is destroyed. 9.  Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 10. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
//
// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
// implementing the do_close() callback. This is recommended for clients using
// non-standard close handling or windows that were not created on the browser
// process UI thread. 1.  User clicks the window close button which sends a
// close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and:
//     A. Calls CefBrowserHost::CloseBrowser(false).
//     B. Cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// Application&#39;s do_close() handler is called. Application will:
//     A. Set a flag to indicate that the next close attempt will be allowed.
//     B. Return false.
// 7.  CEF sends an close notification to the application&#39;s top-level window.
// 8.  Application&#39;s top-level window receives the close notification and
//     allows the window to close based on the flag from #6B.
// 9.  Application&#39;s top-level window is destroyed. 10. Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 11. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
///
//export cefingo_life_span_handler_do_close
func cefingo_life_span_handler_do_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.10:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.do_close_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goRet := f.DoClose(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T155.11: do_close: Noo!")
	}
	return cRet
}

///
// Called just before a browser is destroyed. Release all references to the
// browser object and do not attempt to execute any functions on the browser
// object (other than GetIdentifier or IsSame) after this callback returns.
// This callback will be the last notification that references |browser| on
// the UI thread. Any in-progress network requests associated with |browser|
// will be aborted when the browser is destroyed, and
// cef_resource_request_handler_t callbacks related to those requests may
// still arrive on the IO thread after this function is called. See do_close()
// documentation for additional usage information.
///
//export cefingo_life_span_handler_on_before_close
func cefingo_life_span_handler_on_before_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T155.12:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_close_handler[(*cCLifeSpanHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBeforeClose(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T155.13: on_before_close: Noo!")
	}

}

///
// Called when the loading state has changed. This callback will be executed
// twice -- once when loading is initiated either programmatically or by user
// action, and once when loading is terminated due to completion, cancellation
// of failure. It will be called before any calls to OnLoadStart and after all
// calls to OnLoadError and/or OnLoadEnd.
///
//export cefingo_load_handler_on_loading_state_change
func cefingo_load_handler_on_loading_state_change(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	isLoading C.int,
	canGoBack C.int,
	canGoForward C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.6:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_loading_state_change_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisLoading := isLoading != 0
		goTmpcanGoBack := canGoBack != 0
		goTmpcanGoForward := canGoForward != 0

		f.OnLoadingStateChange(goTmpself, goTmpbrowser, goTmpisLoading, goTmpcanGoBack, goTmpcanGoForward)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T156.7: on_loading_state_change: Noo!")
	}

}

///
// Called after a navigation has been committed and before the browser begins
// loading contents in the frame. The |frame| value will never be NULL -- call
// the is_main() function to check if this frame is the main frame.
// |transition_type| provides information about the source of the navigation
// and an accurate value is only available in the browser process. Multiple
// frames may be loading at the same time. Sub-frames may start or continue
// loading after the main frame load has ended. This function will not be
// called for same page navigations (fragments, history state, etc.) or for
// navigations that fail or are canceled before commit. For notification of
// overall browser load status use OnLoadingStateChange instead.
///
//export cefingo_load_handler_on_load_start
func cefingo_load_handler_on_load_start(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	transition_type C.cef_transition_type_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.8:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_start_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptransition_type := CTransitionTypeT(transition_type)

		f.OnLoadStart(goTmpself, goTmpbrowser, goTmpframe, goTmptransition_type)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)

	} else {
		Logf("T156.9: on_load_start: Noo!")
	}

}

///
// Called when the browser is done loading a frame. The |frame| value will
// never be NULL -- call the is_main() function to check if this frame is the
// main frame. Multiple frames may be loading at the same time. Sub-frames may
// start or continue loading after the main frame load has ended. This
// function will not be called for same page navigations (fragments, history
// state, etc.) or for navigations that fail or are canceled before commit.
// For notification of overall browser load status use OnLoadingStateChange
// instead.
///
//export cefingo_load_handler_on_load_end
func cefingo_load_handler_on_load_end(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	httpStatusCode C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.10:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_end_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmphttpStatusCode := (int)(httpStatusCode)

		f.OnLoadEnd(goTmpself, goTmpbrowser, goTmpframe, goTmphttpStatusCode)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)

	} else {
		Logf("T156.11: on_load_end: Noo!")
	}

}

///
// Called when a navigation fails or is canceled. This function may be called
// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
// after commit. |errorCode| is the error code number, |errorText| is the
// error text and |failedUrl| is the URL that failed to load. See
// net\base\net_error_list.h for complete descriptions of the error codes.
///
//export cefingo_load_handler_on_load_error
func cefingo_load_handler_on_load_error(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	errorCode C.cef_errorcode_t,
	errorText *C.cef_string_t,
	failedUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T156.12:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_error_handler[(*cCLoadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmperrorCode := CErrorcodeT(errorCode)
		goTmperrorText := string_from_cef_string(errorText)
		goTmpfailedUrl := string_from_cef_string(failedUrl)

		f.OnLoadError(goTmpself, goTmpbrowser, goTmpframe, goTmperrorCode, goTmperrorText, goTmpfailedUrl)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)

	} else {
		Logf("T156.13: on_load_error: Noo!")
	}

}

///
// The list of available media sinks has changed or
// cef_media_router_t::NotifyCurrentSinks was called.
///
//export cefingo_media_observer_on_sinks
func cefingo_media_observer_on_sinks(
	self *C.cef_media_observer_t,
	sinksCount C.size_t,
	sinks **C.cef_media_sink_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.6:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_sinks_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		slice := (*[1 << 30](*C.cef_media_sink_t))(unsafe.Pointer(sinks))[:sinksCount:sinksCount]
		goTmpsinks := make([]*CMediaSinkT, sinksCount)
		for i, v := range slice {
			goTmpsinks[i] = newCMediaSinkT(v)
		}

		f.OnSinks(goTmpself, goTmpsinks)

	} else {
		Logf("T158.7: on_sinks: Noo!")
	}

}

///
// The list of available media routes has changed or
// cef_media_router_t::NotifyCurrentRoutes was called.
///
//export cefingo_media_observer_on_routes
func cefingo_media_observer_on_routes(
	self *C.cef_media_observer_t,
	routesCount C.size_t,
	routes **C.cef_media_route_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.8:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_routes_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		slice := (*[1 << 30](*C.cef_media_route_t))(unsafe.Pointer(routes))[:routesCount:routesCount]
		goTmproutes := make([]*CMediaRouteT, routesCount)
		for i, v := range slice {
			goTmproutes[i] = newCMediaRouteT(v)
		}

		f.OnRoutes(goTmpself, goTmproutes)

	} else {
		Logf("T158.9: on_routes: Noo!")
	}

}

///
// The connection state of |route| has changed.
///
//export cefingo_media_observer_on_route_state_changed
func cefingo_media_observer_on_route_state_changed(
	self *C.cef_media_observer_t,
	route *C.cef_media_route_t,
	state C.cef_media_route_connection_state_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.10:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_route_state_changed_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		goTmproute := newCMediaRouteT(route)
		goTmpstate := CMediaRouteConnectionStateT(state)

		f.OnRouteStateChanged(goTmpself, goTmproute, goTmpstate)
		BaseRelease(goTmproute.pc_media_route)

	} else {
		Logf("T158.11: on_route_state_changed: Noo!")
	}

}

///
// A message was recieved over |route|. |message| is only valid for the scope
// of this callback and should be copied if necessary.
///
//export cefingo_media_observer_on_route_message_received
func cefingo_media_observer_on_route_message_received(
	self *C.cef_media_observer_t,
	route *C.cef_media_route_t,
	message C.VOIDP,
	message_size C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T158.12:")
	cefingoIfaceAccess.Lock()
	f := media_observer_handlers.on_route_message_received_handler[(*cCMediaObserverT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMediaObserverT(self)
		goTmproute := newCMediaRouteT(route)
		goTmpmessage := (*[1 << 30]byte)(message)[:message_size:message_size]

		f.OnRouteMessageReceived(goTmpself, goTmproute, goTmpmessage)
		BaseRelease(goTmproute.pc_media_route)

	} else {
		Logf("T158.13: on_route_message_received: Noo!")
	}

}

///
// Called when |button| is pressed. Call cef_menu_button_t::show_menu() to
// show a popup menu at |screen_point|. When showing a custom popup such as a
// window keep a reference to |button_pressed_lock| until the popup is hidden
// to maintain the pressed button state.
///
//export cefingo_menu_button_delegate_on_menu_button_pressed
func cefingo_menu_button_delegate_on_menu_button_pressed(
	self *C.cef_menu_button_delegate_t,
	menu_button *C.cef_menu_button_t,
	screen_point *C.cef_point_t,
	button_pressed_lock *C.cef_menu_button_pressed_lock_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.6:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_menu_button_pressed_handler[(*cCMenuButtonDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuButtonDelegateT(self)
		goTmpmenu_button := newCMenuButtonT(menu_button)
		goTmpscreen_point := (*CPointT)(screen_point)
		goTmpbutton_pressed_lock := newCMenuButtonPressedLockT(button_pressed_lock)

		f.OnMenuButtonPressed(goTmpself, goTmpmenu_button, goTmpscreen_point, goTmpbutton_pressed_lock)
		BaseRelease(goTmpmenu_button.pc_menu_button)
		BaseRelease(goTmpbutton_pressed_lock.pc_menu_button_pressed_lock)

	} else {
		Logf("T165.7: on_menu_button_pressed: Noo!")
	}

}

///
// Called when |button| is pressed.
///
//export cefingo_menu_button_delegate_on_button_pressed
func cefingo_menu_button_delegate_on_button_pressed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.8:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_button_pressed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonPressed(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.pc_button)

	} else {
		Logf("T165.9: on_button_pressed: Noo!")
	}

}

///
// Called when the state of |button| changes.
///
//export cefingo_menu_button_delegate_on_button_state_changed
func cefingo_menu_button_delegate_on_button_state_changed(
	self *C.cef_button_delegate_t,
	button *C.cef_button_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.10:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_button_state_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCButtonDelegateT(self)
		goTmpbutton := newCButtonT(button)

		f.OnButtonStateChanged(goTmpself, goTmpbutton)
		BaseRelease(goTmpbutton.pc_button)

	} else {
		Logf("T165.11: on_button_state_changed: Noo!")
	}

}

//export cefingo_menu_button_delegate_get_preferred_size
func cefingo_menu_button_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.12:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_preferred_size_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T165.13: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_get_minimum_size
func cefingo_menu_button_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.14:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_minimum_size_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T165.15: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_get_maximum_size
func cefingo_menu_button_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.16:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_maximum_size_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T165.17: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_get_height_for_width
func cefingo_menu_button_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.18:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.get_height_for_width_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.pc_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T165.19: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_menu_button_delegate_on_parent_view_changed
func cefingo_menu_button_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.20:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_parent_view_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpparent.pc_view)

	} else {
		Logf("T165.21: on_parent_view_changed: Noo!")
	}

}

//export cefingo_menu_button_delegate_on_child_view_changed
func cefingo_menu_button_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.22:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_child_view_changed_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpchild.pc_view)

	} else {
		Logf("T165.23: on_child_view_changed: Noo!")
	}

}

//export cefingo_menu_button_delegate_on_focus
func cefingo_menu_button_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.24:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_focus_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T165.25: on_focus: Noo!")
	}

}

//export cefingo_menu_button_delegate_on_blur
func cefingo_menu_button_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T165.26:")
	cefingoIfaceAccess.Lock()
	f := menu_button_delegate_handlers.on_blur_handler[(*cCMenuButtonDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T165.27: on_blur: Noo!")
	}

}

///
// Perform the action associated with the specified |command_id| and optional
// |event_flags|.
///
//export cefingo_menu_model_delegate_execute_command
func cefingo_menu_model_delegate_execute_command(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.6:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.execute_command_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		f.ExecuteCommand(goTmpself, goTmpmenu_model, goTmpcommand_id, goTmpevent_flags)
		BaseRelease(goTmpmenu_model.pc_menu_model)

	} else {
		Logf("T167.7: execute_command: Noo!")
	}

}

///
// Called when the user moves the mouse outside the menu and over the owning
// window.
///
//export cefingo_menu_model_delegate_mouse_outside_menu
func cefingo_menu_model_delegate_mouse_outside_menu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	screen_point *C.cef_point_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.8:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.mouse_outside_menu_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpscreen_point := (*CPointT)(screen_point)

		f.MouseOutsideMenu(goTmpself, goTmpmenu_model, goTmpscreen_point)
		BaseRelease(goTmpmenu_model.pc_menu_model)

	} else {
		Logf("T167.9: mouse_outside_menu: Noo!")
	}

}

///
// Called on unhandled open submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_open_submenu
func cefingo_menu_model_delegate_unhandled_open_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.10:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_open_submenu_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledOpenSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)
		BaseRelease(goTmpmenu_model.pc_menu_model)

	} else {
		Logf("T167.11: unhandled_open_submenu: Noo!")
	}

}

///
// Called on unhandled close submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_close_submenu
func cefingo_menu_model_delegate_unhandled_close_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.12:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_close_submenu_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledCloseSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)
		BaseRelease(goTmpmenu_model.pc_menu_model)

	} else {
		Logf("T167.13: unhandled_close_submenu: Noo!")
	}

}

///
// The menu is about to show.
///
//export cefingo_menu_model_delegate_menu_will_show
func cefingo_menu_model_delegate_menu_will_show(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.14:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_will_show_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuWillShow(goTmpself, goTmpmenu_model)
		BaseRelease(goTmpmenu_model.pc_menu_model)

	} else {
		Logf("T167.15: menu_will_show: Noo!")
	}

}

///
// The menu has closed.
///
//export cefingo_menu_model_delegate_menu_closed
func cefingo_menu_model_delegate_menu_closed(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.16:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_closed_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuClosed(goTmpself, goTmpmenu_model)
		BaseRelease(goTmpmenu_model.pc_menu_model)

	} else {
		Logf("T167.17: menu_closed: Noo!")
	}

}

///
// Optionally modify a menu item label. Return true (1) if |label| was
// modified.
///
//export cefingo_menu_model_delegate_format_label
func cefingo_menu_model_delegate_format_label(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	label *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167.18:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.format_label_handler[(*cCMenuModelDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmplabel := string_from_cef_string(label)

		goRet, goTmplabelOut := f.FormatLabel(goTmpself, goTmpmenu_model, goTmplabel)
		BaseRelease(goTmpmenu_model.pc_menu_model)
		set_cef_string(label, goTmplabelOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T167.19: format_label: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_preferred_size
func cefingo_panel_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.6:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_preferred_size_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T170.7: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_minimum_size
func cefingo_panel_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.8:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_minimum_size_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T170.9: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_maximum_size
func cefingo_panel_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.10:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_maximum_size_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T170.11: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_get_height_for_width
func cefingo_panel_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.12:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.get_height_for_width_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.pc_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T170.13: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_panel_delegate_on_parent_view_changed
func cefingo_panel_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.14:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_parent_view_changed_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpparent.pc_view)

	} else {
		Logf("T170.15: on_parent_view_changed: Noo!")
	}

}

//export cefingo_panel_delegate_on_child_view_changed
func cefingo_panel_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.16:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_child_view_changed_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpchild.pc_view)

	} else {
		Logf("T170.17: on_child_view_changed: Noo!")
	}

}

//export cefingo_panel_delegate_on_focus
func cefingo_panel_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.18:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_focus_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T170.19: on_focus: Noo!")
	}

}

//export cefingo_panel_delegate_on_blur
func cefingo_panel_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T170.20:")
	cefingoIfaceAccess.Lock()
	f := panel_delegate_handlers.on_blur_handler[(*cCPanelDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T170.21: on_blur: Noo!")
	}

}

///
// Called when printing has started for the specified |browser|. This function
// will be called before the other OnPrint*() functions and irrespective of
// how printing was initiated (e.g. cef_browser_host_t::print(), JavaScript
// window.print() or PDF extension print button).
///
//export cefingo_print_handler_on_print_start
func cefingo_print_handler_on_print_start(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.6:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_start_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnPrintStart(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T173.7: on_print_start: Noo!")
	}

}

///
// Synchronize |settings| with client state. If |get_defaults| is true (1)
// then populate |settings| with the default print settings. Do not keep a
// reference to |settings| outside of this callback.
///
//export cefingo_print_handler_on_print_settings
func cefingo_print_handler_on_print_settings(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	settings *C.cef_print_settings_t,
	get_defaults C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.8:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_settings_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpsettings := newCPrintSettingsT(settings)
		goTmpget_defaults := (int)(get_defaults)

		f.OnPrintSettings(goTmpself, goTmpbrowser, goTmpsettings, goTmpget_defaults)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpsettings.pc_print_settings)

	} else {
		Logf("T173.9: on_print_settings: Noo!")
	}

}

///
// Show the print dialog. Execute |callback| once the dialog is dismissed.
// Return true (1) if the dialog will be displayed or false (0) to cancel the
// printing immediately.
///
//export cefingo_print_handler_on_print_dialog
func cefingo_print_handler_on_print_dialog(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	has_selection C.int,
	callback *C.cef_print_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.10:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_dialog_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmphas_selection := (int)(has_selection)
		goTmpcallback := newCPrintDialogCallbackT(callback)

		goRet := f.OnPrintDialog(goTmpself, goTmpbrowser, goTmphas_selection, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_print_dialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T173.11: on_print_dialog: Noo!")
	}
	return cRet
}

///
// Send the print job to the printer. Execute |callback| once the job is
// completed. Return true (1) if the job will proceed or false (0) to cancel
// the job immediately.
///
//export cefingo_print_handler_on_print_job
func cefingo_print_handler_on_print_job(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
	document_name *C.cef_string_t,
	pdf_file_path *C.cef_string_t,
	callback *C.cef_print_job_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.12:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_job_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdocument_name := string_from_cef_string(document_name)
		goTmppdf_file_path := string_from_cef_string(pdf_file_path)
		goTmpcallback := newCPrintJobCallbackT(callback)

		goRet := f.OnPrintJob(goTmpself, goTmpbrowser, goTmpdocument_name, goTmppdf_file_path, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_print_job_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T173.13: on_print_job: Noo!")
	}
	return cRet
}

///
// Reset client state related to printing.
///
//export cefingo_print_handler_on_print_reset
func cefingo_print_handler_on_print_reset(
	self *C.cef_print_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.14:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.on_print_reset_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnPrintReset(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T173.15: on_print_reset: Noo!")
	}

}

///
// Return the PDF paper size in device units. Used in combination with
// cef_browser_host_t::print_to_pdf().
///
//export cefingo_print_handler_get_pdf_paper_size
func cefingo_print_handler_get_pdf_paper_size(
	self *C.cef_print_handler_t,
	device_units_per_inch C.int,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T173.16:")
	cefingoIfaceAccess.Lock()
	f := print_handler_handlers.get_pdf_paper_size_handler[(*cCPrintHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCPrintHandlerT(self)
		goTmpdevice_units_per_inch := (int)(device_units_per_inch)

		goRet := f.GetPdfPaperSize(goTmpself, goTmpdevice_units_per_inch)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T173.17: get_pdf_paper_size: Noo!")
	}
	return cRet
}

///
// Return the handler for accessibility notifications. If no handler is
// provided the default implementation will be used.
///
//export cefingo_render_handler_get_accessibility_handler
func cefingo_render_handler_get_accessibility_handler(
	self *C.cef_render_handler_t,
) (cRet *C.cef_accessibility_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.6:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_accessibility_handler_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)

		goRet := f.GetAccessibilityHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_accessibility_handler)
			cRet = (*C.cef_accessibility_handler_t)(goRet.pc_accessibility_handler)
		}
	} else {
		Logf("T177.7: get_accessibility_handler: Noo!")
	}
	return cRet
}

///
// Called to retrieve the root window rectangle in screen coordinates. Return
// true (1) if the rectangle was provided. If this function returns false (0)
// the rectangle from GetViewRect will be used.
///
//export cefingo_render_handler_get_root_screen_rect
func cefingo_render_handler_get_root_screen_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.8:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_root_screen_rect_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goRet, goTmprectOut := f.GetRootScreenRect(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)
		*rect = (C.cef_rect_t)(goTmprectOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.9: get_root_screen_rect: Noo!")
	}
	return cRet
}

///
// Called to retrieve the view rectangle which is relative to screen
// coordinates. This function must always provide a non-NULL rectangle.
///
//export cefingo_render_handler_get_view_rect
func cefingo_render_handler_get_view_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.10:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_view_rect_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goTmprectOut := f.GetViewRect(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)
		*rect = (C.cef_rect_t)(goTmprectOut)

	} else {
		Logf("T177.11: get_view_rect: Noo!")
	}

}

///
// Called to retrieve the translation from view coordinates to actual screen
// coordinates. Return true (1) if the screen coordinates were provided.
///
//export cefingo_render_handler_get_screen_point
func cefingo_render_handler_get_screen_point(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	viewX C.int,
	viewY C.int,
	screenX *C.int,
	screenY *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.12:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_point_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpviewX := (int)(viewX)
		goTmpviewY := (int)(viewY)

		goRet, goTmpscreenXOut, goTmpscreenYOut := f.GetScreenPoint(goTmpself, goTmpbrowser, goTmpviewX, goTmpviewY)
		BaseRelease(goTmpbrowser.pc_browser)
		*screenX = (C.int)(goTmpscreenXOut)
		*screenY = (C.int)(goTmpscreenYOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.13: get_screen_point: Noo!")
	}
	return cRet
}

///
// Called to allow the client to fill in the CefScreenInfo object with
// appropriate values. Return true (1) if the |screen_info| structure has been
// modified.
//
// If the screen info rectangle is left NULL the rectangle from GetViewRect
// will be used. If the rectangle is still NULL or invalid popups may not be
// drawn correctly.
///
//export cefingo_render_handler_get_screen_info
func cefingo_render_handler_get_screen_info(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	screen_info *C.cef_screen_info_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.14:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_info_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpscreen_info := CScreenInfoT(*screen_info)

		goRet, goTmpscreen_infoOut := f.GetScreenInfo(goTmpself, goTmpbrowser, goTmpscreen_info)
		BaseRelease(goTmpbrowser.pc_browser)
		*screen_info = C.cef_screen_info_t(goTmpscreen_infoOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.15: get_screen_info: Noo!")
	}
	return cRet
}

///
// Called when the browser wants to show or hide the popup widget. The popup
// should be shown if |show| is true (1) and hidden if |show| is false (0).
///
//export cefingo_render_handler_on_popup_show
func cefingo_render_handler_on_popup_show(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	show C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.16:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_show_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpshow := (int)(show)

		f.OnPopupShow(goTmpself, goTmpbrowser, goTmpshow)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.17: on_popup_show: Noo!")
	}

}

///
// Called when the browser wants to move or resize the popup widget. |rect|
// contains the new location and size in view coordinates.
///
//export cefingo_render_handler_on_popup_size
func cefingo_render_handler_on_popup_size(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.18:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_size_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		f.OnPopupSize(goTmpself, goTmpbrowser, goTmprect)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.19: on_popup_size: Noo!")
	}

}

///
// Called when an element should be painted. Pixel values passed to this
// function are scaled relative to view coordinates based on the value of
// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
// indicates whether the element is the view or the popup widget. |buffer|
// contains the pixel data for the whole image. |dirtyRects| contains the set
// of rectangles in pixel coordinates that need to be repainted. |buffer| will
// be |width|*|height|*4 bytes in size and represents a BGRA image with an
// upper-left origin. This function is only called when
// cef_window_tInfo::shared_texture_enabled is set to false (0).
///
//export cefingo_render_handler_on_paint
func cefingo_render_handler_on_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	buffer C.VOIDP,
	width C.int,
	height C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.20:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_paint_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		slice := (*[1 << 30](C.cef_rect_t))(unsafe.Pointer(dirtyRects))[:dirtyRectsCount:dirtyRectsCount]
		goTmpdirtyRects := make([]CRectT, dirtyRectsCount)
		for i, v := range slice {
			goTmpdirtyRects[i] = CRectT(v)
		}
		goTmpbuffer := unsafe.Pointer(buffer)
		goTmpwidth := (int)(width)
		goTmpheight := (int)(height)

		f.OnPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRects, goTmpbuffer, goTmpwidth, goTmpheight)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.21: on_paint: Noo!")
	}

}

///
// Called when an element has been rendered to the shared texture handle.
// |type| indicates whether the element is the view or the popup widget.
// |dirtyRects| contains the set of rectangles in pixel coordinates that need
// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
// can be accessed via ID3D11Device using the OpenSharedResource function.
// This function is only called when cef_window_tInfo::shared_texture_enabled
// is set to true (1), and is currently only supported on Windows.
///
//export cefingo_render_handler_on_accelerated_paint
func cefingo_render_handler_on_accelerated_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	shared_handle C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.22:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_accelerated_paint_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		goTmpshared_handle := unsafe.Pointer(shared_handle)

		f.OnAcceleratedPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRectsCount, goTmpdirtyRects, goTmpshared_handle)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.23: on_accelerated_paint: Noo!")
	}

}

///
// Called when the browser&#39;s cursor has changed. If |type| is CT_CUSTOM then
// |custom_cursor_info| will be populated with the custom cursor information.
///
//export cefingo_render_handler_on_cursor_change
func cefingo_render_handler_on_cursor_change(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	cursor C.HCURSOR,
	ctype C.cef_cursor_type_t,
	custom_cursor_info *C.cef_cursor_info_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.24:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_cursor_change_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcursor := (CCursorHandleT)(cursor)
		goTmptype := CCursorTypeT(ctype)
		goTmpcustom_cursor_info := (*CCursorInfoT)(custom_cursor_info)

		f.OnCursorChange(goTmpself, goTmpbrowser, goTmpcursor, goTmptype, goTmpcustom_cursor_info)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.25: on_cursor_change: Noo!")
	}

}

///
// Called when the user starts dragging content in the web view. Contextual
// information about the dragged content is supplied by |drag_data|. (|x|,
// |y|) is the drag start location in screen coordinates. OS APIs that run a
// system message loop may be used within the StartDragging call.
//
// Return false (0) to abort the drag operation. Don&#39;t call any of
// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
//
// Return true (1) to handle the drag operation. Call
// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
// synchronously or asynchronously to inform the web view that the drag
// operation has ended.
///
//export cefingo_render_handler_start_dragging
func cefingo_render_handler_start_dragging(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	drag_data *C.cef_drag_data_t,
	allowed_ops C.cef_drag_operations_mask_t,
	x C.int,
	y C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.26:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.start_dragging_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdrag_data := newCDragDataT(drag_data)
		goTmpallowed_ops := CDragOperationsMaskT(allowed_ops)
		goTmpx := (int)(x)
		goTmpy := (int)(y)

		goRet := f.StartDragging(goTmpself, goTmpbrowser, goTmpdrag_data, goTmpallowed_ops, goTmpx, goTmpy)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpdrag_data.pc_drag_data)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T177.27: start_dragging: Noo!")
	}
	return cRet
}

///
// Called when the web view wants to update the mouse cursor during a drag &amp;
// drop operation. |operation| describes the allowed operation (none, move,
// copy, link).
///
//export cefingo_render_handler_update_drag_cursor
func cefingo_render_handler_update_drag_cursor(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	operation C.cef_drag_operations_mask_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.28:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.update_drag_cursor_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpoperation := CDragOperationsMaskT(operation)

		f.UpdateDragCursor(goTmpself, goTmpbrowser, goTmpoperation)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.29: update_drag_cursor: Noo!")
	}

}

///
// Called when the scroll offset has changed.
///
//export cefingo_render_handler_on_scroll_offset_changed
func cefingo_render_handler_on_scroll_offset_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	x C.double,
	y C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.30:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_scroll_offset_changed_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpx := (float64)(x)
		goTmpy := (float64)(y)

		f.OnScrollOffsetChanged(goTmpself, goTmpbrowser, goTmpx, goTmpy)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.31: on_scroll_offset_changed: Noo!")
	}

}

///
// Called when the IME composition range has changed. |selected_range| is the
// range of characters that have been selected. |character_bounds| is the
// bounds of each character in view coordinates.
///
//export cefingo_render_handler_on_ime_composition_range_changed
func cefingo_render_handler_on_ime_composition_range_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_range *C.cef_range_t,
	character_boundsCount C.size_t,
	character_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.32:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_ime_composition_range_changed_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_range := (*CRangeT)(selected_range)
		goTmpcharacter_boundsCount := (int64)(character_boundsCount)
		goTmpcharacter_bounds := (*CRectT)(character_bounds)

		f.OnImeCompositionRangeChanged(goTmpself, goTmpbrowser, goTmpselected_range, goTmpcharacter_boundsCount, goTmpcharacter_bounds)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.33: on_ime_composition_range_changed: Noo!")
	}

}

///
// Called when text selection has changed for the specified |browser|.
// |selected_text| is the currently selected text and |selected_range| is the
// character range.
///
//export cefingo_render_handler_on_text_selection_changed
func cefingo_render_handler_on_text_selection_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_text *C.cef_string_t,
	selected_range *C.cef_range_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.34:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_text_selection_changed_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_text := string_from_cef_string(selected_text)
		goTmpselected_range := (*CRangeT)(selected_range)

		f.OnTextSelectionChanged(goTmpself, goTmpbrowser, goTmpselected_text, goTmpselected_range)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.35: on_text_selection_changed: Noo!")
	}

}

///
// Called when an on-screen keyboard should be shown or hidden for the
// specified |browser|. |input_mode| specifies what kind of keyboard should be
// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
// for this browser should be hidden.
///
//export cefingo_render_handler_on_virtual_keyboard_requested
func cefingo_render_handler_on_virtual_keyboard_requested(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	input_mode C.cef_text_input_mode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T177.36:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_virtual_keyboard_requested_handler[(*cCRenderHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinput_mode := CTextInputModeT(input_mode)

		f.OnVirtualKeyboardRequested(goTmpself, goTmpbrowser, goTmpinput_mode)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T177.37: on_virtual_keyboard_requested: Noo!")
	}

}

///
// Called after WebKit has been initialized.
///
//export cefingo_render_process_handler_on_web_kit_initialized
func cefingo_render_process_handler_on_web_kit_initialized(
	self *C.cef_render_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.6:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_web_kit_initialized_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)

		f.OnWebKitInitialized(goTmpself)

	} else {
		Logf("T178.7: on_web_kit_initialized: Noo!")
	}

}

///
// Called after a browser has been created. When browsing cross-origin a new
// browser will be created before the old browser with the same identifier is
// destroyed. |extra_info| is a read-only value originating from
// cef_browser_host_t::cef_browser_host_create_browser(),
// cef_browser_host_t::cef_browser_host_create_browser_sync(),
// cef_life_span_handler_t::on_before_popup() or
// cef_browser_view_t::cef_browser_view_create().
///
//export cefingo_render_process_handler_on_browser_created
func cefingo_render_process_handler_on_browser_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	extra_info *C.cef_dictionary_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.8:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_created_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpextra_info := newCDictionaryValueT(extra_info)

		f.OnBrowserCreated(goTmpself, goTmpbrowser, goTmpextra_info)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpextra_info.pc_dictionary_value)

	} else {
		Logf("T178.9: on_browser_created: Noo!")
	}

}

///
// Called before a browser is destroyed.
///
//export cefingo_render_process_handler_on_browser_destroyed
func cefingo_render_process_handler_on_browser_destroyed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.10:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_destroyed_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserDestroyed(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T178.11: on_browser_destroyed: Noo!")
	}

}

///
// Return the handler for browser load status events.
///
//export cefingo_render_process_handler_get_load_handler
func cefingo_render_process_handler_get_load_handler(
	self *C.cef_render_process_handler_t,
) (cRet *C.cef_load_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.12:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.get_load_handler_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)

		goRet := f.GetLoadHandler(goTmpself)

		if goRet != nil {
			BaseAddRef(goRet.pc_load_handler)
			cRet = (*C.cef_load_handler_t)(goRet.pc_load_handler)
		}
	} else {
		Logf("T178.13: get_load_handler: Noo!")
	}
	return cRet
}

///
// Called immediately after the V8 context for a frame has been created. To
// retrieve the JavaScript &#39;window&#39; object use the
// cef_v8context_t::get_global() function. V8 handles can only be accessed
// from the thread on which they are created. A task runner for posting tasks
// on the associated thread can be retrieved via the
// cef_v8context_t::get_task_runner() function.
///
//export cefingo_render_process_handler_on_context_created
func cefingo_render_process_handler_on_context_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.14:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_created_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextCreated(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpcontext.pc_v8context)

	} else {
		Logf("T178.15: on_context_created: Noo!")
	}

}

///
// Called immediately before the V8 context for a frame is released. No
// references to the context should be kept after this function is called.
///
//export cefingo_render_process_handler_on_context_released
func cefingo_render_process_handler_on_context_released(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.16:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_released_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextReleased(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpcontext.pc_v8context)

	} else {
		Logf("T178.17: on_context_released: Noo!")
	}

}

///
// Called for global uncaught exceptions in a frame. Execution of this
// callback is disabled by default. To enable set
// CefSettings.uncaught_exception_stack_size &gt; 0.
///
//export cefingo_render_process_handler_on_uncaught_exception
func cefingo_render_process_handler_on_uncaught_exception(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
	exception *C.cef_v8exception_t,
	stackTrace *C.cef_v8stack_trace_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.18:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_uncaught_exception_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)
		goTmpexception := newCV8exceptionT(exception)
		goTmpstackTrace := newCV8stackTraceT(stackTrace)

		f.OnUncaughtException(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext, goTmpexception, goTmpstackTrace)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpcontext.pc_v8context)
		BaseRelease(goTmpexception.pc_v8exception)
		BaseRelease(goTmpstackTrace.pc_v8stack_trace)

	} else {
		Logf("T178.19: on_uncaught_exception: Noo!")
	}

}

///
// Called when a new node in the the browser gets focus. The |node| value may
// be NULL if no specific node has gained focus. The node object passed to
// this function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_render_process_handler_on_focused_node_changed
func cefingo_render_process_handler_on_focused_node_changed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	node *C.cef_domnode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.20:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_focused_node_changed_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpnode := newCDomnodeT(node)

		f.OnFocusedNodeChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpnode)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpnode.pc_domnode)

	} else {
		Logf("T178.21: on_focused_node_changed: Noo!")
	}

}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_render_process_handler_on_process_message_received
func cefingo_render_process_handler_on_process_message_received(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T178.22:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_process_message_received_handler[(*cCRenderProcessHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmpmessage.pc_process_message)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T178.23: on_process_message_received: Noo!")
	}
	return cRet
}

///
// Called on the browser process UI thread immediately after the request
// context has been initialized.
///
//export cefingo_request_context_handler_on_request_context_initialized
func cefingo_request_context_handler_on_request_context_initialized(
	self *C.cef_request_context_handler_t,
	request_context *C.cef_request_context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T185.6:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_request_context_initialized_handler[(*cCRequestContextHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmprequest_context := newCRequestContextT(request_context)

		f.OnRequestContextInitialized(goTmpself, goTmprequest_context)
		BaseRelease(goTmprequest_context.pc_request_context)

	} else {
		Logf("T185.7: on_request_context_initialized: Noo!")
	}

}

///
// Called on multiple browser process threads before a plugin instance is
// loaded. |mime_type| is the mime type of the plugin that will be loaded.
// |plugin_url| is the content URL that the plugin will load and may be NULL.
// |is_main_frame| will be true (1) if the plugin is being loaded in the main
// (top-level) frame, |top_origin_url| is the URL for the top-level frame that
// contains the plugin when loading a specific plugin instance or NULL when
// building the initial list of enabled plugins for &#39;navigator.plugins&#39;
// JavaScript state. |plugin_info| includes additional information about the
// plugin that will be loaded. |plugin_policy| is the recommended policy.
// Modify |plugin_policy| and return true (1) to change the policy. Return
// false (0) to use the recommended policy. The default plugin policy can be
// set at runtime using the `--plugin-policy=[allow|detect|block]` command-
// line flag. Decisions to mark a plugin as disabled by setting
// |plugin_policy| to PLUGIN_POLICY_DISABLED may be cached when
// |top_origin_url| is NULL. To purge the plugin list cache and potentially
// trigger new calls to this function call
// cef_request_context_t::PurgePluginListCache.
///
//export cefingo_request_context_handler_on_before_plugin_load
func cefingo_request_context_handler_on_before_plugin_load(
	self *C.cef_request_context_handler_t,
	mime_type *C.cef_string_t,
	plugin_url *C.cef_string_t,
	is_main_frame C.int,
	top_origin_url *C.cef_string_t,
	plugin_info *C.cef_web_plugin_info_t,
	plugin_policy *C.cef_plugin_policy_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T185.8:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_before_plugin_load_handler[(*cCRequestContextHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmpmime_type := string_from_cef_string(mime_type)
		goTmpplugin_url := string_from_cef_string(plugin_url)
		goTmpis_main_frame := (int)(is_main_frame)
		goTmptop_origin_url := string_from_cef_string(top_origin_url)
		goTmpplugin_info := newCWebPluginInfoT(plugin_info)

		goRet, goTmpplugin_policyOut := f.OnBeforePluginLoad(goTmpself, goTmpmime_type, goTmpplugin_url, goTmpis_main_frame, goTmptop_origin_url, goTmpplugin_info)
		BaseRelease(goTmpplugin_info.pc_web_plugin_info)
		*plugin_policy = (C.cef_plugin_policy_t)(goTmpplugin_policyOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T185.9: on_before_plugin_load: Noo!")
	}
	return cRet
}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request, and may be NULL for requests originating from service workers or
// cef_urlrequest_t. |request| represents the request contents and cannot be
// modified in this callback. |is_navigation| will be true (1) if the resource
// request is a navigation. |is_download| will be true (1) if the resource
// request is a download. |request_initiator| is the origin (scheme + domain)
// of the page that initiated the request. Set |disable_default_handling| to
// true (1) to disable default handling of the request, in which case it will
// need to be handled via cef_resource_request_handler_t::GetResourceHandler
// or it will be canceled. To allow the resource load to proceed with default
// handling return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. This function will not be called if
// the client associated with |browser| returns a non-NULL value from
// cef_request_handler_t::GetResourceRequestHandler for the same request
// (identified by cef_request_t::GetIdentifier).
///
//export cefingo_request_context_handler_get_resource_request_handler
func cefingo_request_context_handler_get_resource_request_handler(
	self *C.cef_request_context_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	is_navigation C.int,
	is_download C.int,
	request_initiator *C.cef_string_t,
	disable_default_handling *C.int,
) (cRet *C.cef_resource_request_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T185.10:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.get_resource_request_handler_handler[(*cCRequestContextHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpis_navigation := (int)(is_navigation)
		goTmpis_download := (int)(is_download)
		goTmprequest_initiator := string_from_cef_string(request_initiator)

		goRet, goTmpdisable_default_handlingOut := f.GetResourceRequestHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpis_navigation, goTmpis_download, goTmprequest_initiator)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		*disable_default_handling = 0
		if goTmpdisable_default_handlingOut {
			*disable_default_handling = 1
		}

		if goRet != nil {
			BaseAddRef(goRet.pc_resource_request_handler)
			cRet = (*C.cef_resource_request_handler_t)(goRet.pc_resource_request_handler)
		}
	} else {
		Logf("T185.11: get_resource_request_handler: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before browser navigation. Return true (1) to
// cancel the navigation or false (0) to allow the navigation to proceed. The
// |request| object cannot be modified in this callback.
// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
// If the navigation is allowed cef_load_handler_t::OnLoadStart and
// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event).
///
//export cefingo_request_handler_on_before_browse
func cefingo_request_handler_on_before_browse(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	user_gesture C.int,
	is_redirect C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.6:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_before_browse_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpuser_gesture := (int)(user_gesture)
		goTmpis_redirect := (int)(is_redirect)

		goRet := f.OnBeforeBrowse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpuser_gesture, goTmpis_redirect)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.7: on_before_browse: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before OnBeforeBrowse in certain limited cases
// where navigating a new or different browser might be desirable. This
// includes user-initiated navigation that might open in a special way (e.g.
// links clicked via middle-click or ctrl + left-click) and certain types of
// cross-origin navigation initiated from the renderer process (e.g.
// navigating the top-level frame to/from a file URL). The |browser| and
// |frame| values represent the source of the navigation. The
// |target_disposition| value indicates where the user intended to navigate
// the browser based on standard Chromium behaviors (e.g. current tab, new
// tab, etc). The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event). Return
// true (1) to cancel the navigation or false (0) to allow the navigation to
// proceed in the source browser&#39;s top-level frame.
///
//export cefingo_request_handler_on_open_urlfrom_tab
func cefingo_request_handler_on_open_urlfrom_tab(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.8:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_open_urlfrom_tab_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := user_gesture != 0

		goRet := f.OnOpenUrlfromTab(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_disposition, goTmpuser_gesture)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.9: on_open_urlfrom_tab: Noo!")
	}
	return cRet
}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request. |request| represents the request contents and cannot be modified
// in this callback. |is_navigation| will be true (1) if the resource request
// is a navigation. |is_download| will be true (1) if the resource request is
// a download. |request_initiator| is the origin (scheme + domain) of the page
// that initiated the request. Set |disable_default_handling| to true (1) to
// disable default handling of the request, in which case it will need to be
// handled via cef_resource_request_handler_t::GetResourceHandler or it will
// be canceled. To allow the resource load to proceed with default handling
// return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. If this callback returns NULL the
// same function will be called on the associated
// cef_request_context_handler_t, if any.
///
//export cefingo_request_handler_get_resource_request_handler
func cefingo_request_handler_get_resource_request_handler(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	is_navigation C.int,
	is_download C.int,
	request_initiator *C.cef_string_t,
	disable_default_handling *C.int,
) (cRet *C.cef_resource_request_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.10:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.get_resource_request_handler_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpis_navigation := (int)(is_navigation)
		goTmpis_download := (int)(is_download)
		goTmprequest_initiator := string_from_cef_string(request_initiator)

		goRet, goTmpdisable_default_handlingOut := f.GetResourceRequestHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpis_navigation, goTmpis_download, goTmprequest_initiator)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		*disable_default_handling = 0
		if goTmpdisable_default_handlingOut {
			*disable_default_handling = 1
		}

		if goRet != nil {
			BaseAddRef(goRet.pc_resource_request_handler)
			cRet = (*C.cef_resource_request_handler_t)(goRet.pc_resource_request_handler)
		}
	} else {
		Logf("T187.11: get_resource_request_handler: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |origin_url| is the origin making this authentication request. |isProxy|
// indicates whether the host is a proxy server. |host| contains the hostname
// and |port| contains the port number. |realm| is the realm of the challenge
// and may be NULL. |scheme| is the authentication scheme used, such as
// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
// FTP server. Return true (1) to continue the request and call
// cef_auth_callback_t::cont() either in this function or at a later time when
// the authentication information is available. Return false (0) to cancel the
// request immediately.
///
//export cefingo_request_handler_get_auth_credentials
func cefingo_request_handler_get_auth_credentials(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.12:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.get_auth_credentials_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		goTmprealm := string_from_cef_string(realm)
		goTmpscheme := string_from_cef_string(scheme)
		goTmpcallback := newCAuthCallbackT(callback)

		goRet := f.GetAuthCredentials(goTmpself, goTmpbrowser, goTmporigin_url, goTmpisProxy, goTmphost, goTmpport, goTmprealm, goTmpscheme, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_auth_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.13: get_auth_credentials: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when JavaScript requests a specific storage quota
// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
// origin of the page making the request. |new_size| is the requested quota
// size in bytes. Return true (1) to continue the request and call
// cef_request_callback_t::cont() either in this function or at a later time
// to grant or deny the request. Return false (0) to cancel the request
// immediately.
///
//export cefingo_request_handler_on_quota_request
func cefingo_request_handler_on_quota_request(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	new_size C.int64,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.14:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_quota_request_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpnew_size := (int64)(new_size)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnQuotaRequest(goTmpself, goTmpbrowser, goTmporigin_url, goTmpnew_size, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_request_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.15: on_quota_request: Noo!")
	}
	return cRet
}

///
// Called on the UI thread to handle requests for URLs with an invalid SSL
// certificate. Return true (1) and call cef_request_callback_t::cont() either
// in this function or at a later time to continue or cancel the request.
// Return false (0) to cancel the request immediately. If
// CefSettings.ignore_certificate_errors is set all invalid certificates will
// be accepted without calling this function.
///
//export cefingo_request_handler_on_certificate_error
func cefingo_request_handler_on_certificate_error(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	cert_error C.cef_errorcode_t,
	request_url *C.cef_string_t,
	ssl_info *C.cef_sslinfo_t,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.16:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_certificate_error_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcert_error := CErrorcodeT(cert_error)
		goTmprequest_url := string_from_cef_string(request_url)
		goTmpssl_info := newCSslinfoT(ssl_info)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnCertificateError(goTmpself, goTmpbrowser, goTmpcert_error, goTmprequest_url, goTmpssl_info, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpssl_info.pc_sslinfo)
		BaseRelease(goTmpcallback.pc_request_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.17: on_certificate_error: Noo!")
	}
	return cRet
}

///
// Called on the UI thread when a client certificate is being requested for
// authentication. Return false (0) to use the default behavior and
// automatically select the first certificate available. Return true (1) and
// call cef_select_client_certificate_callback_t::Select either in this
// function or at a later time to select a certificate. Do not call Select or
// call it with NULL to continue without using any certificate. |isProxy|
// indicates whether the host is an HTTPS proxy or the origin server. |host|
// and |port| contains the hostname and port of the SSL server. |certificates|
// is the list of certificates to choose from; this list has already been
// pruned by Chromium so that it only contains certificates from issuers that
// the server trusts.
///
//export cefingo_request_handler_on_select_client_certificate
func cefingo_request_handler_on_select_client_certificate(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	certificatesCount C.size_t,
	certificates **C.cef_x509certificate_t,
	callback *C.cef_select_client_certificate_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.18:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_select_client_certificate_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		slice := (*[1 << 30](*C.cef_x509certificate_t))(unsafe.Pointer(certificates))[:certificatesCount:certificatesCount]
		goTmpcertificates := make([]*CX509certificateT, certificatesCount)
		for i, v := range slice {
			goTmpcertificates[i] = newCX509certificateT(v)
		}
		goTmpcallback := newCSelectClientCertificateCallbackT(callback)

		goRet := f.OnSelectClientCertificate(goTmpself, goTmpbrowser, goTmpisProxy, goTmphost, goTmpport, goTmpcertificates, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpcallback.pc_select_client_certificate_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T187.19: on_select_client_certificate: Noo!")
	}
	return cRet
}

///
// Called on the browser process UI thread when a plugin has crashed.
// |plugin_path| is the path of the plugin that crashed.
///
//export cefingo_request_handler_on_plugin_crashed
func cefingo_request_handler_on_plugin_crashed(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	plugin_path *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.20:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_plugin_crashed_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpplugin_path := string_from_cef_string(plugin_path)

		f.OnPluginCrashed(goTmpself, goTmpbrowser, goTmpplugin_path)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T187.21: on_plugin_crashed: Noo!")
	}

}

///
// Called on the browser process UI thread when the render view associated
// with |browser| is ready to receive/handle IPC messages in the render
// process.
///
//export cefingo_request_handler_on_render_view_ready
func cefingo_request_handler_on_render_view_ready(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.22:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_view_ready_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnRenderViewReady(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T187.23: on_render_view_ready: Noo!")
	}

}

///
// Called on the browser process UI thread when the render process terminates
// unexpectedly. |status| indicates how the process terminated.
///
//export cefingo_request_handler_on_render_process_terminated
func cefingo_request_handler_on_render_process_terminated(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	status C.cef_termination_status_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.24:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_process_terminated_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpstatus := CTerminationStatusT(status)

		f.OnRenderProcessTerminated(goTmpself, goTmpbrowser, goTmpstatus)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T187.25: on_render_process_terminated: Noo!")
	}

}

///
// Called on the browser process UI thread when the window.document object of
// the main frame has been created.
///
//export cefingo_request_handler_on_document_available_in_main_frame
func cefingo_request_handler_on_document_available_in_main_frame(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T187.26:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_document_available_in_main_frame_handler[(*cCRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnDocumentAvailableInMainFrame(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.pc_browser)

	} else {
		Logf("T187.27: on_document_available_in_main_frame: Noo!")
	}

}

///
// Called to retrieve a localized translation for the specified |string_id|.
// To provide the translation set |string| to the translation string and
// return true (1). To use the default translation return false (0). Include
// cef_pack_strings.h for a listing of valid string ID values.
///
//export cefingo_resource_bundle_handler_get_localized_string
func cefingo_resource_bundle_handler_get_localized_string(
	self *C.cef_resource_bundle_handler_t,
	string_id C.int,
	cstring *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T188.6:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_localized_string_handler[(*cCResourceBundleHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpstring_id := (int)(string_id)

		goRet, goTmpstringOut := f.GetLocalizedString(goTmpself, goTmpstring_id)
		set_cef_string(cstring, goTmpstringOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T188.7: get_localized_string: Noo!")
	}
	return cRet
}

///
// Called to retrieve data for the specified scale independent |resource_id|.
// To provide the resource data set |data| and |data_size| to the data pointer
// and size respectively and return true (1). To use the default resource data
// return false (0). The resource data will not be copied and must remain
// resident in memory. Include cef_pack_resources.h for a listing of valid
// resource ID values.
///
//export cefingo_resource_bundle_handler_get_data_resource
func cefingo_resource_bundle_handler_get_data_resource(
	self *C.cef_resource_bundle_handler_t,
	resource_id C.int,
	data *C.VOIDP,
	data_size *C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T188.8:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_data_resource_handler[(*cCResourceBundleHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpresource_id := (int)(resource_id)

		goRet, goTmpdataOut := f.GetDataResource(goTmpself, goTmpresource_id)
		*data_size = C.size_t(len(goTmpdataOut))
		*data = (C.VOIDP)(c_calloc(*data_size, 1, "T188.9:cef_resource_bundle_handler_t::get_data_resource::data"))
		target := (*[1 << 30]byte)(unsafe.Pointer(*data))[:*data_size:*data_size]
		copy(target, goTmpdataOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T188.10: get_data_resource: Noo!")
	}
	return cRet
}

///
// Called to retrieve data for the specified |resource_id| nearest the scale
// factor |scale_factor|. To provide the resource data set |data| and
// |data_size| to the data pointer and size respectively and return true (1).
// To use the default resource data return false (0). The resource data will
// not be copied and must remain resident in memory. Include
// cef_pack_resources.h for a listing of valid resource ID values.
///
//export cefingo_resource_bundle_handler_get_data_resource_for_scale
func cefingo_resource_bundle_handler_get_data_resource_for_scale(
	self *C.cef_resource_bundle_handler_t,
	resource_id C.int,
	scale_factor C.cef_scale_factor_t,
	data *C.VOIDP,
	data_size *C.size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T188.11:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_data_resource_for_scale_handler[(*cCResourceBundleHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpresource_id := (int)(resource_id)
		goTmpscale_factor := CScaleFactorT(scale_factor)

		goRet, goTmpdataOut := f.GetDataResourceForScale(goTmpself, goTmpresource_id, goTmpscale_factor)
		*data_size = C.size_t(len(goTmpdataOut))
		*data = (C.VOIDP)(c_calloc(*data_size, 1, "T188.12:cef_resource_bundle_handler_t::get_data_resource_for_scale::data"))
		target := (*[1 << 30]byte)(unsafe.Pointer(*data))[:*data_size:*data_size]
		copy(target, goTmpdataOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T188.13: get_data_resource_for_scale: Noo!")
	}
	return cRet
}

///
// Open the response stream. To handle the request immediately set
// |handle_request| to true (1) and return true (1). To decide at a later time
// set |handle_request| to false (0), return true (1), and execute |callback|
// to continue or cancel the request. To cancel the request immediately set
// |handle_request| to true (1) and return false (0). This function will be
// called in sequence but not from a dedicated thread. For backwards
// compatibility set |handle_request| to false (0) and return false (0) and
// the ProcessRequest function will be called.
///
//export cefingo_resource_handler_open
func cefingo_resource_handler_open(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	handle_request *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.6:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.open_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCCallbackT(callback)

		goRet, goTmphandle_requestOut := f.Open(goTmpself, goTmprequest, goTmpcallback)
		BaseRelease(goTmprequest.pc_request)
		*handle_request = 0
		if goTmphandle_requestOut {
			*handle_request = 1
		}
		BaseRelease(goTmpcallback.pc_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.7: open: Noo!")
	}
	return cRet
}

///
// Begin processing the request. To handle the request return true (1) and
// call cef_callback_t::cont() once the response header information is
// available (cef_callback_t::cont() can also be called from inside this
// function if header information is available immediately). To cancel the
// request return false (0).
//
// WARNING: This function is deprecated. Use Open instead.
///
//export cefingo_resource_handler_process_request
func cefingo_resource_handler_process_request(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.8:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.process_request_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCCallbackT(callback)

		goRet := f.ProcessRequest(goTmpself, goTmprequest, goTmpcallback)
		BaseRelease(goTmprequest.pc_request)
		BaseRelease(goTmpcallback.pc_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.9: process_request: Noo!")
	}
	return cRet
}

///
// Retrieve response header information. If the response length is not known
// set |response_length| to -1 and read_response() will be called until it
// returns false (0). If the response length is known set |response_length| to
// a positive value and read_response() will be called until it returns false
// (0) or the specified number of bytes have been read. Use the |response|
// object to set the mime type, http status code and other optional header
// values. To redirect the request to a new URL set |redirectUrl| to the new
// URL. |redirectUrl| can be either a relative or fully qualified URL. It is
// also possible to set |response| to a redirect http status code and pass the
// new URL via a Location header. Likewise with |redirectUrl| it is valid to
// set a relative or fully qualified URL as the Location header value. If an
// error occured while setting up the request you can call set_error() on
// |response| to indicate the error condition.
///
//export cefingo_resource_handler_get_response_headers
func cefingo_resource_handler_get_response_headers(
	self *C.cef_resource_handler_t,
	response *C.cef_response_t,
	response_length *C.int64,
	redirectUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.10:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.get_response_headers_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpresponse := newCResponseT(response)

		goTmpresponse_lengthOut, goTmpredirectUrlOut := f.GetResponseHeaders(goTmpself, goTmpresponse)
		BaseRelease(goTmpresponse.pc_response)
		*response_length = (C.int64)(goTmpresponse_lengthOut)
		set_cef_string(redirectUrl, goTmpredirectUrlOut)

	} else {
		Logf("T191.11: get_response_headers: Noo!")
	}

}

///
// Skip response data when requested by a Range header. Skip over and discard
// |bytes_to_skip| bytes of response data. If data is available immediately
// set |bytes_skipped| to the number of bytes skipped and return true (1). To
// read the data at a later time set |bytes_skipped| to 0, return true (1) and
// execute |callback| when the data is available. To indicate failure set
// |bytes_skipped| to &lt; 0 (e.g. -2 for ERR_FAILED) and return false (0). This
// function will be called in sequence but not from a dedicated thread.
///
//export cefingo_resource_handler_skip
func cefingo_resource_handler_skip(
	self *C.cef_resource_handler_t,
	bytes_to_skip C.int64,
	bytes_skipped *C.int64,
	callback *C.cef_resource_skip_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.12:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.skip_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpbytes_to_skip := (int64)(bytes_to_skip)
		goTmpcallback := newCResourceSkipCallbackT(callback)

		goRet, goTmpbytes_skippedOut := f.Skip(goTmpself, goTmpbytes_to_skip, goTmpcallback)
		*bytes_skipped = (C.int64)(goTmpbytes_skippedOut)
		BaseRelease(goTmpcallback.pc_resource_skip_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.13: skip: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time keep a
// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
// |callback| when the data is available (|data_out| will remain valid until
// the callback is executed). To indicate response completion set |bytes_read|
// to 0 and return false (0). To indicate failure set |bytes_read| to &lt; 0
// (e.g. -2 for ERR_FAILED) and return false (0). This function will be called
// in sequence but not from a dedicated thread. For backwards compatibility
// set |bytes_read| to -1 and return false (0) and the ReadResponse function
// will be called.
///
//export cefingo_resource_handler_read
func cefingo_resource_handler_read(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_resource_read_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.14:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		goTmpcallback := newCResourceReadCallbackT(callback)

		goRet, goTmpbytes_readOut := f.Read(goTmpself, goTmpdata_out, goTmpcallback)
		*bytes_read = (C.int)(goTmpbytes_readOut)
		BaseRelease(goTmpcallback.pc_resource_read_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.15: read: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time set
// |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when the
// data is available. To indicate response completion return false (0).
//
// WARNING: This function is deprecated. Use Skip and Read instead.
///
//export cefingo_resource_handler_read_response
func cefingo_resource_handler_read_response(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.16:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_response_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		goTmpcallback := newCCallbackT(callback)

		goRet, goTmpbytes_readOut := f.ReadResponse(goTmpself, goTmpdata_out, goTmpcallback)
		*bytes_read = (C.int)(goTmpbytes_readOut)
		BaseRelease(goTmpcallback.pc_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T191.17: read_response: Noo!")
	}
	return cRet
}

///
// Request processing has been canceled.
///
//export cefingo_resource_handler_cancel
func cefingo_resource_handler_cancel(
	self *C.cef_resource_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T191.18:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.cancel_handler[(*cCResourceHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)

		f.Cancel(goTmpself)

	} else {
		Logf("T191.19: cancel: Noo!")
	}

}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To
// optionally filter cookies for the request return a
// cef_cookie_access_filter_t object. The |request| object cannot not be
// modified in this callback.
///
//export cefingo_resource_request_handler_get_cookie_access_filter
func cefingo_resource_request_handler_get_cookie_access_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_cookie_access_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.6:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_cookie_access_filter_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goRet := f.GetCookieAccessFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)

		if goRet != nil {
			BaseAddRef(goRet.pc_cookie_access_filter)
			cRet = (*C.cef_cookie_access_filter_t)(goRet.pc_cookie_access_filter)
		}
	} else {
		Logf("T192.7: get_cookie_access_filter: Noo!")
	}
	return cRet
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To redirect
// or change the resource load optionally modify |request|. Modification of
// the request URL will be treated as a redirect. Return RV_CONTINUE to
// continue the request immediately. Return RV_CONTINUE_ASYNC and call
// cef_request_callback_t:: cont() at a later time to continue or cancel the
// request asynchronously. Return RV_CANCEL to cancel the request immediately.
//
///
//export cefingo_resource_request_handler_on_before_resource_load
func cefingo_resource_request_handler_on_before_resource_load(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	callback *C.cef_request_callback_t,
) (cRet C.cef_return_value_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.8:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_before_resource_load_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnBeforeResourceLoad(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpcallback)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		BaseRelease(goTmpcallback.pc_request_callback)

		cRet = (C.cef_return_value_t)(goRet)
	} else {
		Logf("T192.9: on_before_resource_load: Noo!")
	}
	return cRet
}

///
// Called on the IO thread before a resource is loaded. The |browser| and
// |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource to load using the default network loader return NULL. To specify a
// handler for the resource return a cef_resource_handler_t object. The
// |request| object cannot not be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_handler
func cefingo_resource_request_handler_get_resource_handler(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.10:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_handler_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goRet := f.GetResourceHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)

		if goRet != nil {
			BaseAddRef(goRet.pc_resource_handler)
			cRet = (*C.cef_resource_handler_t)(goRet.pc_resource_handler)
		}
	} else {
		Logf("T192.11: get_resource_handler: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when a resource load is redirected. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. The
// |request| parameter will contain the old URL and other request-related
// information. The |response| parameter will contain the response that
// resulted in the redirect. The |new_url| parameter will contain the new URL
// and can be changed if desired. The |request| and |response| objects cannot
// be modified in this callback.
///
//export cefingo_resource_request_handler_on_resource_redirect
func cefingo_resource_request_handler_on_resource_redirect(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	new_url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.12:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_redirect_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goTmpnew_urlOut := f.OnResourceRedirect(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		BaseRelease(goTmpresponse.pc_response)
		set_cef_string(new_url, goTmpnew_urlOut)

	} else {
		Logf("T192.13: on_resource_redirect: Noo!")
	}

}

///
// Called on the IO thread when a resource response is received. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource load to proceed without modification return false (0). To redirect
// or retry the resource load optionally modify |request| and return true (1).
// Modification of the request URL will be treated as a redirect. Requests
// handled using the default network loader cannot be redirected in this
// callback. The |response| object cannot be modified in this callback.
//
// WARNING: Redirecting using this function is deprecated. Use
// OnBeforeResourceLoad or GetResourceHandler to perform redirects.
///
//export cefingo_resource_request_handler_on_resource_response
func cefingo_resource_request_handler_on_resource_response(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.14:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_response_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goRet := f.OnResourceResponse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		BaseRelease(goTmpresponse.pc_response)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T192.15: on_resource_response: Noo!")
	}
	return cRet
}

///
// Called on the IO thread to optionally filter resource response content. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| and |response| represent the request and response respectively
// and cannot be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_response_filter
func cefingo_resource_request_handler_get_resource_response_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet *C.cef_response_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.16:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_response_filter_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goRet := f.GetResourceResponseFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		BaseRelease(goTmpresponse.pc_response)

		if goRet != nil {
			BaseAddRef(goRet.pc_response_filter)
			cRet = (*C.cef_response_filter_t)(goRet.pc_response_filter)
		}
	} else {
		Logf("T192.17: get_resource_response_filter: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when a resource load has completed. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// and |response| represent the request and response respectively and cannot
// be modified in this callback. |status| indicates the load completion
// status. |received_content_length| is the number of response bytes actually
// read. This function will be called for all requests, including requests
// that are aborted due to CEF shutdown or destruction of the associated
// browser. In cases where the associated browser is destroyed this callback
// may arrive after the cef_life_span_handler_t::OnBeforeClose callback for
// that browser. The cef_frame_t::IsValid function can be used to test for
// this situation, and care should be taken not to call |browser| or |frame|
// functions that modify state (like LoadURL, SendProcessMessage, etc.) if the
// frame is invalid.
///
//export cefingo_resource_request_handler_on_resource_load_complete
func cefingo_resource_request_handler_on_resource_load_complete(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	status C.cef_urlrequest_status_t,
	received_content_length C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.18:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_load_complete_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)
		goTmpstatus := CUrlrequestStatusT(status)
		goTmpreceived_content_length := (int64)(received_content_length)

		f.OnResourceLoadComplete(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse, goTmpstatus, goTmpreceived_content_length)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		BaseRelease(goTmpresponse.pc_response)

	} else {
		Logf("T192.19: on_resource_load_complete: Noo!")
	}

}

///
// Called on the IO thread to handle requests for URLs with an unknown
// protocol component. The |browser| and |frame| values represent the source
// of the request, and may be NULL for requests originating from service
// workers or cef_urlrequest_t. |request| cannot be modified in this callback.
// Set |allow_os_execution| to true (1) to attempt execution via the
// registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD USE
// THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL
// ANALYSIS BEFORE ALLOWING OS EXECUTION.
///
//export cefingo_resource_request_handler_on_protocol_execution
func cefingo_resource_request_handler_on_protocol_execution(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	allow_os_execution *C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T192.20:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_protocol_execution_handler[(*cCResourceRequestHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goTmpallow_os_executionOut := f.OnProtocolExecution(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		*allow_os_execution = (C.int)(goTmpallow_os_executionOut)

	} else {
		Logf("T192.21: on_protocol_execution: Noo!")
	}

}

///
// Called on the IO thread before a resource request is sent. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// cannot be modified in this callback. Return true (1) if the specified
// cookie can be sent with the request or false (0) otherwise.
///
//export cefingo_cookie_access_filter_can_send_cookie
func cefingo_cookie_access_filter_can_send_cookie(
	self *C.cef_cookie_access_filter_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	cookie *C.cef_cookie_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T193.6:")
	cefingoIfaceAccess.Lock()
	f := cookie_access_filter_handlers.can_send_cookie_handler[(*cCCookieAccessFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCCookieAccessFilterT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpcookie := (*CCookieT)(cookie)

		goRet := f.CanSendCookie(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpcookie)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T193.7: can_send_cookie: Noo!")
	}
	return cRet
}

///
// Called on the IO thread after a resource response is received. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| cannot be modified in this callback. Return true (1) if the
// specified cookie returned with the response can be saved or false (0)
// otherwise.
///
//export cefingo_cookie_access_filter_can_save_cookie
func cefingo_cookie_access_filter_can_save_cookie(
	self *C.cef_cookie_access_filter_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	cookie *C.cef_cookie_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T193.8:")
	cefingoIfaceAccess.Lock()
	f := cookie_access_filter_handlers.can_save_cookie_handler[(*cCCookieAccessFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCCookieAccessFilterT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)
		goTmpcookie := (*CCookieT)(cookie)

		goRet := f.CanSaveCookie(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse, goTmpcookie)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)
		BaseRelease(goTmpresponse.pc_response)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T193.9: can_save_cookie: Noo!")
	}
	return cRet
}

///
// Initialize the response filter. Will only be called a single time. The
// filter will not be installed if this function returns false (0).
///
//export cefingo_response_filter_init_filter
func cefingo_response_filter_init_filter(
	self *C.cef_response_filter_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T195.6:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.init_filter_handler[(*cCResponseFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResponseFilterT(self)

		goRet := f.InitFilter(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T195.7: init_filter: Noo!")
	}
	return cRet
}

///
// Called to filter a chunk of data. Expected usage is as follows:
//
//  A. Read input data from |data_in| and set |data_in_read| to the number of
//     bytes that were read up to a maximum of |data_in_size|. |data_in| will
//     be NULL if |data_in_size| is zero.
//  B. Write filtered output data to |data_out| and set |data_out_written| to
//     the number of bytes that were written up to a maximum of
//     |data_out_size|. If no output data was written then all data must be
//     read from |data_in| (user must set |data_in_read| = |data_in_size|).
//  C. Return RESPONSE_FILTER_DONE if all output data was written or
//     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
//
// This function will be called repeatedly until the input buffer has been
// fully read (user sets |data_in_read| = |data_in_size|) and there is no more
// input data to filter (the resource response is complete). This function may
// then be called an additional time with an NULL input buffer if the user
// filled the output buffer (set |data_out_written| = |data_out_size|) and
// returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is
// still pending.
//
// Calls to this function will stop when one of the following conditions is
// met:
//
//  A. There is no more input data to filter (the resource response is
//     complete) and the user sets |data_out_written| = 0 or returns
//     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
//  B. The user returns RESPONSE_FILTER_ERROR to indicate an error.
//
// Do not keep a reference to the buffers passed to this function.
///
//export cefingo_response_filter_filter
func cefingo_response_filter_filter(
	self *C.cef_response_filter_t,
	data_in C.VOIDP,
	data_in_size C.size_t,
	data_in_read *C.size_t,
	data_out C.VOIDP,
	data_out_size C.size_t,
	data_out_written *C.size_t,
) (cRet C.cef_response_filter_status_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T195.8:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.filter_handler[(*cCResponseFilterT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResponseFilterT(self)
		goTmpdata_in := (*[1 << 30]byte)(data_in)[:data_in_size:data_in_size]
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:data_out_size:data_out_size]

		goRet, goTmpdata_in_readOut, goTmpdata_out_writtenOut := f.Filter(goTmpself, goTmpdata_in, goTmpdata_out)
		*data_in_read = (C.size_t)(goTmpdata_in_readOut)
		*data_out_written = (C.size_t)(goTmpdata_out_writtenOut)

		cRet = (C.cef_response_filter_status_t)(goRet)
	} else {
		Logf("T195.9: filter: Noo!")
	}
	return cRet
}

///
// Return a new resource handler instance to handle the request or an NULL
// reference to allow default handling of the request. |browser| and |frame|
// will be the browser window and frame respectively that originated the
// request or NULL if the request did not originate from a browser window (for
// example, if the request came from cef_urlrequest_t). The |request| object
// passed to this function cannot be modified.
///
//export cefingo_scheme_handler_factory_create
func cefingo_scheme_handler_factory_create(
	self *C.cef_scheme_handler_factory_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	scheme_name *C.cef_string_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T197.6:")
	cefingoIfaceAccess.Lock()
	f := scheme_handler_factory_handlers.create_handler[(*cCSchemeHandlerFactoryT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCSchemeHandlerFactoryT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpscheme_name := string_from_cef_string(scheme_name)
		goTmprequest := newCRequestT(request)

		goRet := f.Create(goTmpself, goTmpbrowser, goTmpframe, goTmpscheme_name, goTmprequest)
		BaseRelease(goTmpbrowser.pc_browser)
		BaseRelease(goTmpframe.pc_frame)
		BaseRelease(goTmprequest.pc_request)

		if goRet != nil {
			BaseAddRef(goRet.pc_resource_handler)
			cRet = (*C.cef_resource_handler_t)(goRet.pc_resource_handler)
		}
	} else {
		Logf("T197.7: create: Noo!")
	}
	return cRet
}

///
// Read raw binary data.
///
//export cefingo_read_handler_read
func cefingo_read_handler_read(
	self *C.cef_read_handler_t,
	ptr C.VOIDP,
	size C.size_t,
	n C.size_t,
) (cRet C.size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.6:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.read_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)
		goTmpptr := (*[1 << 30]byte)(ptr)[: size*n : size*n]
		goTmpsize := (int64)(size)
		goTmpn := (int64)(n)

		goRet := f.Read(goTmpself, goTmpptr, goTmpsize, goTmpn)

		cRet = (C.size_t)(goRet)
	} else {
		Logf("T201.7: read: Noo!")
	}
	return cRet
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
//export cefingo_read_handler_seek
func cefingo_read_handler_seek(
	self *C.cef_read_handler_t,
	offset C.int64,
	whence C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.8:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.seek_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)
		goTmpoffset := (int64)(offset)
		goTmpwhence := (int)(whence)

		goRet := f.Seek(goTmpself, goTmpoffset, goTmpwhence)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T201.9: seek: Noo!")
	}
	return cRet
}

///
// Return the current offset position.
///
//export cefingo_read_handler_tell
func cefingo_read_handler_tell(
	self *C.cef_read_handler_t,
) (cRet C.int64) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.10:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.tell_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)

		goRet := f.Tell(goTmpself)

		cRet = (C.int64)(goRet)
	} else {
		Logf("T201.11: tell: Noo!")
	}
	return cRet
}

///
// Return non-zero if at end of file.
///
//export cefingo_read_handler_eof
func cefingo_read_handler_eof(
	self *C.cef_read_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.12:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.eof_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)

		goRet := f.Eof(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T201.13: eof: Noo!")
	}
	return cRet
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
//export cefingo_read_handler_may_block
func cefingo_read_handler_may_block(
	self *C.cef_read_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T201.14:")
	cefingoIfaceAccess.Lock()
	f := read_handler_handlers.may_block_handler[(*cCReadHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCReadHandlerT(self)

		goRet := f.MayBlock(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T201.15: may_block: Noo!")
	}
	return cRet
}

///
// Write raw binary data.
///
//export cefingo_write_handler_write
func cefingo_write_handler_write(
	self *C.cef_write_handler_t,
	ptr C.VOIDP,
	size C.size_t,
	n C.size_t,
) (cRet C.size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.6:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.write_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)
		goTmpptr := (*[1 << 30]byte)(ptr)[: size*n : size*n]
		goTmpsize := (int64)(size)
		goTmpn := (int64)(n)

		goRet := f.Write(goTmpself, goTmpptr, goTmpsize, goTmpn)

		cRet = (C.size_t)(goRet)
	} else {
		Logf("T203.7: write: Noo!")
	}
	return cRet
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
//export cefingo_write_handler_seek
func cefingo_write_handler_seek(
	self *C.cef_write_handler_t,
	offset C.int64,
	whence C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.8:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.seek_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)
		goTmpoffset := (int64)(offset)
		goTmpwhence := (int)(whence)

		goRet := f.Seek(goTmpself, goTmpoffset, goTmpwhence)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T203.9: seek: Noo!")
	}
	return cRet
}

///
// Return the current offset position.
///
//export cefingo_write_handler_tell
func cefingo_write_handler_tell(
	self *C.cef_write_handler_t,
) (cRet C.int64) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.10:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.tell_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)

		goRet := f.Tell(goTmpself)

		cRet = (C.int64)(goRet)
	} else {
		Logf("T203.11: tell: Noo!")
	}
	return cRet
}

///
// Flush the stream.
///
//export cefingo_write_handler_flush
func cefingo_write_handler_flush(
	self *C.cef_write_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.12:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.flush_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)

		goRet := f.Flush(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T203.13: flush: Noo!")
	}
	return cRet
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
//export cefingo_write_handler_may_block
func cefingo_write_handler_may_block(
	self *C.cef_write_handler_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T203.14:")
	cefingoIfaceAccess.Lock()
	f := write_handler_handlers.may_block_handler[(*cCWriteHandlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWriteHandlerT(self)

		goRet := f.MayBlock(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T203.15: may_block: Noo!")
	}
	return cRet
}

///
// Method that will be executed.
///
//export cefingo_string_visitor_visit
func cefingo_string_visitor_visit(
	self *C.cef_string_visitor_t,
	cstring *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T205.6:")
	cefingoIfaceAccess.Lock()
	f := string_visitor_handlers.visit_handler[(*cCStringVisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCStringVisitorT(self)
		goTmpstring := string_from_cef_string(cstring)

		f.Visit(goTmpself, goTmpstring)

	} else {
		Logf("T205.7: visit: Noo!")
	}

}

///
// Method that will be executed on the target thread.
///
//export cefingo_task_execute
func cefingo_task_execute(
	self *C.cef_task_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T206.6:")
	cefingoIfaceAccess.Lock()
	f := task_handlers.execute_handler[(*cCTaskT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCTaskT(self)

		f.Execute(goTmpself)

	} else {
		Logf("T206.7: execute: Noo!")
	}

}

///
// Called when |textfield| recieves a keyboard event. |event| contains
// information about the keyboard event. Return true (1) if the keyboard event
// was handled or false (0) otherwise for default handling.
///
//export cefingo_textfield_delegate_on_key_event
func cefingo_textfield_delegate_on_key_event(
	self *C.cef_textfield_delegate_t,
	textfield *C.cef_textfield_t,
	event *C.cef_key_event_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.6:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_key_event_handler[(*cCTextfieldDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCTextfieldDelegateT(self)
		goTmptextfield := newCTextfieldT(textfield)
		goTmpevent := (*CKeyEventT)(event)

		goRet := f.OnKeyEvent(goTmpself, goTmptextfield, goTmpevent)
		BaseRelease(goTmptextfield.pc_textfield)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T209.7: on_key_event: Noo!")
	}
	return cRet
}

///
// Called after performing a user action that may change |textfield|.
///
//export cefingo_textfield_delegate_on_after_user_action
func cefingo_textfield_delegate_on_after_user_action(
	self *C.cef_textfield_delegate_t,
	textfield *C.cef_textfield_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.8:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_after_user_action_handler[(*cCTextfieldDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCTextfieldDelegateT(self)
		goTmptextfield := newCTextfieldT(textfield)

		f.OnAfterUserAction(goTmpself, goTmptextfield)
		BaseRelease(goTmptextfield.pc_textfield)

	} else {
		Logf("T209.9: on_after_user_action: Noo!")
	}

}

//export cefingo_textfield_delegate_get_preferred_size
func cefingo_textfield_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.10:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_preferred_size_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T209.11: get_preferred_size: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_get_minimum_size
func cefingo_textfield_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.12:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_minimum_size_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T209.13: get_minimum_size: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_get_maximum_size
func cefingo_textfield_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.14:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_maximum_size_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T209.15: get_maximum_size: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_get_height_for_width
func cefingo_textfield_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.16:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.get_height_for_width_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.pc_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T209.17: get_height_for_width: Noo!")
	}
	return cRet
}

//export cefingo_textfield_delegate_on_parent_view_changed
func cefingo_textfield_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.18:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_parent_view_changed_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpparent.pc_view)

	} else {
		Logf("T209.19: on_parent_view_changed: Noo!")
	}

}

//export cefingo_textfield_delegate_on_child_view_changed
func cefingo_textfield_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.20:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_child_view_changed_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpchild.pc_view)

	} else {
		Logf("T209.21: on_child_view_changed: Noo!")
	}

}

//export cefingo_textfield_delegate_on_focus
func cefingo_textfield_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.22:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_focus_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T209.23: on_focus: Noo!")
	}

}

//export cefingo_textfield_delegate_on_blur
func cefingo_textfield_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T209.24:")
	cefingoIfaceAccess.Lock()
	f := textfield_delegate_handlers.on_blur_handler[(*cCTextfieldDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T209.25: on_blur: Noo!")
	}

}

///
// Notifies the client that the request has completed. Use the
// cef_urlrequest_t::GetRequestStatus function to determine if the request was
// successful or not.
///
//export cefingo_urlrequest_client_on_request_complete
func cefingo_urlrequest_client_on_request_complete(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.6:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_request_complete_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)

		f.OnRequestComplete(goTmpself, goTmprequest)
		BaseRelease(goTmprequest.pc_urlrequest)

	} else {
		Logf("T211.7: on_request_complete: Noo!")
	}

}

///
// Notifies the client of upload progress. |current| denotes the number of
// bytes sent so far and |total| is the total size of uploading data (or -1 if
// chunked upload is enabled). This function will only be called if the
// UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request.
///
//export cefingo_urlrequest_client_on_upload_progress
func cefingo_urlrequest_client_on_upload_progress(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	current C.int64,
	total C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.8:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_upload_progress_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)
		goTmpcurrent := (int64)(current)
		goTmptotal := (int64)(total)

		f.OnUploadProgress(goTmpself, goTmprequest, goTmpcurrent, goTmptotal)
		BaseRelease(goTmprequest.pc_urlrequest)

	} else {
		Logf("T211.9: on_upload_progress: Noo!")
	}

}

///
// Notifies the client of download progress. |current| denotes the number of
// bytes received up to the call and |total| is the expected total size of the
// response (or -1 if not determined).
///
//export cefingo_urlrequest_client_on_download_progress
func cefingo_urlrequest_client_on_download_progress(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	current C.int64,
	total C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.10:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_download_progress_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)
		goTmpcurrent := (int64)(current)
		goTmptotal := (int64)(total)

		f.OnDownloadProgress(goTmpself, goTmprequest, goTmpcurrent, goTmptotal)
		BaseRelease(goTmprequest.pc_urlrequest)

	} else {
		Logf("T211.11: on_download_progress: Noo!")
	}

}

///
// Called when some part of the response is read. |data| contains the current
// bytes received since the last call. This function will not be called if the
// UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request.
///
//export cefingo_urlrequest_client_on_download_data
func cefingo_urlrequest_client_on_download_data(
	self *C.cef_urlrequest_client_t,
	request *C.cef_urlrequest_t,
	data C.VOIDP,
	data_length C.size_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.12:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.on_download_data_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmprequest := newCUrlrequestT(request)
		goTmpdata := (*[1 << 30]byte)(data)[:data_length:data_length]

		f.OnDownloadData(goTmpself, goTmprequest, goTmpdata)
		BaseRelease(goTmprequest.pc_urlrequest)

	} else {
		Logf("T211.13: on_download_data: Noo!")
	}

}

///
// Called on the IO thread when the browser needs credentials from the user.
// |isProxy| indicates whether the host is a proxy server. |host| contains the
// hostname and |port| contains the port number. Return true (1) to continue
// the request and call cef_auth_callback_t::cont() when the authentication
// information is available. If the request has an associated browser/frame
// then returning false (0) will result in a call to GetAuthCredentials on the
// cef_request_handler_t associated with that browser, if any. Otherwise,
// returning false (0) will cancel the request immediately. This function will
// only be called for requests initiated from the browser process.
///
//export cefingo_urlrequest_client_get_auth_credentials
func cefingo_urlrequest_client_get_auth_credentials(
	self *C.cef_urlrequest_client_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T211.14:")
	cefingoIfaceAccess.Lock()
	f := urlrequest_client_handlers.get_auth_credentials_handler[(*cCUrlrequestClientT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCUrlrequestClientT(self)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		goTmprealm := string_from_cef_string(realm)
		goTmpscheme := string_from_cef_string(scheme)
		goTmpcallback := newCAuthCallbackT(callback)

		goRet := f.GetAuthCredentials(goTmpself, goTmpisProxy, goTmphost, goTmpport, goTmprealm, goTmpscheme, goTmpcallback)
		BaseRelease(goTmpcallback.pc_auth_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T211.15: get_auth_credentials: Noo!")
	}
	return cRet
}

///
// Handle execution of the function identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the function. |arguments| is the list of
// arguments passed to the function. If execution succeeds set |retval| to the
// function return value. If execution fails set |exception| to the exception
// that will be thrown. Return true (1) if execution was handled.
///
//export cefingo_v8handler_execute
func cefingo_v8handler_execute(
	self *C.cef_v8handler_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	argumentsCount C.size_t,
	arguments **C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T213.6:")
	cefingoIfaceAccess.Lock()
	f := v8handler_handlers.execute_handler[(*cCV8handlerT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8handlerT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)
		slice := (*[1 << 30](*C.cef_v8value_t))(unsafe.Pointer(arguments))[:argumentsCount:argumentsCount]
		goTmparguments := make([]*CV8valueT, argumentsCount)
		for i, v := range slice {
			goTmparguments[i] = newCV8valueT(v)
		}

		goRet, goTmpretvalOut, goTmpexceptionOut := f.Execute(goTmpself, goTmpname, goTmpobject, goTmparguments)
		BaseRelease(goTmpobject.pc_v8value)
		if goTmpretvalOut != nil {
			BaseAddRef(goTmpretvalOut.pc_v8value)
			*retval = (*C.cef_v8value_t)(goTmpretvalOut.pc_v8value)
		}
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T213.7: execute: Noo!")
	}
	return cRet
}

///
// Handle retrieval the accessor value identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the accessor. If retrieval succeeds set
// |retval| to the return value. If retrieval fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor retrieval was
// handled.
///
//export cefingo_v8accessor_get
func cefingo_v8accessor_get(
	self *C.cef_v8accessor_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T214.6:")
	cefingoIfaceAccess.Lock()
	f := v8accessor_handlers.get_handler[(*cCV8accessorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8accessorT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)

		goRet, goTmpretvalOut, goTmpexceptionOut := f.Get(goTmpself, goTmpname, goTmpobject)
		BaseRelease(goTmpobject.pc_v8value)
		if goTmpretvalOut != nil {
			BaseAddRef(goTmpretvalOut.pc_v8value)
			*retval = (*C.cef_v8value_t)(goTmpretvalOut.pc_v8value)
		}
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T214.7: get: Noo!")
	}
	return cRet
}

///
// Handle assignment of the accessor value identified by |name|. |object| is
// the receiver (&#39;this&#39; object) of the accessor. |value| is the new value
// being assigned to the accessor. If assignment fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor assignment was
// handled.
///
//export cefingo_v8accessor_set
func cefingo_v8accessor_set(
	self *C.cef_v8accessor_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	value *C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T214.8:")
	cefingoIfaceAccess.Lock()
	f := v8accessor_handlers.set_handler[(*cCV8accessorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8accessorT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)
		goTmpvalue := newCV8valueT(value)

		goRet, goTmpexceptionOut := f.Set(goTmpself, goTmpname, goTmpobject, goTmpvalue)
		BaseRelease(goTmpobject.pc_v8value)
		BaseRelease(goTmpvalue.pc_v8value)
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T214.9: set: Noo!")
	}
	return cRet
}

///
// Called to release |buffer| when the ArrayBuffer JS object is garbage
// collected. |buffer| is the value that was passed to CreateArrayBuffer along
// with this object.
///
//export cefingo_v8array_buffer_release_callback_release_buffer
func cefingo_v8array_buffer_release_callback_release_buffer(
	self *C.cef_v8array_buffer_release_callback_t,
	buffer C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T217.6:")
	cefingoIfaceAccess.Lock()
	f := v8array_buffer_release_callback_handlers.release_buffer_handler[(*cCV8arrayBufferReleaseCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8arrayBufferReleaseCallbackT(self)
		goTmpbuffer := unsafe.Pointer(buffer)

		f.ReleaseBuffer(goTmpself, goTmpbuffer)

	} else {
		Logf("T217.7: release_buffer: Noo!")
	}

}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
//export cefingo_view_delegate_get_preferred_size
func cefingo_view_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.6:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_preferred_size_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T226.7: get_preferred_size: Noo!")
	}
	return cRet
}

///
// Return the minimum size for |view|.
///
//export cefingo_view_delegate_get_minimum_size
func cefingo_view_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.8:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_minimum_size_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T226.9: get_minimum_size: Noo!")
	}
	return cRet
}

///
// Return the maximum size for |view|.
///
//export cefingo_view_delegate_get_maximum_size
func cefingo_view_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.10:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_maximum_size_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T226.11: get_maximum_size: Noo!")
	}
	return cRet
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
//export cefingo_view_delegate_get_height_for_width
func cefingo_view_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.12:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.get_height_for_width_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.pc_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T226.13: get_height_for_width: Noo!")
	}
	return cRet
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
//export cefingo_view_delegate_on_parent_view_changed
func cefingo_view_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.14:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_parent_view_changed_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpparent.pc_view)

	} else {
		Logf("T226.15: on_parent_view_changed: Noo!")
	}

}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
//export cefingo_view_delegate_on_child_view_changed
func cefingo_view_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.16:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_child_view_changed_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpchild.pc_view)

	} else {
		Logf("T226.17: on_child_view_changed: Noo!")
	}

}

///
// Called when |view| gains focus.
///
//export cefingo_view_delegate_on_focus
func cefingo_view_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.18:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_focus_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T226.19: on_focus: Noo!")
	}

}

///
// Called when |view| loses focus.
///
//export cefingo_view_delegate_on_blur
func cefingo_view_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T226.20:")
	cefingoIfaceAccess.Lock()
	f := view_delegate_handlers.on_blur_handler[(*cCViewDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T226.21: on_blur: Noo!")
	}

}

///
// Method that will be called once for each plugin. |count| is the 0-based
// index for the current plugin. |total| is the total number of plugins.
// Return false (0) to stop visiting plugins. This function may never be
// called if no plugins are found.
///
//export cefingo_web_plugin_info_visitor_visit
func cefingo_web_plugin_info_visitor_visit(
	self *C.cef_web_plugin_info_visitor_t,
	info *C.cef_web_plugin_info_t,
	count C.int,
	total C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T228.6:")
	cefingoIfaceAccess.Lock()
	f := web_plugin_info_visitor_handlers.visit_handler[(*cCWebPluginInfoVisitorT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWebPluginInfoVisitorT(self)
		goTmpinfo := newCWebPluginInfoT(info)
		goTmpcount := (int)(count)
		goTmptotal := (int)(total)

		goRet := f.Visit(goTmpself, goTmpinfo, goTmpcount, goTmptotal)
		BaseRelease(goTmpinfo.pc_web_plugin_info)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T228.7: visit: Noo!")
	}
	return cRet
}

///
// Method that will be called for the requested plugin. |unstable| will be
// true (1) if the plugin has reached the crash count threshold of 3 times in
// 120 seconds.
///
//export cefingo_web_plugin_unstable_callback_is_unstable
func cefingo_web_plugin_unstable_callback_is_unstable(
	self *C.cef_web_plugin_unstable_callback_t,
	path *C.cef_string_t,
	unstable C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T229.6:")
	cefingoIfaceAccess.Lock()
	f := web_plugin_unstable_callback_handlers.is_unstable_handler[(*cCWebPluginUnstableCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWebPluginUnstableCallbackT(self)
		goTmppath := string_from_cef_string(path)
		goTmpunstable := (int)(unstable)

		f.IsUnstable(goTmpself, goTmppath, goTmpunstable)

	} else {
		Logf("T229.7: is_unstable: Noo!")
	}

}

///
// Method that will be called when CDM registration is complete. |result| will
// be CEF_CDM_REGISTRATION_ERROR_NONE if registration completed successfully.
// Otherwise, |result| and |error_message| will contain additional information
// about why registration failed.
///
//export cefingo_register_cdm_callback_on_cdm_registration_complete
func cefingo_register_cdm_callback_on_cdm_registration_complete(
	self *C.cef_register_cdm_callback_t,
	result C.cef_cdm_registration_error_t,
	error_message *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T230.6:")
	cefingoIfaceAccess.Lock()
	f := register_cdm_callback_handlers.on_cdm_registration_complete_handler[(*cCRegisterCdmCallbackT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRegisterCdmCallbackT(self)
		goTmpresult := CCdmRegistrationErrorT(result)
		goTmperror_message := string_from_cef_string(error_message)

		f.OnCdmRegistrationComplete(goTmpself, goTmpresult, goTmperror_message)

	} else {
		Logf("T230.7: on_cdm_registration_complete: Noo!")
	}

}

///
// Called when |window| is created.
///
//export cefingo_window_delegate_on_window_created
func cefingo_window_delegate_on_window_created(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.6:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_window_created_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		f.OnWindowCreated(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

	} else {
		Logf("T232.7: on_window_created: Noo!")
	}

}

///
// Called when |window| is destroyed. Release all references to |window| and
// do not attempt to execute any functions on |window| after this callback
// returns.
///
//export cefingo_window_delegate_on_window_destroyed
func cefingo_window_delegate_on_window_destroyed(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.8:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_window_destroyed_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		f.OnWindowDestroyed(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

	} else {
		Logf("T232.9: on_window_destroyed: Noo!")
	}

}

///
// Return the parent for |window| or NULL if the |window| does not have a
// parent. Windows with parents will not get a taskbar button. Set |is_menu|
// to true (1) if |window| will be displayed as a menu, in which case it will
// not be clipped to the parent window bounds. Set |can_activate_menu| to
// false (0) if |is_menu| is true (1) and |window| should not be activated
// (given keyboard focus) when displayed.
///
//export cefingo_window_delegate_get_parent_window
func cefingo_window_delegate_get_parent_window(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	is_menu *C.int,
	can_activate_menu *C.int,
) (cRet *C.cef_window_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.10:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_parent_window_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet, goTmpis_menuOut, goTmpcan_activate_menuOut := f.GetParentWindow(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)
		*is_menu = 0
		if goTmpis_menuOut {
			*is_menu = 1
		}
		*can_activate_menu = 0
		if goTmpcan_activate_menuOut {
			*can_activate_menu = 1
		}

		if goRet != nil {
			BaseAddRef(goRet.pc_window)
			cRet = (*C.cef_window_t)(goRet.pc_window)
		}
	} else {
		Logf("T232.11: get_parent_window: Noo!")
	}
	return cRet
}

///
// Return the initial bounds for |window| in density independent pixel (DIP)
// coordinates. If this function returns an NULL CefRect then
// get_preferred_size() will be called to retrieve the size, and the window
// will be placed on the screen with origin (0,0). This function can be used
// in combination with cef_view_t::get_bounds_in_screen() to restore the
// previous window bounds.
///
//export cefingo_window_delegate_get_initial_bounds
func cefingo_window_delegate_get_initial_bounds(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.cef_rect_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.12:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_initial_bounds_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.GetInitialBounds(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

		cRet = (C.cef_rect_t)(goRet)
	} else {
		Logf("T232.13: get_initial_bounds: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| should be created without a frame or title bar.
// The window will be resizable if can_resize() returns true (1). Use
// cef_window_t::set_draggable_regions() to specify draggable regions.
///
//export cefingo_window_delegate_is_frameless
func cefingo_window_delegate_is_frameless(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.14:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.is_frameless_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.IsFrameless(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.15: is_frameless: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be resized.
///
//export cefingo_window_delegate_can_resize
func cefingo_window_delegate_can_resize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.16:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_resize_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanResize(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.17: can_resize: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be maximized.
///
//export cefingo_window_delegate_can_maximize
func cefingo_window_delegate_can_maximize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.18:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_maximize_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanMaximize(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.19: can_maximize: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be minimized.
///
//export cefingo_window_delegate_can_minimize
func cefingo_window_delegate_can_minimize(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.20:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_minimize_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanMinimize(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.21: can_minimize: Noo!")
	}
	return cRet
}

///
// Return true (1) if |window| can be closed. This will be called for user-
// initiated window close actions and when cef_window_t::close() is called.
///
//export cefingo_window_delegate_can_close
func cefingo_window_delegate_can_close(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.22:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.can_close_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)

		goRet := f.CanClose(goTmpself, goTmpwindow)
		BaseRelease(goTmpwindow.pc_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.23: can_close: Noo!")
	}
	return cRet
}

///
// Called when a keyboard accelerator registered with
// cef_window_t::SetAccelerator is triggered. Return true (1) if the
// accelerator was handled or false (0) otherwise.
///
//export cefingo_window_delegate_on_accelerator
func cefingo_window_delegate_on_accelerator(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	command_id C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.24:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_accelerator_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)
		goTmpcommand_id := (int)(command_id)

		goRet := f.OnAccelerator(goTmpself, goTmpwindow, goTmpcommand_id)
		BaseRelease(goTmpwindow.pc_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.25: on_accelerator: Noo!")
	}
	return cRet
}

///
// Called after all other controls in the window have had a chance to handle
// the event. |event| contains information about the keyboard event. Return
// true (1) if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_window_delegate_on_key_event
func cefingo_window_delegate_on_key_event(
	self *C.cef_window_delegate_t,
	window *C.cef_window_t,
	event *C.cef_key_event_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.26:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_key_event_handler[(*cCWindowDelegateT)(self)]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCWindowDelegateT(self)
		goTmpwindow := newCWindowT(window)
		goTmpevent := (*CKeyEventT)(event)

		goRet := f.OnKeyEvent(goTmpself, goTmpwindow, goTmpevent)
		BaseRelease(goTmpwindow.pc_window)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.27: on_key_event: Noo!")
	}
	return cRet
}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
//export cefingo_window_delegate_get_preferred_size
func cefingo_window_delegate_get_preferred_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.28:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_preferred_size_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetPreferredSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T232.29: get_preferred_size: Noo!")
	}
	return cRet
}

///
// Return the minimum size for |view|.
///
//export cefingo_window_delegate_get_minimum_size
func cefingo_window_delegate_get_minimum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.30:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_minimum_size_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMinimumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T232.31: get_minimum_size: Noo!")
	}
	return cRet
}

///
// Return the maximum size for |view|.
///
//export cefingo_window_delegate_get_maximum_size
func cefingo_window_delegate_get_maximum_size(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) (cRet C.cef_size_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.32:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_maximum_size_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		goRet := f.GetMaximumSize(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

		cRet = (C.cef_size_t)(goRet)
	} else {
		Logf("T232.33: get_maximum_size: Noo!")
	}
	return cRet
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
//export cefingo_window_delegate_get_height_for_width
func cefingo_window_delegate_get_height_for_width(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	width C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.34:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.get_height_for_width_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpwidth := (int)(width)

		goRet := f.GetHeightForWidth(goTmpself, goTmpview, goTmpwidth)
		BaseRelease(goTmpview.pc_view)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T232.35: get_height_for_width: Noo!")
	}
	return cRet
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
//export cefingo_window_delegate_on_parent_view_changed
func cefingo_window_delegate_on_parent_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	parent *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.36:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_parent_view_changed_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpparent := newCViewT(parent)

		f.OnParentViewChanged(goTmpself, goTmpview, goTmpadded, goTmpparent)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpparent.pc_view)

	} else {
		Logf("T232.37: on_parent_view_changed: Noo!")
	}

}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
//export cefingo_window_delegate_on_child_view_changed
func cefingo_window_delegate_on_child_view_changed(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
	added C.int,
	child *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.38:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_child_view_changed_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)
		goTmpadded := (int)(added)
		goTmpchild := newCViewT(child)

		f.OnChildViewChanged(goTmpself, goTmpview, goTmpadded, goTmpchild)
		BaseRelease(goTmpview.pc_view)
		BaseRelease(goTmpchild.pc_view)

	} else {
		Logf("T232.39: on_child_view_changed: Noo!")
	}

}

///
// Called when |view| gains focus.
///
//export cefingo_window_delegate_on_focus
func cefingo_window_delegate_on_focus(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.40:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_focus_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnFocus(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T232.41: on_focus: Noo!")
	}

}

///
// Called when |view| loses focus.
///
//export cefingo_window_delegate_on_blur
func cefingo_window_delegate_on_blur(
	self *C.cef_view_delegate_t,
	view *C.cef_view_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T232.42:")
	cefingoIfaceAccess.Lock()
	f := window_delegate_handlers.on_blur_handler[(*cCWindowDelegateT)(unsafe.Pointer(self))]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCViewDelegateT(self)
		goTmpview := newCViewT(view)

		f.OnBlur(goTmpself, goTmpview)
		BaseRelease(goTmpview.pc_view)

	} else {
		Logf("T232.43: on_blur: Noo!")
	}

}
