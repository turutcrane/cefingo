// Code generated by "gen-cefingo.go" DO NOT EDIT.
package capi

import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"

///
// Called after renderer process sends accessibility tree changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_tree_change
func cefingo_accessibility_handler_on_accessibility_tree_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T21:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_tree_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityTreeChange(goTmpself, goTmpvalue)
		BaseRelease(goTmpvalue.p_value)

	} else {
		Logf("T34: on_accessibility_tree_change: Noo!")
	}

}

///
// Called after renderer process sends accessibility location changes to the
// browser process.
///
//export cefingo_accessibility_handler_on_accessibility_location_change
func cefingo_accessibility_handler_on_accessibility_location_change(
	self *C.cef_accessibility_handler_t,
	value *C.cef_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T51:")
	cefingoIfaceAccess.Lock()
	f := accessibility_handler_handlers.on_accessibility_location_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAccessibilityHandlerT(self)
		goTmpvalue := newCValueT(value)

		f.OnAccessibilityLocationChange(goTmpself, goTmpvalue)
		BaseRelease(goTmpvalue.p_value)

	} else {
		Logf("T64: on_accessibility_location_change: Noo!")
	}

}

//export cefingo_app_get_resource_bundle_handler
func cefingo_app_get_resource_bundle_handler(self *C.cef_app_t) (ch *C.cef_resource_bundle_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.resource_bundle_handler[self]
	if handler == nil {
		Logf("T79: get_resource_bundle_handler")
	} else {
		BaseAddRef(handler.p_resource_bundle_handler)
		ch = handler.p_resource_bundle_handler
	}
	return ch
}

//export cefingo_app_get_browser_process_handler
func cefingo_app_get_browser_process_handler(self *C.cef_app_t) (ch *C.cef_browser_process_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.browser_process_handler[self]
	if handler == nil {
		Logf("T94: get_browser_process_handler")
	} else {
		BaseAddRef(handler.p_browser_process_handler)
		ch = handler.p_browser_process_handler
	}
	return ch
}

//export cefingo_app_get_render_process_handler
func cefingo_app_get_render_process_handler(self *C.cef_app_t) (ch *C.cef_render_process_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := app_handlers.render_process_handler[self]
	if handler == nil {
		Logf("T109: get_render_process_handler")
	} else {
		BaseAddRef(handler.p_render_process_handler)
		ch = handler.p_render_process_handler
	}
	return ch
}

///
// Provides an opportunity to view and/or modify command-line arguments before
// processing by CEF and Chromium. The |process_type| value will be NULL for
// the browser process. Do not keep a reference to the cef_command_line_t
// object passed to this function. The CefSettings.command_line_args_disabled
// value can be used to start with an NULL command-line object. Any values
// specified in CefSettings that equate to command-line arguments will be set
// before this function is called. Be cautious when using this function to
// modify command-line arguments for non-browser processes as this may result
// in undefined behavior including crashes.
///
//export cefingo_app_on_before_command_line_processing
func cefingo_app_on_before_command_line_processing(
	self *C.cef_app_t,
	process_type *C.cef_string_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T134:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_before_command_line_processing_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpprocess_type := string_from_cef_string(process_type)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeCommandLineProcessing(goTmpself, goTmpprocess_type, goTmpcommand_line)
		BaseRelease(goTmpcommand_line.p_command_line)

	} else {
		Logf("T148: on_before_command_line_processing: Noo!")
	}

}

///
// Provides an opportunity to register custom schemes. Do not keep a reference
// to the |registrar| object. This function is called on the main thread for
// each process and the registered schemes should be the same across all
// processes.
///
//export cefingo_app_on_register_custom_schemes
func cefingo_app_on_register_custom_schemes(
	self *C.cef_app_t,
	registrar *C.cef_scheme_registrar_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T167:")
	cefingoIfaceAccess.Lock()
	f := app_handlers.on_register_custom_schemes_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCAppT(self)
		goTmpregistrar := newCSchemeRegistrarT(registrar)

		f.OnRegisterCustomSchemes(goTmpself, goTmpregistrar)

	} else {
		Logf("T179: on_register_custom_schemes: Noo!")
	}

}

///
// Called asynchronously after the file dialog is dismissed.
// |selected_accept_filter| is the 0-based index of the value selected from
// the accept filters array passed to cef_browser_host_t::RunFileDialog.
// |file_paths| will be a single value or a list of values depending on the
// dialog mode. If the selection was cancelled |file_paths| will be NULL.
///
//export cefingo_run_file_dialog_callback_on_file_dialog_dismissed
func cefingo_run_file_dialog_callback_on_file_dialog_dismissed(
	self *C.cef_run_file_dialog_callback_t,
	selected_accept_filter C.int,
	file_paths C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T200:")
	cefingoIfaceAccess.Lock()
	f := run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRunFileDialogCallbackT(self)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpfile_paths := (CStringListT)(file_paths)

		f.OnFileDialogDismissed(goTmpself, goTmpselected_accept_filter, goTmpfile_paths)

	} else {
		Logf("T213: on_file_dialog_dismissed: Noo!")
	}

}

//export cefingo_browser_process_handler_get_print_handler
func cefingo_browser_process_handler_get_print_handler(self *C.cef_browser_process_handler_t) (ch *C.cef_print_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := browser_process_handler_handlers.print_handler[self]
	if handler == nil {
		Logf("T228: get_print_handler")
	} else {
		BaseAddRef(handler.p_print_handler)
		ch = handler.p_print_handler
	}
	return ch
}

///
// Called on the browser process UI thread immediately after the CEF context
// has been initialized.
///
//export cefingo_browser_process_handler_on_context_initialized
func cefingo_browser_process_handler_on_context_initialized(
	self *C.cef_browser_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T244:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_context_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)

		f.OnContextInitialized(goTmpself)

	} else {
		Logf("T255: on_context_initialized: Noo!")
	}

}

///
// Called before a child process is launched. Will be called on the browser
// process UI thread when launching a render process and on the browser
// process IO thread when launching a GPU or plugin process. Provides an
// opportunity to modify the child process command line. Do not keep a
// reference to |command_line| outside of this function.
///
//export cefingo_browser_process_handler_on_before_child_process_launch
func cefingo_browser_process_handler_on_before_child_process_launch(
	self *C.cef_browser_process_handler_t,
	command_line *C.cef_command_line_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T275:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_before_child_process_launch_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpcommand_line := newCCommandLineT(command_line)

		f.OnBeforeChildProcessLaunch(goTmpself, goTmpcommand_line)
		BaseRelease(goTmpcommand_line.p_command_line)

	} else {
		Logf("T288: on_before_child_process_launch: Noo!")
	}

}

///
// Called on the browser process IO thread after the main thread has been
// created for a new render process. Provides an opportunity to specify extra
// information that will be passed to
// cef_render_process_handler_t::on_render_thread_created() in the render
// process. Do not keep a reference to |extra_info| outside of this function.
///
//export cefingo_browser_process_handler_on_render_process_thread_created
func cefingo_browser_process_handler_on_render_process_thread_created(
	self *C.cef_browser_process_handler_t,
	extra_info *C.cef_list_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T308:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_render_process_thread_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpextra_info := newCListValueT(extra_info)

		f.OnRenderProcessThreadCreated(goTmpself, goTmpextra_info)
		BaseRelease(goTmpextra_info.p_list_value)

	} else {
		Logf("T321: on_render_process_thread_created: Noo!")
	}

}

///
// Called from any thread when work has been scheduled for the browser process
// main (UI) thread. This callback is used in combination with CefSettings.
// external_message_pump and cef_do_message_loop_work() in cases where the CEF
// message loop must be integrated into an existing application message loop
// (see additional comments and warnings on CefDoMessageLoopWork). This
// callback should schedule a cef_do_message_loop_work() call to happen on the
// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
// |delay_ms| is &lt;= 0 then the call should happen reasonably soon. If
// |delay_ms| is &gt; 0 then the call should be scheduled to happen after the
// specified delay and any currently pending scheduled call should be
// cancelled.
///
//export cefingo_browser_process_handler_on_schedule_message_pump_work
func cefingo_browser_process_handler_on_schedule_message_pump_work(
	self *C.cef_browser_process_handler_t,
	delay_ms C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T347:")
	cefingoIfaceAccess.Lock()
	f := browser_process_handler_handlers.on_schedule_message_pump_work_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCBrowserProcessHandlerT(self)
		goTmpdelay_ms := (int64)(delay_ms)

		f.OnScheduleMessagePumpWork(goTmpself, goTmpdelay_ms)

	} else {
		Logf("T359: on_schedule_message_pump_work: Noo!")
	}

}

//export cefingo_client_get_context_menu_handler
func cefingo_client_get_context_menu_handler(self *C.cef_client_t) (ch *C.cef_context_menu_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.context_menu_handler[self]
	if handler == nil {
		Logf("T374: get_context_menu_handler")
	} else {
		BaseAddRef(handler.p_context_menu_handler)
		ch = handler.p_context_menu_handler
	}
	return ch
}

//export cefingo_client_get_dialog_handler
func cefingo_client_get_dialog_handler(self *C.cef_client_t) (ch *C.cef_dialog_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.dialog_handler[self]
	if handler == nil {
		Logf("T389: get_dialog_handler")
	} else {
		BaseAddRef(handler.p_dialog_handler)
		ch = handler.p_dialog_handler
	}
	return ch
}

//export cefingo_client_get_display_handler
func cefingo_client_get_display_handler(self *C.cef_client_t) (ch *C.cef_display_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.display_handler[self]
	if handler == nil {
		Logf("T404: get_display_handler")
	} else {
		BaseAddRef(handler.p_display_handler)
		ch = handler.p_display_handler
	}
	return ch
}

//export cefingo_client_get_download_handler
func cefingo_client_get_download_handler(self *C.cef_client_t) (ch *C.cef_download_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.download_handler[self]
	if handler == nil {
		Logf("T419: get_download_handler")
	} else {
		BaseAddRef(handler.p_download_handler)
		ch = handler.p_download_handler
	}
	return ch
}

//export cefingo_client_get_drag_handler
func cefingo_client_get_drag_handler(self *C.cef_client_t) (ch *C.cef_drag_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.drag_handler[self]
	if handler == nil {
		Logf("T434: get_drag_handler")
	} else {
		BaseAddRef(handler.p_drag_handler)
		ch = handler.p_drag_handler
	}
	return ch
}

//export cefingo_client_get_find_handler
func cefingo_client_get_find_handler(self *C.cef_client_t) (ch *C.cef_find_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.find_handler[self]
	if handler == nil {
		Logf("T449: get_find_handler")
	} else {
		BaseAddRef(handler.p_find_handler)
		ch = handler.p_find_handler
	}
	return ch
}

//export cefingo_client_get_focus_handler
func cefingo_client_get_focus_handler(self *C.cef_client_t) (ch *C.cef_focus_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.focus_handler[self]
	if handler == nil {
		Logf("T464: get_focus_handler")
	} else {
		BaseAddRef(handler.p_focus_handler)
		ch = handler.p_focus_handler
	}
	return ch
}

//export cefingo_client_get_jsdialog_handler
func cefingo_client_get_jsdialog_handler(self *C.cef_client_t) (ch *C.cef_jsdialog_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.jsdialog_handler[self]
	if handler == nil {
		Logf("T479: get_jsdialog_handler")
	} else {
		BaseAddRef(handler.p_jsdialog_handler)
		ch = handler.p_jsdialog_handler
	}
	return ch
}

//export cefingo_client_get_keyboard_handler
func cefingo_client_get_keyboard_handler(self *C.cef_client_t) (ch *C.cef_keyboard_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.keyboard_handler[self]
	if handler == nil {
		Logf("T494: get_keyboard_handler")
	} else {
		BaseAddRef(handler.p_keyboard_handler)
		ch = handler.p_keyboard_handler
	}
	return ch
}

//export cefingo_client_get_life_span_handler
func cefingo_client_get_life_span_handler(self *C.cef_client_t) (ch *C.cef_life_span_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.life_span_handler[self]
	if handler == nil {
		Logf("T509: get_life_span_handler")
	} else {
		BaseAddRef(handler.p_life_span_handler)
		ch = handler.p_life_span_handler
	}
	return ch
}

//export cefingo_client_get_load_handler
func cefingo_client_get_load_handler(self *C.cef_client_t) (ch *C.cef_load_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.load_handler[self]
	if handler == nil {
		Logf("T524: get_load_handler")
	} else {
		BaseAddRef(handler.p_load_handler)
		ch = handler.p_load_handler
	}
	return ch
}

//export cefingo_client_get_render_handler
func cefingo_client_get_render_handler(self *C.cef_client_t) (ch *C.cef_render_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.render_handler[self]
	if handler == nil {
		Logf("T539: get_render_handler")
	} else {
		BaseAddRef(handler.p_render_handler)
		ch = handler.p_render_handler
	}
	return ch
}

//export cefingo_client_get_request_handler
func cefingo_client_get_request_handler(self *C.cef_client_t) (ch *C.cef_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := client_handlers.request_handler[self]
	if handler == nil {
		Logf("T554: get_request_handler")
	} else {
		BaseAddRef(handler.p_request_handler)
		ch = handler.p_request_handler
	}
	return ch
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_client_on_process_message_received
func cefingo_client_on_process_message_received(
	self *C.cef_client_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T575:")
	cefingoIfaceAccess.Lock()
	f := client_handlers.on_process_message_received_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCClientT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpmessage.p_process_message)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T594: on_process_message_received: Noo!")
	}
	return cRet
}

///
// Called before a context menu is displayed. |params| provides information
// about the context menu state. |model| initially contains the default
// context menu. The |model| can be cleared to show no context menu or
// modified to show a custom menu. Do not keep references to |params| or
// |model| outside of this callback.
///
//export cefingo_context_menu_handler_on_before_context_menu
func cefingo_context_menu_handler_on_before_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T617:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_before_context_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)

		f.OnBeforeContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)
		BaseRelease(goTmpmodel.p_menu_model)

	} else {
		Logf("T636: on_before_context_menu: Noo!")
	}

}

///
// Called to allow custom display of the context menu. |params| provides
// information about the context menu state. |model| contains the context menu
// model resulting from OnBeforeContextMenu. For custom display return true
// (1) and execute |callback| either synchronously or asynchronously with the
// selected command ID. For default display return false (0). Do not keep
// references to |params| or |model| outside of this callback.
///
//export cefingo_context_menu_handler_run_context_menu
func cefingo_context_menu_handler_run_context_menu(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	model *C.cef_menu_model_t,
	callback *C.cef_run_context_menu_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T661:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.run_context_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpmodel := newCMenuModelT(model)
		goTmpcallback := newCRunContextMenuCallbackT(callback)

		goRet := f.RunContextMenu(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpmodel, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)
		BaseRelease(goTmpmodel.p_menu_model)
		BaseRelease(goTmpcallback.p_run_context_menu_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T683: run_context_menu: Noo!")
	}
	return cRet
}

///
// Called to execute a command selected from the context menu. Return true (1)
// if the command was handled or false (0) for the default implementation. See
// cef_menu_id_t for the command ids that have default implementations. All
// user-defined command ids should be between MENU_ID_USER_FIRST and
// MENU_ID_USER_LAST. |params| will have the same values as what was passed to
// on_before_context_menu(). Do not keep a reference to |params| outside of
// this callback.
///
//export cefingo_context_menu_handler_on_context_menu_command
func cefingo_context_menu_handler_on_context_menu_command(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	params *C.cef_context_menu_params_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T709:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_command_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpparams := newCContextMenuParamsT(params)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		goRet := f.OnContextMenuCommand(goTmpself, goTmpbrowser, goTmpframe, goTmpparams, goTmpcommand_id, goTmpevent_flags)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpparams.p_context_menu_params)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T729: on_context_menu_command: Noo!")
	}
	return cRet
}

///
// Called when the context menu is dismissed irregardless of whether the menu
// was NULL or a command was selected.
///
//export cefingo_context_menu_handler_on_context_menu_dismissed
func cefingo_context_menu_handler_on_context_menu_dismissed(
	self *C.cef_context_menu_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T747:")
	cefingoIfaceAccess.Lock()
	f := context_menu_handler_handlers.on_context_menu_dismissed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCContextMenuHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)

		f.OnContextMenuDismissed(goTmpself, goTmpbrowser, goTmpframe)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T762: on_context_menu_dismissed: Noo!")
	}

}

///
// Called to run a file chooser dialog. |mode| represents the type of dialog
// to display. |title| to the title to be used for the dialog and may be NULL
// to show the default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode).
// |default_file_path| is the path with optional directory and/or file name
// component that should be initially selected in the dialog. |accept_filters|
// are used to restrict the selectable file types and may any combination of
// (a) valid lower-cased MIME types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b)
// individual file extensions (e.g. &quot;.txt&quot; or &quot;.png&quot;), or (c) combined
// description and file extension delimited using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image
// Types|.png;.gif;.jpg&quot;). |selected_accept_filter| is the 0-based index of
// the filter that should be selected by default. To display a custom dialog
// return true (1) and execute |callback| either inline or at a later time. To
// display the default dialog return false (0).
///
//export cefingo_dialog_handler_on_file_dialog
func cefingo_dialog_handler_on_file_dialog(
	self *C.cef_dialog_handler_t,
	browser *C.cef_browser_t,
	mode C.cef_file_dialog_mode_t,
	title *C.cef_string_t,
	default_file_path *C.cef_string_t,
	accept_filters C.cef_string_list_t,
	selected_accept_filter C.int,
	callback *C.cef_file_dialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T796:")
	cefingoIfaceAccess.Lock()
	f := dialog_handler_handlers.on_file_dialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmode := CFileDialogModeT(mode)
		goTmptitle := string_from_cef_string(title)
		goTmpdefault_file_path := string_from_cef_string(default_file_path)
		goTmpaccept_filters := (CStringListT)(accept_filters)
		goTmpselected_accept_filter := (int)(selected_accept_filter)
		goTmpcallback := newCFileDialogCallbackT(callback)

		goRet := f.OnFileDialog(goTmpself, goTmpbrowser, goTmpmode, goTmptitle, goTmpdefault_file_path, goTmpaccept_filters, goTmpselected_accept_filter, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_file_dialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T817: on_file_dialog: Noo!")
	}
	return cRet
}

///
// Called when a frame&#39;s address has changed.
///
//export cefingo_display_handler_on_address_change
func cefingo_display_handler_on_address_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T835:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_address_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpurl := string_from_cef_string(url)

		f.OnAddressChange(goTmpself, goTmpbrowser, goTmpframe, goTmpurl)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T851: on_address_change: Noo!")
	}

}

///
// Called when the page title changes.
///
//export cefingo_display_handler_on_title_change
func cefingo_display_handler_on_title_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	title *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T868:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_title_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptitle := string_from_cef_string(title)

		f.OnTitleChange(goTmpself, goTmpbrowser, goTmptitle)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T882: on_title_change: Noo!")
	}

}

///
// Called when the page icon changes.
///
//export cefingo_display_handler_on_favicon_urlchange
func cefingo_display_handler_on_favicon_urlchange(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	icon_urls C.cef_string_list_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T899:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_favicon_urlchange_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpicon_urls := (CStringListT)(icon_urls)

		f.OnFaviconUrlchange(goTmpself, goTmpbrowser, goTmpicon_urls)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T913: on_favicon_urlchange: Noo!")
	}

}

///
// Called when web content in the page has toggled fullscreen mode. If
// |fullscreen| is true (1) the content will automatically be sized to fill
// the browser content area. If |fullscreen| is false (0) the content will
// automatically return to its original size and position. The client is
// responsible for resizing the browser if desired.
///
//export cefingo_display_handler_on_fullscreen_mode_change
func cefingo_display_handler_on_fullscreen_mode_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	fullscreen C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T934:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_fullscreen_mode_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfullscreen := (int)(fullscreen)

		f.OnFullscreenModeChange(goTmpself, goTmpbrowser, goTmpfullscreen)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T948: on_fullscreen_mode_change: Noo!")
	}

}

///
// Called when the browser is about to display a tooltip. |text| contains the
// text that will be displayed in the tooltip. To handle the display of the
// tooltip yourself return true (1). Otherwise, you can optionally modify
// |text| and then return false (0) to allow the browser to display the
// tooltip. When window rendering is disabled the application is responsible
// for drawing tooltips and the return value is ignored.
///
//export cefingo_display_handler_on_tooltip
func cefingo_display_handler_on_tooltip(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	text *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T970:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_tooltip_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptext := string_from_cef_string(text)

		goRet, goTmptextOut := f.OnTooltip(goTmpself, goTmpbrowser, goTmptext)
		BaseRelease(goTmpbrowser.p_browser)
		set_cef_string(text, goTmptextOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T985: on_tooltip: Noo!")
	}
	return cRet
}

///
// Called when the browser receives a status message. |value| contains the
// text that will be displayed in the status message.
///
//export cefingo_display_handler_on_status_message
func cefingo_display_handler_on_status_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	value *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1004:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_status_message_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpvalue := string_from_cef_string(value)

		f.OnStatusMessage(goTmpself, goTmpbrowser, goTmpvalue)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1018: on_status_message: Noo!")
	}

}

///
// Called to display a console message. Return true (1) to stop the message
// from being output to the console.
///
//export cefingo_display_handler_on_console_message
func cefingo_display_handler_on_console_message(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	level C.cef_log_severity_t,
	message *C.cef_string_t,
	source *C.cef_string_t,
	line C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1039:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_console_message_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmplevel := CLogSeverityT(level)
		goTmpmessage := string_from_cef_string(message)
		goTmpsource := string_from_cef_string(source)
		goTmpline := (int)(line)

		goRet := f.OnConsoleMessage(goTmpself, goTmpbrowser, goTmplevel, goTmpmessage, goTmpsource, goTmpline)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1057: on_console_message: Noo!")
	}
	return cRet
}

///
// Called when auto-resize is enabled via
// cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-
// resized. |new_size| will be the desired size in view coordinates. Return
// true (1) if the resize was handled or false (0) for default handling.
///
//export cefingo_display_handler_on_auto_resize
func cefingo_display_handler_on_auto_resize(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	new_size *C.cef_size_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1077:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_auto_resize_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnew_size := (*CSizeT)(new_size)

		goRet := f.OnAutoResize(goTmpself, goTmpbrowser, goTmpnew_size)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1092: on_auto_resize: Noo!")
	}
	return cRet
}

///
// Called when the overall page loading progress has changed. |progress|
// ranges from 0.0 to 1.0.
///
//export cefingo_display_handler_on_loading_progress_change
func cefingo_display_handler_on_loading_progress_change(
	self *C.cef_display_handler_t,
	browser *C.cef_browser_t,
	progress C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1110:")
	cefingoIfaceAccess.Lock()
	f := display_handler_handlers.on_loading_progress_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDisplayHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpprogress := (float64)(progress)

		f.OnLoadingProgressChange(goTmpself, goTmpbrowser, goTmpprogress)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1124: on_loading_progress_change: Noo!")
	}

}

///
// Called before a download begins. |suggested_name| is the suggested name for
// the download file. By default the download will be canceled. Execute
// |callback| either asynchronously or in this function to continue the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_before_download
func cefingo_download_handler_on_before_download(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	suggested_name *C.cef_string_t,
	callback *C.cef_before_download_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1147:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_before_download_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpsuggested_name := string_from_cef_string(suggested_name)
		goTmpcallback := newCBeforeDownloadCallbackT(callback)

		f.OnBeforeDownload(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpsuggested_name, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdownload_item.p_download_item)
		BaseRelease(goTmpcallback.p_before_download_callback)

	} else {
		Logf("T1165: on_before_download: Noo!")
	}

}

///
// Called when a download&#39;s status or progress information has been updated.
// This may be called multiple times before and after on_before_download().
// Execute |callback| either asynchronously or in this function to cancel the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
//export cefingo_download_handler_on_download_updated
func cefingo_download_handler_on_download_updated(
	self *C.cef_download_handler_t,
	browser *C.cef_browser_t,
	download_item *C.cef_download_item_t,
	callback *C.cef_download_item_callback_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1187:")
	cefingoIfaceAccess.Lock()
	f := download_handler_handlers.on_download_updated_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDownloadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdownload_item := newCDownloadItemT(download_item)
		goTmpcallback := newCDownloadItemCallbackT(callback)

		f.OnDownloadUpdated(goTmpself, goTmpbrowser, goTmpdownload_item, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdownload_item.p_download_item)
		BaseRelease(goTmpcallback.p_download_item_callback)

	} else {
		Logf("T1204: on_download_updated: Noo!")
	}

}

///
// Called when an external drag event enters the browser window. |dragData|
// contains the drag event data and |mask| represents the type of drag
// operation. Return false (0) for default drag handling behavior or true (1)
// to cancel the drag event.
///
//export cefingo_drag_handler_on_drag_enter
func cefingo_drag_handler_on_drag_enter(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	dragData *C.cef_drag_data_t,
	mask C.cef_drag_operations_mask_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1225:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_drag_enter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdragData := newCDragDataT(dragData)
		goTmpmask := CDragOperationsMaskT(mask)

		goRet := f.OnDragEnter(goTmpself, goTmpbrowser, goTmpdragData, goTmpmask)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdragData.p_drag_data)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1242: on_drag_enter: Noo!")
	}
	return cRet
}

///
// Called whenever draggable regions for the browser window change. These can
// be specified using the &#39;-webkit-app-region: drag/no-drag&#39; CSS-property. If
// draggable regions are never defined in a document this function will also
// never be called. If the last draggable region is removed from a document
// this function will be called with an NULL vector.
///
//export cefingo_drag_handler_on_draggable_regions_changed
func cefingo_drag_handler_on_draggable_regions_changed(
	self *C.cef_drag_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	regionsCount C.size_t,
	regions *C.cef_draggable_region_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1265:")
	cefingoIfaceAccess.Lock()
	f := drag_handler_handlers.on_draggable_regions_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCDragHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpregionsCount := (int64)(regionsCount)
		goTmpregions := (*CDraggableRegionT)(regions)

		f.OnDraggableRegionsChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpregionsCount, goTmpregions)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T1282: on_draggable_regions_changed: Noo!")
	}

}

///
// Called if the cef_request_context_t::LoadExtension request fails. |result|
// will be the error code.
///
//export cefingo_extension_handler_on_extension_load_failed
func cefingo_extension_handler_on_extension_load_failed(
	self *C.cef_extension_handler_t,
	result C.cef_errorcode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1299:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_load_failed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpresult := CErrorcodeT(result)

		f.OnExtensionLoadFailed(goTmpself, goTmpresult)

	} else {
		Logf("T1311: on_extension_load_failed: Noo!")
	}

}

///
// Called if the cef_request_context_t::LoadExtension request succeeds.
// |extension| is the loaded extension.
///
//export cefingo_extension_handler_on_extension_loaded
func cefingo_extension_handler_on_extension_loaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1328:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_loaded_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionLoaded(goTmpself, goTmpextension)
		BaseRelease(goTmpextension.p_extension)

	} else {
		Logf("T1341: on_extension_loaded: Noo!")
	}

}

///
// Called after the cef_extension_t::Unload request has completed.
///
//export cefingo_extension_handler_on_extension_unloaded
func cefingo_extension_handler_on_extension_unloaded(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1357:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_extension_unloaded_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)

		f.OnExtensionUnloaded(goTmpself, goTmpextension)
		BaseRelease(goTmpextension.p_extension)

	} else {
		Logf("T1370: on_extension_unloaded: Noo!")
	}

}

///
// Called when an extension needs a browser to host a background script
// specified via the &quot;background&quot; manifest key. The browser will have no
// visible window and cannot be displayed. |extension| is the extension that
// is loading the background script. |url| is an internally generated
// reference to an HTML page that will be used to load the background script
// via a &lt;script&gt; src attribute. To allow creation of the browser optionally
// modify |client| and |settings| and return false (0). To cancel creation of
// the browser (and consequently cancel load of the background script) return
// true (1). Successful creation will be indicated by a call to
// cef_life_span_handler_t::OnAfterCreated, and
// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
// browser. See https://developer.chrome.com/extensions/event_pages for more
// information about extension background script usage.
///
//export cefingo_extension_handler_on_before_background_browser
func cefingo_extension_handler_on_before_background_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	url *C.cef_string_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1401:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_background_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpurl := string_from_cef_string(url)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.p_client
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBackgroundBrowser(goTmpself, goTmpextension, goTmpurl, goTmpclient, goTmpsettings)
		BaseRelease(goTmpextension.p_extension)
		if cefp != goTmpclientOut.p_client {
			*client = goTmpclientOut.p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1417: on_before_background_browser: Noo!")
	}
	return cRet
}

///
// Called when an extension API (e.g. chrome.tabs.create) requests creation of
// a new browser. |extension| and |browser| are the source of the API call.
// |active_browser| may optionally be specified via the windowId property or
// returned via the get_active_browser() callback and provides the default
// |client| and |settings| values for the new browser. |index| is the position
// value optionally specified via the index property. |url| is the URL that
// will be loaded in the browser. |active| is true (1) if the new browser
// should be active when opened.  To allow creation of the browser optionally
// modify |windowInfo|, |client| and |settings| and return false (0). To
// cancel creation of the browser return true (1). Successful creation will be
// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
// modifications to |windowInfo| will be ignored if |active_browser| is
// wrapped in a cef_browser_view_t.
///
//export cefingo_extension_handler_on_before_browser
func cefingo_extension_handler_on_before_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	active_browser *C.cef_browser_t,
	index C.int,
	url *C.cef_string_t,
	active C.int,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1460:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.on_before_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpactive_browser := newCBrowserT(active_browser)
		goTmpindex := (int)(index)
		goTmpurl := string_from_cef_string(url)
		goTmpactive := (int)(active)
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.p_client
		goTmpsettings := CBrowserSettingsT(*settings)

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut := f.OnBeforeBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpactive_browser, goTmpindex, goTmpurl, goTmpactive, goTmpwindowInfo, goTmpclient, goTmpsettings)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpactive_browser.p_browser)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.p_client {
			*client = goTmpclientOut.p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1482: on_before_browser: Noo!")
	}
	return cRet
}

///
// Called when no tabId is specified to an extension API call that accepts a
// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
// source of the API call. Return the browser that will be acted on by the API
// call or return NULL to act on |browser|. The returned browser must share
// the same cef_request_context_t as |browser|. Incognito browsers should not
// be considered unless the source extension has incognito access enabled, in
// which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_get_active_browser
func cefingo_extension_handler_get_active_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
) (cRet *C.cef_browser_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1515:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_active_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)

		goRet := f.GetActiveBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)

		cRet = (*C.cef_browser_t)(goRet.p_browser)
		BaseAddRef(cRet)
	} else {
		Logf("T1532: get_active_browser: Noo!")
	}
	return cRet
}

///
// Called when the tabId associated with |target_browser| is specified to an
// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
// |extension| and |browser| are the source of the API call. Return true (1)
// to allow access of false (0) to deny access. Access to incognito browsers
// should not be allowed unless the source extension has incognito access
// enabled, in which case |include_incognito| will be true (1).
///
//export cefingo_extension_handler_can_access_browser
func cefingo_extension_handler_can_access_browser(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	include_incognito C.int,
	target_browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1557:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.can_access_browser_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinclude_incognito := (int)(include_incognito)
		goTmptarget_browser := newCBrowserT(target_browser)

		goRet := f.CanAccessBrowser(goTmpself, goTmpextension, goTmpbrowser, goTmpinclude_incognito, goTmptarget_browser)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmptarget_browser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1576: can_access_browser: Noo!")
	}
	return cRet
}

///
// Called to retrieve an extension resource that would normally be loaded from
// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
// |extension| and |browser| are the source of the resource request. |file| is
// the requested relative file path. To handle the resource request return
// true (1) and execute |callback| either synchronously or asynchronously. For
// the default behavior which reads the resource from the extension directory
// on disk return false (0). Localization substitutions will not be applied to
// resources handled via this function.
///
//export cefingo_extension_handler_get_extension_resource
func cefingo_extension_handler_get_extension_resource(
	self *C.cef_extension_handler_t,
	extension *C.cef_extension_t,
	browser *C.cef_browser_t,
	file *C.cef_string_t,
	callback *C.cef_get_extension_resource_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1602:")
	cefingoIfaceAccess.Lock()
	f := extension_handler_handlers.get_extension_resource_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCExtensionHandlerT(self)
		goTmpextension := newCExtensionT(extension)
		goTmpbrowser := newCBrowserT(browser)
		goTmpfile := string_from_cef_string(file)
		goTmpcallback := newCGetExtensionResourceCallbackT(callback)

		goRet := f.GetExtensionResource(goTmpself, goTmpextension, goTmpbrowser, goTmpfile, goTmpcallback)
		BaseRelease(goTmpextension.p_extension)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_get_extension_resource_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1621: get_extension_resource: Noo!")
	}
	return cRet
}

///
// Called to report find results returned by cef_browser_host_t::find().
// |identifer| is the identifier passed to find(), |count| is the number of
// matches currently identified, |selectionRect| is the location of where the
// match was found (in window coordinates), |activeMatchOrdinal| is the
// current position in the search results, and |finalUpdate| is true (1) if
// this is the last find notification.
///
//export cefingo_find_handler_on_find_result
func cefingo_find_handler_on_find_result(
	self *C.cef_find_handler_t,
	browser *C.cef_browser_t,
	identifier C.int,
	count C.int,
	selectionRect *C.cef_rect_t,
	activeMatchOrdinal C.int,
	finalUpdate C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1647:")
	cefingoIfaceAccess.Lock()
	f := find_handler_handlers.on_find_result_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFindHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpidentifier := (int)(identifier)
		goTmpcount := (int)(count)
		goTmpselectionRect := (*CRectT)(selectionRect)
		goTmpactiveMatchOrdinal := (int)(activeMatchOrdinal)
		goTmpfinalUpdate := (int)(finalUpdate)

		f.OnFindResult(goTmpself, goTmpbrowser, goTmpidentifier, goTmpcount, goTmpselectionRect, goTmpactiveMatchOrdinal, goTmpfinalUpdate)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1665: on_find_result: Noo!")
	}

}

///
// Called when the browser component is about to loose focus. For instance, if
// focus was on the last HTML element and the user pressed the TAB key. |next|
// will be true (1) if the browser is giving focus to the next component and
// false (0) if the browser is giving focus to the previous component.
///
//export cefingo_focus_handler_on_take_focus
func cefingo_focus_handler_on_take_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	next C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1685:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_take_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpnext := (int)(next)

		f.OnTakeFocus(goTmpself, goTmpbrowser, goTmpnext)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1699: on_take_focus: Noo!")
	}

}

///
// Called when the browser component is requesting focus. |source| indicates
// where the focus request is originating from. Return false (0) to allow the
// focus to be set or true (1) to cancel setting the focus.
///
//export cefingo_focus_handler_on_set_focus
func cefingo_focus_handler_on_set_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
	source C.cef_focus_source_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1718:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_set_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpsource := CFocusSourceT(source)

		goRet := f.OnSetFocus(goTmpself, goTmpbrowser, goTmpsource)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1733: on_set_focus: Noo!")
	}
	return cRet
}

///
// Called when the browser component has received focus.
///
//export cefingo_focus_handler_on_got_focus
func cefingo_focus_handler_on_got_focus(
	self *C.cef_focus_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1749:")
	cefingoIfaceAccess.Lock()
	f := focus_handler_handlers.on_got_focus_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCFocusHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnGotFocus(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1762: on_got_focus: Noo!")
	}

}

///
// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
// and user-friendly display string. The |default_prompt_text| value will be
// specified for prompt dialogs only. Set |suppress_message| to true (1) and
// return false (0) to suppress the message (suppressing messages is
// preferable to immediately executing the callback as this is used to detect
// presumably malicious behavior like spamming alert messages in
// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
// to use the default implementation (the default implementation will show one
// modal dialog at a time and suppress any additional dialog requests until
// the displayed dialog is dismissed). Return true (1) if the application will
// use a custom dialog or if the callback has been executed immediately.
// Custom dialogs may be either modal or modeless. If a custom dialog is used
// the application must execute |callback| once the custom dialog is
// dismissed.
///
//export cefingo_jsdialog_handler_on_jsdialog
func cefingo_jsdialog_handler_on_jsdialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	dialog_type C.cef_jsdialog_type_t,
	message_text *C.cef_string_t,
	default_prompt_text *C.cef_string_t,
	callback *C.cef_jsdialog_callback_t,
	suppress_message *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1798:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_jsdialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpdialog_type := CJsdialogTypeT(dialog_type)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpdefault_prompt_text := string_from_cef_string(default_prompt_text)
		goTmpcallback := newCJsdialogCallbackT(callback)

		goRet, goTmpsuppress_messageOut := f.OnJsdialog(goTmpself, goTmpbrowser, goTmporigin_url, goTmpdialog_type, goTmpmessage_text, goTmpdefault_prompt_text, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_jsdialog_callback)
		*suppress_message = (C.int)(goTmpsuppress_messageOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1819: on_jsdialog: Noo!")
	}
	return cRet
}

///
// Called to run a dialog asking the user if they want to leave a page. Return
// false (0) to use the default dialog implementation. Return true (1) if the
// application will use a custom dialog or if the callback has been executed
// immediately. Custom dialogs may be either modal or modeless. If a custom
// dialog is used the application must execute |callback| once the custom
// dialog is dismissed.
///
//export cefingo_jsdialog_handler_on_before_unload_dialog
func cefingo_jsdialog_handler_on_before_unload_dialog(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
	message_text *C.cef_string_t,
	is_reload C.int,
	callback *C.cef_jsdialog_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1843:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_before_unload_dialog_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpmessage_text := string_from_cef_string(message_text)
		goTmpis_reload := (int)(is_reload)
		goTmpcallback := newCJsdialogCallbackT(callback)

		goRet := f.OnBeforeUnloadDialog(goTmpself, goTmpbrowser, goTmpmessage_text, goTmpis_reload, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_jsdialog_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1861: on_before_unload_dialog: Noo!")
	}
	return cRet
}

///
// Called to cancel any pending dialogs and reset any saved dialog state. Will
// be called due to events like page navigation irregardless of whether any
// dialogs are currently pending.
///
//export cefingo_jsdialog_handler_on_reset_dialog_state
func cefingo_jsdialog_handler_on_reset_dialog_state(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1879:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_reset_dialog_state_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnResetDialogState(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1892: on_reset_dialog_state: Noo!")
	}

}

///
// Called when the default implementation dialog is closed.
///
//export cefingo_jsdialog_handler_on_dialog_closed
func cefingo_jsdialog_handler_on_dialog_closed(
	self *C.cef_jsdialog_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1908:")
	cefingoIfaceAccess.Lock()
	f := jsdialog_handler_handlers.on_dialog_closed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCJsdialogHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnDialogClosed(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T1921: on_dialog_closed: Noo!")
	}

}

///
// Called before a keyboard event is sent to the renderer. |event| contains
// information about the keyboard event. |os_event| is the operating system
// event message, if any. Return true (1) if the event was handled or false
// (0) otherwise. If the event will be handled in on_key_event() as a keyboard
// shortcut set |is_keyboard_shortcut| to true (1) and return false (0).
///
//export cefingo_keyboard_handler_on_pre_key_event
func cefingo_keyboard_handler_on_pre_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
	is_keyboard_shortcut *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1944:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_pre_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)

		goRet, goTmpis_keyboard_shortcutOut := f.OnPreKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)
		BaseRelease(goTmpbrowser.p_browser)
		*is_keyboard_shortcut = (C.int)(goTmpis_keyboard_shortcutOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1961: on_pre_key_event: Noo!")
	}
	return cRet
}

///
// Called after the renderer and JavaScript in the page has had a chance to
// handle the event. |event| contains information about the keyboard event.
// |os_event| is the operating system event message, if any. Return true (1)
// if the keyboard event was handled or false (0) otherwise.
///
//export cefingo_keyboard_handler_on_key_event
func cefingo_keyboard_handler_on_key_event(
	self *C.cef_keyboard_handler_t,
	browser *C.cef_browser_t,
	event *C.cef_key_event_t,
	os_event *C.MSG,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T1982:")
	cefingoIfaceAccess.Lock()
	f := keyboard_handler_handlers.on_key_event_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCKeyboardHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpevent := (*CKeyEventT)(event)
		goTmpos_event := CEventHandleT(os_event)

		goRet := f.OnKeyEvent(goTmpself, goTmpbrowser, goTmpevent, goTmpos_event)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T1998: on_key_event: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before a new popup browser is created. The
// |browser| and |frame| values represent the source of the popup request. The
// |target_url| and |target_frame_name| values indicate where the popup
// browser should navigate and may be NULL if not specified with the request.
// The |target_disposition| value indicates where the user intended to open
// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
// be true (1) if the popup was opened via explicit user gesture (e.g.
// clicking a link) or false (0) if the popup opened automatically (e.g. via
// the DomContentLoaded event). The |popupFeatures| structure contains
// additional information about the requested popup window. To allow creation
// of the popup browser optionally modify |windowInfo|, |client|, |settings|
// and |no_javascript_access| and return false (0). To cancel creation of the
// popup browser return true (1). The |client| and |settings| values will
// default to the source browser&#39;s values. If the |no_javascript_access| value
// is set to false (0) the new browser will not be scriptable and may not be
// hosted in the same renderer process as the source browser. Any
// modifications to |windowInfo| will be ignored if the parent browser is
// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
// the parent browser is destroyed before the popup browser creation completes
// (indicated by a call to OnAfterCreated for the popup browser). The
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created popup browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
//export cefingo_life_span_handler_on_before_popup
func cefingo_life_span_handler_on_before_popup(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_frame_name *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
	popupFeatures *C.cef_popup_features_t,
	windowInfo *C.cef_window_info_t,
	client **C.cef_client_t,
	settings *C.cef_browser_settings_t,
	extra_info **C.cef_dictionary_value_t,
	no_javascript_access *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2047:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_popup_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_frame_name := string_from_cef_string(target_frame_name)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := (int)(user_gesture)
		goTmppopupFeatures := (*CPopupFeaturesT)(popupFeatures)
		goTmpwindowInfo := CWindowInfoT(*windowInfo)
		goTmpclient := newCClientT(*client)
		cefp := goTmpclient.p_client
		goTmpsettings := CBrowserSettingsT(*settings)
		goTmpno_javascript_access := int(*no_javascript_access)

		goRet, goTmpwindowInfoOut, goTmpclientOut, goTmpsettingsOut, goTmpextra_infoOut, goTmpno_javascript_accessOut := f.OnBeforePopup(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_frame_name, goTmptarget_disposition, goTmpuser_gesture, goTmppopupFeatures, goTmpwindowInfo, goTmpclient, goTmpsettings, goTmpno_javascript_access)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		*windowInfo = C.cef_window_info_t(goTmpwindowInfoOut)
		if cefp != goTmpclientOut.p_client {
			*client = goTmpclientOut.p_client
			BaseAddRef(*client)
		}
		*settings = C.cef_browser_settings_t(goTmpsettingsOut)
		if goTmpextra_infoOut != nil {
			*extra_info = goTmpextra_infoOut.p_dictionary_value
			BaseAddRef(*extra_info)
		}
		*no_javascript_access = C.int(goTmpno_javascript_accessOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2073: on_before_popup: Noo!")
	}
	return cRet
}

///
// Called after a new browser is created. This callback will be the first
// notification that references |browser|.
///
//export cefingo_life_span_handler_on_after_created
func cefingo_life_span_handler_on_after_created(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2101:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_after_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnAfterCreated(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2114: on_after_created: Noo!")
	}

}

///
// Called when a browser has recieved a request to close. This may result
// directly from a call to cef_browser_host_t::*close_browser() or indirectly
// if the browser is parented to a top-level window created by CEF and the
// user attempts to close that window (by clicking the &#39;X&#39;, for example). The
// do_close() function will be called after the JavaScript &#39;onunload&#39; event
// has been fired.
//
// An application should handle top-level owner window close notifications by
// calling cef_browser_host_t::try_close_browser() or
// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
// to close immediately (see the examples below). This gives CEF an
// opportunity to process the &#39;onbeforeunload&#39; event and optionally cancel the
// close before do_close() is called.
//
// When windowed rendering is enabled CEF will internally create a window or
// view to host the browser. In that case returning false (0) from do_close()
// will send the standard close notification to the browser&#39;s top-level owner
// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
// Linux or cef_window_delegate_t::can_close() callback from Views). If the
// browser&#39;s host window/view has already been destroyed (via view hierarchy
// tear-down, for example) then do_close() will not be called for that browser
// since is no longer possible to cancel the close.
//
// When windowed rendering is disabled returning false (0) from do_close()
// will cause the browser object to be destroyed immediately.
//
// If the browser&#39;s top-level owner window requires a non-standard close
// notification then send that notification from do_close() and return true
// (1).
//
// The cef_life_span_handler_t::on_before_close() function will be called
// after do_close() (if do_close() is called) and immediately before the
// browser object is destroyed. The application should only exit after
// on_before_close() has been called for all existing browsers.
//
// The below examples describe what should happen during window close when the
// browser is parented to an application-provided top-level window.
//
// Example 1: Using cef_browser_host_t::try_close_browser(). This is
// recommended for clients using standard close handling and windows created
// on the browser process UI thread. 1.  User clicks the window close button
// which sends a close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
//     TryCloseBrowser() returns false so the client cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// CEF sends a close notification to the application&#39;s top-level window
//     (because DoClose() returned false by default).
// 7.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
//     allows the window close.
// 8.  Application&#39;s top-level window is destroyed. 9.  Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 10. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
//
// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
// implementing the do_close() callback. This is recommended for clients using
// non-standard close handling or windows that were not created on the browser
// process UI thread. 1.  User clicks the window close button which sends a
// close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and:
//     A. Calls CefBrowserHost::CloseBrowser(false).
//     B. Cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// Application&#39;s do_close() handler is called. Application will:
//     A. Set a flag to indicate that the next close attempt will be allowed.
//     B. Return false.
// 7.  CEF sends an close notification to the application&#39;s top-level window.
// 8.  Application&#39;s top-level window receives the close notification and
//     allows the window to close based on the flag from #6B.
// 9.  Application&#39;s top-level window is destroyed. 10. Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 11. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
///
//export cefingo_life_span_handler_do_close
func cefingo_life_span_handler_do_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2216:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.do_close_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		goRet := f.DoClose(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2230: do_close: Noo!")
	}
	return cRet
}

///
// Called just before a browser is destroyed. Release all references to the
// browser object and do not attempt to execute any functions on the browser
// object (other than GetIdentifier or IsSame) after this callback returns.
// This callback will be the last notification that references |browser| on
// the UI thread. Any in-progress network requests associated with |browser|
// will be aborted when the browser is destroyed, and
// cef_resource_request_handler_t callbacks related to those requests may
// still arrive on the IO thread after this function is called. See do_close()
// documentation for additional usage information.
///
//export cefingo_life_span_handler_on_before_close
func cefingo_life_span_handler_on_before_close(
	self *C.cef_life_span_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2254:")
	cefingoIfaceAccess.Lock()
	f := life_span_handler_handlers.on_before_close_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLifeSpanHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBeforeClose(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2267: on_before_close: Noo!")
	}

}

///
// Called when the loading state has changed. This callback will be executed
// twice -- once when loading is initiated either programmatically or by user
// action, and once when loading is terminated due to completion, cancellation
// of failure. It will be called before any calls to OnLoadStart and after all
// calls to OnLoadError and/or OnLoadEnd.
///
//export cefingo_load_handler_on_loading_state_change
func cefingo_load_handler_on_loading_state_change(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	isLoading C.int,
	canGoBack C.int,
	canGoForward C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2290:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_loading_state_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisLoading := (int)(isLoading)
		goTmpcanGoBack := (int)(canGoBack)
		goTmpcanGoForward := (int)(canGoForward)

		f.OnLoadingStateChange(goTmpself, goTmpbrowser, goTmpisLoading, goTmpcanGoBack, goTmpcanGoForward)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2306: on_loading_state_change: Noo!")
	}

}

///
// Called after a navigation has been committed and before the browser begins
// loading contents in the frame. The |frame| value will never be NULL -- call
// the is_main() function to check if this frame is the main frame.
// |transition_type| provides information about the source of the navigation
// and an accurate value is only available in the browser process. Multiple
// frames may be loading at the same time. Sub-frames may start or continue
// loading after the main frame load has ended. This function will not be
// called for same page navigations (fragments, history state, etc.) or for
// navigations that fail or are canceled before commit. For notification of
// overall browser load status use OnLoadingStateChange instead.
///
//export cefingo_load_handler_on_load_start
func cefingo_load_handler_on_load_start(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	transition_type C.cef_transition_type_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2333:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_start_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptransition_type := CTransitionTypeT(transition_type)

		f.OnLoadStart(goTmpself, goTmpbrowser, goTmpframe, goTmptransition_type)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T2349: on_load_start: Noo!")
	}

}

///
// Called when the browser is done loading a frame. The |frame| value will
// never be NULL -- call the is_main() function to check if this frame is the
// main frame. Multiple frames may be loading at the same time. Sub-frames may
// start or continue loading after the main frame load has ended. This
// function will not be called for same page navigations (fragments, history
// state, etc.) or for navigations that fail or are canceled before commit.
// For notification of overall browser load status use OnLoadingStateChange
// instead.
///
//export cefingo_load_handler_on_load_end
func cefingo_load_handler_on_load_end(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	httpStatusCode C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2374:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_end_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmphttpStatusCode := (int)(httpStatusCode)

		f.OnLoadEnd(goTmpself, goTmpbrowser, goTmpframe, goTmphttpStatusCode)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T2390: on_load_end: Noo!")
	}

}

///
// Called when a navigation fails or is canceled. This function may be called
// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
// after commit. |errorCode| is the error code number, |errorText| is the
// error text and |failedUrl| is the URL that failed to load. See
// net\base\net_error_list.h for complete descriptions of the error codes.
///
//export cefingo_load_handler_on_load_error
func cefingo_load_handler_on_load_error(
	self *C.cef_load_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	errorCode C.cef_errorcode_t,
	errorText *C.cef_string_t,
	failedUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2414:")
	cefingoIfaceAccess.Lock()
	f := load_handler_handlers.on_load_error_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCLoadHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmperrorCode := CErrorcodeT(errorCode)
		goTmperrorText := string_from_cef_string(errorText)
		goTmpfailedUrl := string_from_cef_string(failedUrl)

		f.OnLoadError(goTmpself, goTmpbrowser, goTmpframe, goTmperrorCode, goTmperrorText, goTmpfailedUrl)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

	} else {
		Logf("T2432: on_load_error: Noo!")
	}

}

///
// Perform the action associated with the specified |command_id| and optional
// |event_flags|.
///
//export cefingo_menu_model_delegate_execute_command
func cefingo_menu_model_delegate_execute_command(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	command_id C.int,
	event_flags C.cef_event_flags_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2451:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.execute_command_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpcommand_id := (int)(command_id)
		goTmpevent_flags := CEventFlagsT(event_flags)

		f.ExecuteCommand(goTmpself, goTmpmenu_model, goTmpcommand_id, goTmpevent_flags)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2466: execute_command: Noo!")
	}

}

///
// Called when the user moves the mouse outside the menu and over the owning
// window.
///
//export cefingo_menu_model_delegate_mouse_outside_menu
func cefingo_menu_model_delegate_mouse_outside_menu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	screen_point *C.cef_point_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2484:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.mouse_outside_menu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpscreen_point := (*CPointT)(screen_point)

		f.MouseOutsideMenu(goTmpself, goTmpmenu_model, goTmpscreen_point)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2498: mouse_outside_menu: Noo!")
	}

}

///
// Called on unhandled open submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_open_submenu
func cefingo_menu_model_delegate_unhandled_open_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2516:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_open_submenu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledOpenSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2530: unhandled_open_submenu: Noo!")
	}

}

///
// Called on unhandled close submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
//export cefingo_menu_model_delegate_unhandled_close_submenu
func cefingo_menu_model_delegate_unhandled_close_submenu(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	is_rtl C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2548:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.unhandled_close_submenu_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmpis_rtl := (int)(is_rtl)

		f.UnhandledCloseSubmenu(goTmpself, goTmpmenu_model, goTmpis_rtl)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2562: unhandled_close_submenu: Noo!")
	}

}

///
// The menu is about to show.
///
//export cefingo_menu_model_delegate_menu_will_show
func cefingo_menu_model_delegate_menu_will_show(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2578:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_will_show_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuWillShow(goTmpself, goTmpmenu_model)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2591: menu_will_show: Noo!")
	}

}

///
// The menu has closed.
///
//export cefingo_menu_model_delegate_menu_closed
func cefingo_menu_model_delegate_menu_closed(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2607:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.menu_closed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)

		f.MenuClosed(goTmpself, goTmpmenu_model)
		BaseRelease(goTmpmenu_model.p_menu_model)

	} else {
		Logf("T2620: menu_closed: Noo!")
	}

}

///
// Optionally modify a menu item label. Return true (1) if |label| was
// modified.
///
//export cefingo_menu_model_delegate_format_label
func cefingo_menu_model_delegate_format_label(
	self *C.cef_menu_model_delegate_t,
	menu_model *C.cef_menu_model_t,
	label *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2638:")
	cefingoIfaceAccess.Lock()
	f := menu_model_delegate_handlers.format_label_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCMenuModelDelegateT(self)
		goTmpmenu_model := newCMenuModelT(menu_model)
		goTmplabel := string_from_cef_string(label)

		goRet, goTmplabelOut := f.FormatLabel(goTmpself, goTmpmenu_model, goTmplabel)
		BaseRelease(goTmpmenu_model.p_menu_model)
		set_cef_string(label, goTmplabelOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2653: format_label: Noo!")
	}
	return cRet
}

//export cefingo_render_handler_get_accessibility_handler
func cefingo_render_handler_get_accessibility_handler(self *C.cef_render_handler_t) (ch *C.cef_accessibility_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := render_handler_handlers.accessibility_handler[self]
	if handler == nil {
		Logf("T2669: get_accessibility_handler")
	} else {
		BaseAddRef(handler.p_accessibility_handler)
		ch = handler.p_accessibility_handler
	}
	return ch
}

///
// Called to retrieve the root window rectangle in screen coordinates. Return
// true (1) if the rectangle was provided. If this function returns false (0)
// the rectangle from GetViewRect will be used.
///
//export cefingo_render_handler_get_root_screen_rect
func cefingo_render_handler_get_root_screen_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2688:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_root_screen_rect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		goRet := f.GetRootScreenRect(goTmpself, goTmpbrowser, goTmprect)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2703: get_root_screen_rect: Noo!")
	}
	return cRet
}

///
// Called to retrieve the view rectangle which is relative to screen
// coordinates. This function must always provide a non-NULL rectangle.
///
//export cefingo_render_handler_get_view_rect
func cefingo_render_handler_get_view_rect(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2721:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_view_rect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		f.GetViewRect(goTmpself, goTmpbrowser, goTmprect)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2735: get_view_rect: Noo!")
	}

}

///
// Called to retrieve the translation from view coordinates to actual screen
// coordinates. Return true (1) if the screen coordinates were provided.
///
//export cefingo_render_handler_get_screen_point
func cefingo_render_handler_get_screen_point(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	viewX C.int,
	viewY C.int,
	screenX *C.int,
	screenY *C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2756:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_point_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpviewX := (int)(viewX)
		goTmpviewY := (int)(viewY)

		goRet, goTmpscreenXOut, goTmpscreenYOut := f.GetScreenPoint(goTmpself, goTmpbrowser, goTmpviewX, goTmpviewY)
		BaseRelease(goTmpbrowser.p_browser)
		*screenX = (C.int)(goTmpscreenXOut)
		*screenY = (C.int)(goTmpscreenYOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2774: get_screen_point: Noo!")
	}
	return cRet
}

///
// Called to allow the client to fill in the CefScreenInfo object with
// appropriate values. Return true (1) if the |screen_info| structure has been
// modified.
//
// If the screen info rectangle is left NULL the rectangle from GetViewRect
// will be used. If the rectangle is still NULL or invalid popups may not be
// drawn correctly.
///
//export cefingo_render_handler_get_screen_info
func cefingo_render_handler_get_screen_info(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	screen_info *C.cef_screen_info_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2797:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.get_screen_info_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpscreen_info := (*CScreenInfoT)(screen_info)

		goRet := f.GetScreenInfo(goTmpself, goTmpbrowser, goTmpscreen_info)
		BaseRelease(goTmpbrowser.p_browser)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T2812: get_screen_info: Noo!")
	}
	return cRet
}

///
// Called when the browser wants to show or hide the popup widget. The popup
// should be shown if |show| is true (1) and hidden if |show| is false (0).
///
//export cefingo_render_handler_on_popup_show
func cefingo_render_handler_on_popup_show(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	show C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2830:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_show_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpshow := (int)(show)

		f.OnPopupShow(goTmpself, goTmpbrowser, goTmpshow)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2844: on_popup_show: Noo!")
	}

}

///
// Called when the browser wants to move or resize the popup widget. |rect|
// contains the new location and size in view coordinates.
///
//export cefingo_render_handler_on_popup_size
func cefingo_render_handler_on_popup_size(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	rect *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2862:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_popup_size_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmprect := (*CRectT)(rect)

		f.OnPopupSize(goTmpself, goTmpbrowser, goTmprect)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2876: on_popup_size: Noo!")
	}

}

///
// Called when an element should be painted. Pixel values passed to this
// function are scaled relative to view coordinates based on the value of
// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
// indicates whether the element is the view or the popup widget. |buffer|
// contains the pixel data for the whole image. |dirtyRects| contains the set
// of rectangles in pixel coordinates that need to be repainted. |buffer| will
// be |width|*|height|*4 bytes in size and represents a BGRA image with an
// upper-left origin. This function is only called when
// cef_window_tInfo::shared_texture_enabled is set to false (0).
///
//export cefingo_render_handler_on_paint
func cefingo_render_handler_on_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	buffer C.VOIDP,
	width C.int,
	height C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2906:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_paint_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		goTmpbuffer := unsafe.Pointer(buffer)
		goTmpwidth := (int)(width)
		goTmpheight := (int)(height)

		f.OnPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRectsCount, goTmpdirtyRects, goTmpbuffer, goTmpwidth, goTmpheight)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2925: on_paint: Noo!")
	}

}

///
// Called when an element has been rendered to the shared texture handle.
// |type| indicates whether the element is the view or the popup widget.
// |dirtyRects| contains the set of rectangles in pixel coordinates that need
// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
// can be accessed via ID3D11Device using the OpenSharedResource function.
// This function is only called when cef_window_tInfo::shared_texture_enabled
// is set to true (1), and is currently only supported on Windows.
///
//export cefingo_render_handler_on_accelerated_paint
func cefingo_render_handler_on_accelerated_paint(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	ctype C.cef_paint_element_type_t,
	dirtyRectsCount C.size_t,
	dirtyRects *C.cef_rect_t,
	shared_handle C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2951:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_accelerated_paint_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmptype := CPaintElementTypeT(ctype)
		goTmpdirtyRectsCount := (int64)(dirtyRectsCount)
		goTmpdirtyRects := (*CRectT)(dirtyRects)
		goTmpshared_handle := unsafe.Pointer(shared_handle)

		f.OnAcceleratedPaint(goTmpself, goTmpbrowser, goTmptype, goTmpdirtyRectsCount, goTmpdirtyRects, goTmpshared_handle)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T2968: on_accelerated_paint: Noo!")
	}

}

///
// Called when the browser&#39;s cursor has changed. If |type| is CT_CUSTOM then
// |custom_cursor_info| will be populated with the custom cursor information.
///
//export cefingo_render_handler_on_cursor_change
func cefingo_render_handler_on_cursor_change(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	cursor C.HCURSOR,
	ctype C.cef_cursor_type_t,
	custom_cursor_info *C.cef_cursor_info_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T2988:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_cursor_change_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcursor := (CCursorHandleT)(cursor)
		goTmptype := CCursorTypeT(ctype)
		goTmpcustom_cursor_info := (*CCursorInfoT)(custom_cursor_info)

		f.OnCursorChange(goTmpself, goTmpbrowser, goTmpcursor, goTmptype, goTmpcustom_cursor_info)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3004: on_cursor_change: Noo!")
	}

}

///
// Called when the user starts dragging content in the web view. Contextual
// information about the dragged content is supplied by |drag_data|. (|x|,
// |y|) is the drag start location in screen coordinates. OS APIs that run a
// system message loop may be used within the StartDragging call.
//
// Return false (0) to abort the drag operation. Don&#39;t call any of
// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
//
// Return true (1) to handle the drag operation. Call
// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
// synchronously or asynchronously to inform the web view that the drag
// operation has ended.
///
//export cefingo_render_handler_start_dragging
func cefingo_render_handler_start_dragging(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	drag_data *C.cef_drag_data_t,
	allowed_ops C.cef_drag_operations_mask_t,
	x C.int,
	y C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3035:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.start_dragging_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpdrag_data := newCDragDataT(drag_data)
		goTmpallowed_ops := CDragOperationsMaskT(allowed_ops)
		goTmpx := (int)(x)
		goTmpy := (int)(y)

		goRet := f.StartDragging(goTmpself, goTmpbrowser, goTmpdrag_data, goTmpallowed_ops, goTmpx, goTmpy)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpdrag_data.p_drag_data)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3054: start_dragging: Noo!")
	}
	return cRet
}

///
// Called when the web view wants to update the mouse cursor during a drag &amp;
// drop operation. |operation| describes the allowed operation (none, move,
// copy, link).
///
//export cefingo_render_handler_update_drag_cursor
func cefingo_render_handler_update_drag_cursor(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	operation C.cef_drag_operations_mask_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3073:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.update_drag_cursor_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpoperation := CDragOperationsMaskT(operation)

		f.UpdateDragCursor(goTmpself, goTmpbrowser, goTmpoperation)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3087: update_drag_cursor: Noo!")
	}

}

///
// Called when the scroll offset has changed.
///
//export cefingo_render_handler_on_scroll_offset_changed
func cefingo_render_handler_on_scroll_offset_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	x C.double,
	y C.double,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3105:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_scroll_offset_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpx := (float64)(x)
		goTmpy := (float64)(y)

		f.OnScrollOffsetChanged(goTmpself, goTmpbrowser, goTmpx, goTmpy)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3120: on_scroll_offset_changed: Noo!")
	}

}

///
// Called when the IME composition range has changed. |selected_range| is the
// range of characters that have been selected. |character_bounds| is the
// bounds of each character in view coordinates.
///
//export cefingo_render_handler_on_ime_composition_range_changed
func cefingo_render_handler_on_ime_composition_range_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_range *C.cef_range_t,
	character_boundsCount C.size_t,
	character_bounds *C.cef_rect_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3141:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_ime_composition_range_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_range := (*CRangeT)(selected_range)
		goTmpcharacter_boundsCount := (int64)(character_boundsCount)
		goTmpcharacter_bounds := (*CRectT)(character_bounds)

		f.OnImeCompositionRangeChanged(goTmpself, goTmpbrowser, goTmpselected_range, goTmpcharacter_boundsCount, goTmpcharacter_bounds)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3157: on_ime_composition_range_changed: Noo!")
	}

}

///
// Called when text selection has changed for the specified |browser|.
// |selected_text| is the currently selected text and |selected_range| is the
// character range.
///
//export cefingo_render_handler_on_text_selection_changed
func cefingo_render_handler_on_text_selection_changed(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	selected_text *C.cef_string_t,
	selected_range *C.cef_range_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3177:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_text_selection_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpselected_text := string_from_cef_string(selected_text)
		goTmpselected_range := (*CRangeT)(selected_range)

		f.OnTextSelectionChanged(goTmpself, goTmpbrowser, goTmpselected_text, goTmpselected_range)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3192: on_text_selection_changed: Noo!")
	}

}

///
// Called when an on-screen keyboard should be shown or hidden for the
// specified |browser|. |input_mode| specifies what kind of keyboard should be
// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
// for this browser should be hidden.
///
//export cefingo_render_handler_on_virtual_keyboard_requested
func cefingo_render_handler_on_virtual_keyboard_requested(
	self *C.cef_render_handler_t,
	browser *C.cef_browser_t,
	input_mode C.cef_text_input_mode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3212:")
	cefingoIfaceAccess.Lock()
	f := render_handler_handlers.on_virtual_keyboard_requested_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpinput_mode := CTextInputModeT(input_mode)

		f.OnVirtualKeyboardRequested(goTmpself, goTmpbrowser, goTmpinput_mode)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3226: on_virtual_keyboard_requested: Noo!")
	}

}

//export cefingo_render_process_handler_get_load_handler
func cefingo_render_process_handler_get_load_handler(self *C.cef_render_process_handler_t) (ch *C.cef_load_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := render_process_handler_handlers.load_handler[self]
	if handler == nil {
		Logf("T3241: get_load_handler")
	} else {
		BaseAddRef(handler.p_load_handler)
		ch = handler.p_load_handler
	}
	return ch
}

///
// Called after the render process main thread has been created. |extra_info|
// is a read-only value originating from
// cef_browser_process_handler_t::on_render_process_thread_created(). Do not
// keep a reference to |extra_info| outside of this function.
///
//export cefingo_render_process_handler_on_render_thread_created
func cefingo_render_process_handler_on_render_thread_created(
	self *C.cef_render_process_handler_t,
	extra_info *C.cef_list_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3260:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_render_thread_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpextra_info := newCListValueT(extra_info)

		f.OnRenderThreadCreated(goTmpself, goTmpextra_info)
		BaseRelease(goTmpextra_info.p_list_value)

	} else {
		Logf("T3273: on_render_thread_created: Noo!")
	}

}

///
// Called after WebKit has been initialized.
///
//export cefingo_render_process_handler_on_web_kit_initialized
func cefingo_render_process_handler_on_web_kit_initialized(
	self *C.cef_render_process_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3288:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_web_kit_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)

		f.OnWebKitInitialized(goTmpself)

	} else {
		Logf("T3299: on_web_kit_initialized: Noo!")
	}

}

///
// Called after a browser has been created. When browsing cross-origin a new
// browser will be created before the old browser with the same identifier is
// destroyed. |extra_info| is a read-only value originating from
// cef_browser_host_t::cef_browser_host_create_browser(),
// cef_browser_host_t::cef_browser_host_create_browser_sync(),
// cef_life_span_handler_t::on_before_popup() or
// cef_browser_view_t::cef_browser_view_create().
///
//export cefingo_render_process_handler_on_browser_created
func cefingo_render_process_handler_on_browser_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	extra_info *C.cef_dictionary_value_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3322:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpextra_info := newCDictionaryValueT(extra_info)

		f.OnBrowserCreated(goTmpself, goTmpbrowser, goTmpextra_info)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpextra_info.p_dictionary_value)

	} else {
		Logf("T3337: on_browser_created: Noo!")
	}

}

///
// Called before a browser is destroyed.
///
//export cefingo_render_process_handler_on_browser_destroyed
func cefingo_render_process_handler_on_browser_destroyed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3353:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_browser_destroyed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnBrowserDestroyed(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T3366: on_browser_destroyed: Noo!")
	}

}

///
// Called immediately after the V8 context for a frame has been created. To
// retrieve the JavaScript &#39;window&#39; object use the
// cef_v8context_t::get_global() function. V8 handles can only be accessed
// from the thread on which they are created. A task runner for posting tasks
// on the associated thread can be retrieved via the
// cef_v8context_t::get_task_runner() function.
///
//export cefingo_render_process_handler_on_context_created
func cefingo_render_process_handler_on_context_created(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3389:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_created_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextCreated(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)

	} else {
		Logf("T3406: on_context_created: Noo!")
	}

}

///
// Called immediately before the V8 context for a frame is released. No
// references to the context should be kept after this function is called.
///
//export cefingo_render_process_handler_on_context_released
func cefingo_render_process_handler_on_context_released(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3425:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_context_released_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)

		f.OnContextReleased(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)

	} else {
		Logf("T3442: on_context_released: Noo!")
	}

}

///
// Called for global uncaught exceptions in a frame. Execution of this
// callback is disabled by default. To enable set
// CefSettings.uncaught_exception_stack_size &gt; 0.
///
//export cefingo_render_process_handler_on_uncaught_exception
func cefingo_render_process_handler_on_uncaught_exception(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	context *C.cef_v8context_t,
	exception *C.cef_v8exception_t,
	stackTrace *C.cef_v8stack_trace_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3464:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_uncaught_exception_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpcontext := newCV8contextT(context)
		goTmpexception := newCV8exceptionT(exception)
		goTmpstackTrace := newCV8stackTraceT(stackTrace)

		f.OnUncaughtException(goTmpself, goTmpbrowser, goTmpframe, goTmpcontext, goTmpexception, goTmpstackTrace)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpcontext.p_v8context)
		BaseRelease(goTmpexception.p_v8exception)
		BaseRelease(goTmpstackTrace.p_v8stack_trace)

	} else {
		Logf("T3485: on_uncaught_exception: Noo!")
	}

}

///
// Called when a new node in the the browser gets focus. The |node| value may
// be NULL if no specific node has gained focus. The node object passed to
// this function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
//export cefingo_render_process_handler_on_focused_node_changed
func cefingo_render_process_handler_on_focused_node_changed(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	node *C.cef_domnode_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3508:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_focused_node_changed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpnode := newCDomnodeT(node)

		f.OnFocusedNodeChanged(goTmpself, goTmpbrowser, goTmpframe, goTmpnode)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpnode.p_domnode)

	} else {
		Logf("T3525: on_focused_node_changed: Noo!")
	}

}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
//export cefingo_render_process_handler_on_process_message_received
func cefingo_render_process_handler_on_process_message_received(
	self *C.cef_render_process_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	source_process C.cef_process_id_t,
	message *C.cef_process_message_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3546:")
	cefingoIfaceAccess.Lock()
	f := render_process_handler_handlers.on_process_message_received_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRenderProcessHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpsource_process := CProcessIdT(source_process)
		goTmpmessage := newCProcessMessageT(message)

		goRet := f.OnProcessMessageReceived(goTmpself, goTmpbrowser, goTmpframe, goTmpsource_process, goTmpmessage)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmpmessage.p_process_message)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3565: on_process_message_received: Noo!")
	}
	return cRet
}

//export cefingo_request_context_handler_get_resource_request_handler
func cefingo_request_context_handler_get_resource_request_handler(self *C.cef_request_context_handler_t) (ch *C.cef_resource_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := request_context_handler_handlers.resource_request_handler[self]
	if handler == nil {
		Logf("T3580: get_resource_request_handler")
	} else {
		BaseAddRef(handler.p_resource_request_handler)
		ch = handler.p_resource_request_handler
	}
	return ch
}

///
// Called on the browser process UI thread immediately after the request
// context has been initialized.
///
//export cefingo_request_context_handler_on_request_context_initialized
func cefingo_request_context_handler_on_request_context_initialized(
	self *C.cef_request_context_handler_t,
	request_context *C.cef_request_context_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3597:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_request_context_initialized_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmprequest_context := newCRequestContextT(request_context)

		f.OnRequestContextInitialized(goTmpself, goTmprequest_context)
		BaseRelease(goTmprequest_context.p_request_context)

	} else {
		Logf("T3610: on_request_context_initialized: Noo!")
	}

}

///
// Called on multiple browser process threads before a plugin instance is
// loaded. |mime_type| is the mime type of the plugin that will be loaded.
// |plugin_url| is the content URL that the plugin will load and may be NULL.
// |is_main_frame| will be true (1) if the plugin is being loaded in the main
// (top-level) frame, |top_origin_url| is the URL for the top-level frame that
// contains the plugin when loading a specific plugin instance or NULL when
// building the initial list of enabled plugins for &#39;navigator.plugins&#39;
// JavaScript state. |plugin_info| includes additional information about the
// plugin that will be loaded. |plugin_policy| is the recommended policy.
// Modify |plugin_policy| and return true (1) to change the policy. Return
// false (0) to use the recommended policy. The default plugin policy can be
// set at runtime using the `--plugin-policy=[allow|detect|block]` command-
// line flag. Decisions to mark a plugin as disabled by setting
// |plugin_policy| to PLUGIN_POLICY_DISABLED may be cached when
// |top_origin_url| is NULL. To purge the plugin list cache and potentially
// trigger new calls to this function call
// cef_request_context_t::PurgePluginListCache.
///
//export cefingo_request_context_handler_on_before_plugin_load
func cefingo_request_context_handler_on_before_plugin_load(
	self *C.cef_request_context_handler_t,
	mime_type *C.cef_string_t,
	plugin_url *C.cef_string_t,
	is_main_frame C.int,
	top_origin_url *C.cef_string_t,
	plugin_info *C.cef_web_plugin_info_t,
	plugin_policy *C.cef_plugin_policy_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3647:")
	cefingoIfaceAccess.Lock()
	f := request_context_handler_handlers.on_before_plugin_load_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestContextHandlerT(self)
		goTmpmime_type := string_from_cef_string(mime_type)
		goTmpplugin_url := string_from_cef_string(plugin_url)
		goTmpis_main_frame := (int)(is_main_frame)
		goTmptop_origin_url := string_from_cef_string(top_origin_url)
		goTmpplugin_info := newCWebPluginInfoT(plugin_info)

		goRet, goTmpplugin_policyOut := f.OnBeforePluginLoad(goTmpself, goTmpmime_type, goTmpplugin_url, goTmpis_main_frame, goTmptop_origin_url, goTmpplugin_info)
		BaseRelease(goTmpplugin_info.p_web_plugin_info)
		*plugin_policy = (C.cef_plugin_policy_t)(goTmpplugin_policyOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3666: on_before_plugin_load: Noo!")
	}
	return cRet
}

//export cefingo_request_handler_get_resource_request_handler
func cefingo_request_handler_get_resource_request_handler(self *C.cef_request_handler_t) (ch *C.cef_resource_request_handler_t) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	handler := request_handler_handlers.resource_request_handler[self]
	if handler == nil {
		Logf("T3681: get_resource_request_handler")
	} else {
		BaseAddRef(handler.p_resource_request_handler)
		ch = handler.p_resource_request_handler
	}
	return ch
}

///
// Called on the UI thread before browser navigation. Return true (1) to
// cancel the navigation or false (0) to allow the navigation to proceed. The
// |request| object cannot be modified in this callback.
// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
// If the navigation is allowed cef_load_handler_t::OnLoadStart and
// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event).
///
//export cefingo_request_handler_on_before_browse
func cefingo_request_handler_on_before_browse(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	user_gesture C.int,
	is_redirect C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3710:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_before_browse_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpuser_gesture := (int)(user_gesture)
		goTmpis_redirect := (int)(is_redirect)

		goRet := f.OnBeforeBrowse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpuser_gesture, goTmpis_redirect)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3730: on_before_browse: Noo!")
	}
	return cRet
}

///
// Called on the UI thread before OnBeforeBrowse in certain limited cases
// where navigating a new or different browser might be desirable. This
// includes user-initiated navigation that might open in a special way (e.g.
// links clicked via middle-click or ctrl + left-click) and certain types of
// cross-origin navigation initiated from the renderer process (e.g.
// navigating the top-level frame to/from a file URL). The |browser| and
// |frame| values represent the source of the navigation. The
// |target_disposition| value indicates where the user intended to navigate
// the browser based on standard Chromium behaviors (e.g. current tab, new
// tab, etc). The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event). Return
// true (1) to cancel the navigation or false (0) to allow the navigation to
// proceed in the source browser&#39;s top-level frame.
///
//export cefingo_request_handler_on_open_urlfrom_tab
func cefingo_request_handler_on_open_urlfrom_tab(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	target_url *C.cef_string_t,
	target_disposition C.cef_window_open_disposition_t,
	user_gesture C.int,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3763:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_open_urlfrom_tab_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmptarget_url := string_from_cef_string(target_url)
		goTmptarget_disposition := CWindowOpenDispositionT(target_disposition)
		goTmpuser_gesture := (int)(user_gesture)

		goRet := f.OnOpenUrlfromTab(goTmpself, goTmpbrowser, goTmpframe, goTmptarget_url, goTmptarget_disposition, goTmpuser_gesture)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3782: on_open_urlfrom_tab: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |origin_url| is the origin making this authentication request. |isProxy|
// indicates whether the host is a proxy server. |host| contains the hostname
// and |port| contains the port number. |realm| is the realm of the challenge
// and may be NULL. |scheme| is the authentication scheme used, such as
// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
// FTP server. Return true (1) to continue the request and call
// cef_auth_callback_t::cont() either in this function or at a later time when
// the authentication information is available. Return false (0) to cancel the
// request immediately.
///
//export cefingo_request_handler_get_auth_credentials
func cefingo_request_handler_get_auth_credentials(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	realm *C.cef_string_t,
	scheme *C.cef_string_t,
	callback *C.cef_auth_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3814:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.get_auth_credentials_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		goTmprealm := string_from_cef_string(realm)
		goTmpscheme := string_from_cef_string(scheme)
		goTmpcallback := newCAuthCallbackT(callback)

		goRet := f.GetAuthCredentials(goTmpself, goTmpbrowser, goTmporigin_url, goTmpisProxy, goTmphost, goTmpport, goTmprealm, goTmpscheme, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_auth_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3836: get_auth_credentials: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when JavaScript requests a specific storage quota
// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
// origin of the page making the request. |new_size| is the requested quota
// size in bytes. Return true (1) to continue the request and call
// cef_request_callback_t::cont() either in this function or at a later time
// to grant or deny the request. Return false (0) to cancel the request
// immediately.
///
//export cefingo_request_handler_on_quota_request
func cefingo_request_handler_on_quota_request(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	origin_url *C.cef_string_t,
	new_size C.int64,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3861:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_quota_request_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmporigin_url := string_from_cef_string(origin_url)
		goTmpnew_size := (int64)(new_size)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnQuotaRequest(goTmpself, goTmpbrowser, goTmporigin_url, goTmpnew_size, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_request_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3879: on_quota_request: Noo!")
	}
	return cRet
}

///
// Called on the UI thread to handle requests for URLs with an invalid SSL
// certificate. Return true (1) and call cef_request_callback_t::cont() either
// in this function or at a later time to continue or cancel the request.
// Return false (0) to cancel the request immediately. If
// CefSettings.ignore_certificate_errors is set all invalid certificates will
// be accepted without calling this function.
///
//export cefingo_request_handler_on_certificate_error
func cefingo_request_handler_on_certificate_error(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	cert_error C.cef_errorcode_t,
	request_url *C.cef_string_t,
	ssl_info *C.cef_sslinfo_t,
	callback *C.cef_request_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3904:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_certificate_error_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpcert_error := CErrorcodeT(cert_error)
		goTmprequest_url := string_from_cef_string(request_url)
		goTmpssl_info := newCSslinfoT(ssl_info)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnCertificateError(goTmpself, goTmpbrowser, goTmpcert_error, goTmprequest_url, goTmpssl_info, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpssl_info.p_sslinfo)
		BaseRelease(goTmpcallback.p_request_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3924: on_certificate_error: Noo!")
	}
	return cRet
}

///
// Called on the UI thread when a client certificate is being requested for
// authentication. Return false (0) to use the default behavior and
// automatically select the first certificate available. Return true (1) and
// call cef_select_client_certificate_callback_t::Select either in this
// function or at a later time to select a certificate. Do not call Select or
// call it with NULL to continue without using any certificate. |isProxy|
// indicates whether the host is an HTTPS proxy or the origin server. |host|
// and |port| contains the hostname and port of the SSL server. |certificates|
// is the list of certificates to choose from; this list has already been
// pruned by Chromium so that it only contains certificates from issuers that
// the server trusts.
///
//export cefingo_request_handler_on_select_client_certificate
func cefingo_request_handler_on_select_client_certificate(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	isProxy C.int,
	host *C.cef_string_t,
	port C.int,
	certificatesCount C.size_t,
	certificates **C.cef_x509certificate_t,
	callback *C.cef_select_client_certificate_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3956:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_select_client_certificate_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpisProxy := (int)(isProxy)
		goTmphost := string_from_cef_string(host)
		goTmpport := (int)(port)
		slice := (*[1 << 30](*C.cef_x509certificate_t))(unsafe.Pointer(certificates))[:certificatesCount:certificatesCount]
		goTmpcertificates := make([]*CX509certificateT, certificatesCount)
		for i, v := range slice {
			goTmpcertificates[i] = newCX509certificateT(v)
		}
		goTmpcallback := newCSelectClientCertificateCallbackT(callback)

		goRet := f.OnSelectClientCertificate(goTmpself, goTmpbrowser, goTmpisProxy, goTmphost, goTmpport, goTmpcertificates, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpcallback.p_select_client_certificate_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T3975: on_select_client_certificate: Noo!")
	}
	return cRet
}

///
// Called on the browser process UI thread when a plugin has crashed.
// |plugin_path| is the path of the plugin that crashed.
///
//export cefingo_request_handler_on_plugin_crashed
func cefingo_request_handler_on_plugin_crashed(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	plugin_path *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T3998:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_plugin_crashed_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpplugin_path := string_from_cef_string(plugin_path)

		f.OnPluginCrashed(goTmpself, goTmpbrowser, goTmpplugin_path)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4012: on_plugin_crashed: Noo!")
	}

}

///
// Called on the browser process UI thread when the render view associated
// with |browser| is ready to receive/handle IPC messages in the render
// process.
///
//export cefingo_request_handler_on_render_view_ready
func cefingo_request_handler_on_render_view_ready(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4030:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_view_ready_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)

		f.OnRenderViewReady(goTmpself, goTmpbrowser)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4043: on_render_view_ready: Noo!")
	}

}

///
// Called on the browser process UI thread when the render process terminates
// unexpectedly. |status| indicates how the process terminated.
///
//export cefingo_request_handler_on_render_process_terminated
func cefingo_request_handler_on_render_process_terminated(
	self *C.cef_request_handler_t,
	browser *C.cef_browser_t,
	status C.cef_termination_status_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4061:")
	cefingoIfaceAccess.Lock()
	f := request_handler_handlers.on_render_process_terminated_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpstatus := CTerminationStatusT(status)

		f.OnRenderProcessTerminated(goTmpself, goTmpbrowser, goTmpstatus)
		BaseRelease(goTmpbrowser.p_browser)

	} else {
		Logf("T4075: on_render_process_terminated: Noo!")
	}

}

///
// Called to retrieve a localized translation for the specified |string_id|.
// To provide the translation set |string| to the translation string and
// return true (1). To use the default translation return false (0). Include
// cef_pack_strings.h for a listing of valid string ID values.
///
//export cefingo_resource_bundle_handler_get_localized_string
func cefingo_resource_bundle_handler_get_localized_string(
	self *C.cef_resource_bundle_handler_t,
	string_id C.int,
	cstring *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4095:")
	cefingoIfaceAccess.Lock()
	f := resource_bundle_handler_handlers.get_localized_string_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceBundleHandlerT(self)
		goTmpstring_id := (int)(string_id)

		goRet, goTmpstringOut := f.GetLocalizedString(goTmpself, goTmpstring_id)
		set_cef_string(cstring, goTmpstringOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4109: get_localized_string: Noo!")
	}
	return cRet
}

///
// Open the response stream. To handle the request immediately set
// |handle_request| to true (1) and return true (1). To decide at a later time
// set |handle_request| to false (0), return true (1), and execute |callback|
// to continue or cancel the request. To cancel the request immediately set
// |handle_request| to true (1) and return false (0). This function will be
// called in sequence but not from a dedicated thread. For backwards
// compatibility set |handle_request| to false (0) and return false (0) and
// the ProcessRequest function will be called.
///
//export cefingo_resource_handler_open
func cefingo_resource_handler_open(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	handle_request *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4134:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.open_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCCallbackT(callback)

		goRet, goTmphandle_requestOut := f.Open(goTmpself, goTmprequest, goTmpcallback)
		BaseRelease(goTmprequest.p_request)
		*handle_request = (C.int)(goTmphandle_requestOut)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4151: open: Noo!")
	}
	return cRet
}

///
// Begin processing the request. To handle the request return true (1) and
// call cef_callback_t::cont() once the response header information is
// available (cef_callback_t::cont() can also be called from inside this
// function if header information is available immediately). To cancel the
// request return false (0).
//
// WARNING: This function is deprecated. Use Open instead.
///
//export cefingo_resource_handler_process_request
func cefingo_resource_handler_process_request(
	self *C.cef_resource_handler_t,
	request *C.cef_request_t,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4174:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.process_request_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCCallbackT(callback)

		goRet := f.ProcessRequest(goTmpself, goTmprequest, goTmpcallback)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4190: process_request: Noo!")
	}
	return cRet
}

///
// Retrieve response header information. If the response length is not known
// set |response_length| to -1 and read_response() will be called until it
// returns false (0). If the response length is known set |response_length| to
// a positive value and read_response() will be called until it returns false
// (0) or the specified number of bytes have been read. Use the |response|
// object to set the mime type, http status code and other optional header
// values. To redirect the request to a new URL set |redirectUrl| to the new
// URL. |redirectUrl| can be either a relative or fully qualified URL. It is
// also possible to set |response| to a redirect http status code and pass the
// new URL via a Location header. Likewise with |redirectUrl| it is valid to
// set a relative or fully qualified URL as the Location header value. If an
// error occured while setting up the request you can call set_error() on
// |response| to indicate the error condition.
///
//export cefingo_resource_handler_get_response_headers
func cefingo_resource_handler_get_response_headers(
	self *C.cef_resource_handler_t,
	response *C.cef_response_t,
	response_length *C.int64,
	redirectUrl *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4220:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.get_response_headers_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpresponse := newCResponseT(response)

		goTmpresponse_lengthOut, goTmpredirectUrlOut := f.GetResponseHeaders(goTmpself, goTmpresponse)
		BaseRelease(goTmpresponse.p_response)
		*response_length = (C.int64)(goTmpresponse_lengthOut)
		set_cef_string(redirectUrl, goTmpredirectUrlOut)

	} else {
		Logf("T4235: get_response_headers: Noo!")
	}

}

///
// Skip response data when requested by a Range header. Skip over and discard
// |bytes_to_skip| bytes of response data. If data is available immediately
// set |bytes_skipped| to the number of bytes skipped and return true (1). To
// read the data at a later time set |bytes_skipped| to 0, return true (1) and
// execute |callback| when the data is available. To indicate failure set
// |bytes_skipped| to &lt; 0 (e.g. -2 for ERR_FAILED) and return false (0). This
// function will be called in sequence but not from a dedicated thread.
///
//export cefingo_resource_handler_skip
func cefingo_resource_handler_skip(
	self *C.cef_resource_handler_t,
	bytes_to_skip C.int64,
	bytes_skipped *C.int64,
	callback *C.cef_resource_skip_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4259:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.skip_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpbytes_to_skip := (int64)(bytes_to_skip)
		goTmpcallback := newCResourceSkipCallbackT(callback)

		goRet, goTmpbytes_skippedOut := f.Skip(goTmpself, goTmpbytes_to_skip, goTmpcallback)
		*bytes_skipped = (C.int64)(goTmpbytes_skippedOut)
		BaseRelease(goTmpcallback.p_resource_skip_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4275: skip: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time keep a
// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
// |callback| when the data is available (|data_out| will remain valid until
// the callback is executed). To indicate response completion set |bytes_read|
// to 0 and return false (0). To indicate failure set |bytes_read| to &lt; 0
// (e.g. -2 for ERR_FAILED) and return false (0). This function will be called
// in sequence but not from a dedicated thread. For backwards compatibility
// set |bytes_read| to -1 and return false (0) and the ReadResponse function
// will be called.
///
//export cefingo_resource_handler_read
func cefingo_resource_handler_read(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_resource_read_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4304:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		goTmpcallback := newCResourceReadCallbackT(callback)

		goRet, goTmpbytes_readOut := f.Read(goTmpself, goTmpdata_out, goTmpcallback)
		*bytes_read = (C.int)(goTmpbytes_readOut)
		BaseRelease(goTmpcallback.p_resource_read_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4321: read: Noo!")
	}
	return cRet
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time set
// |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when the
// data is available. To indicate response completion return false (0).
//
// WARNING: This function is deprecated. Use Skip and Read instead.
///
//export cefingo_resource_handler_read_response
func cefingo_resource_handler_read_response(
	self *C.cef_resource_handler_t,
	data_out C.VOIDP,
	bytes_to_read C.int,
	bytes_read *C.int,
	callback *C.cef_callback_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4345:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.read_response_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:bytes_to_read:bytes_to_read]
		goTmpcallback := newCCallbackT(callback)

		goRet, goTmpbytes_readOut := f.ReadResponse(goTmpself, goTmpdata_out, goTmpcallback)
		*bytes_read = (C.int)(goTmpbytes_readOut)
		BaseRelease(goTmpcallback.p_callback)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4362: read_response: Noo!")
	}
	return cRet
}

///
// Request processing has been canceled.
///
//export cefingo_resource_handler_cancel
func cefingo_resource_handler_cancel(
	self *C.cef_resource_handler_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4376:")
	cefingoIfaceAccess.Lock()
	f := resource_handler_handlers.cancel_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceHandlerT(self)

		f.Cancel(goTmpself)

	} else {
		Logf("T4387: cancel: Noo!")
	}

}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To
// optionally filter cookies for the request return a
// cef_cookie_access_filter_t object. The |request| object cannot not be
// modified in this callback.
///
//export cefingo_resource_request_handler_get_cookie_access_filter
func cefingo_resource_request_handler_get_cookie_access_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_cookie_access_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4410:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_cookie_access_filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goRet := f.GetCookieAccessFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		cRet = (*C.cef_cookie_access_filter_t)(goRet.p_cookie_access_filter)
		BaseAddRef(cRet)
	} else {
		Logf("T4428: get_cookie_access_filter: Noo!")
	}
	return cRet
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To redirect
// or change the resource load optionally modify |request|. Modification of
// the request URL will be treated as a redirect. Return RV_CONTINUE to
// continue the request immediately. Return RV_CONTINUE_ASYNC and call
// cef_request_callback_t:: cont() at a later time to continue or cancel the
// request asynchronously. Return RV_CANCEL to cancel the request immediately.
//
///
//export cefingo_resource_request_handler_on_before_resource_load
func cefingo_resource_request_handler_on_before_resource_load(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	callback *C.cef_request_callback_t,
) (cRet C.cef_return_value_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4456:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_before_resource_load_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpcallback := newCRequestCallbackT(callback)

		goRet := f.OnBeforeResourceLoad(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpcallback)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpcallback.p_request_callback)

		cRet = (C.cef_return_value_t)(goRet)
	} else {
		Logf("T4476: on_before_resource_load: Noo!")
	}
	return cRet
}

///
// Called on the IO thread before a resource is loaded. The |browser| and
// |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource to load using the default network loader return NULL. To specify a
// handler for the resource return a cef_resource_handler_t object. The
// |request| object cannot not be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_handler
func cefingo_resource_request_handler_get_resource_handler(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4499:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_handler_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goRet := f.GetResourceHandler(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		cRet = (*C.cef_resource_handler_t)(goRet.p_resource_handler)
		BaseAddRef(cRet)
	} else {
		Logf("T4517: get_resource_handler: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when a resource load is redirected. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. The
// |request| parameter will contain the old URL and other request-related
// information. The |response| parameter will contain the response that
// resulted in the redirect. The |new_url| parameter will contain the new URL
// and can be changed if desired. The |request| and |response| objects cannot
// be modified in this callback.
///
//export cefingo_resource_request_handler_on_resource_redirect
func cefingo_resource_request_handler_on_resource_redirect(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	new_url *C.cef_string_t,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4545:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_redirect_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goTmpnew_urlOut := f.OnResourceRedirect(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)
		set_cef_string(new_url, goTmpnew_urlOut)

	} else {
		Logf("T4565: on_resource_redirect: Noo!")
	}

}

///
// Called on the IO thread when a resource response is received. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource load to proceed without modification return false (0). To redirect
// or retry the resource load optionally modify |request| and return true (1).
// Modification of the request URL will be treated as a redirect. Requests
// handled using the default network loader cannot be redirected in this
// callback. The |response| object cannot be modified in this callback.
//
// WARNING: Redirecting using this function is deprecated. Use
// OnBeforeResourceLoad or GetResourceHandler to perform redirects.
///
//export cefingo_resource_request_handler_on_resource_response
func cefingo_resource_request_handler_on_resource_response(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4594:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_response_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goRet := f.OnResourceResponse(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4614: on_resource_response: Noo!")
	}
	return cRet
}

///
// Called on the IO thread to optionally filter resource response content. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| and |response| represent the request and response respectively
// and cannot be modified in this callback.
///
//export cefingo_resource_request_handler_get_resource_response_filter
func cefingo_resource_request_handler_get_resource_response_filter(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
) (cRet *C.cef_response_filter_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4637:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.get_resource_response_filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)

		goRet := f.GetResourceResponseFilter(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)

		cRet = (*C.cef_response_filter_t)(goRet.p_response_filter)
		BaseAddRef(cRet)
	} else {
		Logf("T4657: get_resource_response_filter: Noo!")
	}
	return cRet
}

///
// Called on the IO thread when a resource load has completed. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// and |response| represent the request and response respectively and cannot
// be modified in this callback. |status| indicates the load completion
// status. |received_content_length| is the number of response bytes actually
// read. This function will be called for all requests, including requests
// that are aborted due to CEF shutdown or destruction of the associated
// browser. In cases where the associated browser is destroyed this callback
// may arrive after the cef_life_span_handler_t::OnBeforeClose callback for
// that browser. The cef_frame_t::IsValid function can be used to test for
// this situation, and care should be taken not to call |browser| or |frame|
// functions that modify state (like LoadURL, SendProcessMessage, etc.) if the
// frame is invalid.
///
//export cefingo_resource_request_handler_on_resource_load_complete
func cefingo_resource_request_handler_on_resource_load_complete(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	response *C.cef_response_t,
	status C.cef_urlrequest_status_t,
	received_content_length C.int64,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4692:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_resource_load_complete_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)
		goTmpresponse := newCResponseT(response)
		goTmpstatus := CUrlrequestStatusT(status)
		goTmpreceived_content_length := (int64)(received_content_length)

		f.OnResourceLoadComplete(goTmpself, goTmpbrowser, goTmpframe, goTmprequest, goTmpresponse, goTmpstatus, goTmpreceived_content_length)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		BaseRelease(goTmpresponse.p_response)

	} else {
		Logf("T4713: on_resource_load_complete: Noo!")
	}

}

///
// Called on the IO thread to handle requests for URLs with an unknown
// protocol component. The |browser| and |frame| values represent the source
// of the request, and may be NULL for requests originating from service
// workers or cef_urlrequest_t. |request| cannot be modified in this callback.
// Set |allow_os_execution| to true (1) to attempt execution via the
// registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD USE
// THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL
// ANALYSIS BEFORE ALLOWING OS EXECUTION.
///
//export cefingo_resource_request_handler_on_protocol_execution
func cefingo_resource_request_handler_on_protocol_execution(
	self *C.cef_resource_request_handler_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	request *C.cef_request_t,
	allow_os_execution *C.int,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4739:")
	cefingoIfaceAccess.Lock()
	f := resource_request_handler_handlers.on_protocol_execution_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResourceRequestHandlerT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmprequest := newCRequestT(request)

		goTmpallow_os_executionOut := f.OnProtocolExecution(goTmpself, goTmpbrowser, goTmpframe, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)
		*allow_os_execution = (C.int)(goTmpallow_os_executionOut)

	} else {
		Logf("T4757: on_protocol_execution: Noo!")
	}

}

///
// Initialize the response filter. Will only be called a single time. The
// filter will not be installed if this function returns false (0).
///
//export cefingo_response_filter_init_filter
func cefingo_response_filter_init_filter(
	self *C.cef_response_filter_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4773:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.init_filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResponseFilterT(self)

		goRet := f.InitFilter(goTmpself)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4785: init_filter: Noo!")
	}
	return cRet
}

///
// Called to filter a chunk of data. Expected usage is as follows:
//
//  A. Read input data from |data_in| and set |data_in_read| to the number of
//     bytes that were read up to a maximum of |data_in_size|. |data_in| will
//     be NULL if |data_in_size| is zero.
//  B. Write filtered output data to |data_out| and set |data_out_written| to
//     the number of bytes that were written up to a maximum of
//     |data_out_size|. If no output data was written then all data must be
//     read from |data_in| (user must set |data_in_read| = |data_in_size|).
//  C. Return RESPONSE_FILTER_DONE if all output data was written or
//     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
//
// This function will be called repeatedly until the input buffer has been
// fully read (user sets |data_in_read| = |data_in_size|) and there is no more
// input data to filter (the resource response is complete). This function may
// then be called an additional time with an NULL input buffer if the user
// filled the output buffer (set |data_out_written| = |data_out_size|) and
// returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is
// still pending.
//
// Calls to this function will stop when one of the following conditions is
// met:
//
//  A. There is no more input data to filter (the resource response is
//     complete) and the user sets |data_out_written| = 0 or returns
//     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
//  B. The user returns RESPONSE_FILTER_ERROR to indicate an error.
//
// Do not keep a reference to the buffers passed to this function.
///
//export cefingo_response_filter_filter
func cefingo_response_filter_filter(
	self *C.cef_response_filter_t,
	data_in C.VOIDP,
	data_in_size C.size_t,
	data_in_read *C.size_t,
	data_out C.VOIDP,
	data_out_size C.size_t,
	data_out_written *C.size_t,
) (cRet C.cef_response_filter_status_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4834:")
	cefingoIfaceAccess.Lock()
	f := response_filter_handlers.filter_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCResponseFilterT(self)
		goTmpdata_in := (*[1 << 30]byte)(data_in)[:data_in_size:data_in_size]
		goTmpdata_out := (*[1 << 30]byte)(data_out)[:data_out_size:data_out_size]

		goRet, goTmpdata_in_readOut, goTmpdata_out_writtenOut := f.Filter(goTmpself, goTmpdata_in, goTmpdata_out)
		*data_in_read = (C.size_t)(goTmpdata_in_readOut)
		*data_out_written = (C.size_t)(goTmpdata_out_writtenOut)

		cRet = (C.cef_response_filter_status_t)(goRet)
	} else {
		Logf("T4852: filter: Noo!")
	}
	return cRet
}

///
// Return a new resource handler instance to handle the request or an NULL
// reference to allow default handling of the request. |browser| and |frame|
// will be the browser window and frame respectively that originated the
// request or NULL if the request did not originate from a browser window (for
// example, if the request came from cef_urlrequest_t). The |request| object
// passed to this function cannot be modified.
///
//export cefingo_scheme_handler_factory_create
func cefingo_scheme_handler_factory_create(
	self *C.cef_scheme_handler_factory_t,
	browser *C.cef_browser_t,
	frame *C.cef_frame_t,
	scheme_name *C.cef_string_t,
	request *C.cef_request_t,
) (cRet *C.cef_resource_handler_t) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4874:")
	cefingoIfaceAccess.Lock()
	f := scheme_handler_factory_handlers.create_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCSchemeHandlerFactoryT(self)
		goTmpbrowser := newCBrowserT(browser)
		goTmpframe := newCFrameT(frame)
		goTmpscheme_name := string_from_cef_string(scheme_name)
		goTmprequest := newCRequestT(request)

		goRet := f.Create(goTmpself, goTmpbrowser, goTmpframe, goTmpscheme_name, goTmprequest)
		BaseRelease(goTmpbrowser.p_browser)
		BaseRelease(goTmpframe.p_frame)
		BaseRelease(goTmprequest.p_request)

		cRet = (*C.cef_resource_handler_t)(goRet.p_resource_handler)
		BaseAddRef(cRet)
	} else {
		Logf("T4893: create: Noo!")
	}
	return cRet
}

///
// Handle execution of the function identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the function. |arguments| is the list of
// arguments passed to the function. If execution succeeds set |retval| to the
// function return value. If execution fails set |exception| to the exception
// that will be thrown. Return true (1) if execution was handled.
///
//export cefingo_v8handler_execute
func cefingo_v8handler_execute(
	self *C.cef_v8handler_t,
	name *C.cef_string_t,
	object *C.cef_v8value_t,
	argumentsCount C.size_t,
	arguments **C.cef_v8value_t,
	retval **C.cef_v8value_t,
	exception *C.cef_string_t,
) (cRet C.int) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4919:")
	cefingoIfaceAccess.Lock()
	f := v8handler_handlers.execute_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8handlerT(self)
		goTmpname := string_from_cef_string(name)
		goTmpobject := newCV8valueT(object)
		slice := (*[1 << 30](*C.cef_v8value_t))(unsafe.Pointer(arguments))[:argumentsCount:argumentsCount]
		goTmparguments := make([]*CV8valueT, argumentsCount)
		for i, v := range slice {
			goTmparguments[i] = newCV8valueT(v)
		}

		goRet, goTmpretvalOut, goTmpexceptionOut := f.Execute(goTmpself, goTmpname, goTmpobject, goTmparguments)
		BaseRelease(goTmpobject.p_v8value)
		if goTmpretvalOut != nil {
			*retval = goTmpretvalOut.p_v8value
			BaseAddRef(*retval)
		}
		set_cef_string(exception, goTmpexceptionOut)

		if goRet {
			cRet = 1
		}
	} else {
		Logf("T4939: execute: Noo!")
	}
	return cRet
}

///
// Called to release |buffer| when the ArrayBuffer JS object is garbage
// collected. |buffer| is the value that was passed to CreateArrayBuffer along
// with this object.
///
//export cefingo_v8array_buffer_release_callback_release_buffer
func cefingo_v8array_buffer_release_callback_release_buffer(
	self *C.cef_v8array_buffer_release_callback_t,
	buffer C.VOIDP,
) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()

	Tracef(unsafe.Pointer(self), "T4962:")
	cefingoIfaceAccess.Lock()
	f := v8array_buffer_release_callback_handlers.release_buffer_handler[self]
	cefingoIfaceAccess.Unlock()

	if f != nil {
		goTmpself := newCV8arrayBufferReleaseCallbackT(self)
		goTmpbuffer := unsafe.Pointer(buffer)

		f.ReleaseBuffer(goTmpself, goTmpbuffer)

	} else {
		Logf("T4974: release_buffer: Noo!")
	}

}
