// Code generated by "gen-cefingo.go" DO NOT EDIT.

package capi

import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"

// cef_accessibility_handler_capi.h, include/capi/cef_accessibility_handler_capi.h:75:3,

///
// Implement this structure to receive accessibility notification when
// accessibility events have been registered. The functions of this structure
// will be called on the UI thread.
///

// Go type for cef_accessibility_handler_t
type CAccessibilityHandlerT struct {
	noCopy                  noCopy
	p_accessibility_handler *C.cef_accessibility_handler_t
}

type RefToCAccessibilityHandlerT struct {
	p_accessibility_handler *CAccessibilityHandlerT
}

type CAccessibilityHandlerTAccessor interface {
	GetCAccessibilityHandlerT() *CAccessibilityHandlerT
	SetCAccessibilityHandlerT(*CAccessibilityHandlerT)
}

func (r RefToCAccessibilityHandlerT) GetCAccessibilityHandlerT() *CAccessibilityHandlerT {
	return r.p_accessibility_handler
}

func (r *RefToCAccessibilityHandlerT) SetCAccessibilityHandlerT(p *CAccessibilityHandlerT) {
	r.p_accessibility_handler = p
}

// Go type CAccessibilityHandlerT wraps cef type *C.cef_accessibility_handler_t
func newCAccessibilityHandlerT(p *C.cef_accessibility_handler_t) *CAccessibilityHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T48:")
	BaseAddRef(p)
	go_accessibility_handler := CAccessibilityHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_accessibility_handler, func(g *CAccessibilityHandlerT) {
		Tracef(unsafe.Pointer(g.p_accessibility_handler), "T52:")
		BaseRelease(g.p_accessibility_handler)
	})
	return &go_accessibility_handler
}

// *C.cef_accessibility_handler_t has refCounted interface
func (accessibility_handler *CAccessibilityHandlerT) HasOneRef() bool {
	return BaseHasOneRef(accessibility_handler.p_accessibility_handler)
}

func (p *C.cef_accessibility_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called after renderer process sends accessibility tree changes to the
// browser process.
///
type OnAccessibilityTreeChangeHandler interface {
	OnAccessibilityTreeChange(
		self *CAccessibilityHandlerT,
		value *CValueT,
	)
}

///
// Called after renderer process sends accessibility location changes to the
// browser process.
///
type OnAccessibilityLocationChangeHandler interface {
	OnAccessibilityLocationChange(
		self *CAccessibilityHandlerT,
		value *CValueT,
	)
}

var accessibility_handler_handlers = struct {
	on_accessibility_tree_change_handler     map[*C.cef_accessibility_handler_t]OnAccessibilityTreeChangeHandler
	on_accessibility_location_change_handler map[*C.cef_accessibility_handler_t]OnAccessibilityLocationChangeHandler
}{
	map[*C.cef_accessibility_handler_t]OnAccessibilityTreeChangeHandler{},
	map[*C.cef_accessibility_handler_t]OnAccessibilityLocationChangeHandler{},
}

// AllocCAccessibilityHandlerT allocates CAccessibilityHandlerT and construct it
func AllocCAccessibilityHandlerT() *CAccessibilityHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_accessibility_handler_wrapper_t, "T99:")
	cefp := C.cefingo_construct_accessibility_handler((*C.cefingo_accessibility_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_accessibility_handler_t itself in DeassocFunc,
		// or cef_accessibility_handler_t is never GCed.
		Tracef(up, "T105:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(accessibility_handler_handlers.on_accessibility_tree_change_handler, cefp)
		delete(accessibility_handler_handlers.on_accessibility_location_change_handler, cefp)
	}))

	return newCAccessibilityHandlerT(cefp)
}

func (accessibility_handler *CAccessibilityHandlerT) Bind(a interface{}) *CAccessibilityHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := accessibility_handler.p_accessibility_handler

	if h, ok := a.(OnAccessibilityTreeChangeHandler); ok {
		accessibility_handler_handlers.on_accessibility_tree_change_handler[cp] = h
	}

	if h, ok := a.(OnAccessibilityLocationChangeHandler); ok {
		accessibility_handler_handlers.on_accessibility_location_change_handler[cp] = h
	}

	if accessor, ok := a.(CAccessibilityHandlerTAccessor); ok {
		accessor.SetCAccessibilityHandlerT(accessibility_handler)
		Logf("T144:")
	}

	return accessibility_handler
}

// cef_app_capi.h, include/capi/cef_app_capi.h:114:3,

///
// Implement this structure to provide handler implementations. Methods will be
// called by the process and/or thread indicated.
///

// Go type for cef_app_t
type CAppT struct {
	noCopy noCopy
	p_app  *C.cef_app_t
}

type RefToCAppT struct {
	p_app *CAppT
}

type CAppTAccessor interface {
	GetCAppT() *CAppT
	SetCAppT(*CAppT)
}

func (r RefToCAppT) GetCAppT() *CAppT {
	return r.p_app
}

func (r *RefToCAppT) SetCAppT(p *CAppT) {
	r.p_app = p
}

// Go type CAppT wraps cef type *C.cef_app_t
func newCAppT(p *C.cef_app_t) *CAppT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T172:")
	BaseAddRef(p)
	go_app := CAppT{noCopy{}, p}
	runtime.SetFinalizer(&go_app, func(g *CAppT) {
		Tracef(unsafe.Pointer(g.p_app), "T176:")
		BaseRelease(g.p_app)
	})
	return &go_app
}

// *C.cef_app_t has refCounted interface
func (app *CAppT) HasOneRef() bool {
	return BaseHasOneRef(app.p_app)
}

func (p *C.cef_app_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Provides an opportunity to view and/or modify command-line arguments before
// processing by CEF and Chromium. The |process_type| value will be NULL for
// the browser process. Do not keep a reference to the cef_command_line_t
// object passed to this function. The CefSettings.command_line_args_disabled
// value can be used to start with an NULL command-line object. Any values
// specified in CefSettings that equate to command-line arguments will be set
// before this function is called. Be cautious when using this function to
// modify command-line arguments for non-browser processes as this may result
// in undefined behavior including crashes.
///
type OnBeforeCommandLineProcessingHandler interface {
	OnBeforeCommandLineProcessing(
		self *CAppT,
		process_type string,
		command_line *CCommandLineT,
	)
}

///
// Provides an opportunity to register custom schemes. Do not keep a reference
// to the |registrar| object. This function is called on the main thread for
// each process and the registered schemes should be the same across all
// processes.
///
type OnRegisterCustomSchemesHandler interface {
	OnRegisterCustomSchemes(
		self *CAppT,
		registrar *CSchemeRegistrarT,
	)
}

var app_handlers = struct {
	on_before_command_line_processing_handler map[*C.cef_app_t]OnBeforeCommandLineProcessingHandler
	on_register_custom_schemes_handler        map[*C.cef_app_t]OnRegisterCustomSchemesHandler
	resource_bundle_handler                   map[*C.cef_app_t]*CResourceBundleHandlerT
	browser_process_handler                   map[*C.cef_app_t]*CBrowserProcessHandlerT
	render_process_handler                    map[*C.cef_app_t]*CRenderProcessHandlerT
}{
	map[*C.cef_app_t]OnBeforeCommandLineProcessingHandler{},
	map[*C.cef_app_t]OnRegisterCustomSchemesHandler{},
	map[*C.cef_app_t]*CResourceBundleHandlerT{},
	map[*C.cef_app_t]*CBrowserProcessHandlerT{},
	map[*C.cef_app_t]*CRenderProcessHandlerT{},
}

// AllocCAppT allocates CAppT and construct it
func AllocCAppT() *CAppT {
	up := c_calloc(1, C.sizeof_cefingo_app_wrapper_t, "T239:")
	cefp := C.cefingo_construct_app((*C.cefingo_app_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_app_t itself in DeassocFunc,
		// or cef_app_t is never GCed.
		Tracef(up, "T245:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(app_handlers.on_before_command_line_processing_handler, cefp)
		delete(app_handlers.on_register_custom_schemes_handler, cefp)
		delete(app_handlers.resource_bundle_handler, cefp)
		delete(app_handlers.browser_process_handler, cefp)
		delete(app_handlers.render_process_handler, cefp)
	}))

	return newCAppT(cefp)
}

func (app *CAppT) Bind(a interface{}) *CAppT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := app.p_app

	if h, ok := a.(OnBeforeCommandLineProcessingHandler); ok {
		app_handlers.on_before_command_line_processing_handler[cp] = h
	}

	if h, ok := a.(OnRegisterCustomSchemesHandler); ok {
		app_handlers.on_register_custom_schemes_handler[cp] = h
	}

	if accessor, ok := a.(CAppTAccessor); ok {
		accessor.SetCAppT(app)
		Logf("T287:")
	}

	return app
}

func (app *CAppT) AssocResourceBundleHandlerT(handler *CResourceBundleHandlerT) {
	cp := app.p_app
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	app_handlers.resource_bundle_handler[cp] = handler
}

func (app *CAppT) AssocBrowserProcessHandlerT(handler *CBrowserProcessHandlerT) {
	cp := app.p_app
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	app_handlers.browser_process_handler[cp] = handler
}

func (app *CAppT) AssocRenderProcessHandlerT(handler *CRenderProcessHandlerT) {
	cp := app.p_app
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	app_handlers.render_process_handler[cp] = handler
}

///
// This function should be called from the application entry point function to
// execute a secondary process. It can be used to run secondary processes from
// the browser client executable (default behavior) or from a separate
// executable specified by the CefSettings.browser_subprocess_path value. If
// called for the browser process (identified by no "type" command-line value)
// it will return immediately with a value of -1. If called for a recognized
// secondary process it will block until the process should exit and then return
// the process exit code. The |application| parameter may be NULL. The
// |windows_sandbox_info| parameter is only used on Windows and may be NULL (see
// cef_sandbox_win.h for details).
///
func ExecuteProcess(
	args *CMainArgsT,
	application *CAppT,
	windows_sandbox_info unsafe.Pointer,
) (ret int) {
	var goTmpapplication *C.cef_app_t
	if application != nil {
		goTmpapplication = application.p_app
		BaseAddRef(goTmpapplication)
	}

	cRet := C.cef_execute_process((*C.cef_main_args_t)(args), goTmpapplication, windows_sandbox_info)

	ret = (int)(cRet)
	return ret
}

///
// This function should be called on the main application thread to initialize
// the CEF browser process. The |application| parameter may be NULL. A return
// value of true (1) indicates that it succeeded and false (0) indicates that it
// failed. The |windows_sandbox_info| parameter is only used on Windows and may
// be NULL (see cef_sandbox_win.h for details).
///
func Initialize(
	args *CMainArgsT,
	settings *CSettingsT,
	application *CAppT,
	windows_sandbox_info unsafe.Pointer,
) (ret bool) {
	var goTmpapplication *C.cef_app_t
	if application != nil {
		goTmpapplication = application.p_app
		BaseAddRef(goTmpapplication)
	}

	cRet := C.cef_initialize((*C.cef_main_args_t)(args), (*C.cef_settings_t)(settings), goTmpapplication, windows_sandbox_info)

	ret = cRet == 1
	return ret
}

///
// This function should be called on the main application thread to shut down
// the CEF browser process before the application exits.
///
func Shutdown() {

	C.cef_shutdown()

}

///
// Perform a single iteration of CEF message loop processing. This function is
// provided for cases where the CEF message loop must be integrated into an
// existing application message loop. Use of this function is not recommended
// for most users; use either the cef_run_message_loop() function or
// CefSettings.multi_threaded_message_loop if possible. When using this function
// care must be taken to balance performance against excessive CPU usage. It is
// recommended to enable the CefSettings.external_message_pump option when using
// this function so that
// cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can
// facilitate the scheduling process. This function should only be called on the
// main application thread and only if cef_initialize() is called with a
// CefSettings.multi_threaded_message_loop value of false (0). This function
// will not block.
///
func DoMessageLoopWork() {

	C.cef_do_message_loop_work()

}

///
// Run the CEF message loop. Use this function instead of an application-
// provided message loop to get the best balance between performance and CPU
// usage. This function should only be called on the main application thread and
// only if cef_initialize() is called with a
// CefSettings.multi_threaded_message_loop value of false (0). This function
// will block until a quit message is received by the system.
///
func RunMessageLoop() {

	C.cef_run_message_loop()

}

///
// Quit the CEF message loop that was started by calling cef_run_message_loop().
// This function should only be called on the main application thread and only
// if cef_run_message_loop() was used.
///
func QuitMessageLoop() {

	C.cef_quit_message_loop()

}

///
// Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a
// modal message loop. Set to false (0) after exiting the modal message loop.
///
func SetOsmodalLoop(
	osModalLoop bool,
) {
	var tmposModalLoop int
	if osModalLoop {
		tmposModalLoop = 1
	}

	C.cef_set_osmodal_loop(C.int(tmposModalLoop))

}

///
// Call during process startup to enable High-DPI support on Windows 7 or newer.
// Older versions of Windows should be left DPI-unaware because they do not
// support DirectWrite and GDI fonts are kerned very badly.
///
func EnableHighdpiSupport() {

	C.cef_enable_highdpi_support()

}

// cef_audio_handler_capi.h, include/capi/cef_audio_handler_capi.h:115:3,

///
// Implement this structure to handle audio events.
///

// Go type for cef_audio_handler_t
type CAudioHandlerT struct {
	noCopy          noCopy
	p_audio_handler *C.cef_audio_handler_t
}

type RefToCAudioHandlerT struct {
	p_audio_handler *CAudioHandlerT
}

type CAudioHandlerTAccessor interface {
	GetCAudioHandlerT() *CAudioHandlerT
	SetCAudioHandlerT(*CAudioHandlerT)
}

func (r RefToCAudioHandlerT) GetCAudioHandlerT() *CAudioHandlerT {
	return r.p_audio_handler
}

func (r *RefToCAudioHandlerT) SetCAudioHandlerT(p *CAudioHandlerT) {
	r.p_audio_handler = p
}

// Go type CAudioHandlerT wraps cef type *C.cef_audio_handler_t
func newCAudioHandlerT(p *C.cef_audio_handler_t) *CAudioHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T488:")
	BaseAddRef(p)
	go_audio_handler := CAudioHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_audio_handler, func(g *CAudioHandlerT) {
		Tracef(unsafe.Pointer(g.p_audio_handler), "T492:")
		BaseRelease(g.p_audio_handler)
	})
	return &go_audio_handler
}

// *C.cef_audio_handler_t has refCounted interface
func (audio_handler *CAudioHandlerT) HasOneRef() bool {
	return BaseHasOneRef(audio_handler.p_audio_handler)
}

func (p *C.cef_audio_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the UI thread to allow configuration of audio stream parameters.
// Return true (1) to proceed with audio stream capture, or false (0) to
// cancel it. All members of |params| can optionally be configured here, but
// they are also pre-filled with some sensible defaults.
///
type GetAudioParametersHandler interface {
	GetAudioParameters(
		self *CAudioHandlerT,
		browser *CBrowserT,
		params *CAudioParametersT,
	) (ret bool)
}

///
// Called on a browser audio capture thread when the browser starts streaming
// audio. OnAudioSteamStopped will always be called after
// OnAudioStreamStarted; both functions may be called multiple times for the
// same browser. |params| contains the audio parameters like sample rate and
// channel layout. |channels| is the number of channels.
///
type OnAudioStreamStartedHandler interface {
	OnAudioStreamStarted(
		self *CAudioHandlerT,
		browser *CBrowserT,
		params *CAudioParametersT,
		channels int,
	)
}

///
// Called on the UI thread when the stream has stopped. OnAudioSteamStopped
// will always be called after OnAudioStreamStarted; both functions may be
// called multiple times for the same stream.
///
type OnAudioStreamStoppedHandler interface {
	OnAudioStreamStopped(
		self *CAudioHandlerT,
		browser *CBrowserT,
	)
}

///
// Called on the UI or audio stream thread when an error occurred. During the
// stream creation phase this callback will be called on the UI thread while
// in the capturing phase it will be called on the audio stream thread. The
// stream will be stopped immediately.
///
type OnAudioStreamErrorHandler interface {
	OnAudioStreamError(
		self *CAudioHandlerT,
		browser *CBrowserT,
		message string,
	)
}

var audio_handler_handlers = struct {
	get_audio_parameters_handler    map[*C.cef_audio_handler_t]GetAudioParametersHandler
	on_audio_stream_started_handler map[*C.cef_audio_handler_t]OnAudioStreamStartedHandler
	on_audio_stream_stopped_handler map[*C.cef_audio_handler_t]OnAudioStreamStoppedHandler
	on_audio_stream_error_handler   map[*C.cef_audio_handler_t]OnAudioStreamErrorHandler
}{
	map[*C.cef_audio_handler_t]GetAudioParametersHandler{},
	map[*C.cef_audio_handler_t]OnAudioStreamStartedHandler{},
	map[*C.cef_audio_handler_t]OnAudioStreamStoppedHandler{},
	map[*C.cef_audio_handler_t]OnAudioStreamErrorHandler{},
}

// AllocCAudioHandlerT allocates CAudioHandlerT and construct it
func AllocCAudioHandlerT() *CAudioHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_audio_handler_wrapper_t, "T577:")
	cefp := C.cefingo_construct_audio_handler((*C.cefingo_audio_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_audio_handler_t itself in DeassocFunc,
		// or cef_audio_handler_t is never GCed.
		Tracef(up, "T583:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(audio_handler_handlers.get_audio_parameters_handler, cefp)
		delete(audio_handler_handlers.on_audio_stream_started_handler, cefp)
		delete(audio_handler_handlers.on_audio_stream_stopped_handler, cefp)
		delete(audio_handler_handlers.on_audio_stream_error_handler, cefp)
	}))

	return newCAudioHandlerT(cefp)
}

func (audio_handler *CAudioHandlerT) Bind(a interface{}) *CAudioHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := audio_handler.p_audio_handler

	if h, ok := a.(GetAudioParametersHandler); ok {
		audio_handler_handlers.get_audio_parameters_handler[cp] = h
	}

	if h, ok := a.(OnAudioStreamStartedHandler); ok {
		audio_handler_handlers.on_audio_stream_started_handler[cp] = h
	}

	if h, ok := a.(OnAudioStreamStoppedHandler); ok {
		audio_handler_handlers.on_audio_stream_stopped_handler[cp] = h
	}

	if h, ok := a.(OnAudioStreamErrorHandler); ok {
		audio_handler_handlers.on_audio_stream_error_handler[cp] = h
	}

	if accessor, ok := a.(CAudioHandlerTAccessor); ok {
		accessor.SetCAudioHandlerT(audio_handler)
		Logf("T632:")
	}

	return audio_handler
}

// cef_auth_callback_capi.h, include/capi/cef_auth_callback_capi.h:70:3,

///
// Callback structure used for asynchronous continuation of authentication
// requests.
///

// Go type for cef_auth_callback_t
type CAuthCallbackT struct {
	noCopy          noCopy
	p_auth_callback *C.cef_auth_callback_t
}

type RefToCAuthCallbackT struct {
	p_auth_callback *CAuthCallbackT
}

type CAuthCallbackTAccessor interface {
	GetCAuthCallbackT() *CAuthCallbackT
	SetCAuthCallbackT(*CAuthCallbackT)
}

func (r RefToCAuthCallbackT) GetCAuthCallbackT() *CAuthCallbackT {
	return r.p_auth_callback
}

func (r *RefToCAuthCallbackT) SetCAuthCallbackT(p *CAuthCallbackT) {
	r.p_auth_callback = p
}

// Go type CAuthCallbackT wraps cef type *C.cef_auth_callback_t
func newCAuthCallbackT(p *C.cef_auth_callback_t) *CAuthCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T660:")
	BaseAddRef(p)
	go_auth_callback := CAuthCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_auth_callback, func(g *CAuthCallbackT) {
		Tracef(unsafe.Pointer(g.p_auth_callback), "T664:")
		BaseRelease(g.p_auth_callback)
	})
	return &go_auth_callback
}

// *C.cef_auth_callback_t has refCounted interface
func (auth_callback *CAuthCallbackT) HasOneRef() bool {
	return BaseHasOneRef(auth_callback.p_auth_callback)
}

func (p *C.cef_auth_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Continue the authentication request.
///
func (self *CAuthCallbackT) Cont(
	username string,
	password string,
) {
	c_username := create_cef_string(username)
	defer clear_cef_string(c_username)
	c_password := create_cef_string(password)
	defer clear_cef_string(c_password)

	C.cefingo_auth_callback_cont(self.p_auth_callback, (*C.cef_string_t)(c_username), (*C.cef_string_t)(c_password))

}

///
// Cancel the authentication request.
///
func (self *CAuthCallbackT) Cancel() {

	C.cefingo_auth_callback_cancel(self.p_auth_callback)

}

// cef_box_layout_capi.h, include/capi/views/cef_box_layout_capi.h:82:3,

///
// A Layout manager that arranges child views vertically or horizontally in a
// side-by-side fashion with spacing around and between the child views. The
// child views are always sized according to their preferred size. If the host's
// bounds provide insufficient space, child views will be clamped. Excess space
// will not be distributed. Methods must be called on the browser process UI
// thread unless otherwise indicated.
///

// Go type for cef_box_layout_t
type CBoxLayoutT struct {
	noCopy       noCopy
	p_box_layout *C.cef_box_layout_t
}

type RefToCBoxLayoutT struct {
	p_box_layout *CBoxLayoutT
}

type CBoxLayoutTAccessor interface {
	GetCBoxLayoutT() *CBoxLayoutT
	SetCBoxLayoutT(*CBoxLayoutT)
}

func (r RefToCBoxLayoutT) GetCBoxLayoutT() *CBoxLayoutT {
	return r.p_box_layout
}

func (r *RefToCBoxLayoutT) SetCBoxLayoutT(p *CBoxLayoutT) {
	r.p_box_layout = p
}

// Go type CBoxLayoutT wraps cef type *C.cef_box_layout_t
func newCBoxLayoutT(p *C.cef_box_layout_t) *CBoxLayoutT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T745:")
	BaseAddRef(p)
	go_box_layout := CBoxLayoutT{noCopy{}, p}
	runtime.SetFinalizer(&go_box_layout, func(g *CBoxLayoutT) {
		Tracef(unsafe.Pointer(g.p_box_layout), "T749:")
		BaseRelease(g.p_box_layout)
	})
	return &go_box_layout
}

// *C.cef_box_layout_t has refCounted interface
func (box_layout *CBoxLayoutT) HasOneRef() bool {
	return BaseHasOneRef(box_layout.p_box_layout)
}

func (p *C.cef_box_layout_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (box_layout *CBoxLayoutT) ToCLayoutT() *CLayoutT {
	p := (*C.cef_layout_t)(unsafe.Pointer(box_layout.p_box_layout))
	return newCLayoutT(p)
}

///
// Set the flex weight for the given |view|. Using the preferred size as the
// basis, free space along the main axis is distributed to views in the ratio
// of their flex weights. Similarly, if the views will overflow the parent,
// space is subtracted in these ratios. A flex of 0 means this view is not
// resized. Flex values must not be negative.
///
func (self *CBoxLayoutT) SetFlexForView(
	view *CViewT,
	flex int,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	C.cefingo_box_layout_set_flex_for_view(self.p_box_layout, goTmpview, (C.int)(flex))

}

///
// Clears the flex for the given |view|, causing it to use the default flex
// specified via cef_box_layout_tSettings.default_flex.
///
func (self *CBoxLayoutT) ClearFlexForView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	C.cefingo_box_layout_clear_flex_for_view(self.p_box_layout, goTmpview)

}

// cef_browser_capi.h, include/capi/cef_browser_capi.h:183:3,

///
// Structure used to represent a browser window. When used in the browser
// process the functions of this structure may be called on any thread unless
// otherwise indicated in the comments. When used in the render process the
// functions of this structure may only be called on the main thread.
///

// Go type for cef_browser_t
type CBrowserT struct {
	noCopy    noCopy
	p_browser *C.cef_browser_t
}

type RefToCBrowserT struct {
	p_browser *CBrowserT
}

type CBrowserTAccessor interface {
	GetCBrowserT() *CBrowserT
	SetCBrowserT(*CBrowserT)
}

func (r RefToCBrowserT) GetCBrowserT() *CBrowserT {
	return r.p_browser
}

func (r *RefToCBrowserT) SetCBrowserT(p *CBrowserT) {
	r.p_browser = p
}

// Go type CBrowserT wraps cef type *C.cef_browser_t
func newCBrowserT(p *C.cef_browser_t) *CBrowserT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T845:")
	BaseAddRef(p)
	go_browser := CBrowserT{noCopy{}, p}
	runtime.SetFinalizer(&go_browser, func(g *CBrowserT) {
		Tracef(unsafe.Pointer(g.p_browser), "T849:")
		BaseRelease(g.p_browser)
	})
	return &go_browser
}

// *C.cef_browser_t has refCounted interface
func (browser *CBrowserT) HasOneRef() bool {
	return BaseHasOneRef(browser.p_browser)
}

func (p *C.cef_browser_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the browser host object. This function can only be called in the
// browser process.
///
func (self *CBrowserT) GetHost() (ret *CBrowserHostT) {

	cRet := C.cefingo_browser_get_host(self.p_browser)

	ret = newCBrowserHostT(cRet)
	return ret
}

///
// Returns true (1) if the browser can navigate backwards.
///
func (self *CBrowserT) CanGoBack() (ret bool) {

	cRet := C.cefingo_browser_can_go_back(self.p_browser)

	ret = cRet == 1
	return ret
}

///
// Navigate backwards.
///
func (self *CBrowserT) GoBack() {

	C.cefingo_browser_go_back(self.p_browser)

}

///
// Returns true (1) if the browser can navigate forwards.
///
func (self *CBrowserT) CanGoForward() (ret bool) {

	cRet := C.cefingo_browser_can_go_forward(self.p_browser)

	ret = cRet == 1
	return ret
}

///
// Navigate forwards.
///
func (self *CBrowserT) GoForward() {

	C.cefingo_browser_go_forward(self.p_browser)

}

///
// Returns true (1) if the browser is currently loading.
///
func (self *CBrowserT) IsLoading() (ret bool) {

	cRet := C.cefingo_browser_is_loading(self.p_browser)

	ret = cRet == 1
	return ret
}

///
// Reload the current page.
///
func (self *CBrowserT) Reload() {

	C.cefingo_browser_reload(self.p_browser)

}

///
// Reload the current page ignoring any cached data.
///
func (self *CBrowserT) ReloadIgnoreCache() {

	C.cefingo_browser_reload_ignore_cache(self.p_browser)

}

///
// Stop loading the page.
///
func (self *CBrowserT) StopLoad() {

	C.cefingo_browser_stop_load(self.p_browser)

}

///
// Returns the globally unique identifier for this browser. This value is also
// used as the tabId for extension APIs.
///
func (self *CBrowserT) GetIdentifier() (ret int) {

	cRet := C.cefingo_browser_get_identifier(self.p_browser)

	ret = (int)(cRet)
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CBrowserT) IsSame(
	that *CBrowserT,
) (ret bool) {
	var goTmpthat *C.cef_browser_t
	if that != nil {
		goTmpthat = that.p_browser
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_browser_is_same(self.p_browser, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the window is a popup window.
///
func (self *CBrowserT) IsPopup() (ret bool) {

	cRet := C.cefingo_browser_is_popup(self.p_browser)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if a document has been loaded in the browser.
///
func (self *CBrowserT) HasDocument() (ret bool) {

	cRet := C.cefingo_browser_has_document(self.p_browser)

	ret = cRet == 1
	return ret
}

///
// Returns the main (top-level) frame for the browser window.
///
func (self *CBrowserT) GetMainFrame() (ret *CFrameT) {

	cRet := C.cefingo_browser_get_main_frame(self.p_browser)

	ret = newCFrameT(cRet)
	return ret
}

///
// Returns the focused frame for the browser window.
///
func (self *CBrowserT) GetFocusedFrame() (ret *CFrameT) {

	cRet := C.cefingo_browser_get_focused_frame(self.p_browser)

	ret = newCFrameT(cRet)
	return ret
}

///
// Returns the frame with the specified identifier, or NULL if not found.
///
func (self *CBrowserT) GetFrameByident(
	identifier int64,
) (ret *CFrameT) {

	cRet := C.cefingo_browser_get_frame_byident(self.p_browser, (C.int64)(identifier))

	ret = newCFrameT(cRet)
	return ret
}

///
// Returns the frame with the specified name, or NULL if not found.
///
func (self *CBrowserT) GetFrame(
	name string,
) (ret *CFrameT) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_browser_get_frame(self.p_browser, (*C.cef_string_t)(c_name))

	ret = newCFrameT(cRet)
	return ret
}

///
// Returns the number of frames that currently exist.
///
func (self *CBrowserT) GetFrameCount() (ret int64) {

	cRet := C.cefingo_browser_get_frame_count(self.p_browser)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the names of all existing frames.
///
func (self *CBrowserT) GetFrameNames(
	names CStringListT,
) {

	C.cefingo_browser_get_frame_names(self.p_browser, (C.cef_string_list_t)(names))

}

///
// Callback structure for cef_browser_host_t::RunFileDialog. The functions of
// this structure will be called on the browser process UI thread.
///

// Go type for cef_run_file_dialog_callback_t
type CRunFileDialogCallbackT struct {
	noCopy                     noCopy
	p_run_file_dialog_callback *C.cef_run_file_dialog_callback_t
}

type RefToCRunFileDialogCallbackT struct {
	p_run_file_dialog_callback *CRunFileDialogCallbackT
}

type CRunFileDialogCallbackTAccessor interface {
	GetCRunFileDialogCallbackT() *CRunFileDialogCallbackT
	SetCRunFileDialogCallbackT(*CRunFileDialogCallbackT)
}

func (r RefToCRunFileDialogCallbackT) GetCRunFileDialogCallbackT() *CRunFileDialogCallbackT {
	return r.p_run_file_dialog_callback
}

func (r *RefToCRunFileDialogCallbackT) SetCRunFileDialogCallbackT(p *CRunFileDialogCallbackT) {
	r.p_run_file_dialog_callback = p
}

// Go type CRunFileDialogCallbackT wraps cef type *C.cef_run_file_dialog_callback_t
func newCRunFileDialogCallbackT(p *C.cef_run_file_dialog_callback_t) *CRunFileDialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T1145:")
	BaseAddRef(p)
	go_run_file_dialog_callback := CRunFileDialogCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_run_file_dialog_callback, func(g *CRunFileDialogCallbackT) {
		Tracef(unsafe.Pointer(g.p_run_file_dialog_callback), "T1149:")
		BaseRelease(g.p_run_file_dialog_callback)
	})
	return &go_run_file_dialog_callback
}

// *C.cef_run_file_dialog_callback_t has refCounted interface
func (run_file_dialog_callback *CRunFileDialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(run_file_dialog_callback.p_run_file_dialog_callback)
}

func (p *C.cef_run_file_dialog_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called asynchronously after the file dialog is dismissed.
// |selected_accept_filter| is the 0-based index of the value selected from
// the accept filters array passed to cef_browser_host_t::RunFileDialog.
// |file_paths| will be a single value or a list of values depending on the
// dialog mode. If the selection was cancelled |file_paths| will be NULL.
///
type OnFileDialogDismissedHandler interface {
	OnFileDialogDismissed(
		self *CRunFileDialogCallbackT,
		selected_accept_filter int,
		file_paths CStringListT,
	)
}

var run_file_dialog_callback_handlers = struct {
	on_file_dialog_dismissed_handler map[*C.cef_run_file_dialog_callback_t]OnFileDialogDismissedHandler
}{
	map[*C.cef_run_file_dialog_callback_t]OnFileDialogDismissedHandler{},
}

// AllocCRunFileDialogCallbackT allocates CRunFileDialogCallbackT and construct it
func AllocCRunFileDialogCallbackT() *CRunFileDialogCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_run_file_dialog_callback_wrapper_t, "T1187:")
	cefp := C.cefingo_construct_run_file_dialog_callback((*C.cefingo_run_file_dialog_callback_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_run_file_dialog_callback_t itself in DeassocFunc,
		// or cef_run_file_dialog_callback_t is never GCed.
		Tracef(up, "T1193:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler, cefp)
	}))

	return newCRunFileDialogCallbackT(cefp)
}

func (run_file_dialog_callback *CRunFileDialogCallbackT) Bind(a interface{}) *CRunFileDialogCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := run_file_dialog_callback.p_run_file_dialog_callback

	if h, ok := a.(OnFileDialogDismissedHandler); ok {
		run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler[cp] = h
	}

	if accessor, ok := a.(CRunFileDialogCallbackTAccessor); ok {
		accessor.SetCRunFileDialogCallbackT(run_file_dialog_callback)
		Logf("T1227:")
	}

	return run_file_dialog_callback
}

///
// Callback structure for cef_browser_host_t::GetNavigationEntries. The
// functions of this structure will be called on the browser process UI thread.
///

// Go type for cef_navigation_entry_visitor_t
type CNavigationEntryVisitorT struct {
	noCopy                     noCopy
	p_navigation_entry_visitor *C.cef_navigation_entry_visitor_t
}

type RefToCNavigationEntryVisitorT struct {
	p_navigation_entry_visitor *CNavigationEntryVisitorT
}

type CNavigationEntryVisitorTAccessor interface {
	GetCNavigationEntryVisitorT() *CNavigationEntryVisitorT
	SetCNavigationEntryVisitorT(*CNavigationEntryVisitorT)
}

func (r RefToCNavigationEntryVisitorT) GetCNavigationEntryVisitorT() *CNavigationEntryVisitorT {
	return r.p_navigation_entry_visitor
}

func (r *RefToCNavigationEntryVisitorT) SetCNavigationEntryVisitorT(p *CNavigationEntryVisitorT) {
	r.p_navigation_entry_visitor = p
}

// Go type CNavigationEntryVisitorT wraps cef type *C.cef_navigation_entry_visitor_t
func newCNavigationEntryVisitorT(p *C.cef_navigation_entry_visitor_t) *CNavigationEntryVisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T1253:")
	BaseAddRef(p)
	go_navigation_entry_visitor := CNavigationEntryVisitorT{noCopy{}, p}
	runtime.SetFinalizer(&go_navigation_entry_visitor, func(g *CNavigationEntryVisitorT) {
		Tracef(unsafe.Pointer(g.p_navigation_entry_visitor), "T1257:")
		BaseRelease(g.p_navigation_entry_visitor)
	})
	return &go_navigation_entry_visitor
}

// *C.cef_navigation_entry_visitor_t has refCounted interface
func (navigation_entry_visitor *CNavigationEntryVisitorT) HasOneRef() bool {
	return BaseHasOneRef(navigation_entry_visitor.p_navigation_entry_visitor)
}

func (p *C.cef_navigation_entry_visitor_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be executed. Do not keep a reference to |entry| outside of
// this callback. Return true (1) to continue visiting entries or false (0) to
// stop. |current| is true (1) if this entry is the currently loaded
// navigation entry. |index| is the 0-based index of this entry and |total| is
// the total number of entries.
///
func (self *CNavigationEntryVisitorT) Visit(
	entry *CNavigationEntryT,
	current int,
	index int,
	total int,
) (ret bool) {
	var goTmpentry *C.cef_navigation_entry_t
	if entry != nil {
		goTmpentry = entry.p_navigation_entry
		BaseAddRef(goTmpentry)
	}

	cRet := C.cefingo_navigation_entry_visitor_visit(self.p_navigation_entry_visitor, goTmpentry, (C.int)(current), (C.int)(index), (C.int)(total))

	ret = cRet == 1
	return ret
}

///
// Callback structure for cef_browser_host_t::PrintToPDF. The functions of this
// structure will be called on the browser process UI thread.
///

// Go type for cef_pdf_print_callback_t
type CPdfPrintCallbackT struct {
	noCopy               noCopy
	p_pdf_print_callback *C.cef_pdf_print_callback_t
}

type RefToCPdfPrintCallbackT struct {
	p_pdf_print_callback *CPdfPrintCallbackT
}

type CPdfPrintCallbackTAccessor interface {
	GetCPdfPrintCallbackT() *CPdfPrintCallbackT
	SetCPdfPrintCallbackT(*CPdfPrintCallbackT)
}

func (r RefToCPdfPrintCallbackT) GetCPdfPrintCallbackT() *CPdfPrintCallbackT {
	return r.p_pdf_print_callback
}

func (r *RefToCPdfPrintCallbackT) SetCPdfPrintCallbackT(p *CPdfPrintCallbackT) {
	r.p_pdf_print_callback = p
}

// Go type CPdfPrintCallbackT wraps cef type *C.cef_pdf_print_callback_t
func newCPdfPrintCallbackT(p *C.cef_pdf_print_callback_t) *CPdfPrintCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T1330:")
	BaseAddRef(p)
	go_pdf_print_callback := CPdfPrintCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_pdf_print_callback, func(g *CPdfPrintCallbackT) {
		Tracef(unsafe.Pointer(g.p_pdf_print_callback), "T1334:")
		BaseRelease(g.p_pdf_print_callback)
	})
	return &go_pdf_print_callback
}

// *C.cef_pdf_print_callback_t has refCounted interface
func (pdf_print_callback *CPdfPrintCallbackT) HasOneRef() bool {
	return BaseHasOneRef(pdf_print_callback.p_pdf_print_callback)
}

func (p *C.cef_pdf_print_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be executed when the PDF printing has completed. |path| is
// the output path. |ok| will be true (1) if the printing completed
// successfully or false (0) otherwise.
///
func (self *CPdfPrintCallbackT) OnPdfPrintFinished(
	path string,
	ok int,
) {
	c_path := create_cef_string(path)
	defer clear_cef_string(c_path)

	C.cefingo_pdf_print_callback_on_pdf_print_finished(self.p_pdf_print_callback, (*C.cef_string_t)(c_path), (C.int)(ok))

}

///
// Callback structure for cef_browser_host_t::DownloadImage. The functions of
// this structure will be called on the browser process UI thread.
///

// Go type for cef_download_image_callback_t
type CDownloadImageCallbackT struct {
	noCopy                    noCopy
	p_download_image_callback *C.cef_download_image_callback_t
}

type RefToCDownloadImageCallbackT struct {
	p_download_image_callback *CDownloadImageCallbackT
}

type CDownloadImageCallbackTAccessor interface {
	GetCDownloadImageCallbackT() *CDownloadImageCallbackT
	SetCDownloadImageCallbackT(*CDownloadImageCallbackT)
}

func (r RefToCDownloadImageCallbackT) GetCDownloadImageCallbackT() *CDownloadImageCallbackT {
	return r.p_download_image_callback
}

func (r *RefToCDownloadImageCallbackT) SetCDownloadImageCallbackT(p *CDownloadImageCallbackT) {
	r.p_download_image_callback = p
}

// Go type CDownloadImageCallbackT wraps cef type *C.cef_download_image_callback_t
func newCDownloadImageCallbackT(p *C.cef_download_image_callback_t) *CDownloadImageCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T1398:")
	BaseAddRef(p)
	go_download_image_callback := CDownloadImageCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_download_image_callback, func(g *CDownloadImageCallbackT) {
		Tracef(unsafe.Pointer(g.p_download_image_callback), "T1402:")
		BaseRelease(g.p_download_image_callback)
	})
	return &go_download_image_callback
}

// *C.cef_download_image_callback_t has refCounted interface
func (download_image_callback *CDownloadImageCallbackT) HasOneRef() bool {
	return BaseHasOneRef(download_image_callback.p_download_image_callback)
}

func (p *C.cef_download_image_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be executed when the image download has completed.
// |image_url| is the URL that was downloaded and |http_status_code| is the
// resulting HTTP status code. |image| is the resulting image, possibly at
// multiple scale factors, or NULL if the download failed.
///
func (self *CDownloadImageCallbackT) OnDownloadImageFinished(
	image_url string,
	http_status_code int,
	image *CImageT,
) {
	c_image_url := create_cef_string(image_url)
	defer clear_cef_string(c_image_url)
	var goTmpimage *C.cef_image_t
	if image != nil {
		goTmpimage = image.p_image
		BaseAddRef(goTmpimage)
	}

	C.cefingo_download_image_callback_on_download_image_finished(self.p_download_image_callback, (*C.cef_string_t)(c_image_url), (C.int)(http_status_code), goTmpimage)

}

///
// Structure used to represent the browser process aspects of a browser window.
// The functions of this structure can only be called in the browser process.
// They may be called on any thread in that process unless otherwise indicated
// in the comments.
///

// Go type for cef_browser_host_t
type CBrowserHostT struct {
	noCopy         noCopy
	p_browser_host *C.cef_browser_host_t
}

type RefToCBrowserHostT struct {
	p_browser_host *CBrowserHostT
}

type CBrowserHostTAccessor interface {
	GetCBrowserHostT() *CBrowserHostT
	SetCBrowserHostT(*CBrowserHostT)
}

func (r RefToCBrowserHostT) GetCBrowserHostT() *CBrowserHostT {
	return r.p_browser_host
}

func (r *RefToCBrowserHostT) SetCBrowserHostT(p *CBrowserHostT) {
	r.p_browser_host = p
}

// Go type CBrowserHostT wraps cef type *C.cef_browser_host_t
func newCBrowserHostT(p *C.cef_browser_host_t) *CBrowserHostT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T1475:")
	BaseAddRef(p)
	go_browser_host := CBrowserHostT{noCopy{}, p}
	runtime.SetFinalizer(&go_browser_host, func(g *CBrowserHostT) {
		Tracef(unsafe.Pointer(g.p_browser_host), "T1479:")
		BaseRelease(g.p_browser_host)
	})
	return &go_browser_host
}

// *C.cef_browser_host_t has refCounted interface
func (browser_host *CBrowserHostT) HasOneRef() bool {
	return BaseHasOneRef(browser_host.p_browser_host)
}

func (p *C.cef_browser_host_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the hosted browser object.
///
func (self *CBrowserHostT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_browser_host_get_browser(self.p_browser_host)

	ret = newCBrowserT(cRet)
	return ret
}

///
// Request that the browser close. The JavaScript &#39;onbeforeunload&#39; event will
// be fired. If |force_close| is false (0) the event handler, if any, will be
// allowed to prompt the user and the user can optionally cancel the close. If
// |force_close| is true (1) the prompt will not be displayed and the close
// will proceed. Results in a call to cef_life_span_handler_t::do_close() if
// the event handler allows the close or if |force_close| is true (1). See
// cef_life_span_handler_t::do_close() documentation for additional usage
// information.
///
func (self *CBrowserHostT) CloseBrowser(
	force_close bool,
) {
	var tmpforce_close int
	if force_close {
		tmpforce_close = 1
	}

	C.cefingo_browser_host_close_browser(self.p_browser_host, C.int(tmpforce_close))

}

///
// Helper for closing a browser. Call this function from the top-level window
// close handler. Internally this calls CloseBrowser(false (0)) if the close
// has not yet been initiated. This function returns false (0) while the close
// is pending and true (1) after the close has completed. See close_browser()
// and cef_life_span_handler_t::do_close() documentation for additional usage
// information. This function must be called on the browser process UI thread.
///
func (self *CBrowserHostT) TryCloseBrowser() (ret bool) {

	cRet := C.cefingo_browser_host_try_close_browser(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
// Set whether the browser is focused.
///
func (self *CBrowserHostT) SetFocus(
	focus bool,
) {
	var tmpfocus int
	if focus {
		tmpfocus = 1
	}

	C.cefingo_browser_host_set_focus(self.p_browser_host, C.int(tmpfocus))

}

///
// Retrieve the window handle for this browser. If this browser is wrapped in
// a cef_browser_view_t this function should be called on the browser process
// UI thread and it will return the handle for the top-level native window.
///
func (self *CBrowserHostT) GetWindowHandle() (ret CWindowHandleT) {

	cRet := C.cefingo_browser_host_get_window_handle(self.p_browser_host)

	ret = (CWindowHandleT)(cRet)
	return ret
}

///
// Retrieve the window handle of the browser that opened this browser. Will
// return NULL for non-popup windows or if this browser is wrapped in a
// cef_browser_view_t. This function can be used in combination with custom
// handling of modal windows.
///
func (self *CBrowserHostT) GetOpenerWindowHandle() (ret CWindowHandleT) {

	cRet := C.cefingo_browser_host_get_opener_window_handle(self.p_browser_host)

	ret = (CWindowHandleT)(cRet)
	return ret
}

///
// Returns true (1) if this browser is wrapped in a cef_browser_view_t.
///
func (self *CBrowserHostT) HasView() (ret bool) {

	cRet := C.cefingo_browser_host_has_view(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
// Returns the client for this browser.
///
func (self *CBrowserHostT) GetClient() (ret *CClientT) {

	cRet := C.cefingo_browser_host_get_client(self.p_browser_host)

	ret = newCClientT(cRet)
	return ret
}

///
// Returns the request context for this browser.
///
func (self *CBrowserHostT) GetRequestContext() (ret *CRequestContextT) {

	cRet := C.cefingo_browser_host_get_request_context(self.p_browser_host)

	ret = newCRequestContextT(cRet)
	return ret
}

///
// Get the current zoom level. The default zoom level is 0.0. This function
// can only be called on the UI thread.
///
func (self *CBrowserHostT) GetZoomLevel() (ret float64) {

	cRet := C.cefingo_browser_host_get_zoom_level(self.p_browser_host)

	ret = (float64)(cRet)
	return ret
}

///
// Change the zoom level to the specified value. Specify 0.0 to reset the zoom
// level. If called on the UI thread the change will be applied immediately.
// Otherwise, the change will be applied asynchronously on the UI thread.
///
func (self *CBrowserHostT) SetZoomLevel(
	zoomLevel float64,
) {

	C.cefingo_browser_host_set_zoom_level(self.p_browser_host, (C.double)(zoomLevel))

}

///
// Call to run a file chooser dialog. Only a single file chooser dialog may be
// pending at any given time. |mode| represents the type of dialog to display.
// |title| to the title to be used for the dialog and may be NULL to show the
// default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode). |default_file_path|
// is the path with optional directory and/or file name component that will be
// initially selected in the dialog. |accept_filters| are used to restrict the
// selectable file types and may any combination of (a) valid lower-cased MIME
// types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b) individual file extensions (e.g.
// &quot;.txt&quot; or &quot;.png&quot;), or (c) combined description and file extension delimited
// using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image Types|.png;.gif;.jpg&quot;).
// |selected_accept_filter| is the 0-based index of the filter that will be
// selected by default. |callback| will be executed after the dialog is
// dismissed or immediately if another dialog is already pending. The dialog
// will be initiated asynchronously on the UI thread.
///
func (self *CBrowserHostT) RunFileDialog(
	mode CFileDialogModeT,
	title string,
	default_file_path string,
	accept_filters CStringListT,
	selected_accept_filter int,
	callback *CRunFileDialogCallbackT,
) {
	c_title := create_cef_string(title)
	defer clear_cef_string(c_title)
	c_default_file_path := create_cef_string(default_file_path)
	defer clear_cef_string(c_default_file_path)
	var goTmpcallback *C.cef_run_file_dialog_callback_t
	if callback != nil {
		goTmpcallback = callback.p_run_file_dialog_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_browser_host_run_file_dialog(self.p_browser_host, (C.cef_file_dialog_mode_t)(mode), (*C.cef_string_t)(c_title), (*C.cef_string_t)(c_default_file_path), (C.cef_string_list_t)(accept_filters), (C.int)(selected_accept_filter), goTmpcallback)

}

///
// Download the file at |url| using cef_download_handler_t.
///
func (self *CBrowserHostT) StartDownload(
	url string,
) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)

	C.cefingo_browser_host_start_download(self.p_browser_host, (*C.cef_string_t)(c_url))

}

///
// Download |image_url| and execute |callback| on completion with the images
// received from the renderer. If |is_favicon| is true (1) then cookies are
// not sent and not accepted during download. Images with density independent
// pixel (DIP) sizes larger than |max_image_size| are filtered out from the
// image results. Versions of the image at different scale factors may be
// downloaded up to the maximum scale factor supported by the system. If there
// are no image results &lt;= |max_image_size| then the smallest image is resized
// to |max_image_size| and is the only result. A |max_image_size| of 0 means
// unlimited. If |bypass_cache| is true (1) then |image_url| is requested from
// the server even if it is present in the browser cache.
///
func (self *CBrowserHostT) DownloadImage(
	image_url string,
	is_favicon int,
	max_image_size uint32,
	bypass_cache int,
	callback *CDownloadImageCallbackT,
) {
	c_image_url := create_cef_string(image_url)
	defer clear_cef_string(c_image_url)
	var goTmpcallback *C.cef_download_image_callback_t
	if callback != nil {
		goTmpcallback = callback.p_download_image_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_browser_host_download_image(self.p_browser_host, (*C.cef_string_t)(c_image_url), (C.int)(is_favicon), (C.uint32)(max_image_size), (C.int)(bypass_cache), goTmpcallback)

}

///
// Print the current browser contents.
///
func (self *CBrowserHostT) Print() {

	C.cefingo_browser_host_print(self.p_browser_host)

}

///
// Print the current browser contents to the PDF file specified by |path| and
// execute |callback| on completion. The caller is responsible for deleting
// |path| when done. For PDF printing to work on Linux you must implement the
// cef_print_handler_t::GetPdfPaperSize function.
///
func (self *CBrowserHostT) PrintToPdf(
	path string,
	settings *CPdfPrintSettingsT,
	callback *CPdfPrintCallbackT,
) {
	c_path := create_cef_string(path)
	defer clear_cef_string(c_path)
	var goTmpcallback *C.cef_pdf_print_callback_t
	if callback != nil {
		goTmpcallback = callback.p_pdf_print_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_browser_host_print_to_pdf(self.p_browser_host, (*C.cef_string_t)(c_path), (*C.cef_pdf_print_settings_t)(settings), goTmpcallback)

}

///
// Search for |searchText|. |identifier| must be a unique ID and these IDs
// must strictly increase so that newer requests always have greater IDs than
// older requests. If |identifier| is zero or less than the previous ID value
// then it will be automatically assigned a new valid ID. |forward| indicates
// whether to search forward or backward within the page. |matchCase|
// indicates whether the search should be case-sensitive. |findNext| indicates
// whether this is the first request or a follow-up. The cef_find_handler_t
// instance, if any, returned via cef_client_t::GetFindHandler will be called
// to report find results.
///
func (self *CBrowserHostT) Find(
	identifier int,
	searchText string,
	forward int,
	matchCase int,
	findNext int,
) {
	c_searchText := create_cef_string(searchText)
	defer clear_cef_string(c_searchText)

	C.cefingo_browser_host_find(self.p_browser_host, (C.int)(identifier), (*C.cef_string_t)(c_searchText), (C.int)(forward), (C.int)(matchCase), (C.int)(findNext))

}

///
// Cancel all searches that are currently going on.
///
func (self *CBrowserHostT) StopFinding(
	clearSelection int,
) {

	C.cefingo_browser_host_stop_finding(self.p_browser_host, (C.int)(clearSelection))

}

///
// Open developer tools (DevTools) in its own browser. The DevTools browser
// will remain associated with this browser. If the DevTools browser is
// already open then it will be focused, in which case the |windowInfo|,
// |client| and |settings| parameters will be ignored. If |inspect_element_at|
// is non-NULL then the element at the specified (x,y) location will be
// inspected. The |windowInfo| parameter will be ignored if this browser is
// wrapped in a cef_browser_view_t.
///
func (self *CBrowserHostT) ShowDevTools(
	windowInfo *CWindowInfoT,
	client *CClientT,
	settings *CBrowserSettingsT,
	inspect_element_at *CPointT,
) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		goTmpclient = client.p_client
		BaseAddRef(goTmpclient)
	}

	C.cefingo_browser_host_show_dev_tools(self.p_browser_host, (*C.cef_window_info_t)(windowInfo), goTmpclient, (*C.cef_browser_settings_t)(settings), (*C.cef_point_t)(inspect_element_at))

}

///
// Explicitly close the associated DevTools browser, if any.
///
func (self *CBrowserHostT) CloseDevTools() {

	C.cefingo_browser_host_close_dev_tools(self.p_browser_host)

}

///
// Returns true (1) if this browser currently has an associated DevTools
// browser. Must be called on the browser process UI thread.
///
func (self *CBrowserHostT) HasDevTools() (ret bool) {

	cRet := C.cefingo_browser_host_has_dev_tools(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
// Send a function call message over the DevTools protocol. |message| must be
// a UTF8-encoded JSON dictionary that contains &quot;id&quot; (int), &quot;function&quot;
// (string) and &quot;params&quot; (dictionary, optional) values. See the DevTools
// protocol documentation at https://chromedevtools.github.io/devtools-
// protocol/ for details of supported functions and the expected &quot;params&quot;
// dictionary contents. |message| will be copied if necessary. This function
// will return true (1) if called on the UI thread and the message was
// successfully submitted for validation, otherwise false (0). Validation will
// be applied asynchronously and any messages that fail due to formatting
// errors or missing parameters may be discarded without notification. Prefer
// ExecuteDevToolsMethod if a more structured approach to message formatting
// is desired.
//
// Every valid function call will result in an asynchronous function result or
// error message that references the sent message &quot;id&quot;. Event messages are
// received while notifications are enabled (for example, between function
// calls for &quot;Page.enable&quot; and &quot;Page.disable&quot;). All received messages will be
// delivered to the observer(s) registered with AddDevToolsMessageObserver.
// See cef_dev_tools_message_observer_t::OnDevToolsMessage documentation for
// details of received message contents.
//
// Usage of the SendDevToolsMessage, ExecuteDevToolsMethod and
// AddDevToolsMessageObserver functions does not require an active DevTools
// front-end or remote-debugging session. Other active DevTools sessions will
// continue to function independently. However, any modification of global
// browser state by one session may not be reflected in the UI of other
// sessions.
//
// Communication with the DevTools front-end (when displayed) can be logged
// for development purposes by passing the `--devtools-protocol-log-
// file=&lt;path&gt;` command-line flag.
///
func (self *CBrowserHostT) SendDevToolsMessage(
	message unsafe.Pointer,
	message_size int64,
) (ret bool) {

	cRet := C.cefingo_browser_host_send_dev_tools_message(self.p_browser_host, message, (C.size_t)(message_size))

	ret = cRet == 1
	return ret
}

///
// Execute a function call over the DevTools protocol. This is a more
// structured version of SendDevToolsMessage. |message_id| is an incremental
// number that uniquely identifies the message (pass 0 to have the next number
// assigned automatically based on previous values). |function| is the
// function name. |params| are the function parameters, which may be NULL. See
// the DevTools protocol documentation (linked above) for details of supported
// functions and the expected |params| dictionary contents. This function will
// return the assigned message ID if called on the UI thread and the message
// was successfully submitted for validation, otherwise 0. See the
// SendDevToolsMessage documentation for additional usage information.
///
func (self *CBrowserHostT) ExecuteDevToolsMethod(
	message_id int,
	method string,
	params *CDictionaryValueT,
) (ret bool) {
	c_method := create_cef_string(method)
	defer clear_cef_string(c_method)
	var goTmpparams *C.cef_dictionary_value_t
	if params != nil {
		goTmpparams = params.p_dictionary_value
		BaseAddRef(goTmpparams)
	}

	cRet := C.cefingo_browser_host_execute_dev_tools_method(self.p_browser_host, (C.int)(message_id), (*C.cef_string_t)(c_method), goTmpparams)

	ret = cRet == 1
	return ret
}

///
// Add an observer for DevTools protocol messages (function results and
// events). The observer will remain registered until the returned
// Registration object is destroyed. See the SendDevToolsMessage documentation
// for additional usage information.
///
func (self *CBrowserHostT) AddDevToolsMessageObserver(
	observer *CDevToolsMessageObserverT,
) (ret *CRegistrationT) {
	var goTmpobserver *C.cef_dev_tools_message_observer_t
	if observer != nil {
		goTmpobserver = observer.p_dev_tools_message_observer
		BaseAddRef(goTmpobserver)
	}

	cRet := C.cefingo_browser_host_add_dev_tools_message_observer(self.p_browser_host, goTmpobserver)

	ret = newCRegistrationT(cRet)
	return ret
}

///
// Retrieve a snapshot of current navigation entries as values sent to the
// specified visitor. If |current_only| is true (1) only the current
// navigation entry will be sent, otherwise all navigation entries will be
// sent.
///
func (self *CBrowserHostT) GetNavigationEntries(
	visitor *CNavigationEntryVisitorT,
	current_only int,
) {
	var goTmpvisitor *C.cef_navigation_entry_visitor_t
	if visitor != nil {
		goTmpvisitor = visitor.p_navigation_entry_visitor
		BaseAddRef(goTmpvisitor)
	}

	C.cefingo_browser_host_get_navigation_entries(self.p_browser_host, goTmpvisitor, (C.int)(current_only))

}

///
// Set whether mouse cursor change is disabled.
///
func (self *CBrowserHostT) SetMouseCursorChangeDisabled(
	disabled int,
) {

	C.cefingo_browser_host_set_mouse_cursor_change_disabled(self.p_browser_host, (C.int)(disabled))

}

///
// Returns true (1) if mouse cursor change is disabled.
///
func (self *CBrowserHostT) IsMouseCursorChangeDisabled() (ret bool) {

	cRet := C.cefingo_browser_host_is_mouse_cursor_change_disabled(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
// If a misspelled word is currently selected in an editable node calling this
// function will replace it with the specified |word|.
///
func (self *CBrowserHostT) ReplaceMisspelling(
	word string,
) {
	c_word := create_cef_string(word)
	defer clear_cef_string(c_word)

	C.cefingo_browser_host_replace_misspelling(self.p_browser_host, (*C.cef_string_t)(c_word))

}

///
// Add the specified |word| to the spelling dictionary.
///
func (self *CBrowserHostT) AddWordToDictionary(
	word string,
) {
	c_word := create_cef_string(word)
	defer clear_cef_string(c_word)

	C.cefingo_browser_host_add_word_to_dictionary(self.p_browser_host, (*C.cef_string_t)(c_word))

}

///
// Returns true (1) if window rendering is disabled.
///
func (self *CBrowserHostT) IsWindowRenderingDisabled() (ret bool) {

	cRet := C.cefingo_browser_host_is_window_rendering_disabled(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
// Notify the browser that the widget has been resized. The browser will first
// call cef_render_handler_t::GetViewRect to get the new size and then call
// cef_render_handler_t::OnPaint asynchronously with the updated regions. This
// function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) WasResized() {

	C.cefingo_browser_host_was_resized(self.p_browser_host)

}

///
// Notify the browser that it has been hidden or shown. Layouting and
// cef_render_handler_t::OnPaint notification will stop when the browser is
// hidden. This function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) WasHidden(
	hidden int,
) {

	C.cefingo_browser_host_was_hidden(self.p_browser_host, (C.int)(hidden))

}

///
// Send a notification to the browser that the screen info has changed. The
// browser will then call cef_render_handler_t::GetScreenInfo to update the
// screen information with the new values. This simulates moving the webview
// window from one display to another, or changing the properties of the
// current display. This function is only used when window rendering is
// disabled.
///
func (self *CBrowserHostT) NotifyScreenInfoChanged() {

	C.cefingo_browser_host_notify_screen_info_changed(self.p_browser_host)

}

///
// Invalidate the view. The browser will call cef_render_handler_t::OnPaint
// asynchronously. This function is only used when window rendering is
// disabled.
///
func (self *CBrowserHostT) Invalidate(
	ctype CPaintElementTypeT,
) {

	C.cefingo_browser_host_invalidate(self.p_browser_host, (C.cef_paint_element_type_t)(ctype))

}

///
// Issue a BeginFrame request to Chromium.  Only valid when
// cef_window_tInfo::external_begin_frame_enabled is set to true (1).
///
func (self *CBrowserHostT) SendExternalBeginFrame() {

	C.cefingo_browser_host_send_external_begin_frame(self.p_browser_host)

}

///
// Send a key event to the browser.
///
func (self *CBrowserHostT) SendKeyEvent(
	event *CKeyEventT,
) {

	C.cefingo_browser_host_send_key_event(self.p_browser_host, (*C.cef_key_event_t)(event))

}

///
// Send a mouse click event to the browser. The |x| and |y| coordinates are
// relative to the upper-left corner of the view.
///
func (self *CBrowserHostT) SendMouseClickEvent(
	event *CMouseEventT,
	ctype CMouseButtonTypeT,
	mouseUp int,
	clickCount int,
) {

	C.cefingo_browser_host_send_mouse_click_event(self.p_browser_host, (*C.cef_mouse_event_t)(event), (C.cef_mouse_button_type_t)(ctype), (C.int)(mouseUp), (C.int)(clickCount))

}

///
// Send a mouse move event to the browser. The |x| and |y| coordinates are
// relative to the upper-left corner of the view.
///
func (self *CBrowserHostT) SendMouseMoveEvent(
	event *CMouseEventT,
	mouseLeave int,
) {

	C.cefingo_browser_host_send_mouse_move_event(self.p_browser_host, (*C.cef_mouse_event_t)(event), (C.int)(mouseLeave))

}

///
// Send a mouse wheel event to the browser. The |x| and |y| coordinates are
// relative to the upper-left corner of the view. The |deltaX| and |deltaY|
// values represent the movement delta in the X and Y directions respectively.
// In order to scroll inside select popups with window rendering disabled
// cef_render_handler_t::GetScreenPoint should be implemented properly.
///
func (self *CBrowserHostT) SendMouseWheelEvent(
	event *CMouseEventT,
	deltaX int,
	deltaY int,
) {

	C.cefingo_browser_host_send_mouse_wheel_event(self.p_browser_host, (*C.cef_mouse_event_t)(event), (C.int)(deltaX), (C.int)(deltaY))

}

///
// Send a touch event to the browser for a windowless browser.
///
func (self *CBrowserHostT) SendTouchEvent(
	event *CTouchEventT,
) {

	C.cefingo_browser_host_send_touch_event(self.p_browser_host, (*C.cef_touch_event_t)(event))

}

///
// Send a focus event to the browser.
///
func (self *CBrowserHostT) SendFocusEvent(
	setFocus int,
) {

	C.cefingo_browser_host_send_focus_event(self.p_browser_host, (C.int)(setFocus))

}

///
// Send a capture lost event to the browser.
///
func (self *CBrowserHostT) SendCaptureLostEvent() {

	C.cefingo_browser_host_send_capture_lost_event(self.p_browser_host)

}

///
// Notify the browser that the window hosting it is about to be moved or
// resized. This function is only used on Windows and Linux.
///
func (self *CBrowserHostT) NotifyMoveOrResizeStarted() {

	C.cefingo_browser_host_notify_move_or_resize_started(self.p_browser_host)

}

///
// Returns the maximum rate in frames per second (fps) that
// cef_render_handler_t:: OnPaint will be called for a windowless browser. The
// actual fps may be lower if the browser cannot generate frames at the
// requested rate. The minimum value is 1 and the maximum value is 60 (default
// 30). This function can only be called on the UI thread.
///
func (self *CBrowserHostT) GetWindowlessFrameRate() (ret bool) {

	cRet := C.cefingo_browser_host_get_windowless_frame_rate(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
// Set the maximum rate in frames per second (fps) that cef_render_handler_t::
// OnPaint will be called for a windowless browser. The actual fps may be
// lower if the browser cannot generate frames at the requested rate. The
// minimum value is 1 and the maximum value is 60 (default 30). Can also be
// set at browser creation via cef_browser_tSettings.windowless_frame_rate.
///
func (self *CBrowserHostT) SetWindowlessFrameRate(
	frame_rate int,
) {

	C.cefingo_browser_host_set_windowless_frame_rate(self.p_browser_host, (C.int)(frame_rate))

}

///
// Begins a new composition or updates the existing composition. Blink has a
// special node (a composition node) that allows the input function to change
// text without affecting other DOM nodes. |text| is the optional text that
// will be inserted into the composition node. |underlines| is an optional set
// of ranges that will be underlined in the resulting text.
// |replacement_range| is an optional range of the existing text that will be
// replaced. |selection_range| is an optional range of the resulting text that
// will be selected after insertion or replacement. The |replacement_range|
// value is only used on OS X.
//
// This function may be called multiple times as the composition changes. When
// the client is done making changes the composition should either be canceled
// or completed. To cancel the composition call ImeCancelComposition. To
// complete the composition call either ImeCommitText or
// ImeFinishComposingText. Completion is usually signaled when:
//   A. The client receives a WM_IME_COMPOSITION message with a GCS_RESULTSTR
//      flag (on Windows), or;
//   B. The client receives a &quot;commit&quot; signal of GtkIMContext (on Linux), or;
//   C. insertText of NSTextInput is called (on Mac).
//
// This function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeSetComposition(
	text string,
	underlinesCount int64,
	underlines *CCompositionUnderlineT,
	replacement_range *CRangeT,
	selection_range *CRangeT,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_browser_host_ime_set_composition(self.p_browser_host, (*C.cef_string_t)(c_text), (C.size_t)(underlinesCount), (*C.cef_composition_underline_t)(underlines), (*C.cef_range_t)(replacement_range), (*C.cef_range_t)(selection_range))

}

///
// Completes the existing composition by optionally inserting the specified
// |text| into the composition node. |replacement_range| is an optional range
// of the existing text that will be replaced. |relative_cursor_pos| is where
// the cursor will be positioned relative to the current cursor position. See
// comments on ImeSetComposition for usage. The |replacement_range| and
// |relative_cursor_pos| values are only used on OS X. This function is only
// used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeCommitText(
	text string,
	replacement_range *CRangeT,
	relative_cursor_pos int,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_browser_host_ime_commit_text(self.p_browser_host, (*C.cef_string_t)(c_text), (*C.cef_range_t)(replacement_range), (C.int)(relative_cursor_pos))

}

///
// Completes the existing composition by applying the current composition node
// contents. If |keep_selection| is false (0) the current selection, if any,
// will be discarded. See comments on ImeSetComposition for usage. This
// function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeFinishComposingText(
	keep_selection int,
) {

	C.cefingo_browser_host_ime_finish_composing_text(self.p_browser_host, (C.int)(keep_selection))

}

///
// Cancels the existing composition and discards the composition node contents
// without applying them. See comments on ImeSetComposition for usage. This
// function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeCancelComposition() {

	C.cefingo_browser_host_ime_cancel_composition(self.p_browser_host)

}

///
// Call this function when the user drags the mouse into the web view (before
// calling DragTargetDragOver/DragTargetLeave/DragTargetDrop). |drag_data|
// should not contain file contents as this type of data is not allowed to be
// dragged into the web view. File contents can be removed using
// cef_drag_data_t::ResetFileContents (for example, if |drag_data| comes from
// cef_render_handler_t::StartDragging). This function is only used when
// window rendering is disabled.
///
func (self *CBrowserHostT) DragTargetDragEnter(
	drag_data *CDragDataT,
	event *CMouseEventT,
	allowed_ops CDragOperationsMaskT,
) {
	var goTmpdrag_data *C.cef_drag_data_t
	if drag_data != nil {
		goTmpdrag_data = drag_data.p_drag_data
		BaseAddRef(goTmpdrag_data)
	}

	C.cefingo_browser_host_drag_target_drag_enter(self.p_browser_host, goTmpdrag_data, (*C.cef_mouse_event_t)(event), (C.cef_drag_operations_mask_t)(allowed_ops))

}

///
// Call this function each time the mouse is moved across the web view during
// a drag operation (after calling DragTargetDragEnter and before calling
// DragTargetDragLeave/DragTargetDrop). This function is only used when window
// rendering is disabled.
///
func (self *CBrowserHostT) DragTargetDragOver(
	event *CMouseEventT,
	allowed_ops CDragOperationsMaskT,
) {

	C.cefingo_browser_host_drag_target_drag_over(self.p_browser_host, (*C.cef_mouse_event_t)(event), (C.cef_drag_operations_mask_t)(allowed_ops))

}

///
// Call this function when the user drags the mouse out of the web view (after
// calling DragTargetDragEnter). This function is only used when window
// rendering is disabled.
///
func (self *CBrowserHostT) DragTargetDragLeave() {

	C.cefingo_browser_host_drag_target_drag_leave(self.p_browser_host)

}

///
// Call this function when the user completes the drag operation by dropping
// the object onto the web view (after calling DragTargetDragEnter). The
// object being dropped is |drag_data|, given as an argument to the previous
// DragTargetDragEnter call. This function is only used when window rendering
// is disabled.
///
func (self *CBrowserHostT) DragTargetDrop(
	event *CMouseEventT,
) {

	C.cefingo_browser_host_drag_target_drop(self.p_browser_host, (*C.cef_mouse_event_t)(event))

}

///
// Call this function when the drag operation started by a
// cef_render_handler_t::StartDragging call has ended either in a drop or by
// being cancelled. |x| and |y| are mouse coordinates relative to the upper-
// left corner of the view. If the web view is both the drag source and the
// drag target then all DragTarget* functions should be called before
// DragSource* mthods. This function is only used when window rendering is
// disabled.
///
func (self *CBrowserHostT) DragSourceEndedAt(
	x int,
	y int,
	op CDragOperationsMaskT,
) {

	C.cefingo_browser_host_drag_source_ended_at(self.p_browser_host, (C.int)(x), (C.int)(y), (C.cef_drag_operations_mask_t)(op))

}

///
// Call this function when the drag operation started by a
// cef_render_handler_t::StartDragging call has completed. This function may
// be called immediately without first calling DragSourceEndedAt to cancel a
// drag operation. If the web view is both the drag source and the drag target
// then all DragTarget* functions should be called before DragSource* mthods.
// This function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) DragSourceSystemDragEnded() {

	C.cefingo_browser_host_drag_source_system_drag_ended(self.p_browser_host)

}

///
// Returns the current visible navigation entry for this browser. This
// function can only be called on the UI thread.
///
func (self *CBrowserHostT) GetVisibleNavigationEntry() (ret *CNavigationEntryT) {

	cRet := C.cefingo_browser_host_get_visible_navigation_entry(self.p_browser_host)

	ret = newCNavigationEntryT(cRet)
	return ret
}

///
// Set accessibility state for all frames. |accessibility_state| may be
// default, enabled or disabled. If |accessibility_state| is STATE_DEFAULT
// then accessibility will be disabled by default and the state may be further
// controlled with the &quot;force-renderer-accessibility&quot; and &quot;disable-renderer-
// accessibility&quot; command-line switches. If |accessibility_state| is
// STATE_ENABLED then accessibility will be enabled. If |accessibility_state|
// is STATE_DISABLED then accessibility will be completely disabled.
//
// For windowed browsers accessibility will be enabled in Complete mode (which
// corresponds to kAccessibilityModeComplete in Chromium). In this mode all
// platform accessibility objects will be created and managed by Chromium&#39;s
// internal implementation. The client needs only to detect the screen reader
// and call this function appropriately. For example, on macOS the client can
// handle the @&quot;AXEnhancedUserStructure&quot; accessibility attribute to detect
// VoiceOver state changes and on Windows the client can handle WM_GETOBJECT
// with OBJID_CLIENT to detect accessibility readers.
//
// For windowless browsers accessibility will be enabled in TreeOnly mode
// (which corresponds to kAccessibilityModeWebContentsOnly in Chromium). In
// this mode renderer accessibility is enabled, the full tree is computed, and
// events are passed to CefAccessibiltyHandler, but platform accessibility
// objects are not created. The client may implement platform accessibility
// objects using CefAccessibiltyHandler callbacks if desired.
///
func (self *CBrowserHostT) SetAccessibilityState(
	accessibility_state CStateT,
) {

	C.cefingo_browser_host_set_accessibility_state(self.p_browser_host, (C.cef_state_t)(accessibility_state))

}

///
// Enable notifications of auto resize via
// cef_display_handler_t::OnAutoResize. Notifications are disabled by default.
// |min_size| and |max_size| define the range of allowed sizes.
///
func (self *CBrowserHostT) SetAutoResizeEnabled(
	enabled int,
	min_size *CSizeT,
	max_size *CSizeT,
) {

	C.cefingo_browser_host_set_auto_resize_enabled(self.p_browser_host, (C.int)(enabled), (*C.cef_size_t)(min_size), (*C.cef_size_t)(max_size))

}

///
// Returns the extension hosted in this browser or NULL if no extension is
// hosted. See cef_request_context_t::LoadExtension for details.
///
func (self *CBrowserHostT) GetExtension() (ret *CExtensionT) {

	cRet := C.cefingo_browser_host_get_extension(self.p_browser_host)

	ret = newCExtensionT(cRet)
	return ret
}

///
// Returns true (1) if this browser is hosting an extension background script.
// Background hosts do not have a window and are not displayable. See
// cef_request_context_t::LoadExtension for details.
///
func (self *CBrowserHostT) IsBackgroundHost() (ret bool) {

	cRet := C.cefingo_browser_host_is_background_host(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
//  Set whether the browser&#39;s audio is muted.
///
func (self *CBrowserHostT) SetAudioMuted(
	mute int,
) {

	C.cefingo_browser_host_set_audio_muted(self.p_browser_host, (C.int)(mute))

}

///
// Returns true (1) if the browser&#39;s audio is muted.  This function can only
// be called on the UI thread.
///
func (self *CBrowserHostT) IsAudioMuted() (ret bool) {

	cRet := C.cefingo_browser_host_is_audio_muted(self.p_browser_host)

	ret = cRet == 1
	return ret
}

///
// Create a new browser window using the window parameters specified by
// |windowInfo|. All values will be copied internally and the actual window will
// be created on the UI thread. If |request_context| is NULL the global request
// context will be used. This function can be called on any browser process
// thread and will not block. The optional |extra_info| parameter provides an
// opportunity to specify extra information specific to the created browser that
// will be passed to cef_render_process_handler_t::on_browser_created() in the
// render process.
///
func BrowserHostCreateBrowser(
	windowInfo *CWindowInfoT,
	client *CClientT,
	url string,
	settings *CBrowserSettingsT,
	extra_info *CDictionaryValueT,
	request_context *CRequestContextT,
) (ret bool) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		goTmpclient = client.p_client
		BaseAddRef(goTmpclient)
	}
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)
	var goTmpextra_info *C.cef_dictionary_value_t
	if extra_info != nil {
		goTmpextra_info = extra_info.p_dictionary_value
		BaseAddRef(goTmpextra_info)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		goTmprequest_context = request_context.p_request_context
		BaseAddRef(goTmprequest_context)
	}

	cRet := C.cef_browser_host_create_browser((*C.cef_window_info_t)(windowInfo), goTmpclient, (*C.cef_string_t)(c_url), (*C.cef_browser_settings_t)(settings), goTmpextra_info, goTmprequest_context)

	ret = cRet == 1
	return ret
}

///
// Create a new browser window using the window parameters specified by
// |windowInfo|. If |request_context| is NULL the global request context will be
// used. This function can only be called on the browser process UI thread. The
// optional |extra_info| parameter provides an opportunity to specify extra
// information specific to the created browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
func BrowserHostCreateBrowserSync(
	windowInfo *CWindowInfoT,
	client *CClientT,
	url string,
	settings *CBrowserSettingsT,
	extra_info *CDictionaryValueT,
	request_context *CRequestContextT,
) (ret *CBrowserT) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		goTmpclient = client.p_client
		BaseAddRef(goTmpclient)
	}
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)
	var goTmpextra_info *C.cef_dictionary_value_t
	if extra_info != nil {
		goTmpextra_info = extra_info.p_dictionary_value
		BaseAddRef(goTmpextra_info)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		goTmprequest_context = request_context.p_request_context
		BaseAddRef(goTmprequest_context)
	}

	cRet := C.cef_browser_host_create_browser_sync((*C.cef_window_info_t)(windowInfo), goTmpclient, (*C.cef_string_t)(c_url), (*C.cef_browser_settings_t)(settings), goTmpextra_info, goTmprequest_context)

	ret = newCBrowserT(cRet)
	return ret
}

// cef_browser_process_handler_capi.h, include/capi/cef_browser_process_handler_capi.h:115:3,

///
// Structure used to implement browser process callbacks. The functions of this
// structure will be called on the browser process main thread unless otherwise
// indicated.
///

// Go type for cef_browser_process_handler_t
type CBrowserProcessHandlerT struct {
	noCopy                    noCopy
	p_browser_process_handler *C.cef_browser_process_handler_t
}

type RefToCBrowserProcessHandlerT struct {
	p_browser_process_handler *CBrowserProcessHandlerT
}

type CBrowserProcessHandlerTAccessor interface {
	GetCBrowserProcessHandlerT() *CBrowserProcessHandlerT
	SetCBrowserProcessHandlerT(*CBrowserProcessHandlerT)
}

func (r RefToCBrowserProcessHandlerT) GetCBrowserProcessHandlerT() *CBrowserProcessHandlerT {
	return r.p_browser_process_handler
}

func (r *RefToCBrowserProcessHandlerT) SetCBrowserProcessHandlerT(p *CBrowserProcessHandlerT) {
	r.p_browser_process_handler = p
}

// Go type CBrowserProcessHandlerT wraps cef type *C.cef_browser_process_handler_t
func newCBrowserProcessHandlerT(p *C.cef_browser_process_handler_t) *CBrowserProcessHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T2700:")
	BaseAddRef(p)
	go_browser_process_handler := CBrowserProcessHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_browser_process_handler, func(g *CBrowserProcessHandlerT) {
		Tracef(unsafe.Pointer(g.p_browser_process_handler), "T2704:")
		BaseRelease(g.p_browser_process_handler)
	})
	return &go_browser_process_handler
}

// *C.cef_browser_process_handler_t has refCounted interface
func (browser_process_handler *CBrowserProcessHandlerT) HasOneRef() bool {
	return BaseHasOneRef(browser_process_handler.p_browser_process_handler)
}

func (p *C.cef_browser_process_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the browser process UI thread immediately after the CEF context
// has been initialized.
///
type OnContextInitializedHandler interface {
	OnContextInitialized(
		self *CBrowserProcessHandlerT,
	)
}

///
// Called before a child process is launched. Will be called on the browser
// process UI thread when launching a render process and on the browser
// process IO thread when launching a GPU or plugin process. Provides an
// opportunity to modify the child process command line. Do not keep a
// reference to |command_line| outside of this function.
///
type OnBeforeChildProcessLaunchHandler interface {
	OnBeforeChildProcessLaunch(
		self *CBrowserProcessHandlerT,
		command_line *CCommandLineT,
	)
}

///
// Called on the browser process IO thread after the main thread has been
// created for a new render process. Provides an opportunity to specify extra
// information that will be passed to
// cef_render_process_handler_t::on_render_thread_created() in the render
// process. Do not keep a reference to |extra_info| outside of this function.
///
type OnRenderProcessThreadCreatedHandler interface {
	OnRenderProcessThreadCreated(
		self *CBrowserProcessHandlerT,
		extra_info *CListValueT,
	)
}

///
// Called from any thread when work has been scheduled for the browser process
// main (UI) thread. This callback is used in combination with CefSettings.
// external_message_pump and cef_do_message_loop_work() in cases where the CEF
// message loop must be integrated into an existing application message loop
// (see additional comments and warnings on CefDoMessageLoopWork). This
// callback should schedule a cef_do_message_loop_work() call to happen on the
// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
// |delay_ms| is &lt;= 0 then the call should happen reasonably soon. If
// |delay_ms| is &gt; 0 then the call should be scheduled to happen after the
// specified delay and any currently pending scheduled call should be
// cancelled.
///
type OnScheduleMessagePumpWorkHandler interface {
	OnScheduleMessagePumpWork(
		self *CBrowserProcessHandlerT,
		delay_ms int64,
	)
}

var browser_process_handler_handlers = struct {
	on_context_initialized_handler           map[*C.cef_browser_process_handler_t]OnContextInitializedHandler
	on_before_child_process_launch_handler   map[*C.cef_browser_process_handler_t]OnBeforeChildProcessLaunchHandler
	on_render_process_thread_created_handler map[*C.cef_browser_process_handler_t]OnRenderProcessThreadCreatedHandler
	print_handler                            map[*C.cef_browser_process_handler_t]*CPrintHandlerT
	on_schedule_message_pump_work_handler    map[*C.cef_browser_process_handler_t]OnScheduleMessagePumpWorkHandler
}{
	map[*C.cef_browser_process_handler_t]OnContextInitializedHandler{},
	map[*C.cef_browser_process_handler_t]OnBeforeChildProcessLaunchHandler{},
	map[*C.cef_browser_process_handler_t]OnRenderProcessThreadCreatedHandler{},
	map[*C.cef_browser_process_handler_t]*CPrintHandlerT{},
	map[*C.cef_browser_process_handler_t]OnScheduleMessagePumpWorkHandler{},
}

// AllocCBrowserProcessHandlerT allocates CBrowserProcessHandlerT and construct it
func AllocCBrowserProcessHandlerT() *CBrowserProcessHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_browser_process_handler_wrapper_t, "T2793:")
	cefp := C.cefingo_construct_browser_process_handler((*C.cefingo_browser_process_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_browser_process_handler_t itself in DeassocFunc,
		// or cef_browser_process_handler_t is never GCed.
		Tracef(up, "T2799:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(browser_process_handler_handlers.on_context_initialized_handler, cefp)
		delete(browser_process_handler_handlers.on_before_child_process_launch_handler, cefp)
		delete(browser_process_handler_handlers.on_render_process_thread_created_handler, cefp)
		delete(browser_process_handler_handlers.print_handler, cefp)
		delete(browser_process_handler_handlers.on_schedule_message_pump_work_handler, cefp)
	}))

	return newCBrowserProcessHandlerT(cefp)
}

func (browser_process_handler *CBrowserProcessHandlerT) Bind(a interface{}) *CBrowserProcessHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := browser_process_handler.p_browser_process_handler

	if h, ok := a.(OnContextInitializedHandler); ok {
		browser_process_handler_handlers.on_context_initialized_handler[cp] = h
	}

	if h, ok := a.(OnBeforeChildProcessLaunchHandler); ok {
		browser_process_handler_handlers.on_before_child_process_launch_handler[cp] = h
	}

	if h, ok := a.(OnRenderProcessThreadCreatedHandler); ok {
		browser_process_handler_handlers.on_render_process_thread_created_handler[cp] = h
	}

	if h, ok := a.(OnScheduleMessagePumpWorkHandler); ok {
		browser_process_handler_handlers.on_schedule_message_pump_work_handler[cp] = h
	}

	if accessor, ok := a.(CBrowserProcessHandlerTAccessor); ok {
		accessor.SetCBrowserProcessHandlerT(browser_process_handler)
		Logf("T2849:")
	}

	return browser_process_handler
}

func (browser_process_handler *CBrowserProcessHandlerT) AssocPrintHandlerT(handler *CPrintHandlerT) {
	cp := browser_process_handler.p_browser_process_handler
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	browser_process_handler_handlers.print_handler[cp] = handler
}

// cef_browser_view_capi.h, include/capi/views/cef_browser_view_capi.h:79:3,

///
// A View hosting a cef_browser_t instance. Methods must be called on the
// browser process UI thread unless otherwise indicated.
///

// Go type for cef_browser_view_t
type CBrowserViewT struct {
	noCopy         noCopy
	p_browser_view *C.cef_browser_view_t
}

type RefToCBrowserViewT struct {
	p_browser_view *CBrowserViewT
}

type CBrowserViewTAccessor interface {
	GetCBrowserViewT() *CBrowserViewT
	SetCBrowserViewT(*CBrowserViewT)
}

func (r RefToCBrowserViewT) GetCBrowserViewT() *CBrowserViewT {
	return r.p_browser_view
}

func (r *RefToCBrowserViewT) SetCBrowserViewT(p *CBrowserViewT) {
	r.p_browser_view = p
}

// Go type CBrowserViewT wraps cef type *C.cef_browser_view_t
func newCBrowserViewT(p *C.cef_browser_view_t) *CBrowserViewT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T2885:")
	BaseAddRef(p)
	go_browser_view := CBrowserViewT{noCopy{}, p}
	runtime.SetFinalizer(&go_browser_view, func(g *CBrowserViewT) {
		Tracef(unsafe.Pointer(g.p_browser_view), "T2889:")
		BaseRelease(g.p_browser_view)
	})
	return &go_browser_view
}

// *C.cef_browser_view_t has refCounted interface
func (browser_view *CBrowserViewT) HasOneRef() bool {
	return BaseHasOneRef(browser_view.p_browser_view)
}

func (p *C.cef_browser_view_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (browser_view *CBrowserViewT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(browser_view.p_browser_view))
	return newCViewT(p)
}

///
// Returns the cef_browser_t hosted by this BrowserView. Will return NULL if
// the browser has not yet been created or has already been destroyed.
///
func (self *CBrowserViewT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_browser_view_get_browser(self.p_browser_view)

	ret = newCBrowserT(cRet)
	return ret
}

///
// Sets whether accelerators registered with cef_window_t::SetAccelerator are
// triggered before or after the event is sent to the cef_browser_t. If
// |prefer_accelerators| is true (1) then the matching accelerator will be
// triggered immediately and the event will not be sent to the cef_browser_t.
// If |prefer_accelerators| is false (0) then the matching accelerator will
// only be triggered if the event is not handled by web content or by
// cef_keyboard_handler_t. The default value is false (0).
///
func (self *CBrowserViewT) SetPreferAccelerators(
	prefer_accelerators int,
) {

	C.cefingo_browser_view_set_prefer_accelerators(self.p_browser_view, (C.int)(prefer_accelerators))

}

///
// Create a new BrowserView. The underlying cef_browser_t will not be created
// until this view is added to the views hierarchy. The optional |extra_info|
// parameter provides an opportunity to specify extra information specific to
// the created browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
func BrowserViewCreate(
	client *CClientT,
	url string,
	settings *CBrowserSettingsT,
	extra_info *CDictionaryValueT,
	request_context *CRequestContextT,
	delegate *CBrowserViewDelegateT,
) (ret *CBrowserViewT) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		goTmpclient = client.p_client
		BaseAddRef(goTmpclient)
	}
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)
	var goTmpextra_info *C.cef_dictionary_value_t
	if extra_info != nil {
		goTmpextra_info = extra_info.p_dictionary_value
		BaseAddRef(goTmpextra_info)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		goTmprequest_context = request_context.p_request_context
		BaseAddRef(goTmprequest_context)
	}
	var goTmpdelegate *C.cef_browser_view_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_browser_view_delegate
		BaseAddRef(goTmpdelegate)
	}

	cRet := C.cef_browser_view_create(goTmpclient, (*C.cef_string_t)(c_url), (*C.cef_browser_settings_t)(settings), goTmpextra_info, goTmprequest_context, goTmpdelegate)

	ret = newCBrowserViewT(cRet)
	return ret
}

///
// Returns the BrowserView associated with |browser|.
///
func BrowserViewGetForBrowser(
	browser *CBrowserT,
) (ret *CBrowserViewT) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		goTmpbrowser = browser.p_browser
		BaseAddRef(goTmpbrowser)
	}

	cRet := C.cef_browser_view_get_for_browser(goTmpbrowser)

	ret = newCBrowserViewT(cRet)
	return ret
}

// cef_browser_view_delegate_capi.h, include/capi/views/cef_browser_view_delegate_capi.h:115:3,

///
// Implement this structure to handle BrowserView events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_browser_view_delegate_t
type CBrowserViewDelegateT struct {
	noCopy                  noCopy
	p_browser_view_delegate *C.cef_browser_view_delegate_t
}

type RefToCBrowserViewDelegateT struct {
	p_browser_view_delegate *CBrowserViewDelegateT
}

type CBrowserViewDelegateTAccessor interface {
	GetCBrowserViewDelegateT() *CBrowserViewDelegateT
	SetCBrowserViewDelegateT(*CBrowserViewDelegateT)
}

func (r RefToCBrowserViewDelegateT) GetCBrowserViewDelegateT() *CBrowserViewDelegateT {
	return r.p_browser_view_delegate
}

func (r *RefToCBrowserViewDelegateT) SetCBrowserViewDelegateT(p *CBrowserViewDelegateT) {
	r.p_browser_view_delegate = p
}

// Go type CBrowserViewDelegateT wraps cef type *C.cef_browser_view_delegate_t
func newCBrowserViewDelegateT(p *C.cef_browser_view_delegate_t) *CBrowserViewDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T3040:")
	BaseAddRef(p)
	go_browser_view_delegate := CBrowserViewDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_browser_view_delegate, func(g *CBrowserViewDelegateT) {
		Tracef(unsafe.Pointer(g.p_browser_view_delegate), "T3044:")
		BaseRelease(g.p_browser_view_delegate)
	})
	return &go_browser_view_delegate
}

// *C.cef_browser_view_delegate_t has refCounted interface
func (browser_view_delegate *CBrowserViewDelegateT) HasOneRef() bool {
	return BaseHasOneRef(browser_view_delegate.p_browser_view_delegate)
}

func (p *C.cef_browser_view_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (browser_view_delegate *CBrowserViewDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(browser_view_delegate.p_browser_view_delegate))
	return newCViewDelegateT(p)
}

///
// Called when |browser| associated with |browser_view| is created. This
// function will be called after cef_life_span_handler_t::on_after_created()
// is called for |browser| and before on_popup_browser_view_created() is
// called for |browser|&#39;s parent delegate if |browser| is a popup.
///
type CBrowserViewDelegateTOnBrowserCreatedHandler interface {
	OnBrowserCreated(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		browser *CBrowserT,
	)
}

///
// Called when |browser| associated with |browser_view| is destroyed. Release
// all references to |browser| and do not attempt to execute any functions on
// |browser| after this callback returns. This function will be called before
// cef_life_span_handler_t::on_before_close() is called for |browser|.
///
type CBrowserViewDelegateTOnBrowserDestroyedHandler interface {
	OnBrowserDestroyed(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		browser *CBrowserT,
	)
}

///
// Called before a new popup BrowserView is created. The popup originated from
// |browser_view|. |settings| and |client| are the values returned from
// cef_life_span_handler_t::on_before_popup(). |is_devtools| will be true (1)
// if the popup will be a DevTools browser. Return the delegate that will be
// used for the new popup BrowserView.
///
type GetDelegateForPopupBrowserViewHandler interface {
	GetDelegateForPopupBrowserView(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		settings *CBrowserSettingsT,
		client *CClientT,
		is_devtools int,
	) (ret *CBrowserViewDelegateT)
}

///
// Called after |popup_browser_view| is created. This function will be called
// after cef_life_span_handler_t::on_after_created() and on_browser_created()
// are called for the new popup browser. The popup originated from
// |browser_view|. |is_devtools| will be true (1) if the popup is a DevTools
// browser. Optionally add |popup_browser_view| to the views hierarchy
// yourself and return true (1). Otherwise return false (0) and a default
// cef_window_t will be created for the popup.
///
type OnPopupBrowserViewCreatedHandler interface {
	OnPopupBrowserViewCreated(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		popup_browser_view *CBrowserViewT,
		is_devtools int,
	) (ret bool)
}

var browser_view_delegate_handlers = struct {
	on_browser_created_handler                  map[*C.cef_browser_view_delegate_t]CBrowserViewDelegateTOnBrowserCreatedHandler
	on_browser_destroyed_handler                map[*C.cef_browser_view_delegate_t]CBrowserViewDelegateTOnBrowserDestroyedHandler
	get_delegate_for_popup_browser_view_handler map[*C.cef_browser_view_delegate_t]GetDelegateForPopupBrowserViewHandler
	on_popup_browser_view_created_handler       map[*C.cef_browser_view_delegate_t]OnPopupBrowserViewCreatedHandler
	get_preferred_size_handler                  map[*C.cef_browser_view_delegate_t]GetPreferredSizeHandler
	get_minimum_size_handler                    map[*C.cef_browser_view_delegate_t]GetMinimumSizeHandler
	get_maximum_size_handler                    map[*C.cef_browser_view_delegate_t]GetMaximumSizeHandler
	get_height_for_width_handler                map[*C.cef_browser_view_delegate_t]GetHeightForWidthHandler
	on_parent_view_changed_handler              map[*C.cef_browser_view_delegate_t]OnParentViewChangedHandler
	on_child_view_changed_handler               map[*C.cef_browser_view_delegate_t]OnChildViewChangedHandler
	on_focus_handler                            map[*C.cef_browser_view_delegate_t]OnFocusHandler
	on_blur_handler                             map[*C.cef_browser_view_delegate_t]OnBlurHandler
}{
	map[*C.cef_browser_view_delegate_t]CBrowserViewDelegateTOnBrowserCreatedHandler{},
	map[*C.cef_browser_view_delegate_t]CBrowserViewDelegateTOnBrowserDestroyedHandler{},
	map[*C.cef_browser_view_delegate_t]GetDelegateForPopupBrowserViewHandler{},
	map[*C.cef_browser_view_delegate_t]OnPopupBrowserViewCreatedHandler{},
	map[*C.cef_browser_view_delegate_t]GetPreferredSizeHandler{},
	map[*C.cef_browser_view_delegate_t]GetMinimumSizeHandler{},
	map[*C.cef_browser_view_delegate_t]GetMaximumSizeHandler{},
	map[*C.cef_browser_view_delegate_t]GetHeightForWidthHandler{},
	map[*C.cef_browser_view_delegate_t]OnParentViewChangedHandler{},
	map[*C.cef_browser_view_delegate_t]OnChildViewChangedHandler{},
	map[*C.cef_browser_view_delegate_t]OnFocusHandler{},
	map[*C.cef_browser_view_delegate_t]OnBlurHandler{},
}

// AllocCBrowserViewDelegateT allocates CBrowserViewDelegateT and construct it
func AllocCBrowserViewDelegateT() *CBrowserViewDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_browser_view_delegate_wrapper_t, "T3157:")
	cefp := C.cefingo_construct_browser_view_delegate((*C.cefingo_browser_view_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_browser_view_delegate_t itself in DeassocFunc,
		// or cef_browser_view_delegate_t is never GCed.
		Tracef(up, "T3163:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(browser_view_delegate_handlers.on_browser_created_handler, cefp)
		delete(browser_view_delegate_handlers.on_browser_destroyed_handler, cefp)
		delete(browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler, cefp)
		delete(browser_view_delegate_handlers.on_popup_browser_view_created_handler, cefp)
		delete(browser_view_delegate_handlers.get_preferred_size_handler, cefp)
		delete(browser_view_delegate_handlers.get_minimum_size_handler, cefp)
		delete(browser_view_delegate_handlers.get_maximum_size_handler, cefp)
		delete(browser_view_delegate_handlers.get_height_for_width_handler, cefp)
		delete(browser_view_delegate_handlers.on_parent_view_changed_handler, cefp)
		delete(browser_view_delegate_handlers.on_child_view_changed_handler, cefp)
		delete(browser_view_delegate_handlers.on_focus_handler, cefp)
		delete(browser_view_delegate_handlers.on_blur_handler, cefp)
	}))

	return newCBrowserViewDelegateT(cefp)
}

func (browser_view_delegate *CBrowserViewDelegateT) Bind(a interface{}) *CBrowserViewDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := browser_view_delegate.p_browser_view_delegate

	if h, ok := a.(CBrowserViewDelegateTOnBrowserCreatedHandler); ok {
		browser_view_delegate_handlers.on_browser_created_handler[cp] = h
	}

	if h, ok := a.(CBrowserViewDelegateTOnBrowserDestroyedHandler); ok {
		browser_view_delegate_handlers.on_browser_destroyed_handler[cp] = h
	}

	if h, ok := a.(GetDelegateForPopupBrowserViewHandler); ok {
		browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler[cp] = h
	}

	if h, ok := a.(OnPopupBrowserViewCreatedHandler); ok {
		browser_view_delegate_handlers.on_popup_browser_view_created_handler[cp] = h
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		browser_view_delegate_handlers.get_preferred_size_handler[cp] = h
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		browser_view_delegate_handlers.get_minimum_size_handler[cp] = h
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		browser_view_delegate_handlers.get_maximum_size_handler[cp] = h
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		browser_view_delegate_handlers.get_height_for_width_handler[cp] = h
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		browser_view_delegate_handlers.on_parent_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		browser_view_delegate_handlers.on_child_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnFocusHandler); ok {
		browser_view_delegate_handlers.on_focus_handler[cp] = h
	}

	if h, ok := a.(OnBlurHandler); ok {
		browser_view_delegate_handlers.on_blur_handler[cp] = h
	}

	if accessor, ok := a.(CBrowserViewDelegateTAccessor); ok {
		accessor.SetCBrowserViewDelegateT(browser_view_delegate)
		Logf("T3252:")
	}

	return browser_view_delegate
}

// cef_button_capi.h, include/capi/views/cef_button_capi.h:97:3,

///
// A View representing a button. Depending on the specific type, the button
// could be implemented by a native control or custom rendered. Methods must be
// called on the browser process UI thread unless otherwise indicated.
///

// Go type for cef_button_t
type CButtonT struct {
	noCopy   noCopy
	p_button *C.cef_button_t
}

type RefToCButtonT struct {
	p_button *CButtonT
}

type CButtonTAccessor interface {
	GetCButtonT() *CButtonT
	SetCButtonT(*CButtonT)
}

func (r RefToCButtonT) GetCButtonT() *CButtonT {
	return r.p_button
}

func (r *RefToCButtonT) SetCButtonT(p *CButtonT) {
	r.p_button = p
}

// Go type CButtonT wraps cef type *C.cef_button_t
func newCButtonT(p *C.cef_button_t) *CButtonT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T3281:")
	BaseAddRef(p)
	go_button := CButtonT{noCopy{}, p}
	runtime.SetFinalizer(&go_button, func(g *CButtonT) {
		Tracef(unsafe.Pointer(g.p_button), "T3285:")
		BaseRelease(g.p_button)
	})
	return &go_button
}

// *C.cef_button_t has refCounted interface
func (button *CButtonT) HasOneRef() bool {
	return BaseHasOneRef(button.p_button)
}

func (p *C.cef_button_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (button *CButtonT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(button.p_button))
	return newCViewT(p)
}

///
// Returns this Button as a LabelButton or NULL if this is not a LabelButton.
///
func (self *CButtonT) AsLabelButton() (ret *CLabelButtonT) {

	cRet := C.cefingo_button_as_label_button(self.p_button)

	ret = newCLabelButtonT(cRet)
	return ret
}

///
// Sets the current display state of the Button.
///
func (self *CButtonT) SetState(
	state CButtonStateT,
) {

	C.cefingo_button_set_state(self.p_button, (C.cef_button_state_t)(state))

}

///
// Returns the current display state of the Button.
///
func (self *CButtonT) GetState() (ret CButtonStateT) {

	cRet := C.cefingo_button_get_state(self.p_button)

	ret = CButtonStateT(cRet)
	return ret
}

///
// Sets the Button will use an ink drop effect for displaying state changes.
///
func (self *CButtonT) SetInkDropEnabled(
	enabled int,
) {

	C.cefingo_button_set_ink_drop_enabled(self.p_button, (C.int)(enabled))

}

///
// Sets the tooltip text that will be displayed when the user hovers the mouse
// cursor over the Button.
///
func (self *CButtonT) SetTooltipText(
	tooltip_text string,
) {
	c_tooltip_text := create_cef_string(tooltip_text)
	defer clear_cef_string(c_tooltip_text)

	C.cefingo_button_set_tooltip_text(self.p_button, (*C.cef_string_t)(c_tooltip_text))

}

///
// Sets the accessible name that will be exposed to assistive technology (AT).
///
func (self *CButtonT) SetAccessibleName(
	name string,
) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	C.cefingo_button_set_accessible_name(self.p_button, (*C.cef_string_t)(c_name))

}

// cef_button_delegate_capi.h, include/capi/views/cef_button_delegate_capi.h:74:3,

///
// Implement this structure to handle Button events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_button_delegate_t
type CButtonDelegateT struct {
	noCopy            noCopy
	p_button_delegate *C.cef_button_delegate_t
}

type RefToCButtonDelegateT struct {
	p_button_delegate *CButtonDelegateT
}

type CButtonDelegateTAccessor interface {
	GetCButtonDelegateT() *CButtonDelegateT
	SetCButtonDelegateT(*CButtonDelegateT)
}

func (r RefToCButtonDelegateT) GetCButtonDelegateT() *CButtonDelegateT {
	return r.p_button_delegate
}

func (r *RefToCButtonDelegateT) SetCButtonDelegateT(p *CButtonDelegateT) {
	r.p_button_delegate = p
}

// Go type CButtonDelegateT wraps cef type *C.cef_button_delegate_t
func newCButtonDelegateT(p *C.cef_button_delegate_t) *CButtonDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T3419:")
	BaseAddRef(p)
	go_button_delegate := CButtonDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_button_delegate, func(g *CButtonDelegateT) {
		Tracef(unsafe.Pointer(g.p_button_delegate), "T3423:")
		BaseRelease(g.p_button_delegate)
	})
	return &go_button_delegate
}

// *C.cef_button_delegate_t has refCounted interface
func (button_delegate *CButtonDelegateT) HasOneRef() bool {
	return BaseHasOneRef(button_delegate.p_button_delegate)
}

func (p *C.cef_button_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (button_delegate *CButtonDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(button_delegate.p_button_delegate))
	return newCViewDelegateT(p)
}

///
// Called when |button| is pressed.
///
type OnButtonPressedHandler interface {
	OnButtonPressed(
		self *CButtonDelegateT,
		button *CButtonT,
	)
}

///
// Called when the state of |button| changes.
///
type OnButtonStateChangedHandler interface {
	OnButtonStateChanged(
		self *CButtonDelegateT,
		button *CButtonT,
	)
}

var button_delegate_handlers = struct {
	on_button_pressed_handler       map[*C.cef_button_delegate_t]OnButtonPressedHandler
	on_button_state_changed_handler map[*C.cef_button_delegate_t]OnButtonStateChangedHandler
	get_preferred_size_handler      map[*C.cef_button_delegate_t]GetPreferredSizeHandler
	get_minimum_size_handler        map[*C.cef_button_delegate_t]GetMinimumSizeHandler
	get_maximum_size_handler        map[*C.cef_button_delegate_t]GetMaximumSizeHandler
	get_height_for_width_handler    map[*C.cef_button_delegate_t]GetHeightForWidthHandler
	on_parent_view_changed_handler  map[*C.cef_button_delegate_t]OnParentViewChangedHandler
	on_child_view_changed_handler   map[*C.cef_button_delegate_t]OnChildViewChangedHandler
	on_focus_handler                map[*C.cef_button_delegate_t]OnFocusHandler
	on_blur_handler                 map[*C.cef_button_delegate_t]OnBlurHandler
}{
	map[*C.cef_button_delegate_t]OnButtonPressedHandler{},
	map[*C.cef_button_delegate_t]OnButtonStateChangedHandler{},
	map[*C.cef_button_delegate_t]GetPreferredSizeHandler{},
	map[*C.cef_button_delegate_t]GetMinimumSizeHandler{},
	map[*C.cef_button_delegate_t]GetMaximumSizeHandler{},
	map[*C.cef_button_delegate_t]GetHeightForWidthHandler{},
	map[*C.cef_button_delegate_t]OnParentViewChangedHandler{},
	map[*C.cef_button_delegate_t]OnChildViewChangedHandler{},
	map[*C.cef_button_delegate_t]OnFocusHandler{},
	map[*C.cef_button_delegate_t]OnBlurHandler{},
}

// AllocCButtonDelegateT allocates CButtonDelegateT and construct it
func AllocCButtonDelegateT() *CButtonDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_button_delegate_wrapper_t, "T3489:")
	cefp := C.cefingo_construct_button_delegate((*C.cefingo_button_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_button_delegate_t itself in DeassocFunc,
		// or cef_button_delegate_t is never GCed.
		Tracef(up, "T3495:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(button_delegate_handlers.on_button_pressed_handler, cefp)
		delete(button_delegate_handlers.on_button_state_changed_handler, cefp)
		delete(button_delegate_handlers.get_preferred_size_handler, cefp)
		delete(button_delegate_handlers.get_minimum_size_handler, cefp)
		delete(button_delegate_handlers.get_maximum_size_handler, cefp)
		delete(button_delegate_handlers.get_height_for_width_handler, cefp)
		delete(button_delegate_handlers.on_parent_view_changed_handler, cefp)
		delete(button_delegate_handlers.on_child_view_changed_handler, cefp)
		delete(button_delegate_handlers.on_focus_handler, cefp)
		delete(button_delegate_handlers.on_blur_handler, cefp)
	}))

	return newCButtonDelegateT(cefp)
}

func (button_delegate *CButtonDelegateT) Bind(a interface{}) *CButtonDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := button_delegate.p_button_delegate

	if h, ok := a.(OnButtonPressedHandler); ok {
		button_delegate_handlers.on_button_pressed_handler[cp] = h
	}

	if h, ok := a.(OnButtonStateChangedHandler); ok {
		button_delegate_handlers.on_button_state_changed_handler[cp] = h
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		button_delegate_handlers.get_preferred_size_handler[cp] = h
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		button_delegate_handlers.get_minimum_size_handler[cp] = h
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		button_delegate_handlers.get_maximum_size_handler[cp] = h
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		button_delegate_handlers.get_height_for_width_handler[cp] = h
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		button_delegate_handlers.on_parent_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		button_delegate_handlers.on_child_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnFocusHandler); ok {
		button_delegate_handlers.on_focus_handler[cp] = h
	}

	if h, ok := a.(OnBlurHandler); ok {
		button_delegate_handlers.on_blur_handler[cp] = h
	}

	if accessor, ok := a.(CButtonDelegateTAccessor); ok {
		accessor.SetCButtonDelegateT(button_delegate)
		Logf("T3574:")
	}

	return button_delegate
}

// cef_callback_capi.h, include/capi/cef_callback_capi.h:67:3,

///
// Generic callback structure used for asynchronous continuation.
///

// Go type for cef_callback_t
type CCallbackT struct {
	noCopy     noCopy
	p_callback *C.cef_callback_t
}

type RefToCCallbackT struct {
	p_callback *CCallbackT
}

type CCallbackTAccessor interface {
	GetCCallbackT() *CCallbackT
	SetCCallbackT(*CCallbackT)
}

func (r RefToCCallbackT) GetCCallbackT() *CCallbackT {
	return r.p_callback
}

func (r *RefToCCallbackT) SetCCallbackT(p *CCallbackT) {
	r.p_callback = p
}

// Go type CCallbackT wraps cef type *C.cef_callback_t
func newCCallbackT(p *C.cef_callback_t) *CCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T3601:")
	BaseAddRef(p)
	go_callback := CCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_callback, func(g *CCallbackT) {
		Tracef(unsafe.Pointer(g.p_callback), "T3605:")
		BaseRelease(g.p_callback)
	})
	return &go_callback
}

// *C.cef_callback_t has refCounted interface
func (callback *CCallbackT) HasOneRef() bool {
	return BaseHasOneRef(callback.p_callback)
}

func (p *C.cef_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Continue processing.
///
func (self *CCallbackT) Cont() {

	C.cefingo_callback_cont(self.p_callback)

}

///
// Cancel processing.
///
func (self *CCallbackT) Cancel() {

	C.cefingo_callback_cancel(self.p_callback)

}

///
// Generic callback structure used for asynchronous completion.
///

// Go type for cef_completion_callback_t
type CCompletionCallbackT struct {
	noCopy                noCopy
	p_completion_callback *C.cef_completion_callback_t
}

type RefToCCompletionCallbackT struct {
	p_completion_callback *CCompletionCallbackT
}

type CCompletionCallbackTAccessor interface {
	GetCCompletionCallbackT() *CCompletionCallbackT
	SetCCompletionCallbackT(*CCompletionCallbackT)
}

func (r RefToCCompletionCallbackT) GetCCompletionCallbackT() *CCompletionCallbackT {
	return r.p_completion_callback
}

func (r *RefToCCompletionCallbackT) SetCCompletionCallbackT(p *CCompletionCallbackT) {
	r.p_completion_callback = p
}

// Go type CCompletionCallbackT wraps cef type *C.cef_completion_callback_t
func newCCompletionCallbackT(p *C.cef_completion_callback_t) *CCompletionCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T3673:")
	BaseAddRef(p)
	go_completion_callback := CCompletionCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_completion_callback, func(g *CCompletionCallbackT) {
		Tracef(unsafe.Pointer(g.p_completion_callback), "T3677:")
		BaseRelease(g.p_completion_callback)
	})
	return &go_completion_callback
}

// *C.cef_completion_callback_t has refCounted interface
func (completion_callback *CCompletionCallbackT) HasOneRef() bool {
	return BaseHasOneRef(completion_callback.p_completion_callback)
}

func (p *C.cef_completion_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called once the task is complete.
///
func (self *CCompletionCallbackT) OnComplete() {

	C.cefingo_completion_callback_on_complete(self.p_completion_callback)

}

// cef_client_capi.h, include/capi/cef_client_capi.h:172:3,

///
// Implement this structure to provide handler implementations.
///

// Go type for cef_client_t
type CClientT struct {
	noCopy   noCopy
	p_client *C.cef_client_t
}

type RefToCClientT struct {
	p_client *CClientT
}

type CClientTAccessor interface {
	GetCClientT() *CClientT
	SetCClientT(*CClientT)
}

func (r RefToCClientT) GetCClientT() *CClientT {
	return r.p_client
}

func (r *RefToCClientT) SetCClientT(p *CClientT) {
	r.p_client = p
}

// Go type CClientT wraps cef type *C.cef_client_t
func newCClientT(p *C.cef_client_t) *CClientT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T3736:")
	BaseAddRef(p)
	go_client := CClientT{noCopy{}, p}
	runtime.SetFinalizer(&go_client, func(g *CClientT) {
		Tracef(unsafe.Pointer(g.p_client), "T3740:")
		BaseRelease(g.p_client)
	})
	return &go_client
}

// *C.cef_client_t has refCounted interface
func (client *CClientT) HasOneRef() bool {
	return BaseHasOneRef(client.p_client)
}

func (p *C.cef_client_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
type CClientTOnProcessMessageReceivedHandler interface {
	OnProcessMessageReceived(
		self *CClientT,
		browser *CBrowserT,
		frame *CFrameT,
		source_process CProcessIdT,
		message *CProcessMessageT,
	) (ret bool)
}

var client_handlers = struct {
	audio_handler                       map[*C.cef_client_t]*CAudioHandlerT
	context_menu_handler                map[*C.cef_client_t]*CContextMenuHandlerT
	dialog_handler                      map[*C.cef_client_t]*CDialogHandlerT
	display_handler                     map[*C.cef_client_t]*CDisplayHandlerT
	download_handler                    map[*C.cef_client_t]*CDownloadHandlerT
	drag_handler                        map[*C.cef_client_t]*CDragHandlerT
	find_handler                        map[*C.cef_client_t]*CFindHandlerT
	focus_handler                       map[*C.cef_client_t]*CFocusHandlerT
	jsdialog_handler                    map[*C.cef_client_t]*CJsdialogHandlerT
	keyboard_handler                    map[*C.cef_client_t]*CKeyboardHandlerT
	life_span_handler                   map[*C.cef_client_t]*CLifeSpanHandlerT
	load_handler                        map[*C.cef_client_t]*CLoadHandlerT
	render_handler                      map[*C.cef_client_t]*CRenderHandlerT
	request_handler                     map[*C.cef_client_t]*CRequestHandlerT
	on_process_message_received_handler map[*C.cef_client_t]CClientTOnProcessMessageReceivedHandler
}{
	map[*C.cef_client_t]*CAudioHandlerT{},
	map[*C.cef_client_t]*CContextMenuHandlerT{},
	map[*C.cef_client_t]*CDialogHandlerT{},
	map[*C.cef_client_t]*CDisplayHandlerT{},
	map[*C.cef_client_t]*CDownloadHandlerT{},
	map[*C.cef_client_t]*CDragHandlerT{},
	map[*C.cef_client_t]*CFindHandlerT{},
	map[*C.cef_client_t]*CFocusHandlerT{},
	map[*C.cef_client_t]*CJsdialogHandlerT{},
	map[*C.cef_client_t]*CKeyboardHandlerT{},
	map[*C.cef_client_t]*CLifeSpanHandlerT{},
	map[*C.cef_client_t]*CLoadHandlerT{},
	map[*C.cef_client_t]*CRenderHandlerT{},
	map[*C.cef_client_t]*CRequestHandlerT{},
	map[*C.cef_client_t]CClientTOnProcessMessageReceivedHandler{},
}

// AllocCClientT allocates CClientT and construct it
func AllocCClientT() *CClientT {
	up := c_calloc(1, C.sizeof_cefingo_client_wrapper_t, "T3806:")
	cefp := C.cefingo_construct_client((*C.cefingo_client_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_client_t itself in DeassocFunc,
		// or cef_client_t is never GCed.
		Tracef(up, "T3812:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(client_handlers.audio_handler, cefp)
		delete(client_handlers.context_menu_handler, cefp)
		delete(client_handlers.dialog_handler, cefp)
		delete(client_handlers.display_handler, cefp)
		delete(client_handlers.download_handler, cefp)
		delete(client_handlers.drag_handler, cefp)
		delete(client_handlers.find_handler, cefp)
		delete(client_handlers.focus_handler, cefp)
		delete(client_handlers.jsdialog_handler, cefp)
		delete(client_handlers.keyboard_handler, cefp)
		delete(client_handlers.life_span_handler, cefp)
		delete(client_handlers.load_handler, cefp)
		delete(client_handlers.render_handler, cefp)
		delete(client_handlers.request_handler, cefp)
		delete(client_handlers.on_process_message_received_handler, cefp)
	}))

	return newCClientT(cefp)
}

func (client *CClientT) Bind(a interface{}) *CClientT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := client.p_client

	if h, ok := a.(CClientTOnProcessMessageReceivedHandler); ok {
		client_handlers.on_process_message_received_handler[cp] = h
	}

	if accessor, ok := a.(CClientTAccessor); ok {
		accessor.SetCClientT(client)
		Logf("T3860:")
	}

	return client
}

func (client *CClientT) AssocAudioHandlerT(handler *CAudioHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.audio_handler[cp] = handler
}

func (client *CClientT) AssocContextMenuHandlerT(handler *CContextMenuHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.context_menu_handler[cp] = handler
}

func (client *CClientT) AssocDialogHandlerT(handler *CDialogHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.dialog_handler[cp] = handler
}

func (client *CClientT) AssocDisplayHandlerT(handler *CDisplayHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.display_handler[cp] = handler
}

func (client *CClientT) AssocDownloadHandlerT(handler *CDownloadHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.download_handler[cp] = handler
}

func (client *CClientT) AssocDragHandlerT(handler *CDragHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.drag_handler[cp] = handler
}

func (client *CClientT) AssocFindHandlerT(handler *CFindHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.find_handler[cp] = handler
}

func (client *CClientT) AssocFocusHandlerT(handler *CFocusHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.focus_handler[cp] = handler
}

func (client *CClientT) AssocJsdialogHandlerT(handler *CJsdialogHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.jsdialog_handler[cp] = handler
}

func (client *CClientT) AssocKeyboardHandlerT(handler *CKeyboardHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.keyboard_handler[cp] = handler
}

func (client *CClientT) AssocLifeSpanHandlerT(handler *CLifeSpanHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.life_span_handler[cp] = handler
}

func (client *CClientT) AssocLoadHandlerT(handler *CLoadHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.load_handler[cp] = handler
}

func (client *CClientT) AssocRenderHandlerT(handler *CRenderHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.render_handler[cp] = handler
}

func (client *CClientT) AssocRequestHandlerT(handler *CRequestHandlerT) {
	cp := client.p_client
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	client_handlers.request_handler[cp] = handler
}

// cef_command_line_capi.h, include/capi/cef_command_line_capi.h:197:3,

///
// Structure used to create and/or parse command line arguments. Arguments with
// '--', '-' and, on Windows, '/' prefixes are considered switches. Switches
// will always precede any arguments without switch prefixes. Switches can
// optionally have a value specified using the '=' delimiter (e.g.
// "-switch=value"). An argument of "--" will terminate switch parsing with all
// subsequent tokens, regardless of prefix, being interpreted as non-switch
// arguments. Switch names are considered case-insensitive. This structure can
// be used before cef_initialize() is called.
///

// Go type for cef_command_line_t
type CCommandLineT struct {
	noCopy         noCopy
	p_command_line *C.cef_command_line_t
}

type RefToCCommandLineT struct {
	p_command_line *CCommandLineT
}

type CCommandLineTAccessor interface {
	GetCCommandLineT() *CCommandLineT
	SetCCommandLineT(*CCommandLineT)
}

func (r RefToCCommandLineT) GetCCommandLineT() *CCommandLineT {
	return r.p_command_line
}

func (r *RefToCCommandLineT) SetCCommandLineT(p *CCommandLineT) {
	r.p_command_line = p
}

// Go type CCommandLineT wraps cef type *C.cef_command_line_t
func newCCommandLineT(p *C.cef_command_line_t) *CCommandLineT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T4006:")
	BaseAddRef(p)
	go_command_line := CCommandLineT{noCopy{}, p}
	runtime.SetFinalizer(&go_command_line, func(g *CCommandLineT) {
		Tracef(unsafe.Pointer(g.p_command_line), "T4010:")
		BaseRelease(g.p_command_line)
	})
	return &go_command_line
}

// *C.cef_command_line_t has refCounted interface
func (command_line *CCommandLineT) HasOneRef() bool {
	return BaseHasOneRef(command_line.p_command_line)
}

func (p *C.cef_command_line_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CCommandLineT) IsValid() (ret bool) {

	cRet := C.cefingo_command_line_is_valid(self.p_command_line)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CCommandLineT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_command_line_is_read_only(self.p_command_line)

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object.
///
func (self *CCommandLineT) Copy() (ret *CCommandLineT) {

	cRet := C.cefingo_command_line_copy(self.p_command_line)

	ret = newCCommandLineT(cRet)
	return ret
}

///
// Initialize the command line with the string returned by calling
// GetCommandLineW(). This function is only supported on Windows.
///
func (self *CCommandLineT) InitFromString(
	command_line string,
) {
	c_command_line := create_cef_string(command_line)
	defer clear_cef_string(c_command_line)

	C.cefingo_command_line_init_from_string(self.p_command_line, (*C.cef_string_t)(c_command_line))

}

///
// Reset the command-line switches and arguments but leave the program
// component unchanged.
///
func (self *CCommandLineT) Reset() {

	C.cefingo_command_line_reset(self.p_command_line)

}

///
// Retrieve the original command line string as a vector of strings. The argv
// array: { program, [(--|-|/)switch[=value]]*, [--], [argument]* }
///
func (self *CCommandLineT) GetArgv(
	argv CStringListT,
) {

	C.cefingo_command_line_get_argv(self.p_command_line, (C.cef_string_list_t)(argv))

}

///
// Constructs and returns the represented command line string. Use this
// function cautiously because quoting behavior is unclear.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CCommandLineT) GetCommandLineString() (ret string) {

	cRet := C.cefingo_command_line_get_command_line_string(self.p_command_line)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Get the program part of the command line string (the first item).
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CCommandLineT) GetProgram() (ret string) {

	cRet := C.cefingo_command_line_get_program(self.p_command_line)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the program part of the command line string (the first item).
///
func (self *CCommandLineT) SetProgram(
	program string,
) {
	c_program := create_cef_string(program)
	defer clear_cef_string(c_program)

	C.cefingo_command_line_set_program(self.p_command_line, (*C.cef_string_t)(c_program))

}

///
// Returns true (1) if the command line has switches.
///
func (self *CCommandLineT) HasSwitches() (ret bool) {

	cRet := C.cefingo_command_line_has_switches(self.p_command_line)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the command line contains the given switch.
///
func (self *CCommandLineT) HasSwitch(
	name string,
) (ret bool) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_command_line_has_switch(self.p_command_line, (*C.cef_string_t)(c_name))

	ret = cRet == 1
	return ret
}

///
// Returns the value associated with the given switch. If the switch has no
// value or isn&#39;t present this function returns the NULL string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CCommandLineT) GetSwitchValue(
	name string,
) (ret string) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_command_line_get_switch_value(self.p_command_line, (*C.cef_string_t)(c_name))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the map of switch names and values. If a switch has no value an
// NULL string is returned.
///
func (self *CCommandLineT) GetSwitches(
	switches CStringMapT,
) {

	C.cefingo_command_line_get_switches(self.p_command_line, (C.cef_string_map_t)(switches))

}

///
// Add a switch to the end of the command line. If the switch has no value
// pass an NULL value string.
///
func (self *CCommandLineT) AppendSwitch(
	name string,
) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	C.cefingo_command_line_append_switch(self.p_command_line, (*C.cef_string_t)(c_name))

}

///
// Add a switch with the specified value to the end of the command line.
///
func (self *CCommandLineT) AppendSwitchWithValue(
	name string,
	value string,
) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	C.cefingo_command_line_append_switch_with_value(self.p_command_line, (*C.cef_string_t)(c_name), (*C.cef_string_t)(c_value))

}

///
// True if there are remaining command line arguments.
///
func (self *CCommandLineT) HasArguments() (ret bool) {

	cRet := C.cefingo_command_line_has_arguments(self.p_command_line)

	ret = cRet == 1
	return ret
}

///
// Get the remaining command line arguments.
///
func (self *CCommandLineT) GetArguments(
	arguments CStringListT,
) {

	C.cefingo_command_line_get_arguments(self.p_command_line, (C.cef_string_list_t)(arguments))

}

///
// Add an argument to the end of the command line.
///
func (self *CCommandLineT) AppendArgument(
	argument string,
) {
	c_argument := create_cef_string(argument)
	defer clear_cef_string(c_argument)

	C.cefingo_command_line_append_argument(self.p_command_line, (*C.cef_string_t)(c_argument))

}

///
// Insert a command before the current command. Common for debuggers, like
// &quot;valgrind&quot; or &quot;gdb --args&quot;.
///
func (self *CCommandLineT) PrependWrapper(
	wrapper string,
) {
	c_wrapper := create_cef_string(wrapper)
	defer clear_cef_string(c_wrapper)

	C.cefingo_command_line_prepend_wrapper(self.p_command_line, (*C.cef_string_t)(c_wrapper))

}

///
// Create a new cef_command_line_t instance.
///
func CommandLineCreate() (ret *CCommandLineT) {

	cRet := C.cef_command_line_create()

	ret = newCCommandLineT(cRet)
	return ret
}

///
// Returns the singleton global cef_command_line_t object. The returned object
// will be read-only.
///
func CommandLineGetGlobal() (ret *CCommandLineT) {

	cRet := C.cef_command_line_get_global()

	ret = newCCommandLineT(cRet)
	return ret
}

// cef_context_menu_handler_capi.h, include/capi/cef_context_menu_handler_capi.h:75:3,

///
// Callback structure used for continuation of custom context menu display.
///

// Go type for cef_run_context_menu_callback_t
type CRunContextMenuCallbackT struct {
	noCopy                      noCopy
	p_run_context_menu_callback *C.cef_run_context_menu_callback_t
}

type RefToCRunContextMenuCallbackT struct {
	p_run_context_menu_callback *CRunContextMenuCallbackT
}

type CRunContextMenuCallbackTAccessor interface {
	GetCRunContextMenuCallbackT() *CRunContextMenuCallbackT
	SetCRunContextMenuCallbackT(*CRunContextMenuCallbackT)
}

func (r RefToCRunContextMenuCallbackT) GetCRunContextMenuCallbackT() *CRunContextMenuCallbackT {
	return r.p_run_context_menu_callback
}

func (r *RefToCRunContextMenuCallbackT) SetCRunContextMenuCallbackT(p *CRunContextMenuCallbackT) {
	r.p_run_context_menu_callback = p
}

// Go type CRunContextMenuCallbackT wraps cef type *C.cef_run_context_menu_callback_t
func newCRunContextMenuCallbackT(p *C.cef_run_context_menu_callback_t) *CRunContextMenuCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T4367:")
	BaseAddRef(p)
	go_run_context_menu_callback := CRunContextMenuCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_run_context_menu_callback, func(g *CRunContextMenuCallbackT) {
		Tracef(unsafe.Pointer(g.p_run_context_menu_callback), "T4371:")
		BaseRelease(g.p_run_context_menu_callback)
	})
	return &go_run_context_menu_callback
}

// *C.cef_run_context_menu_callback_t has refCounted interface
func (run_context_menu_callback *CRunContextMenuCallbackT) HasOneRef() bool {
	return BaseHasOneRef(run_context_menu_callback.p_run_context_menu_callback)
}

func (p *C.cef_run_context_menu_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Complete context menu display by selecting the specified |command_id| and
// |event_flags|.
///
func (self *CRunContextMenuCallbackT) Cont(
	command_id int,
	event_flags CEventFlagsT,
) {

	C.cefingo_run_context_menu_callback_cont(self.p_run_context_menu_callback, (C.int)(command_id), (C.cef_event_flags_t)(event_flags))

}

///
// Cancel context menu display.
///
func (self *CRunContextMenuCallbackT) Cancel() {

	C.cefingo_run_context_menu_callback_cancel(self.p_run_context_menu_callback)

}

///
// Implement this structure to handle context menu events. The functions of this
// structure will be called on the UI thread.
///

// Go type for cef_context_menu_handler_t
type CContextMenuHandlerT struct {
	noCopy                 noCopy
	p_context_menu_handler *C.cef_context_menu_handler_t
}

type RefToCContextMenuHandlerT struct {
	p_context_menu_handler *CContextMenuHandlerT
}

type CContextMenuHandlerTAccessor interface {
	GetCContextMenuHandlerT() *CContextMenuHandlerT
	SetCContextMenuHandlerT(*CContextMenuHandlerT)
}

func (r RefToCContextMenuHandlerT) GetCContextMenuHandlerT() *CContextMenuHandlerT {
	return r.p_context_menu_handler
}

func (r *RefToCContextMenuHandlerT) SetCContextMenuHandlerT(p *CContextMenuHandlerT) {
	r.p_context_menu_handler = p
}

// Go type CContextMenuHandlerT wraps cef type *C.cef_context_menu_handler_t
func newCContextMenuHandlerT(p *C.cef_context_menu_handler_t) *CContextMenuHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T4443:")
	BaseAddRef(p)
	go_context_menu_handler := CContextMenuHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_context_menu_handler, func(g *CContextMenuHandlerT) {
		Tracef(unsafe.Pointer(g.p_context_menu_handler), "T4447:")
		BaseRelease(g.p_context_menu_handler)
	})
	return &go_context_menu_handler
}

// *C.cef_context_menu_handler_t has refCounted interface
func (context_menu_handler *CContextMenuHandlerT) HasOneRef() bool {
	return BaseHasOneRef(context_menu_handler.p_context_menu_handler)
}

func (p *C.cef_context_menu_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called before a context menu is displayed. |params| provides information
// about the context menu state. |model| initially contains the default
// context menu. The |model| can be cleared to show no context menu or
// modified to show a custom menu. Do not keep references to |params| or
// |model| outside of this callback.
///
type OnBeforeContextMenuHandler interface {
	OnBeforeContextMenu(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		params *CContextMenuParamsT,
		model *CMenuModelT,
	)
}

///
// Called to allow custom display of the context menu. |params| provides
// information about the context menu state. |model| contains the context menu
// model resulting from OnBeforeContextMenu. For custom display return true
// (1) and execute |callback| either synchronously or asynchronously with the
// selected command ID. For default display return false (0). Do not keep
// references to |params| or |model| outside of this callback.
///
type RunContextMenuHandler interface {
	RunContextMenu(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		params *CContextMenuParamsT,
		model *CMenuModelT,
		callback *CRunContextMenuCallbackT,
	) (ret bool)
}

///
// Called to execute a command selected from the context menu. Return true (1)
// if the command was handled or false (0) for the default implementation. See
// cef_menu_id_t for the command ids that have default implementations. All
// user-defined command ids should be between MENU_ID_USER_FIRST and
// MENU_ID_USER_LAST. |params| will have the same values as what was passed to
// on_before_context_menu(). Do not keep a reference to |params| outside of
// this callback.
///
type OnContextMenuCommandHandler interface {
	OnContextMenuCommand(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		params *CContextMenuParamsT,
		command_id int,
		event_flags CEventFlagsT,
	) (ret bool)
}

///
// Called when the context menu is dismissed irregardless of whether the menu
// was NULL or a command was selected.
///
type OnContextMenuDismissedHandler interface {
	OnContextMenuDismissed(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
	)
}

var context_menu_handler_handlers = struct {
	on_before_context_menu_handler    map[*C.cef_context_menu_handler_t]OnBeforeContextMenuHandler
	run_context_menu_handler          map[*C.cef_context_menu_handler_t]RunContextMenuHandler
	on_context_menu_command_handler   map[*C.cef_context_menu_handler_t]OnContextMenuCommandHandler
	on_context_menu_dismissed_handler map[*C.cef_context_menu_handler_t]OnContextMenuDismissedHandler
}{
	map[*C.cef_context_menu_handler_t]OnBeforeContextMenuHandler{},
	map[*C.cef_context_menu_handler_t]RunContextMenuHandler{},
	map[*C.cef_context_menu_handler_t]OnContextMenuCommandHandler{},
	map[*C.cef_context_menu_handler_t]OnContextMenuDismissedHandler{},
}

// AllocCContextMenuHandlerT allocates CContextMenuHandlerT and construct it
func AllocCContextMenuHandlerT() *CContextMenuHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_context_menu_handler_wrapper_t, "T4544:")
	cefp := C.cefingo_construct_context_menu_handler((*C.cefingo_context_menu_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_context_menu_handler_t itself in DeassocFunc,
		// or cef_context_menu_handler_t is never GCed.
		Tracef(up, "T4550:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(context_menu_handler_handlers.on_before_context_menu_handler, cefp)
		delete(context_menu_handler_handlers.run_context_menu_handler, cefp)
		delete(context_menu_handler_handlers.on_context_menu_command_handler, cefp)
		delete(context_menu_handler_handlers.on_context_menu_dismissed_handler, cefp)
	}))

	return newCContextMenuHandlerT(cefp)
}

func (context_menu_handler *CContextMenuHandlerT) Bind(a interface{}) *CContextMenuHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := context_menu_handler.p_context_menu_handler

	if h, ok := a.(OnBeforeContextMenuHandler); ok {
		context_menu_handler_handlers.on_before_context_menu_handler[cp] = h
	}

	if h, ok := a.(RunContextMenuHandler); ok {
		context_menu_handler_handlers.run_context_menu_handler[cp] = h
	}

	if h, ok := a.(OnContextMenuCommandHandler); ok {
		context_menu_handler_handlers.on_context_menu_command_handler[cp] = h
	}

	if h, ok := a.(OnContextMenuDismissedHandler); ok {
		context_menu_handler_handlers.on_context_menu_dismissed_handler[cp] = h
	}

	if accessor, ok := a.(CContextMenuHandlerTAccessor); ok {
		accessor.SetCContextMenuHandlerT(context_menu_handler)
		Logf("T4599:")
	}

	return context_menu_handler
}

///
// Provides information about the context menu state. The ethods of this
// structure can only be accessed on browser process the UI thread.
///

// Go type for cef_context_menu_params_t
type CContextMenuParamsT struct {
	noCopy                noCopy
	p_context_menu_params *C.cef_context_menu_params_t
}

type RefToCContextMenuParamsT struct {
	p_context_menu_params *CContextMenuParamsT
}

type CContextMenuParamsTAccessor interface {
	GetCContextMenuParamsT() *CContextMenuParamsT
	SetCContextMenuParamsT(*CContextMenuParamsT)
}

func (r RefToCContextMenuParamsT) GetCContextMenuParamsT() *CContextMenuParamsT {
	return r.p_context_menu_params
}

func (r *RefToCContextMenuParamsT) SetCContextMenuParamsT(p *CContextMenuParamsT) {
	r.p_context_menu_params = p
}

// Go type CContextMenuParamsT wraps cef type *C.cef_context_menu_params_t
func newCContextMenuParamsT(p *C.cef_context_menu_params_t) *CContextMenuParamsT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T4625:")
	BaseAddRef(p)
	go_context_menu_params := CContextMenuParamsT{noCopy{}, p}
	runtime.SetFinalizer(&go_context_menu_params, func(g *CContextMenuParamsT) {
		Tracef(unsafe.Pointer(g.p_context_menu_params), "T4629:")
		BaseRelease(g.p_context_menu_params)
	})
	return &go_context_menu_params
}

// *C.cef_context_menu_params_t has refCounted interface
func (context_menu_params *CContextMenuParamsT) HasOneRef() bool {
	return BaseHasOneRef(context_menu_params.p_context_menu_params)
}

func (p *C.cef_context_menu_params_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the X coordinate of the mouse where the context menu was invoked.
// Coords are relative to the associated RenderView&#39;s origin.
///
func (self *CContextMenuParamsT) GetXcoord() (ret bool) {

	cRet := C.cefingo_context_menu_params_get_xcoord(self.p_context_menu_params)

	ret = cRet == 1
	return ret
}

///
// Returns the Y coordinate of the mouse where the context menu was invoked.
// Coords are relative to the associated RenderView&#39;s origin.
///
func (self *CContextMenuParamsT) GetYcoord() (ret bool) {

	cRet := C.cefingo_context_menu_params_get_ycoord(self.p_context_menu_params)

	ret = cRet == 1
	return ret
}

///
// Returns flags representing the type of node that the context menu was
// invoked on.
///
func (self *CContextMenuParamsT) GetTypeFlags() (ret CContextMenuTypeFlagsT) {

	cRet := C.cefingo_context_menu_params_get_type_flags(self.p_context_menu_params)

	ret = CContextMenuTypeFlagsT(cRet)
	return ret
}

///
// Returns the URL of the link, if any, that encloses the node that the
// context menu was invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetLinkUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_link_url(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the link URL, if any, to be used ONLY for &quot;copy link address&quot;. We
// don&#39;t validate this field in the frontend process.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetUnfilteredLinkUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_unfiltered_link_url(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the source URL, if any, for the element that the context menu was
// invoked on. Example of elements with source URLs are img, audio, and video.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetSourceUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_source_url(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if the context menu was invoked on an image which has non-
// NULL contents.
///
func (self *CContextMenuParamsT) HasImageContents() (ret bool) {

	cRet := C.cefingo_context_menu_params_has_image_contents(self.p_context_menu_params)

	ret = cRet == 1
	return ret
}

///
// Returns the title text or the alt text if the context menu was invoked on
// an image.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetTitleText() (ret string) {

	cRet := C.cefingo_context_menu_params_get_title_text(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the URL of the top level page that the context menu was invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetPageUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_page_url(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the URL of the subframe that the context menu was invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetFrameUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_frame_url(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the character encoding of the subframe that the context menu was
// invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetFrameCharset() (ret string) {

	cRet := C.cefingo_context_menu_params_get_frame_charset(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the type of context node that the context menu was invoked on.
///
func (self *CContextMenuParamsT) GetMediaType() (ret CContextMenuMediaTypeT) {

	cRet := C.cefingo_context_menu_params_get_media_type(self.p_context_menu_params)

	ret = CContextMenuMediaTypeT(cRet)
	return ret
}

///
// Returns flags representing the actions supported by the media element, if
// any, that the context menu was invoked on.
///
func (self *CContextMenuParamsT) GetMediaStateFlags() (ret CContextMenuMediaStateFlagsT) {

	cRet := C.cefingo_context_menu_params_get_media_state_flags(self.p_context_menu_params)

	ret = CContextMenuMediaStateFlagsT(cRet)
	return ret
}

///
// Returns the text of the selection, if any, that the context menu was
// invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetSelectionText() (ret string) {

	cRet := C.cefingo_context_menu_params_get_selection_text(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the text of the misspelled word, if any, that the context menu was
// invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetMisspelledWord() (ret string) {

	cRet := C.cefingo_context_menu_params_get_misspelled_word(self.p_context_menu_params)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if suggestions exist, false (0) otherwise. Fills in
// |suggestions| from the spell check service for the misspelled word if there
// is one.
///
func (self *CContextMenuParamsT) GetDictionarySuggestions(
	suggestions CStringListT,
) (ret bool) {

	cRet := C.cefingo_context_menu_params_get_dictionary_suggestions(self.p_context_menu_params, (C.cef_string_list_t)(suggestions))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the context menu was invoked on an editable node.
///
func (self *CContextMenuParamsT) IsEditable() (ret bool) {

	cRet := C.cefingo_context_menu_params_is_editable(self.p_context_menu_params)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the context menu was invoked on an editable node where
// spell-check is enabled.
///
func (self *CContextMenuParamsT) IsSpellCheckEnabled() (ret bool) {

	cRet := C.cefingo_context_menu_params_is_spell_check_enabled(self.p_context_menu_params)

	ret = cRet == 1
	return ret
}

///
// Returns flags representing the actions supported by the editable node, if
// any, that the context menu was invoked on.
///
func (self *CContextMenuParamsT) GetEditStateFlags() (ret CContextMenuEditStateFlagsT) {

	cRet := C.cefingo_context_menu_params_get_edit_state_flags(self.p_context_menu_params)

	ret = CContextMenuEditStateFlagsT(cRet)
	return ret
}

///
// Returns true (1) if the context menu contains items specified by the
// renderer process (for example, plugin placeholder or pepper plugin menu
// items).
///
func (self *CContextMenuParamsT) IsCustomMenu() (ret bool) {

	cRet := C.cefingo_context_menu_params_is_custom_menu(self.p_context_menu_params)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the context menu was invoked from a pepper plugin.
///
func (self *CContextMenuParamsT) IsPepperMenu() (ret bool) {

	cRet := C.cefingo_context_menu_params_is_pepper_menu(self.p_context_menu_params)

	ret = cRet == 1
	return ret
}

// cef_cookie_capi.h, include/capi/cef_cookie_capi.h:137:3,

///
// Structure used for managing cookies. The functions of this structure may be
// called on any thread unless otherwise indicated.
///

// Go type for cef_cookie_manager_t
type CCookieManagerT struct {
	noCopy           noCopy
	p_cookie_manager *C.cef_cookie_manager_t
}

type RefToCCookieManagerT struct {
	p_cookie_manager *CCookieManagerT
}

type CCookieManagerTAccessor interface {
	GetCCookieManagerT() *CCookieManagerT
	SetCCookieManagerT(*CCookieManagerT)
}

func (r RefToCCookieManagerT) GetCCookieManagerT() *CCookieManagerT {
	return r.p_cookie_manager
}

func (r *RefToCCookieManagerT) SetCCookieManagerT(p *CCookieManagerT) {
	r.p_cookie_manager = p
}

// Go type CCookieManagerT wraps cef type *C.cef_cookie_manager_t
func newCCookieManagerT(p *C.cef_cookie_manager_t) *CCookieManagerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5015:")
	BaseAddRef(p)
	go_cookie_manager := CCookieManagerT{noCopy{}, p}
	runtime.SetFinalizer(&go_cookie_manager, func(g *CCookieManagerT) {
		Tracef(unsafe.Pointer(g.p_cookie_manager), "T5019:")
		BaseRelease(g.p_cookie_manager)
	})
	return &go_cookie_manager
}

// *C.cef_cookie_manager_t has refCounted interface
func (cookie_manager *CCookieManagerT) HasOneRef() bool {
	return BaseHasOneRef(cookie_manager.p_cookie_manager)
}

func (p *C.cef_cookie_manager_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Set the schemes supported by this manager. If |include_defaults| is true
// (1) the default schemes (&quot;http&quot;, &quot;https&quot;, &quot;ws&quot; and &quot;wss&quot;) will also be
// supported. Calling this function with an NULL |schemes| value and
// |include_defaults| set to false (0) will disable all loading and saving of
// cookies for this manager. If |callback| is non-NULL it will be executed
// asnychronously on the UI thread after the change has been applied. Must be
// called before any cookies are accessed.
///
func (self *CCookieManagerT) SetSupportedSchemes(
	schemes CStringListT,
	include_defaults int,
	callback *CCompletionCallbackT,
) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		goTmpcallback = callback.p_completion_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_cookie_manager_set_supported_schemes(self.p_cookie_manager, (C.cef_string_list_t)(schemes), (C.int)(include_defaults), goTmpcallback)

}

///
// Visit all cookies on the UI thread. The returned cookies are ordered by
// longest path, then by earliest creation date. Returns false (0) if cookies
// cannot be accessed.
///
func (self *CCookieManagerT) VisitAllCookies(
	visitor *CCookieVisitorT,
) (ret bool) {
	var goTmpvisitor *C.cef_cookie_visitor_t
	if visitor != nil {
		goTmpvisitor = visitor.p_cookie_visitor
		BaseAddRef(goTmpvisitor)
	}

	cRet := C.cefingo_cookie_manager_visit_all_cookies(self.p_cookie_manager, goTmpvisitor)

	ret = cRet == 1
	return ret
}

///
// Visit a subset of cookies on the UI thread. The results are filtered by the
// given url scheme, host, domain and path. If |includeHttpOnly| is true (1)
// HTTP-only cookies will also be included in the results. The returned
// cookies are ordered by longest path, then by earliest creation date.
// Returns false (0) if cookies cannot be accessed.
///
func (self *CCookieManagerT) VisitUrlCookies(
	url string,
	includeHttpOnly int,
	visitor *CCookieVisitorT,
) (ret bool) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)
	var goTmpvisitor *C.cef_cookie_visitor_t
	if visitor != nil {
		goTmpvisitor = visitor.p_cookie_visitor
		BaseAddRef(goTmpvisitor)
	}

	cRet := C.cefingo_cookie_manager_visit_url_cookies(self.p_cookie_manager, (*C.cef_string_t)(c_url), (C.int)(includeHttpOnly), goTmpvisitor)

	ret = cRet == 1
	return ret
}

///
// Sets a cookie given a valid URL and explicit user-provided cookie
// attributes. This function expects each attribute to be well-formed. It will
// check for disallowed characters (e.g. the &#39;;&#39; character is disallowed
// within the cookie value attribute) and fail without setting the cookie if
// such characters are found. If |callback| is non-NULL it will be executed
// asnychronously on the UI thread after the cookie has been set. Returns
// false (0) if an invalid URL is specified or if cookies cannot be accessed.
///
func (self *CCookieManagerT) SetCookie(
	url string,
	cookie *CCookieT,
	callback *CSetCookieCallbackT,
) (ret bool) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)
	var goTmpcallback *C.cef_set_cookie_callback_t
	if callback != nil {
		goTmpcallback = callback.p_set_cookie_callback
		BaseAddRef(goTmpcallback)
	}

	cRet := C.cefingo_cookie_manager_set_cookie(self.p_cookie_manager, (*C.cef_string_t)(c_url), (*C.cef_cookie_t)(cookie), goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Delete all cookies that match the specified parameters. If both |url| and
// |cookie_name| values are specified all host and domain cookies matching
// both will be deleted. If only |url| is specified all host cookies (but not
// domain cookies) irrespective of path will be deleted. If |url| is NULL all
// cookies for all hosts and domains will be deleted. If |callback| is non-
// NULL it will be executed asnychronously on the UI thread after the cookies
// have been deleted. Returns false (0) if a non-NULL invalid URL is specified
// or if cookies cannot be accessed. Cookies can alternately be deleted using
// the Visit*Cookies() functions.
///
func (self *CCookieManagerT) DeleteCookies(
	url string,
	cookie_name string,
	callback *CDeleteCookiesCallbackT,
) (ret bool) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)
	c_cookie_name := create_cef_string(cookie_name)
	defer clear_cef_string(c_cookie_name)
	var goTmpcallback *C.cef_delete_cookies_callback_t
	if callback != nil {
		goTmpcallback = callback.p_delete_cookies_callback
		BaseAddRef(goTmpcallback)
	}

	cRet := C.cefingo_cookie_manager_delete_cookies(self.p_cookie_manager, (*C.cef_string_t)(c_url), (*C.cef_string_t)(c_cookie_name), goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Flush the backing store (if any) to disk. If |callback| is non-NULL it will
// be executed asnychronously on the UI thread after the flush is complete.
// Returns false (0) if cookies cannot be accessed.
///
func (self *CCookieManagerT) FlushStore(
	callback *CCompletionCallbackT,
) (ret bool) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		goTmpcallback = callback.p_completion_callback
		BaseAddRef(goTmpcallback)
	}

	cRet := C.cefingo_cookie_manager_flush_store(self.p_cookie_manager, goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Returns the global cookie manager. By default data will be stored at
// CefSettings.cache_path if specified or in memory otherwise. If |callback| is
// non-NULL it will be executed asnychronously on the UI thread after the
// manager's storage has been initialized. Using this function is equivalent to
// calling cef_request_context_t::cef_request_context_get_global_context()->GetD
// efaultCookieManager().
///
func CookieManagerGetGlobalManager(
	callback *CCompletionCallbackT,
) (ret *CCookieManagerT) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		goTmpcallback = callback.p_completion_callback
		BaseAddRef(goTmpcallback)
	}

	cRet := C.cef_cookie_manager_get_global_manager(goTmpcallback)

	ret = newCCookieManagerT(cRet)
	return ret
}

///
// Structure to implement for visiting cookie values. The functions of this
// structure will always be called on the UI thread.
///

// Go type for cef_cookie_visitor_t
type CCookieVisitorT struct {
	noCopy           noCopy
	p_cookie_visitor *C.cef_cookie_visitor_t
}

type RefToCCookieVisitorT struct {
	p_cookie_visitor *CCookieVisitorT
}

type CCookieVisitorTAccessor interface {
	GetCCookieVisitorT() *CCookieVisitorT
	SetCCookieVisitorT(*CCookieVisitorT)
}

func (r RefToCCookieVisitorT) GetCCookieVisitorT() *CCookieVisitorT {
	return r.p_cookie_visitor
}

func (r *RefToCCookieVisitorT) SetCCookieVisitorT(p *CCookieVisitorT) {
	r.p_cookie_visitor = p
}

// Go type CCookieVisitorT wraps cef type *C.cef_cookie_visitor_t
func newCCookieVisitorT(p *C.cef_cookie_visitor_t) *CCookieVisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5246:")
	BaseAddRef(p)
	go_cookie_visitor := CCookieVisitorT{noCopy{}, p}
	runtime.SetFinalizer(&go_cookie_visitor, func(g *CCookieVisitorT) {
		Tracef(unsafe.Pointer(g.p_cookie_visitor), "T5250:")
		BaseRelease(g.p_cookie_visitor)
	})
	return &go_cookie_visitor
}

// *C.cef_cookie_visitor_t has refCounted interface
func (cookie_visitor *CCookieVisitorT) HasOneRef() bool {
	return BaseHasOneRef(cookie_visitor.p_cookie_visitor)
}

func (p *C.cef_cookie_visitor_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called once for each cookie. |count| is the 0-based
// index for the current cookie. |total| is the total number of cookies. Set
// |deleteCookie| to true (1) to delete the cookie currently being visited.
// Return false (0) to stop visiting cookies. This function may never be
// called if no cookies are found.
///
type CCookieVisitorTVisitHandler interface {
	Visit(
		self *CCookieVisitorT,
		cookie *CCookieT,
		count int,
		total int,
	) (ret bool, deleteCookie int)
}

var cookie_visitor_handlers = struct {
	visit_handler map[*C.cef_cookie_visitor_t]CCookieVisitorTVisitHandler
}{
	map[*C.cef_cookie_visitor_t]CCookieVisitorTVisitHandler{},
}

// AllocCCookieVisitorT allocates CCookieVisitorT and construct it
func AllocCCookieVisitorT() *CCookieVisitorT {
	up := c_calloc(1, C.sizeof_cefingo_cookie_visitor_wrapper_t, "T5289:")
	cefp := C.cefingo_construct_cookie_visitor((*C.cefingo_cookie_visitor_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_cookie_visitor_t itself in DeassocFunc,
		// or cef_cookie_visitor_t is never GCed.
		Tracef(up, "T5295:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(cookie_visitor_handlers.visit_handler, cefp)
	}))

	return newCCookieVisitorT(cefp)
}

func (cookie_visitor *CCookieVisitorT) Bind(a interface{}) *CCookieVisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := cookie_visitor.p_cookie_visitor

	if h, ok := a.(CCookieVisitorTVisitHandler); ok {
		cookie_visitor_handlers.visit_handler[cp] = h
	}

	if accessor, ok := a.(CCookieVisitorTAccessor); ok {
		accessor.SetCCookieVisitorT(cookie_visitor)
		Logf("T5329:")
	}

	return cookie_visitor
}

///
// Structure to implement to be notified of asynchronous completion via
// cef_cookie_manager_t::set_cookie().
///

// Go type for cef_set_cookie_callback_t
type CSetCookieCallbackT struct {
	noCopy                noCopy
	p_set_cookie_callback *C.cef_set_cookie_callback_t
}

type RefToCSetCookieCallbackT struct {
	p_set_cookie_callback *CSetCookieCallbackT
}

type CSetCookieCallbackTAccessor interface {
	GetCSetCookieCallbackT() *CSetCookieCallbackT
	SetCSetCookieCallbackT(*CSetCookieCallbackT)
}

func (r RefToCSetCookieCallbackT) GetCSetCookieCallbackT() *CSetCookieCallbackT {
	return r.p_set_cookie_callback
}

func (r *RefToCSetCookieCallbackT) SetCSetCookieCallbackT(p *CSetCookieCallbackT) {
	r.p_set_cookie_callback = p
}

// Go type CSetCookieCallbackT wraps cef type *C.cef_set_cookie_callback_t
func newCSetCookieCallbackT(p *C.cef_set_cookie_callback_t) *CSetCookieCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5355:")
	BaseAddRef(p)
	go_set_cookie_callback := CSetCookieCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_set_cookie_callback, func(g *CSetCookieCallbackT) {
		Tracef(unsafe.Pointer(g.p_set_cookie_callback), "T5359:")
		BaseRelease(g.p_set_cookie_callback)
	})
	return &go_set_cookie_callback
}

// *C.cef_set_cookie_callback_t has refCounted interface
func (set_cookie_callback *CSetCookieCallbackT) HasOneRef() bool {
	return BaseHasOneRef(set_cookie_callback.p_set_cookie_callback)
}

func (p *C.cef_set_cookie_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called upon completion. |success| will be true (1) if
// the cookie was set successfully.
///
type CSetCookieCallbackTOnCompleteHandler interface {
	OnComplete(
		self *CSetCookieCallbackT,
		success int,
	)
}

var set_cookie_callback_handlers = struct {
	on_complete_handler map[*C.cef_set_cookie_callback_t]CSetCookieCallbackTOnCompleteHandler
}{
	map[*C.cef_set_cookie_callback_t]CSetCookieCallbackTOnCompleteHandler{},
}

// AllocCSetCookieCallbackT allocates CSetCookieCallbackT and construct it
func AllocCSetCookieCallbackT() *CSetCookieCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_set_cookie_callback_wrapper_t, "T5393:")
	cefp := C.cefingo_construct_set_cookie_callback((*C.cefingo_set_cookie_callback_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_set_cookie_callback_t itself in DeassocFunc,
		// or cef_set_cookie_callback_t is never GCed.
		Tracef(up, "T5399:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(set_cookie_callback_handlers.on_complete_handler, cefp)
	}))

	return newCSetCookieCallbackT(cefp)
}

func (set_cookie_callback *CSetCookieCallbackT) Bind(a interface{}) *CSetCookieCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := set_cookie_callback.p_set_cookie_callback

	if h, ok := a.(CSetCookieCallbackTOnCompleteHandler); ok {
		set_cookie_callback_handlers.on_complete_handler[cp] = h
	}

	if accessor, ok := a.(CSetCookieCallbackTAccessor); ok {
		accessor.SetCSetCookieCallbackT(set_cookie_callback)
		Logf("T5433:")
	}

	return set_cookie_callback
}

///
// Structure to implement to be notified of asynchronous completion via
// cef_cookie_manager_t::delete_cookies().
///

// Go type for cef_delete_cookies_callback_t
type CDeleteCookiesCallbackT struct {
	noCopy                    noCopy
	p_delete_cookies_callback *C.cef_delete_cookies_callback_t
}

type RefToCDeleteCookiesCallbackT struct {
	p_delete_cookies_callback *CDeleteCookiesCallbackT
}

type CDeleteCookiesCallbackTAccessor interface {
	GetCDeleteCookiesCallbackT() *CDeleteCookiesCallbackT
	SetCDeleteCookiesCallbackT(*CDeleteCookiesCallbackT)
}

func (r RefToCDeleteCookiesCallbackT) GetCDeleteCookiesCallbackT() *CDeleteCookiesCallbackT {
	return r.p_delete_cookies_callback
}

func (r *RefToCDeleteCookiesCallbackT) SetCDeleteCookiesCallbackT(p *CDeleteCookiesCallbackT) {
	r.p_delete_cookies_callback = p
}

// Go type CDeleteCookiesCallbackT wraps cef type *C.cef_delete_cookies_callback_t
func newCDeleteCookiesCallbackT(p *C.cef_delete_cookies_callback_t) *CDeleteCookiesCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5459:")
	BaseAddRef(p)
	go_delete_cookies_callback := CDeleteCookiesCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_delete_cookies_callback, func(g *CDeleteCookiesCallbackT) {
		Tracef(unsafe.Pointer(g.p_delete_cookies_callback), "T5463:")
		BaseRelease(g.p_delete_cookies_callback)
	})
	return &go_delete_cookies_callback
}

// *C.cef_delete_cookies_callback_t has refCounted interface
func (delete_cookies_callback *CDeleteCookiesCallbackT) HasOneRef() bool {
	return BaseHasOneRef(delete_cookies_callback.p_delete_cookies_callback)
}

func (p *C.cef_delete_cookies_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called upon completion. |num_deleted| will be the
// number of cookies that were deleted.
///
type CDeleteCookiesCallbackTOnCompleteHandler interface {
	OnComplete(
		self *CDeleteCookiesCallbackT,
		num_deleted int,
	)
}

var delete_cookies_callback_handlers = struct {
	on_complete_handler map[*C.cef_delete_cookies_callback_t]CDeleteCookiesCallbackTOnCompleteHandler
}{
	map[*C.cef_delete_cookies_callback_t]CDeleteCookiesCallbackTOnCompleteHandler{},
}

// AllocCDeleteCookiesCallbackT allocates CDeleteCookiesCallbackT and construct it
func AllocCDeleteCookiesCallbackT() *CDeleteCookiesCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_delete_cookies_callback_wrapper_t, "T5497:")
	cefp := C.cefingo_construct_delete_cookies_callback((*C.cefingo_delete_cookies_callback_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_delete_cookies_callback_t itself in DeassocFunc,
		// or cef_delete_cookies_callback_t is never GCed.
		Tracef(up, "T5503:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(delete_cookies_callback_handlers.on_complete_handler, cefp)
	}))

	return newCDeleteCookiesCallbackT(cefp)
}

func (delete_cookies_callback *CDeleteCookiesCallbackT) Bind(a interface{}) *CDeleteCookiesCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := delete_cookies_callback.p_delete_cookies_callback

	if h, ok := a.(CDeleteCookiesCallbackTOnCompleteHandler); ok {
		delete_cookies_callback_handlers.on_complete_handler[cp] = h
	}

	if accessor, ok := a.(CDeleteCookiesCallbackTAccessor); ok {
		accessor.SetCDeleteCookiesCallbackT(delete_cookies_callback)
		Logf("T5537:")
	}

	return delete_cookies_callback
}

// cef_devtools_message_observer_capi.h, include/capi/cef_devtools_message_observer_capi.h:141:3,

///
// Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The
// functions of this structure will be called on the browser process UI thread.
///

// Go type for cef_dev_tools_message_observer_t
type CDevToolsMessageObserverT struct {
	noCopy                       noCopy
	p_dev_tools_message_observer *C.cef_dev_tools_message_observer_t
}

type RefToCDevToolsMessageObserverT struct {
	p_dev_tools_message_observer *CDevToolsMessageObserverT
}

type CDevToolsMessageObserverTAccessor interface {
	GetCDevToolsMessageObserverT() *CDevToolsMessageObserverT
	SetCDevToolsMessageObserverT(*CDevToolsMessageObserverT)
}

func (r RefToCDevToolsMessageObserverT) GetCDevToolsMessageObserverT() *CDevToolsMessageObserverT {
	return r.p_dev_tools_message_observer
}

func (r *RefToCDevToolsMessageObserverT) SetCDevToolsMessageObserverT(p *CDevToolsMessageObserverT) {
	r.p_dev_tools_message_observer = p
}

// Go type CDevToolsMessageObserverT wraps cef type *C.cef_dev_tools_message_observer_t
func newCDevToolsMessageObserverT(p *C.cef_dev_tools_message_observer_t) *CDevToolsMessageObserverT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5565:")
	BaseAddRef(p)
	go_dev_tools_message_observer := CDevToolsMessageObserverT{noCopy{}, p}
	runtime.SetFinalizer(&go_dev_tools_message_observer, func(g *CDevToolsMessageObserverT) {
		Tracef(unsafe.Pointer(g.p_dev_tools_message_observer), "T5569:")
		BaseRelease(g.p_dev_tools_message_observer)
	})
	return &go_dev_tools_message_observer
}

// *C.cef_dev_tools_message_observer_t has refCounted interface
func (dev_tools_message_observer *CDevToolsMessageObserverT) HasOneRef() bool {
	return BaseHasOneRef(dev_tools_message_observer.p_dev_tools_message_observer)
}

func (p *C.cef_dev_tools_message_observer_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called on receipt of a DevTools protocol message.
// |browser| is the originating browser instance. |message| is a UTF8-encoded
// JSON dictionary representing either a function result or an event.
// |message| is only valid for the scope of this callback and should be copied
// if necessary. Return true (1) if the message was handled or false (0) if
// the message should be further processed and passed to the
// OnDevToolsMethodResult or OnDevToolsEvent functions as appropriate.
//
// Method result dictionaries include an &quot;id&quot; (int) value that identifies the
// orginating function call sent from cef_browser_host_t::SendDevToolsMessage,
// and optionally either a &quot;result&quot; (dictionary) or &quot;error&quot; (dictionary)
// value. The &quot;error&quot; dictionary will contain &quot;code&quot; (int) and &quot;message&quot;
// (string) values. Event dictionaries include a &quot;function&quot; (string) value and
// optionally a &quot;params&quot; (dictionary) value. See the DevTools protocol
// documentation at https://chromedevtools.github.io/devtools-protocol/ for
// details of supported function calls and the expected &quot;result&quot; or &quot;params&quot;
// dictionary contents. JSON dictionaries can be parsed using the CefParseJSON
// function if desired, however be aware of performance considerations when
// parsing large messages (some of which may exceed 1MB in size).
///
func (self *CDevToolsMessageObserverT) OnDevToolsMessage(
	browser *CBrowserT,
	message unsafe.Pointer,
	message_size int64,
) (ret bool) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		goTmpbrowser = browser.p_browser
		BaseAddRef(goTmpbrowser)
	}

	cRet := C.cefingo_dev_tools_message_observer_on_dev_tools_message(self.p_dev_tools_message_observer, goTmpbrowser, message, (C.size_t)(message_size))

	ret = cRet == 1
	return ret
}

///
// Method that will be called after attempted execution of a DevTools protocol
// function. |browser| is the originating browser instance. |message_id| is
// the &quot;id&quot; value that identifies the originating function call message. If
// the function succeeded |success| will be true (1) and |result| will be the
// UTF8-encoded JSON &quot;result&quot; dictionary value (which may be NULL). If the
// function failed |success| will be false (0) and |result| will be the
// UTF8-encoded JSON &quot;error&quot; dictionary value. |result| is only valid for the
// scope of this callback and should be copied if necessary. See the
// OnDevToolsMessage documentation for additional details on |result|
// contents.
///
func (self *CDevToolsMessageObserverT) OnDevToolsMethodResult(
	browser *CBrowserT,
	message_id int,
	success int,
	result unsafe.Pointer,
	result_size int64,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		goTmpbrowser = browser.p_browser
		BaseAddRef(goTmpbrowser)
	}

	C.cefingo_dev_tools_message_observer_on_dev_tools_method_result(self.p_dev_tools_message_observer, goTmpbrowser, (C.int)(message_id), (C.int)(success), result, (C.size_t)(result_size))

}

///
// Method that will be called on receipt of a DevTools protocol event.
// |browser| is the originating browser instance. |function| is the &quot;function&quot;
// value. |params| is the UTF8-encoded JSON &quot;params&quot; dictionary value (which
// may be NULL). |params| is only valid for the scope of this callback and
// should be copied if necessary. See the OnDevToolsMessage documentation for
// additional details on |params| contents.
///
func (self *CDevToolsMessageObserverT) OnDevToolsEvent(
	browser *CBrowserT,
	method string,
	params unsafe.Pointer,
	params_size int64,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		goTmpbrowser = browser.p_browser
		BaseAddRef(goTmpbrowser)
	}
	c_method := create_cef_string(method)
	defer clear_cef_string(c_method)

	C.cefingo_dev_tools_message_observer_on_dev_tools_event(self.p_dev_tools_message_observer, goTmpbrowser, (*C.cef_string_t)(c_method), params, (C.size_t)(params_size))

}

///
// Method that will be called when the DevTools agent has attached. |browser|
// is the originating browser instance. This will generally occur in response
// to the first message sent while the agent is detached.
///
func (self *CDevToolsMessageObserverT) OnDevToolsAgentAttached(
	browser *CBrowserT,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		goTmpbrowser = browser.p_browser
		BaseAddRef(goTmpbrowser)
	}

	C.cefingo_dev_tools_message_observer_on_dev_tools_agent_attached(self.p_dev_tools_message_observer, goTmpbrowser)

}

///
// Method that will be called when the DevTools agent has detached. |browser|
// is the originating browser instance. Any function results that were pending
// before the agent became detached will not be delivered, and any active
// event subscriptions will be canceled.
///
func (self *CDevToolsMessageObserverT) OnDevToolsAgentDetached(
	browser *CBrowserT,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		goTmpbrowser = browser.p_browser
		BaseAddRef(goTmpbrowser)
	}

	C.cefingo_dev_tools_message_observer_on_dev_tools_agent_detached(self.p_dev_tools_message_observer, goTmpbrowser)

}

// cef_dialog_handler_capi.h, include/capi/cef_dialog_handler_capi.h:74:3,

///
// Callback structure for asynchronous continuation of file dialog requests.
///

// Go type for cef_file_dialog_callback_t
type CFileDialogCallbackT struct {
	noCopy                 noCopy
	p_file_dialog_callback *C.cef_file_dialog_callback_t
}

type RefToCFileDialogCallbackT struct {
	p_file_dialog_callback *CFileDialogCallbackT
}

type CFileDialogCallbackTAccessor interface {
	GetCFileDialogCallbackT() *CFileDialogCallbackT
	SetCFileDialogCallbackT(*CFileDialogCallbackT)
}

func (r RefToCFileDialogCallbackT) GetCFileDialogCallbackT() *CFileDialogCallbackT {
	return r.p_file_dialog_callback
}

func (r *RefToCFileDialogCallbackT) SetCFileDialogCallbackT(p *CFileDialogCallbackT) {
	r.p_file_dialog_callback = p
}

// Go type CFileDialogCallbackT wraps cef type *C.cef_file_dialog_callback_t
func newCFileDialogCallbackT(p *C.cef_file_dialog_callback_t) *CFileDialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5752:")
	BaseAddRef(p)
	go_file_dialog_callback := CFileDialogCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_file_dialog_callback, func(g *CFileDialogCallbackT) {
		Tracef(unsafe.Pointer(g.p_file_dialog_callback), "T5756:")
		BaseRelease(g.p_file_dialog_callback)
	})
	return &go_file_dialog_callback
}

// *C.cef_file_dialog_callback_t has refCounted interface
func (file_dialog_callback *CFileDialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(file_dialog_callback.p_file_dialog_callback)
}

func (p *C.cef_file_dialog_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Continue the file selection. |selected_accept_filter| should be the 0-based
// index of the value selected from the accept filters array passed to
// cef_dialog_handler_t::OnFileDialog. |file_paths| should be a single value
// or a list of values depending on the dialog mode. An NULL |file_paths|
// value is treated the same as calling cancel().
///
func (self *CFileDialogCallbackT) Cont(
	selected_accept_filter int,
	file_paths CStringListT,
) {

	C.cefingo_file_dialog_callback_cont(self.p_file_dialog_callback, (C.int)(selected_accept_filter), (C.cef_string_list_t)(file_paths))

}

///
// Cancel the file selection.
///
func (self *CFileDialogCallbackT) Cancel() {

	C.cefingo_file_dialog_callback_cancel(self.p_file_dialog_callback)

}

///
// Implement this structure to handle dialog events. The functions of this
// structure will be called on the browser process UI thread.
///

// Go type for cef_dialog_handler_t
type CDialogHandlerT struct {
	noCopy           noCopy
	p_dialog_handler *C.cef_dialog_handler_t
}

type RefToCDialogHandlerT struct {
	p_dialog_handler *CDialogHandlerT
}

type CDialogHandlerTAccessor interface {
	GetCDialogHandlerT() *CDialogHandlerT
	SetCDialogHandlerT(*CDialogHandlerT)
}

func (r RefToCDialogHandlerT) GetCDialogHandlerT() *CDialogHandlerT {
	return r.p_dialog_handler
}

func (r *RefToCDialogHandlerT) SetCDialogHandlerT(p *CDialogHandlerT) {
	r.p_dialog_handler = p
}

// Go type CDialogHandlerT wraps cef type *C.cef_dialog_handler_t
func newCDialogHandlerT(p *C.cef_dialog_handler_t) *CDialogHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5831:")
	BaseAddRef(p)
	go_dialog_handler := CDialogHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_dialog_handler, func(g *CDialogHandlerT) {
		Tracef(unsafe.Pointer(g.p_dialog_handler), "T5835:")
		BaseRelease(g.p_dialog_handler)
	})
	return &go_dialog_handler
}

// *C.cef_dialog_handler_t has refCounted interface
func (dialog_handler *CDialogHandlerT) HasOneRef() bool {
	return BaseHasOneRef(dialog_handler.p_dialog_handler)
}

func (p *C.cef_dialog_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called to run a file chooser dialog. |mode| represents the type of dialog
// to display. |title| to the title to be used for the dialog and may be NULL
// to show the default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode).
// |default_file_path| is the path with optional directory and/or file name
// component that should be initially selected in the dialog. |accept_filters|
// are used to restrict the selectable file types and may any combination of
// (a) valid lower-cased MIME types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b)
// individual file extensions (e.g. &quot;.txt&quot; or &quot;.png&quot;), or (c) combined
// description and file extension delimited using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image
// Types|.png;.gif;.jpg&quot;). |selected_accept_filter| is the 0-based index of
// the filter that should be selected by default. To display a custom dialog
// return true (1) and execute |callback| either inline or at a later time. To
// display the default dialog return false (0).
///
type OnFileDialogHandler interface {
	OnFileDialog(
		self *CDialogHandlerT,
		browser *CBrowserT,
		mode CFileDialogModeT,
		title string,
		default_file_path string,
		accept_filters CStringListT,
		selected_accept_filter int,
		callback *CFileDialogCallbackT,
	) (ret bool)
}

var dialog_handler_handlers = struct {
	on_file_dialog_handler map[*C.cef_dialog_handler_t]OnFileDialogHandler
}{
	map[*C.cef_dialog_handler_t]OnFileDialogHandler{},
}

// AllocCDialogHandlerT allocates CDialogHandlerT and construct it
func AllocCDialogHandlerT() *CDialogHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_dialog_handler_wrapper_t, "T5886:")
	cefp := C.cefingo_construct_dialog_handler((*C.cefingo_dialog_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_dialog_handler_t itself in DeassocFunc,
		// or cef_dialog_handler_t is never GCed.
		Tracef(up, "T5892:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(dialog_handler_handlers.on_file_dialog_handler, cefp)
	}))

	return newCDialogHandlerT(cefp)
}

func (dialog_handler *CDialogHandlerT) Bind(a interface{}) *CDialogHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := dialog_handler.p_dialog_handler

	if h, ok := a.(OnFileDialogHandler); ok {
		dialog_handler_handlers.on_file_dialog_handler[cp] = h
	}

	if accessor, ok := a.(CDialogHandlerTAccessor); ok {
		accessor.SetCDialogHandlerT(dialog_handler)
		Logf("T5926:")
	}

	return dialog_handler
}

// cef_display_capi.h, include/capi/views/cef_display_capi.h:105:3,

///
// This structure typically, but not always, corresponds to a physical display
// connected to the system. A fake Display may exist on a headless system, or a
// Display may correspond to a remote, virtual display. All size and position
// values are in density independent pixels (DIP) unless otherwise indicated.
// Methods must be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_display_t
type CDisplayT struct {
	noCopy    noCopy
	p_display *C.cef_display_t
}

type RefToCDisplayT struct {
	p_display *CDisplayT
}

type CDisplayTAccessor interface {
	GetCDisplayT() *CDisplayT
	SetCDisplayT(*CDisplayT)
}

func (r RefToCDisplayT) GetCDisplayT() *CDisplayT {
	return r.p_display
}

func (r *RefToCDisplayT) SetCDisplayT(p *CDisplayT) {
	r.p_display = p
}

// Go type CDisplayT wraps cef type *C.cef_display_t
func newCDisplayT(p *C.cef_display_t) *CDisplayT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T5958:")
	BaseAddRef(p)
	go_display := CDisplayT{noCopy{}, p}
	runtime.SetFinalizer(&go_display, func(g *CDisplayT) {
		Tracef(unsafe.Pointer(g.p_display), "T5962:")
		BaseRelease(g.p_display)
	})
	return &go_display
}

// *C.cef_display_t has refCounted interface
func (display *CDisplayT) HasOneRef() bool {
	return BaseHasOneRef(display.p_display)
}

func (p *C.cef_display_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the unique identifier for this Display.
///
func (self *CDisplayT) GetId() (ret int64) {

	cRet := C.cefingo_display_get_id(self.p_display)

	ret = (int64)(cRet)
	return ret
}

///
// Returns this Display&#39;s device pixel scale factor. This specifies how much
// the UI should be scaled when the actual output has more pixels than
// standard displays (which is around 100~120dpi). The potential return values
// differ by platform.
///
func (self *CDisplayT) GetDeviceScaleFactor() (ret float32) {

	cRet := C.cefingo_display_get_device_scale_factor(self.p_display)

	ret = (float32)(cRet)
	return ret
}

///
// Convert |point| from density independent pixels (DIP) to pixel coordinates
// using this Display&#39;s device scale factor.
///
func (self *CDisplayT) ConvertPointToPixels(
	point *CPointT,
) {

	C.cefingo_display_convert_point_to_pixels(self.p_display, (*C.cef_point_t)(point))

}

///
// Convert |point| from pixel coordinates to density independent pixels (DIP)
// using this Display&#39;s device scale factor.
///
func (self *CDisplayT) ConvertPointFromPixels(
	point *CPointT,
) {

	C.cefingo_display_convert_point_from_pixels(self.p_display, (*C.cef_point_t)(point))

}

///
// Returns this Display&#39;s bounds. This is the full size of the display.
///
func (self *CDisplayT) GetBounds() (ret CRectT) {

	cRet := C.cefingo_display_get_bounds(self.p_display)

	ret = (CRectT)(cRet)
	return ret
}

///
// Returns this Display&#39;s work area. This excludes areas of the display that
// are occupied for window manager toolbars, etc.
///
func (self *CDisplayT) GetWorkArea() (ret CRectT) {

	cRet := C.cefingo_display_get_work_area(self.p_display)

	ret = (CRectT)(cRet)
	return ret
}

///
// Returns this Display&#39;s rotation in degrees.
///
func (self *CDisplayT) GetRotation() (ret bool) {

	cRet := C.cefingo_display_get_rotation(self.p_display)

	ret = cRet == 1
	return ret
}

///
// Returns the primary Display.
///
func DisplayGetPrimary() (ret *CDisplayT) {

	cRet := C.cef_display_get_primary()

	ret = newCDisplayT(cRet)
	return ret
}

///
// Returns the Display nearest |point|. Set |input_pixel_coords| to true (1) if
// |point| is in pixel coordinates instead of density independent pixels (DIP).
///
func DisplayGetNearestPoint(
	point *CPointT,
	input_pixel_coords int,
) (ret *CDisplayT) {

	cRet := C.cef_display_get_nearest_point((*C.cef_point_t)(point), (C.int)(input_pixel_coords))

	ret = newCDisplayT(cRet)
	return ret
}

///
// Returns the Display that most closely intersects |bounds|.  Set
// |input_pixel_coords| to true (1) if |bounds| is in pixel coordinates instead
// of density independent pixels (DIP).
///
func DisplayGetMatchingBounds(
	bounds *CRectT,
	input_pixel_coords int,
) (ret *CDisplayT) {

	cRet := C.cef_display_get_matching_bounds((*C.cef_rect_t)(bounds), (C.int)(input_pixel_coords))

	ret = newCDisplayT(cRet)
	return ret
}

///
// Returns the total number of Displays. Mirrored displays are excluded; this
// function is intended to return the number of distinct, usable displays.
///
func DisplayGetCount() (ret int64) {

	cRet := C.cef_display_get_count()

	ret = (int64)(cRet)
	return ret
}

///
// Returns all Displays. Mirrored displays are excluded; this function is
// intended to return distinct, usable displays.
///
func DisplayGetAlls() (displays []*CDisplayT) {
	var _displaysCount C.size_t
	displaysCount := &_displaysCount
	var tmpdisplays *C.cef_display_t

	C.cef_display_get_alls((*C.size_t)(displaysCount), &tmpdisplays)

	displays = make([]*CDisplayT, *displaysCount)
	_tmpdisplays := (*[1 << 30](*C.cef_display_t))(unsafe.Pointer(tmpdisplays))[:*displaysCount:*displaysCount]
	for i := C.size_t(0); i < *displaysCount; i++ {
		displays[i] = newCDisplayT(_tmpdisplays[i])
	}
	return displays
}

// cef_display_handler_capi.h, include/capi/cef_display_handler_capi.h:144:3,

///
// Implement this structure to handle events related to browser display state.
// The functions of this structure will be called on the UI thread.
///

// Go type for cef_display_handler_t
type CDisplayHandlerT struct {
	noCopy            noCopy
	p_display_handler *C.cef_display_handler_t
}

type RefToCDisplayHandlerT struct {
	p_display_handler *CDisplayHandlerT
}

type CDisplayHandlerTAccessor interface {
	GetCDisplayHandlerT() *CDisplayHandlerT
	SetCDisplayHandlerT(*CDisplayHandlerT)
}

func (r RefToCDisplayHandlerT) GetCDisplayHandlerT() *CDisplayHandlerT {
	return r.p_display_handler
}

func (r *RefToCDisplayHandlerT) SetCDisplayHandlerT(p *CDisplayHandlerT) {
	r.p_display_handler = p
}

// Go type CDisplayHandlerT wraps cef type *C.cef_display_handler_t
func newCDisplayHandlerT(p *C.cef_display_handler_t) *CDisplayHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T6186:")
	BaseAddRef(p)
	go_display_handler := CDisplayHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_display_handler, func(g *CDisplayHandlerT) {
		Tracef(unsafe.Pointer(g.p_display_handler), "T6190:")
		BaseRelease(g.p_display_handler)
	})
	return &go_display_handler
}

// *C.cef_display_handler_t has refCounted interface
func (display_handler *CDisplayHandlerT) HasOneRef() bool {
	return BaseHasOneRef(display_handler.p_display_handler)
}

func (p *C.cef_display_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called when a frame&#39;s address has changed.
///
type OnAddressChangeHandler interface {
	OnAddressChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		url string,
	)
}

///
// Called when the page title changes.
///
type OnTitleChangeHandler interface {
	OnTitleChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		title string,
	)
}

///
// Called when the page icon changes.
///
type OnFaviconUrlchangeHandler interface {
	OnFaviconUrlchange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		icon_urls CStringListT,
	)
}

///
// Called when web content in the page has toggled fullscreen mode. If
// |fullscreen| is true (1) the content will automatically be sized to fill
// the browser content area. If |fullscreen| is false (0) the content will
// automatically return to its original size and position. The client is
// responsible for resizing the browser if desired.
///
type OnFullscreenModeChangeHandler interface {
	OnFullscreenModeChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		fullscreen int,
	)
}

///
// Called when the browser is about to display a tooltip. |text| contains the
// text that will be displayed in the tooltip. To handle the display of the
// tooltip yourself return true (1). Otherwise, you can optionally modify
// |text| and then return false (0) to allow the browser to display the
// tooltip. When window rendering is disabled the application is responsible
// for drawing tooltips and the return value is ignored.
///
type OnTooltipHandler interface {
	OnTooltip(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		text string,
	) (ret bool, textOut string)
}

///
// Called when the browser receives a status message. |value| contains the
// text that will be displayed in the status message.
///
type OnStatusMessageHandler interface {
	OnStatusMessage(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		value string,
	)
}

///
// Called to display a console message. Return true (1) to stop the message
// from being output to the console.
///
type OnConsoleMessageHandler interface {
	OnConsoleMessage(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		level CLogSeverityT,
		message string,
		source string,
		line int,
	) (ret bool)
}

///
// Called when auto-resize is enabled via
// cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-
// resized. |new_size| will be the desired size in view coordinates. Return
// true (1) if the resize was handled or false (0) for default handling.
///
type OnAutoResizeHandler interface {
	OnAutoResize(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		new_size *CSizeT,
	) (ret bool)
}

///
// Called when the overall page loading progress has changed. |progress|
// ranges from 0.0 to 1.0.
///
type OnLoadingProgressChangeHandler interface {
	OnLoadingProgressChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		progress float64,
	)
}

var display_handler_handlers = struct {
	on_address_change_handler          map[*C.cef_display_handler_t]OnAddressChangeHandler
	on_title_change_handler            map[*C.cef_display_handler_t]OnTitleChangeHandler
	on_favicon_urlchange_handler       map[*C.cef_display_handler_t]OnFaviconUrlchangeHandler
	on_fullscreen_mode_change_handler  map[*C.cef_display_handler_t]OnFullscreenModeChangeHandler
	on_tooltip_handler                 map[*C.cef_display_handler_t]OnTooltipHandler
	on_status_message_handler          map[*C.cef_display_handler_t]OnStatusMessageHandler
	on_console_message_handler         map[*C.cef_display_handler_t]OnConsoleMessageHandler
	on_auto_resize_handler             map[*C.cef_display_handler_t]OnAutoResizeHandler
	on_loading_progress_change_handler map[*C.cef_display_handler_t]OnLoadingProgressChangeHandler
}{
	map[*C.cef_display_handler_t]OnAddressChangeHandler{},
	map[*C.cef_display_handler_t]OnTitleChangeHandler{},
	map[*C.cef_display_handler_t]OnFaviconUrlchangeHandler{},
	map[*C.cef_display_handler_t]OnFullscreenModeChangeHandler{},
	map[*C.cef_display_handler_t]OnTooltipHandler{},
	map[*C.cef_display_handler_t]OnStatusMessageHandler{},
	map[*C.cef_display_handler_t]OnConsoleMessageHandler{},
	map[*C.cef_display_handler_t]OnAutoResizeHandler{},
	map[*C.cef_display_handler_t]OnLoadingProgressChangeHandler{},
}

// AllocCDisplayHandlerT allocates CDisplayHandlerT and construct it
func AllocCDisplayHandlerT() *CDisplayHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_display_handler_wrapper_t, "T6347:")
	cefp := C.cefingo_construct_display_handler((*C.cefingo_display_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_display_handler_t itself in DeassocFunc,
		// or cef_display_handler_t is never GCed.
		Tracef(up, "T6353:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(display_handler_handlers.on_address_change_handler, cefp)
		delete(display_handler_handlers.on_title_change_handler, cefp)
		delete(display_handler_handlers.on_favicon_urlchange_handler, cefp)
		delete(display_handler_handlers.on_fullscreen_mode_change_handler, cefp)
		delete(display_handler_handlers.on_tooltip_handler, cefp)
		delete(display_handler_handlers.on_status_message_handler, cefp)
		delete(display_handler_handlers.on_console_message_handler, cefp)
		delete(display_handler_handlers.on_auto_resize_handler, cefp)
		delete(display_handler_handlers.on_loading_progress_change_handler, cefp)
	}))

	return newCDisplayHandlerT(cefp)
}

func (display_handler *CDisplayHandlerT) Bind(a interface{}) *CDisplayHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := display_handler.p_display_handler

	if h, ok := a.(OnAddressChangeHandler); ok {
		display_handler_handlers.on_address_change_handler[cp] = h
	}

	if h, ok := a.(OnTitleChangeHandler); ok {
		display_handler_handlers.on_title_change_handler[cp] = h
	}

	if h, ok := a.(OnFaviconUrlchangeHandler); ok {
		display_handler_handlers.on_favicon_urlchange_handler[cp] = h
	}

	if h, ok := a.(OnFullscreenModeChangeHandler); ok {
		display_handler_handlers.on_fullscreen_mode_change_handler[cp] = h
	}

	if h, ok := a.(OnTooltipHandler); ok {
		display_handler_handlers.on_tooltip_handler[cp] = h
	}

	if h, ok := a.(OnStatusMessageHandler); ok {
		display_handler_handlers.on_status_message_handler[cp] = h
	}

	if h, ok := a.(OnConsoleMessageHandler); ok {
		display_handler_handlers.on_console_message_handler[cp] = h
	}

	if h, ok := a.(OnAutoResizeHandler); ok {
		display_handler_handlers.on_auto_resize_handler[cp] = h
	}

	if h, ok := a.(OnLoadingProgressChangeHandler); ok {
		display_handler_handlers.on_loading_progress_change_handler[cp] = h
	}

	if accessor, ok := a.(CDisplayHandlerTAccessor); ok {
		accessor.SetCDisplayHandlerT(display_handler)
		Logf("T6427:")
	}

	return display_handler
}

// cef_dom_capi.h, include/capi/cef_dom_capi.h:71:3,

///
// Structure to implement for visiting the DOM. The functions of this structure
// will be called on the render process main thread.
///

// Go type for cef_domvisitor_t
type CDomvisitorT struct {
	noCopy       noCopy
	p_domvisitor *C.cef_domvisitor_t
}

type RefToCDomvisitorT struct {
	p_domvisitor *CDomvisitorT
}

type CDomvisitorTAccessor interface {
	GetCDomvisitorT() *CDomvisitorT
	SetCDomvisitorT(*CDomvisitorT)
}

func (r RefToCDomvisitorT) GetCDomvisitorT() *CDomvisitorT {
	return r.p_domvisitor
}

func (r *RefToCDomvisitorT) SetCDomvisitorT(p *CDomvisitorT) {
	r.p_domvisitor = p
}

// Go type CDomvisitorT wraps cef type *C.cef_domvisitor_t
func newCDomvisitorT(p *C.cef_domvisitor_t) *CDomvisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T6455:")
	BaseAddRef(p)
	go_domvisitor := CDomvisitorT{noCopy{}, p}
	runtime.SetFinalizer(&go_domvisitor, func(g *CDomvisitorT) {
		Tracef(unsafe.Pointer(g.p_domvisitor), "T6459:")
		BaseRelease(g.p_domvisitor)
	})
	return &go_domvisitor
}

// *C.cef_domvisitor_t has refCounted interface
func (domvisitor *CDomvisitorT) HasOneRef() bool {
	return BaseHasOneRef(domvisitor.p_domvisitor)
}

func (p *C.cef_domvisitor_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method executed for visiting the DOM. The document object passed to this
// function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
type CDomvisitorTVisitHandler interface {
	Visit(
		self *CDomvisitorT,
		document *CDomdocumentT,
	)
}

var domvisitor_handlers = struct {
	visit_handler map[*C.cef_domvisitor_t]CDomvisitorTVisitHandler
}{
	map[*C.cef_domvisitor_t]CDomvisitorTVisitHandler{},
}

// AllocCDomvisitorT allocates CDomvisitorT and construct it
func AllocCDomvisitorT() *CDomvisitorT {
	up := c_calloc(1, C.sizeof_cefingo_domvisitor_wrapper_t, "T6496:")
	cefp := C.cefingo_construct_domvisitor((*C.cefingo_domvisitor_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_domvisitor_t itself in DeassocFunc,
		// or cef_domvisitor_t is never GCed.
		Tracef(up, "T6502:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(domvisitor_handlers.visit_handler, cefp)
	}))

	return newCDomvisitorT(cefp)
}

func (domvisitor *CDomvisitorT) Bind(a interface{}) *CDomvisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := domvisitor.p_domvisitor

	if h, ok := a.(CDomvisitorTVisitHandler); ok {
		domvisitor_handlers.visit_handler[cp] = h
	}

	if accessor, ok := a.(CDomvisitorTAccessor); ok {
		accessor.SetCDomvisitorT(domvisitor)
		Logf("T6536:")
	}

	return domvisitor
}

///
// Structure used to represent a DOM document. The functions of this structure
// should only be called on the render process main thread thread.
///

// Go type for cef_domdocument_t
type CDomdocumentT struct {
	noCopy        noCopy
	p_domdocument *C.cef_domdocument_t
}

type RefToCDomdocumentT struct {
	p_domdocument *CDomdocumentT
}

type CDomdocumentTAccessor interface {
	GetCDomdocumentT() *CDomdocumentT
	SetCDomdocumentT(*CDomdocumentT)
}

func (r RefToCDomdocumentT) GetCDomdocumentT() *CDomdocumentT {
	return r.p_domdocument
}

func (r *RefToCDomdocumentT) SetCDomdocumentT(p *CDomdocumentT) {
	r.p_domdocument = p
}

// Go type CDomdocumentT wraps cef type *C.cef_domdocument_t
func newCDomdocumentT(p *C.cef_domdocument_t) *CDomdocumentT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T6562:")
	BaseAddRef(p)
	go_domdocument := CDomdocumentT{noCopy{}, p}
	runtime.SetFinalizer(&go_domdocument, func(g *CDomdocumentT) {
		Tracef(unsafe.Pointer(g.p_domdocument), "T6566:")
		BaseRelease(g.p_domdocument)
	})
	return &go_domdocument
}

// *C.cef_domdocument_t has refCounted interface
func (domdocument *CDomdocumentT) HasOneRef() bool {
	return BaseHasOneRef(domdocument.p_domdocument)
}

func (p *C.cef_domdocument_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the document type.
///
func (self *CDomdocumentT) GetType() (ret CDomDocumentTypeT) {

	cRet := C.cefingo_domdocument_get_type(self.p_domdocument)

	ret = CDomDocumentTypeT(cRet)
	return ret
}

///
// Returns the root document node.
///
func (self *CDomdocumentT) GetDocument() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_document(self.p_domdocument)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the BODY node of an HTML document.
///
func (self *CDomdocumentT) GetBody() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_body(self.p_domdocument)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the HEAD node of an HTML document.
///
func (self *CDomdocumentT) GetHead() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_head(self.p_domdocument)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the title of an HTML document.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetTitle() (ret string) {

	cRet := C.cefingo_domdocument_get_title(self.p_domdocument)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the document element with the specified ID value.
///
func (self *CDomdocumentT) GetElementById(
	id string,
) (ret *CDomnodeT) {
	c_id := create_cef_string(id)
	defer clear_cef_string(c_id)

	cRet := C.cefingo_domdocument_get_element_by_id(self.p_domdocument, (*C.cef_string_t)(c_id))

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the node that currently has keyboard focus.
///
func (self *CDomdocumentT) GetFocusedNode() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_focused_node(self.p_domdocument)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns true (1) if a portion of the document is selected.
///
func (self *CDomdocumentT) HasSelection() (ret bool) {

	cRet := C.cefingo_domdocument_has_selection(self.p_domdocument)

	ret = cRet == 1
	return ret
}

///
// Returns the selection offset within the start node.
///
func (self *CDomdocumentT) GetSelectionStartOffset() (ret bool) {

	cRet := C.cefingo_domdocument_get_selection_start_offset(self.p_domdocument)

	ret = cRet == 1
	return ret
}

///
// Returns the selection offset within the end node.
///
func (self *CDomdocumentT) GetSelectionEndOffset() (ret bool) {

	cRet := C.cefingo_domdocument_get_selection_end_offset(self.p_domdocument)

	ret = cRet == 1
	return ret
}

///
// Returns the contents of this selection as markup.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetSelectionAsMarkup() (ret string) {

	cRet := C.cefingo_domdocument_get_selection_as_markup(self.p_domdocument)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the contents of this selection as text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetSelectionAsText() (ret string) {

	cRet := C.cefingo_domdocument_get_selection_as_text(self.p_domdocument)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the base URL for the document.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetBaseUrl() (ret string) {

	cRet := C.cefingo_domdocument_get_base_url(self.p_domdocument)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a complete URL based on the document base URL and the specified
// partial URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetCompleteUrl(
	partialURL string,
) (ret string) {
	c_partialURL := create_cef_string(partialURL)
	defer clear_cef_string(c_partialURL)

	cRet := C.cefingo_domdocument_get_complete_url(self.p_domdocument, (*C.cef_string_t)(c_partialURL))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Structure used to represent a DOM node. The functions of this structure
// should only be called on the render process main thread.
///

// Go type for cef_domnode_t
type CDomnodeT struct {
	noCopy    noCopy
	p_domnode *C.cef_domnode_t
}

type RefToCDomnodeT struct {
	p_domnode *CDomnodeT
}

type CDomnodeTAccessor interface {
	GetCDomnodeT() *CDomnodeT
	SetCDomnodeT(*CDomnodeT)
}

func (r RefToCDomnodeT) GetCDomnodeT() *CDomnodeT {
	return r.p_domnode
}

func (r *RefToCDomnodeT) SetCDomnodeT(p *CDomnodeT) {
	r.p_domnode = p
}

// Go type CDomnodeT wraps cef type *C.cef_domnode_t
func newCDomnodeT(p *C.cef_domnode_t) *CDomnodeT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T6827:")
	BaseAddRef(p)
	go_domnode := CDomnodeT{noCopy{}, p}
	runtime.SetFinalizer(&go_domnode, func(g *CDomnodeT) {
		Tracef(unsafe.Pointer(g.p_domnode), "T6831:")
		BaseRelease(g.p_domnode)
	})
	return &go_domnode
}

// *C.cef_domnode_t has refCounted interface
func (domnode *CDomnodeT) HasOneRef() bool {
	return BaseHasOneRef(domnode.p_domnode)
}

func (p *C.cef_domnode_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the type for this node.
///
func (self *CDomnodeT) GetType() (ret CDomNodeTypeT) {

	cRet := C.cefingo_domnode_get_type(self.p_domnode)

	ret = CDomNodeTypeT(cRet)
	return ret
}

///
// Returns true (1) if this is a text node.
///
func (self *CDomnodeT) IsText() (ret bool) {

	cRet := C.cefingo_domnode_is_text(self.p_domnode)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is an element node.
///
func (self *CDomnodeT) IsElement() (ret bool) {

	cRet := C.cefingo_domnode_is_element(self.p_domnode)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is an editable node.
///
func (self *CDomnodeT) IsEditable() (ret bool) {

	cRet := C.cefingo_domnode_is_editable(self.p_domnode)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is a form control element node.
///
func (self *CDomnodeT) IsFormControlElement() (ret bool) {

	cRet := C.cefingo_domnode_is_form_control_element(self.p_domnode)

	ret = cRet == 1
	return ret
}

///
// Returns the type of this form control element node.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetFormControlElementType() (ret string) {

	cRet := C.cefingo_domnode_get_form_control_element_type(self.p_domnode)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CDomnodeT) IsSame(
	that *CDomnodeT,
) (ret bool) {
	var goTmpthat *C.cef_domnode_t
	if that != nil {
		goTmpthat = that.p_domnode
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_domnode_is_same(self.p_domnode, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns the name of this node.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetName() (ret string) {

	cRet := C.cefingo_domnode_get_name(self.p_domnode)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the value of this node.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetValue() (ret string) {

	cRet := C.cefingo_domnode_get_value(self.p_domnode)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the value of this node. Returns true (1) on success.
///
func (self *CDomnodeT) SetValue(
	value string,
) (ret bool) {
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	cRet := C.cefingo_domnode_set_value(self.p_domnode, (*C.cef_string_t)(c_value))

	ret = cRet == 1
	return ret
}

///
// Returns the contents of this node as markup.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetAsMarkup() (ret string) {

	cRet := C.cefingo_domnode_get_as_markup(self.p_domnode)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the document associated with this node.
///
func (self *CDomnodeT) GetDocument() (ret *CDomdocumentT) {

	cRet := C.cefingo_domnode_get_document(self.p_domnode)

	ret = newCDomdocumentT(cRet)
	return ret
}

///
// Returns the parent node.
///
func (self *CDomnodeT) GetParent() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_parent(self.p_domnode)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the previous sibling node.
///
func (self *CDomnodeT) GetPreviousSibling() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_previous_sibling(self.p_domnode)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the next sibling node.
///
func (self *CDomnodeT) GetNextSibling() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_next_sibling(self.p_domnode)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns true (1) if this node has child nodes.
///
func (self *CDomnodeT) HasChildren() (ret bool) {

	cRet := C.cefingo_domnode_has_children(self.p_domnode)

	ret = cRet == 1
	return ret
}

///
// Return the first child node.
///
func (self *CDomnodeT) GetFirstChild() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_first_child(self.p_domnode)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the last child node.
///
func (self *CDomnodeT) GetLastChild() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_last_child(self.p_domnode)

	ret = newCDomnodeT(cRet)
	return ret
}

///
// Returns the tag name of this element.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetElementTagName() (ret string) {

	cRet := C.cefingo_domnode_get_element_tag_name(self.p_domnode)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this element has attributes.
///
func (self *CDomnodeT) HasElementAttributes() (ret bool) {

	cRet := C.cefingo_domnode_has_element_attributes(self.p_domnode)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this element has an attribute named |attrName|.
///
func (self *CDomnodeT) HasElementAttribute(
	attrName string,
) (ret bool) {
	c_attrName := create_cef_string(attrName)
	defer clear_cef_string(c_attrName)

	cRet := C.cefingo_domnode_has_element_attribute(self.p_domnode, (*C.cef_string_t)(c_attrName))

	ret = cRet == 1
	return ret
}

///
// Returns the element attribute named |attrName|.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetElementAttribute(
	attrName string,
) (ret string) {
	c_attrName := create_cef_string(attrName)
	defer clear_cef_string(c_attrName)

	cRet := C.cefingo_domnode_get_element_attribute(self.p_domnode, (*C.cef_string_t)(c_attrName))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a map of all element attributes.
///
func (self *CDomnodeT) GetElementAttributes(
	attrMap CStringMapT,
) {

	C.cefingo_domnode_get_element_attributes(self.p_domnode, (C.cef_string_map_t)(attrMap))

}

///
// Set the value for the element attribute named |attrName|. Returns true (1)
// on success.
///
func (self *CDomnodeT) SetElementAttribute(
	attrName string,
	value string,
) (ret bool) {
	c_attrName := create_cef_string(attrName)
	defer clear_cef_string(c_attrName)
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	cRet := C.cefingo_domnode_set_element_attribute(self.p_domnode, (*C.cef_string_t)(c_attrName), (*C.cef_string_t)(c_value))

	ret = cRet == 1
	return ret
}

///
// Returns the inner text of the element.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetElementInnerText() (ret string) {

	cRet := C.cefingo_domnode_get_element_inner_text(self.p_domnode)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the bounds of the element.
///
func (self *CDomnodeT) GetElementBounds() (ret CRectT) {

	cRet := C.cefingo_domnode_get_element_bounds(self.p_domnode)

	ret = (CRectT)(cRet)
	return ret
}

// cef_download_handler_capi.h, include/capi/cef_download_handler_capi.h:69:3,

///
// Callback structure used to asynchronously continue a download.
///

// Go type for cef_before_download_callback_t
type CBeforeDownloadCallbackT struct {
	noCopy                     noCopy
	p_before_download_callback *C.cef_before_download_callback_t
}

type RefToCBeforeDownloadCallbackT struct {
	p_before_download_callback *CBeforeDownloadCallbackT
}

type CBeforeDownloadCallbackTAccessor interface {
	GetCBeforeDownloadCallbackT() *CBeforeDownloadCallbackT
	SetCBeforeDownloadCallbackT(*CBeforeDownloadCallbackT)
}

func (r RefToCBeforeDownloadCallbackT) GetCBeforeDownloadCallbackT() *CBeforeDownloadCallbackT {
	return r.p_before_download_callback
}

func (r *RefToCBeforeDownloadCallbackT) SetCBeforeDownloadCallbackT(p *CBeforeDownloadCallbackT) {
	r.p_before_download_callback = p
}

// Go type CBeforeDownloadCallbackT wraps cef type *C.cef_before_download_callback_t
func newCBeforeDownloadCallbackT(p *C.cef_before_download_callback_t) *CBeforeDownloadCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T7274:")
	BaseAddRef(p)
	go_before_download_callback := CBeforeDownloadCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_before_download_callback, func(g *CBeforeDownloadCallbackT) {
		Tracef(unsafe.Pointer(g.p_before_download_callback), "T7278:")
		BaseRelease(g.p_before_download_callback)
	})
	return &go_before_download_callback
}

// *C.cef_before_download_callback_t has refCounted interface
func (before_download_callback *CBeforeDownloadCallbackT) HasOneRef() bool {
	return BaseHasOneRef(before_download_callback.p_before_download_callback)
}

func (p *C.cef_before_download_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Call to continue the download. Set |download_path| to the full file path
// for the download including the file name or leave blank to use the
// suggested name and the default temp directory. Set |show_dialog| to true
// (1) if you do wish to show the default &quot;Save As&quot; dialog.
///
func (self *CBeforeDownloadCallbackT) Cont(
	download_path string,
	show_dialog int,
) {
	c_download_path := create_cef_string(download_path)
	defer clear_cef_string(c_download_path)

	C.cefingo_before_download_callback_cont(self.p_before_download_callback, (*C.cef_string_t)(c_download_path), (C.int)(show_dialog))

}

///
// Callback structure used to asynchronously cancel a download.
///

// Go type for cef_download_item_callback_t
type CDownloadItemCallbackT struct {
	noCopy                   noCopy
	p_download_item_callback *C.cef_download_item_callback_t
}

type RefToCDownloadItemCallbackT struct {
	p_download_item_callback *CDownloadItemCallbackT
}

type CDownloadItemCallbackTAccessor interface {
	GetCDownloadItemCallbackT() *CDownloadItemCallbackT
	SetCDownloadItemCallbackT(*CDownloadItemCallbackT)
}

func (r RefToCDownloadItemCallbackT) GetCDownloadItemCallbackT() *CDownloadItemCallbackT {
	return r.p_download_item_callback
}

func (r *RefToCDownloadItemCallbackT) SetCDownloadItemCallbackT(p *CDownloadItemCallbackT) {
	r.p_download_item_callback = p
}

// Go type CDownloadItemCallbackT wraps cef type *C.cef_download_item_callback_t
func newCDownloadItemCallbackT(p *C.cef_download_item_callback_t) *CDownloadItemCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T7342:")
	BaseAddRef(p)
	go_download_item_callback := CDownloadItemCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_download_item_callback, func(g *CDownloadItemCallbackT) {
		Tracef(unsafe.Pointer(g.p_download_item_callback), "T7346:")
		BaseRelease(g.p_download_item_callback)
	})
	return &go_download_item_callback
}

// *C.cef_download_item_callback_t has refCounted interface
func (download_item_callback *CDownloadItemCallbackT) HasOneRef() bool {
	return BaseHasOneRef(download_item_callback.p_download_item_callback)
}

func (p *C.cef_download_item_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Call to cancel the download.
///
func (self *CDownloadItemCallbackT) Cancel() {

	C.cefingo_download_item_callback_cancel(self.p_download_item_callback)

}

///
// Call to pause the download.
///
func (self *CDownloadItemCallbackT) Pause() {

	C.cefingo_download_item_callback_pause(self.p_download_item_callback)

}

///
// Call to resume the download.
///
func (self *CDownloadItemCallbackT) Resume() {

	C.cefingo_download_item_callback_resume(self.p_download_item_callback)

}

///
// Structure used to handle file downloads. The functions of this structure will
// called on the browser process UI thread.
///

// Go type for cef_download_handler_t
type CDownloadHandlerT struct {
	noCopy             noCopy
	p_download_handler *C.cef_download_handler_t
}

type RefToCDownloadHandlerT struct {
	p_download_handler *CDownloadHandlerT
}

type CDownloadHandlerTAccessor interface {
	GetCDownloadHandlerT() *CDownloadHandlerT
	SetCDownloadHandlerT(*CDownloadHandlerT)
}

func (r RefToCDownloadHandlerT) GetCDownloadHandlerT() *CDownloadHandlerT {
	return r.p_download_handler
}

func (r *RefToCDownloadHandlerT) SetCDownloadHandlerT(p *CDownloadHandlerT) {
	r.p_download_handler = p
}

// Go type CDownloadHandlerT wraps cef type *C.cef_download_handler_t
func newCDownloadHandlerT(p *C.cef_download_handler_t) *CDownloadHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T7426:")
	BaseAddRef(p)
	go_download_handler := CDownloadHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_download_handler, func(g *CDownloadHandlerT) {
		Tracef(unsafe.Pointer(g.p_download_handler), "T7430:")
		BaseRelease(g.p_download_handler)
	})
	return &go_download_handler
}

// *C.cef_download_handler_t has refCounted interface
func (download_handler *CDownloadHandlerT) HasOneRef() bool {
	return BaseHasOneRef(download_handler.p_download_handler)
}

func (p *C.cef_download_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called before a download begins. |suggested_name| is the suggested name for
// the download file. By default the download will be canceled. Execute
// |callback| either asynchronously or in this function to continue the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
type OnBeforeDownloadHandler interface {
	OnBeforeDownload(
		self *CDownloadHandlerT,
		browser *CBrowserT,
		download_item *CDownloadItemT,
		suggested_name string,
		callback *CBeforeDownloadCallbackT,
	)
}

///
// Called when a download&#39;s status or progress information has been updated.
// This may be called multiple times before and after on_before_download().
// Execute |callback| either asynchronously or in this function to cancel the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
type OnDownloadUpdatedHandler interface {
	OnDownloadUpdated(
		self *CDownloadHandlerT,
		browser *CBrowserT,
		download_item *CDownloadItemT,
		callback *CDownloadItemCallbackT,
	)
}

var download_handler_handlers = struct {
	on_before_download_handler  map[*C.cef_download_handler_t]OnBeforeDownloadHandler
	on_download_updated_handler map[*C.cef_download_handler_t]OnDownloadUpdatedHandler
}{
	map[*C.cef_download_handler_t]OnBeforeDownloadHandler{},
	map[*C.cef_download_handler_t]OnDownloadUpdatedHandler{},
}

// AllocCDownloadHandlerT allocates CDownloadHandlerT and construct it
func AllocCDownloadHandlerT() *CDownloadHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_download_handler_wrapper_t, "T7488:")
	cefp := C.cefingo_construct_download_handler((*C.cefingo_download_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_download_handler_t itself in DeassocFunc,
		// or cef_download_handler_t is never GCed.
		Tracef(up, "T7494:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(download_handler_handlers.on_before_download_handler, cefp)
		delete(download_handler_handlers.on_download_updated_handler, cefp)
	}))

	return newCDownloadHandlerT(cefp)
}

func (download_handler *CDownloadHandlerT) Bind(a interface{}) *CDownloadHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := download_handler.p_download_handler

	if h, ok := a.(OnBeforeDownloadHandler); ok {
		download_handler_handlers.on_before_download_handler[cp] = h
	}

	if h, ok := a.(OnDownloadUpdatedHandler); ok {
		download_handler_handlers.on_download_updated_handler[cp] = h
	}

	if accessor, ok := a.(CDownloadHandlerTAccessor); ok {
		accessor.SetCDownloadHandlerT(download_handler)
		Logf("T7533:")
	}

	return download_handler
}

// cef_download_item_capi.h, include/capi/cef_download_item_capi.h:156:3,

///
// Structure used to represent a download item.
///

// Go type for cef_download_item_t
type CDownloadItemT struct {
	noCopy          noCopy
	p_download_item *C.cef_download_item_t
}

type RefToCDownloadItemT struct {
	p_download_item *CDownloadItemT
}

type CDownloadItemTAccessor interface {
	GetCDownloadItemT() *CDownloadItemT
	SetCDownloadItemT(*CDownloadItemT)
}

func (r RefToCDownloadItemT) GetCDownloadItemT() *CDownloadItemT {
	return r.p_download_item
}

func (r *RefToCDownloadItemT) SetCDownloadItemT(p *CDownloadItemT) {
	r.p_download_item = p
}

// Go type CDownloadItemT wraps cef type *C.cef_download_item_t
func newCDownloadItemT(p *C.cef_download_item_t) *CDownloadItemT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T7560:")
	BaseAddRef(p)
	go_download_item := CDownloadItemT{noCopy{}, p}
	runtime.SetFinalizer(&go_download_item, func(g *CDownloadItemT) {
		Tracef(unsafe.Pointer(g.p_download_item), "T7564:")
		BaseRelease(g.p_download_item)
	})
	return &go_download_item
}

// *C.cef_download_item_t has refCounted interface
func (download_item *CDownloadItemT) HasOneRef() bool {
	return BaseHasOneRef(download_item.p_download_item)
}

func (p *C.cef_download_item_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CDownloadItemT) IsValid() (ret bool) {

	cRet := C.cefingo_download_item_is_valid(self.p_download_item)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the download is in progress.
///
func (self *CDownloadItemT) IsInProgress() (ret bool) {

	cRet := C.cefingo_download_item_is_in_progress(self.p_download_item)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the download is complete.
///
func (self *CDownloadItemT) IsComplete() (ret bool) {

	cRet := C.cefingo_download_item_is_complete(self.p_download_item)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the download has been canceled or interrupted.
///
func (self *CDownloadItemT) IsCanceled() (ret bool) {

	cRet := C.cefingo_download_item_is_canceled(self.p_download_item)

	ret = cRet == 1
	return ret
}

///
// Returns a simple speed estimate in bytes/s.
///
func (self *CDownloadItemT) GetCurrentSpeed() (ret int64) {

	cRet := C.cefingo_download_item_get_current_speed(self.p_download_item)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the rough percent complete or -1 if the receive total size is
// unknown.
///
func (self *CDownloadItemT) GetPercentComplete() (ret bool) {

	cRet := C.cefingo_download_item_get_percent_complete(self.p_download_item)

	ret = cRet == 1
	return ret
}

///
// Returns the total number of bytes.
///
func (self *CDownloadItemT) GetTotalBytes() (ret int64) {

	cRet := C.cefingo_download_item_get_total_bytes(self.p_download_item)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the number of received bytes.
///
func (self *CDownloadItemT) GetReceivedBytes() (ret int64) {

	cRet := C.cefingo_download_item_get_received_bytes(self.p_download_item)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the time that the download started.
///
func (self *CDownloadItemT) GetStartTime() (ret CTimeT) {

	cRet := C.cefingo_download_item_get_start_time(self.p_download_item)

	ret = (CTimeT)(cRet)
	return ret
}

///
// Returns the time that the download ended.
///
func (self *CDownloadItemT) GetEndTime() (ret CTimeT) {

	cRet := C.cefingo_download_item_get_end_time(self.p_download_item)

	ret = (CTimeT)(cRet)
	return ret
}

///
// Returns the full path to the downloaded or downloading file.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetFullPath() (ret string) {

	cRet := C.cefingo_download_item_get_full_path(self.p_download_item)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the unique identifier for this download.
///
func (self *CDownloadItemT) GetId() (ret uint32) {

	cRet := C.cefingo_download_item_get_id(self.p_download_item)

	ret = (uint32)(cRet)
	return ret
}

///
// Returns the URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetUrl() (ret string) {

	cRet := C.cefingo_download_item_get_url(self.p_download_item)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the original URL before any redirections.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetOriginalUrl() (ret string) {

	cRet := C.cefingo_download_item_get_original_url(self.p_download_item)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the suggested file name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetSuggestedFileName() (ret string) {

	cRet := C.cefingo_download_item_get_suggested_file_name(self.p_download_item)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the content disposition.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetContentDisposition() (ret string) {

	cRet := C.cefingo_download_item_get_content_disposition(self.p_download_item)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the mime type.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetMimeType() (ret string) {

	cRet := C.cefingo_download_item_get_mime_type(self.p_download_item)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

// cef_drag_data_capi.h, include/capi/cef_drag_data_capi.h:217:3,

///
// Structure used to represent drag data. The functions of this structure may be
// called on any thread.
///

// Go type for cef_drag_data_t
type CDragDataT struct {
	noCopy      noCopy
	p_drag_data *C.cef_drag_data_t
}

type RefToCDragDataT struct {
	p_drag_data *CDragDataT
}

type CDragDataTAccessor interface {
	GetCDragDataT() *CDragDataT
	SetCDragDataT(*CDragDataT)
}

func (r RefToCDragDataT) GetCDragDataT() *CDragDataT {
	return r.p_drag_data
}

func (r *RefToCDragDataT) SetCDragDataT(p *CDragDataT) {
	r.p_drag_data = p
}

// Go type CDragDataT wraps cef type *C.cef_drag_data_t
func newCDragDataT(p *C.cef_drag_data_t) *CDragDataT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T7866:")
	BaseAddRef(p)
	go_drag_data := CDragDataT{noCopy{}, p}
	runtime.SetFinalizer(&go_drag_data, func(g *CDragDataT) {
		Tracef(unsafe.Pointer(g.p_drag_data), "T7870:")
		BaseRelease(g.p_drag_data)
	})
	return &go_drag_data
}

// *C.cef_drag_data_t has refCounted interface
func (drag_data *CDragDataT) HasOneRef() bool {
	return BaseHasOneRef(drag_data.p_drag_data)
}

func (p *C.cef_drag_data_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns a copy of the current object.
///
func (self *CDragDataT) Clone() (ret *CDragDataT) {

	cRet := C.cefingo_drag_data_clone(self.p_drag_data)

	ret = newCDragDataT(cRet)
	return ret
}

///
// Returns true (1) if this object is read-only.
///
func (self *CDragDataT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_drag_data_is_read_only(self.p_drag_data)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the drag data is a link.
///
func (self *CDragDataT) IsLink() (ret bool) {

	cRet := C.cefingo_drag_data_is_link(self.p_drag_data)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the drag data is a text or html fragment.
///
func (self *CDragDataT) IsFragment() (ret bool) {

	cRet := C.cefingo_drag_data_is_fragment(self.p_drag_data)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the drag data is a file.
///
func (self *CDragDataT) IsFile() (ret bool) {

	cRet := C.cefingo_drag_data_is_file(self.p_drag_data)

	ret = cRet == 1
	return ret
}

///
// Return the link URL that is being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetLinkUrl() (ret string) {

	cRet := C.cefingo_drag_data_get_link_url(self.p_drag_data)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the title associated with the link being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetLinkTitle() (ret string) {

	cRet := C.cefingo_drag_data_get_link_title(self.p_drag_data)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the metadata, if any, associated with the link being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetLinkMetadata() (ret string) {

	cRet := C.cefingo_drag_data_get_link_metadata(self.p_drag_data)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the plain text fragment that is being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFragmentText() (ret string) {

	cRet := C.cefingo_drag_data_get_fragment_text(self.p_drag_data)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the text/html fragment that is being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFragmentHtml() (ret string) {

	cRet := C.cefingo_drag_data_get_fragment_html(self.p_drag_data)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the base URL that the fragment came from. This value is used for
// resolving relative URLs and may be NULL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFragmentBaseUrl() (ret string) {

	cRet := C.cefingo_drag_data_get_fragment_base_url(self.p_drag_data)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the name of the file being dragged out of the browser window.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFileName() (ret string) {

	cRet := C.cefingo_drag_data_get_file_name(self.p_drag_data)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Write the contents of the file being dragged out of the web view into
// |writer|. Returns the number of bytes sent to |writer|. If |writer| is NULL
// this function will return the size of the file contents in bytes. Call
// get_file_name() to get a suggested name for the file.
///
func (self *CDragDataT) GetFileContents(
	writer *CStreamWriterT,
) (ret int64) {
	var goTmpwriter *C.cef_stream_writer_t
	if writer != nil {
		goTmpwriter = writer.p_stream_writer
		BaseAddRef(goTmpwriter)
	}

	cRet := C.cefingo_drag_data_get_file_contents(self.p_drag_data, goTmpwriter)

	ret = (int64)(cRet)
	return ret
}

///
// Retrieve the list of file names that are being dragged into the browser
// window.
///
func (self *CDragDataT) GetFileNames(
	names CStringListT,
) (ret bool) {

	cRet := C.cefingo_drag_data_get_file_names(self.p_drag_data, (C.cef_string_list_t)(names))

	ret = cRet == 1
	return ret
}

///
// Set the link URL that is being dragged.
///
func (self *CDragDataT) SetLinkUrl(
	url string,
) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)

	C.cefingo_drag_data_set_link_url(self.p_drag_data, (*C.cef_string_t)(c_url))

}

///
// Set the title associated with the link being dragged.
///
func (self *CDragDataT) SetLinkTitle(
	title string,
) {
	c_title := create_cef_string(title)
	defer clear_cef_string(c_title)

	C.cefingo_drag_data_set_link_title(self.p_drag_data, (*C.cef_string_t)(c_title))

}

///
// Set the metadata associated with the link being dragged.
///
func (self *CDragDataT) SetLinkMetadata(
	data string,
) {
	c_data := create_cef_string(data)
	defer clear_cef_string(c_data)

	C.cefingo_drag_data_set_link_metadata(self.p_drag_data, (*C.cef_string_t)(c_data))

}

///
// Set the plain text fragment that is being dragged.
///
func (self *CDragDataT) SetFragmentText(
	text string,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_drag_data_set_fragment_text(self.p_drag_data, (*C.cef_string_t)(c_text))

}

///
// Set the text/html fragment that is being dragged.
///
func (self *CDragDataT) SetFragmentHtml(
	html string,
) {
	c_html := create_cef_string(html)
	defer clear_cef_string(c_html)

	C.cefingo_drag_data_set_fragment_html(self.p_drag_data, (*C.cef_string_t)(c_html))

}

///
// Set the base URL that the fragment came from.
///
func (self *CDragDataT) SetFragmentBaseUrl(
	base_url string,
) {
	c_base_url := create_cef_string(base_url)
	defer clear_cef_string(c_base_url)

	C.cefingo_drag_data_set_fragment_base_url(self.p_drag_data, (*C.cef_string_t)(c_base_url))

}

///
// Reset the file contents. You should do this before calling
// cef_browser_host_t::DragTargetDragEnter as the web view does not allow us
// to drag in this kind of data.
///
func (self *CDragDataT) ResetFileContents() {

	C.cefingo_drag_data_reset_file_contents(self.p_drag_data)

}

///
// Add a file that is being dragged into the webview.
///
func (self *CDragDataT) AddFile(
	path string,
	display_name string,
) {
	c_path := create_cef_string(path)
	defer clear_cef_string(c_path)
	c_display_name := create_cef_string(display_name)
	defer clear_cef_string(c_display_name)

	C.cefingo_drag_data_add_file(self.p_drag_data, (*C.cef_string_t)(c_path), (*C.cef_string_t)(c_display_name))

}

///
// Get the image representation of drag data. May return NULL if no image
// representation is available.
///
func (self *CDragDataT) GetImage() (ret *CImageT) {

	cRet := C.cefingo_drag_data_get_image(self.p_drag_data)

	ret = newCImageT(cRet)
	return ret
}

///
// Get the image hotspot (drag start location relative to image dimensions).
///
func (self *CDragDataT) GetImageHotspot() (ret CPointT) {

	cRet := C.cefingo_drag_data_get_image_hotspot(self.p_drag_data)

	ret = (CPointT)(cRet)
	return ret
}

///
// Returns true (1) if an image representation of drag data is available.
///
func (self *CDragDataT) HasImage() (ret bool) {

	cRet := C.cefingo_drag_data_has_image(self.p_drag_data)

	ret = cRet == 1
	return ret
}

///
// Create a new cef_drag_data_t object.
///
func DragDataCreate() (ret *CDragDataT) {

	cRet := C.cef_drag_data_create()

	ret = newCDragDataT(cRet)
	return ret
}

// cef_drag_handler_capi.h, include/capi/cef_drag_handler_capi.h:86:3,

///
// Implement this structure to handle events related to dragging. The functions
// of this structure will be called on the UI thread.
///

// Go type for cef_drag_handler_t
type CDragHandlerT struct {
	noCopy         noCopy
	p_drag_handler *C.cef_drag_handler_t
}

type RefToCDragHandlerT struct {
	p_drag_handler *CDragHandlerT
}

type CDragHandlerTAccessor interface {
	GetCDragHandlerT() *CDragHandlerT
	SetCDragHandlerT(*CDragHandlerT)
}

func (r RefToCDragHandlerT) GetCDragHandlerT() *CDragHandlerT {
	return r.p_drag_handler
}

func (r *RefToCDragHandlerT) SetCDragHandlerT(p *CDragHandlerT) {
	r.p_drag_handler = p
}

// Go type CDragHandlerT wraps cef type *C.cef_drag_handler_t
func newCDragHandlerT(p *C.cef_drag_handler_t) *CDragHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T8315:")
	BaseAddRef(p)
	go_drag_handler := CDragHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_drag_handler, func(g *CDragHandlerT) {
		Tracef(unsafe.Pointer(g.p_drag_handler), "T8319:")
		BaseRelease(g.p_drag_handler)
	})
	return &go_drag_handler
}

// *C.cef_drag_handler_t has refCounted interface
func (drag_handler *CDragHandlerT) HasOneRef() bool {
	return BaseHasOneRef(drag_handler.p_drag_handler)
}

func (p *C.cef_drag_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called when an external drag event enters the browser window. |dragData|
// contains the drag event data and |mask| represents the type of drag
// operation. Return false (0) for default drag handling behavior or true (1)
// to cancel the drag event.
///
type OnDragEnterHandler interface {
	OnDragEnter(
		self *CDragHandlerT,
		browser *CBrowserT,
		dragData *CDragDataT,
		mask CDragOperationsMaskT,
	) (ret bool)
}

///
// Called whenever draggable regions for the browser window change. These can
// be specified using the &#39;-webkit-app-region: drag/no-drag&#39; CSS-property. If
// draggable regions are never defined in a document this function will also
// never be called. If the last draggable region is removed from a document
// this function will be called with an NULL vector.
///
type OnDraggableRegionsChangedHandler interface {
	OnDraggableRegionsChanged(
		self *CDragHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		regionsCount int64,
		regions *CDraggableRegionT,
	)
}

var drag_handler_handlers = struct {
	on_drag_enter_handler                map[*C.cef_drag_handler_t]OnDragEnterHandler
	on_draggable_regions_changed_handler map[*C.cef_drag_handler_t]OnDraggableRegionsChangedHandler
}{
	map[*C.cef_drag_handler_t]OnDragEnterHandler{},
	map[*C.cef_drag_handler_t]OnDraggableRegionsChangedHandler{},
}

// AllocCDragHandlerT allocates CDragHandlerT and construct it
func AllocCDragHandlerT() *CDragHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_drag_handler_wrapper_t, "T8376:")
	cefp := C.cefingo_construct_drag_handler((*C.cefingo_drag_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_drag_handler_t itself in DeassocFunc,
		// or cef_drag_handler_t is never GCed.
		Tracef(up, "T8382:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(drag_handler_handlers.on_drag_enter_handler, cefp)
		delete(drag_handler_handlers.on_draggable_regions_changed_handler, cefp)
	}))

	return newCDragHandlerT(cefp)
}

func (drag_handler *CDragHandlerT) Bind(a interface{}) *CDragHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := drag_handler.p_drag_handler

	if h, ok := a.(OnDragEnterHandler); ok {
		drag_handler_handlers.on_drag_enter_handler[cp] = h
	}

	if h, ok := a.(OnDraggableRegionsChangedHandler); ok {
		drag_handler_handlers.on_draggable_regions_changed_handler[cp] = h
	}

	if accessor, ok := a.(CDragHandlerTAccessor); ok {
		accessor.SetCDragHandlerT(drag_handler)
		Logf("T8421:")
	}

	return drag_handler
}

// cef_extension_capi.h, include/capi/cef_extension_capi.h:124:3,

///
// Object representing an extension. Methods may be called on any thread unless
// otherwise indicated.
///

// Go type for cef_extension_t
type CExtensionT struct {
	noCopy      noCopy
	p_extension *C.cef_extension_t
}

type RefToCExtensionT struct {
	p_extension *CExtensionT
}

type CExtensionTAccessor interface {
	GetCExtensionT() *CExtensionT
	SetCExtensionT(*CExtensionT)
}

func (r RefToCExtensionT) GetCExtensionT() *CExtensionT {
	return r.p_extension
}

func (r *RefToCExtensionT) SetCExtensionT(p *CExtensionT) {
	r.p_extension = p
}

// Go type CExtensionT wraps cef type *C.cef_extension_t
func newCExtensionT(p *C.cef_extension_t) *CExtensionT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T8449:")
	BaseAddRef(p)
	go_extension := CExtensionT{noCopy{}, p}
	runtime.SetFinalizer(&go_extension, func(g *CExtensionT) {
		Tracef(unsafe.Pointer(g.p_extension), "T8453:")
		BaseRelease(g.p_extension)
	})
	return &go_extension
}

// *C.cef_extension_t has refCounted interface
func (extension *CExtensionT) HasOneRef() bool {
	return BaseHasOneRef(extension.p_extension)
}

func (p *C.cef_extension_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the unique extension identifier. This is calculated based on the
// extension public key, if available, or on the extension path. See
// https://developer.chrome.com/extensions/manifest/key for details.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CExtensionT) GetIdentifier() (ret string) {

	cRet := C.cefingo_extension_get_identifier(self.p_extension)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the absolute path to the extension directory on disk. This value
// will be prefixed with PK_DIR_RESOURCES if a relative path was passed to
// cef_request_context_t::LoadExtension.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CExtensionT) GetPath() (ret string) {

	cRet := C.cefingo_extension_get_path(self.p_extension)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the extension manifest contents as a cef_dictionary_value_t object.
// See https://developer.chrome.com/extensions/manifest for details.
///
func (self *CExtensionT) GetManifest() (ret *CDictionaryValueT) {

	cRet := C.cefingo_extension_get_manifest(self.p_extension)

	ret = newCDictionaryValueT(cRet)
	return ret
}

///
// Returns true (1) if this object is the same extension as |that| object.
// Extensions are considered the same if identifier, path and loader context
// match.
///
func (self *CExtensionT) IsSame(
	that *CExtensionT,
) (ret bool) {
	var goTmpthat *C.cef_extension_t
	if that != nil {
		goTmpthat = that.p_extension
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_extension_is_same(self.p_extension, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns the handler for this extension. Will return NULL for internal
// extensions or if no handler was passed to
// cef_request_context_t::LoadExtension.
///
func (self *CExtensionT) GetHandler() (ret *CExtensionHandlerT) {

	cRet := C.cefingo_extension_get_handler(self.p_extension)

	ret = newCExtensionHandlerT(cRet)
	return ret
}

///
// Returns the request context that loaded this extension. Will return NULL
// for internal extensions or if the extension has been unloaded. See the
// cef_request_context_t::LoadExtension documentation for more information
// about loader contexts. Must be called on the browser process UI thread.
///
func (self *CExtensionT) GetLoaderContext() (ret *CRequestContextT) {

	cRet := C.cefingo_extension_get_loader_context(self.p_extension)

	ret = newCRequestContextT(cRet)
	return ret
}

///
// Returns true (1) if this extension is currently loaded. Must be called on
// the browser process UI thread.
///
func (self *CExtensionT) IsLoaded() (ret bool) {

	cRet := C.cefingo_extension_is_loaded(self.p_extension)

	ret = cRet == 1
	return ret
}

///
// Unload this extension if it is not an internal extension and is currently
// loaded. Will result in a call to
// cef_extension_handler_t::OnExtensionUnloaded on success.
///
func (self *CExtensionT) Unload() {

	C.cefingo_extension_unload(self.p_extension)

}

// cef_extension_handler_capi.h, include/capi/cef_extension_handler_capi.h:75:3,

///
// Callback structure used for asynchronous continuation of
// cef_extension_handler_t::GetExtensionResource.
///

// Go type for cef_get_extension_resource_callback_t
type CGetExtensionResourceCallbackT struct {
	noCopy                            noCopy
	p_get_extension_resource_callback *C.cef_get_extension_resource_callback_t
}

type RefToCGetExtensionResourceCallbackT struct {
	p_get_extension_resource_callback *CGetExtensionResourceCallbackT
}

type CGetExtensionResourceCallbackTAccessor interface {
	GetCGetExtensionResourceCallbackT() *CGetExtensionResourceCallbackT
	SetCGetExtensionResourceCallbackT(*CGetExtensionResourceCallbackT)
}

func (r RefToCGetExtensionResourceCallbackT) GetCGetExtensionResourceCallbackT() *CGetExtensionResourceCallbackT {
	return r.p_get_extension_resource_callback
}

func (r *RefToCGetExtensionResourceCallbackT) SetCGetExtensionResourceCallbackT(p *CGetExtensionResourceCallbackT) {
	r.p_get_extension_resource_callback = p
}

// Go type CGetExtensionResourceCallbackT wraps cef type *C.cef_get_extension_resource_callback_t
func newCGetExtensionResourceCallbackT(p *C.cef_get_extension_resource_callback_t) *CGetExtensionResourceCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T8635:")
	BaseAddRef(p)
	go_get_extension_resource_callback := CGetExtensionResourceCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_get_extension_resource_callback, func(g *CGetExtensionResourceCallbackT) {
		Tracef(unsafe.Pointer(g.p_get_extension_resource_callback), "T8639:")
		BaseRelease(g.p_get_extension_resource_callback)
	})
	return &go_get_extension_resource_callback
}

// *C.cef_get_extension_resource_callback_t has refCounted interface
func (get_extension_resource_callback *CGetExtensionResourceCallbackT) HasOneRef() bool {
	return BaseHasOneRef(get_extension_resource_callback.p_get_extension_resource_callback)
}

func (p *C.cef_get_extension_resource_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Continue the request. Read the resource contents from |stream|.
///
func (self *CGetExtensionResourceCallbackT) Cont(
	stream *CStreamReaderT,
) {
	var goTmpstream *C.cef_stream_reader_t
	if stream != nil {
		goTmpstream = stream.p_stream_reader
		BaseAddRef(goTmpstream)
	}

	C.cefingo_get_extension_resource_callback_cont(self.p_get_extension_resource_callback, goTmpstream)

}

///
// Cancel the request.
///
func (self *CGetExtensionResourceCallbackT) Cancel() {

	C.cefingo_get_extension_resource_callback_cancel(self.p_get_extension_resource_callback)

}

///
// Implement this structure to handle events related to browser extensions. The
// functions of this structure will be called on the UI thread. See
// cef_request_context_t::LoadExtension for information about extension loading.
///

// Go type for cef_extension_handler_t
type CExtensionHandlerT struct {
	noCopy              noCopy
	p_extension_handler *C.cef_extension_handler_t
}

type RefToCExtensionHandlerT struct {
	p_extension_handler *CExtensionHandlerT
}

type CExtensionHandlerTAccessor interface {
	GetCExtensionHandlerT() *CExtensionHandlerT
	SetCExtensionHandlerT(*CExtensionHandlerT)
}

func (r RefToCExtensionHandlerT) GetCExtensionHandlerT() *CExtensionHandlerT {
	return r.p_extension_handler
}

func (r *RefToCExtensionHandlerT) SetCExtensionHandlerT(p *CExtensionHandlerT) {
	r.p_extension_handler = p
}

// Go type CExtensionHandlerT wraps cef type *C.cef_extension_handler_t
func newCExtensionHandlerT(p *C.cef_extension_handler_t) *CExtensionHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T8715:")
	BaseAddRef(p)
	go_extension_handler := CExtensionHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_extension_handler, func(g *CExtensionHandlerT) {
		Tracef(unsafe.Pointer(g.p_extension_handler), "T8719:")
		BaseRelease(g.p_extension_handler)
	})
	return &go_extension_handler
}

// *C.cef_extension_handler_t has refCounted interface
func (extension_handler *CExtensionHandlerT) HasOneRef() bool {
	return BaseHasOneRef(extension_handler.p_extension_handler)
}

func (p *C.cef_extension_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called if the cef_request_context_t::LoadExtension request fails. |result|
// will be the error code.
///
type OnExtensionLoadFailedHandler interface {
	OnExtensionLoadFailed(
		self *CExtensionHandlerT,
		result CErrorcodeT,
	)
}

///
// Called if the cef_request_context_t::LoadExtension request succeeds.
// |extension| is the loaded extension.
///
type OnExtensionLoadedHandler interface {
	OnExtensionLoaded(
		self *CExtensionHandlerT,
		extension *CExtensionT,
	)
}

///
// Called after the cef_extension_t::Unload request has completed.
///
type OnExtensionUnloadedHandler interface {
	OnExtensionUnloaded(
		self *CExtensionHandlerT,
		extension *CExtensionT,
	)
}

///
// Called when an extension needs a browser to host a background script
// specified via the &quot;background&quot; manifest key. The browser will have no
// visible window and cannot be displayed. |extension| is the extension that
// is loading the background script. |url| is an internally generated
// reference to an HTML page that will be used to load the background script
// via a &lt;script&gt; src attribute. To allow creation of the browser optionally
// modify |client| and |settings| and return false (0). To cancel creation of
// the browser (and consequently cancel load of the background script) return
// true (1). Successful creation will be indicated by a call to
// cef_life_span_handler_t::OnAfterCreated, and
// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
// browser. See https://developer.chrome.com/extensions/event_pages for more
// information about extension background script usage.
///
type OnBeforeBackgroundBrowserHandler interface {
	OnBeforeBackgroundBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		url string,
		client *CClientT,
		settings CBrowserSettingsT,
	) (ret bool, clientOut *CClientT, settingsOut CBrowserSettingsT)
}

///
// Called when an extension API (e.g. chrome.tabs.create) requests creation of
// a new browser. |extension| and |browser| are the source of the API call.
// |active_browser| may optionally be specified via the windowId property or
// returned via the get_active_browser() callback and provides the default
// |client| and |settings| values for the new browser. |index| is the position
// value optionally specified via the index property. |url| is the URL that
// will be loaded in the browser. |active| is true (1) if the new browser
// should be active when opened.  To allow creation of the browser optionally
// modify |windowInfo|, |client| and |settings| and return false (0). To
// cancel creation of the browser return true (1). Successful creation will be
// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
// modifications to |windowInfo| will be ignored if |active_browser| is
// wrapped in a cef_browser_view_t.
///
type OnBeforeBrowserHandler interface {
	OnBeforeBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		active_browser *CBrowserT,
		index int,
		url string,
		active int,
		windowInfo CWindowInfoT,
		client *CClientT,
		settings CBrowserSettingsT,
	) (ret bool, windowInfoOut CWindowInfoT, clientOut *CClientT, settingsOut CBrowserSettingsT)
}

///
// Called when no tabId is specified to an extension API call that accepts a
// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
// source of the API call. Return the browser that will be acted on by the API
// call or return NULL to act on |browser|. The returned browser must share
// the same cef_request_context_t as |browser|. Incognito browsers should not
// be considered unless the source extension has incognito access enabled, in
// which case |include_incognito| will be true (1).
///
type GetActiveBrowserHandler interface {
	GetActiveBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		include_incognito int,
	) (ret *CBrowserT)
}

///
// Called when the tabId associated with |target_browser| is specified to an
// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
// |extension| and |browser| are the source of the API call. Return true (1)
// to allow access of false (0) to deny access. Access to incognito browsers
// should not be allowed unless the source extension has incognito access
// enabled, in which case |include_incognito| will be true (1).
///
type CanAccessBrowserHandler interface {
	CanAccessBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		include_incognito int,
		target_browser *CBrowserT,
	) (ret bool)
}

///
// Called to retrieve an extension resource that would normally be loaded from
// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
// |extension| and |browser| are the source of the resource request. |file| is
// the requested relative file path. To handle the resource request return
// true (1) and execute |callback| either synchronously or asynchronously. For
// the default behavior which reads the resource from the extension directory
// on disk return false (0). Localization substitutions will not be applied to
// resources handled via this function.
///
type GetExtensionResourceHandler interface {
	GetExtensionResource(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		file string,
		callback *CGetExtensionResourceCallbackT,
	) (ret bool)
}

var extension_handler_handlers = struct {
	on_extension_load_failed_handler     map[*C.cef_extension_handler_t]OnExtensionLoadFailedHandler
	on_extension_loaded_handler          map[*C.cef_extension_handler_t]OnExtensionLoadedHandler
	on_extension_unloaded_handler        map[*C.cef_extension_handler_t]OnExtensionUnloadedHandler
	on_before_background_browser_handler map[*C.cef_extension_handler_t]OnBeforeBackgroundBrowserHandler
	on_before_browser_handler            map[*C.cef_extension_handler_t]OnBeforeBrowserHandler
	get_active_browser_handler           map[*C.cef_extension_handler_t]GetActiveBrowserHandler
	can_access_browser_handler           map[*C.cef_extension_handler_t]CanAccessBrowserHandler
	get_extension_resource_handler       map[*C.cef_extension_handler_t]GetExtensionResourceHandler
}{
	map[*C.cef_extension_handler_t]OnExtensionLoadFailedHandler{},
	map[*C.cef_extension_handler_t]OnExtensionLoadedHandler{},
	map[*C.cef_extension_handler_t]OnExtensionUnloadedHandler{},
	map[*C.cef_extension_handler_t]OnBeforeBackgroundBrowserHandler{},
	map[*C.cef_extension_handler_t]OnBeforeBrowserHandler{},
	map[*C.cef_extension_handler_t]GetActiveBrowserHandler{},
	map[*C.cef_extension_handler_t]CanAccessBrowserHandler{},
	map[*C.cef_extension_handler_t]GetExtensionResourceHandler{},
}

// AllocCExtensionHandlerT allocates CExtensionHandlerT and construct it
func AllocCExtensionHandlerT() *CExtensionHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_extension_handler_wrapper_t, "T8899:")
	cefp := C.cefingo_construct_extension_handler((*C.cefingo_extension_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_extension_handler_t itself in DeassocFunc,
		// or cef_extension_handler_t is never GCed.
		Tracef(up, "T8905:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(extension_handler_handlers.on_extension_load_failed_handler, cefp)
		delete(extension_handler_handlers.on_extension_loaded_handler, cefp)
		delete(extension_handler_handlers.on_extension_unloaded_handler, cefp)
		delete(extension_handler_handlers.on_before_background_browser_handler, cefp)
		delete(extension_handler_handlers.on_before_browser_handler, cefp)
		delete(extension_handler_handlers.get_active_browser_handler, cefp)
		delete(extension_handler_handlers.can_access_browser_handler, cefp)
		delete(extension_handler_handlers.get_extension_resource_handler, cefp)
	}))

	return newCExtensionHandlerT(cefp)
}

func (extension_handler *CExtensionHandlerT) Bind(a interface{}) *CExtensionHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := extension_handler.p_extension_handler

	if h, ok := a.(OnExtensionLoadFailedHandler); ok {
		extension_handler_handlers.on_extension_load_failed_handler[cp] = h
	}

	if h, ok := a.(OnExtensionLoadedHandler); ok {
		extension_handler_handlers.on_extension_loaded_handler[cp] = h
	}

	if h, ok := a.(OnExtensionUnloadedHandler); ok {
		extension_handler_handlers.on_extension_unloaded_handler[cp] = h
	}

	if h, ok := a.(OnBeforeBackgroundBrowserHandler); ok {
		extension_handler_handlers.on_before_background_browser_handler[cp] = h
	}

	if h, ok := a.(OnBeforeBrowserHandler); ok {
		extension_handler_handlers.on_before_browser_handler[cp] = h
	}

	if h, ok := a.(GetActiveBrowserHandler); ok {
		extension_handler_handlers.get_active_browser_handler[cp] = h
	}

	if h, ok := a.(CanAccessBrowserHandler); ok {
		extension_handler_handlers.can_access_browser_handler[cp] = h
	}

	if h, ok := a.(GetExtensionResourceHandler); ok {
		extension_handler_handlers.get_extension_resource_handler[cp] = h
	}

	if accessor, ok := a.(CExtensionHandlerTAccessor); ok {
		accessor.SetCExtensionHandlerT(extension_handler)
		Logf("T8974:")
	}

	return extension_handler
}

// cef_fill_layout_capi.h, include/capi/views/cef_fill_layout_capi.h:59:3,

///
// A simple Layout that causes the associated Panel's one child to be sized to
// match the bounds of its parent. Methods must be called on the browser process
// UI thread unless otherwise indicated.
///

// Go type for cef_fill_layout_t
type CFillLayoutT struct {
	noCopy        noCopy
	p_fill_layout *C.cef_fill_layout_t
}

type RefToCFillLayoutT struct {
	p_fill_layout *CFillLayoutT
}

type CFillLayoutTAccessor interface {
	GetCFillLayoutT() *CFillLayoutT
	SetCFillLayoutT(*CFillLayoutT)
}

func (r RefToCFillLayoutT) GetCFillLayoutT() *CFillLayoutT {
	return r.p_fill_layout
}

func (r *RefToCFillLayoutT) SetCFillLayoutT(p *CFillLayoutT) {
	r.p_fill_layout = p
}

// Go type CFillLayoutT wraps cef type *C.cef_fill_layout_t
func newCFillLayoutT(p *C.cef_fill_layout_t) *CFillLayoutT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T9003:")
	BaseAddRef(p)
	go_fill_layout := CFillLayoutT{noCopy{}, p}
	runtime.SetFinalizer(&go_fill_layout, func(g *CFillLayoutT) {
		Tracef(unsafe.Pointer(g.p_fill_layout), "T9007:")
		BaseRelease(g.p_fill_layout)
	})
	return &go_fill_layout
}

// *C.cef_fill_layout_t has refCounted interface
func (fill_layout *CFillLayoutT) HasOneRef() bool {
	return BaseHasOneRef(fill_layout.p_fill_layout)
}

func (p *C.cef_fill_layout_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (fill_layout *CFillLayoutT) ToCLayoutT() *CLayoutT {
	p := (*C.cef_layout_t)(unsafe.Pointer(fill_layout.p_fill_layout))
	return newCLayoutT(p)
}

// cef_find_handler_capi.h, include/capi/cef_find_handler_capi.h:75:3,

///
// Implement this structure to handle events related to find results. The
// functions of this structure will be called on the UI thread.
///

// Go type for cef_find_handler_t
type CFindHandlerT struct {
	noCopy         noCopy
	p_find_handler *C.cef_find_handler_t
}

type RefToCFindHandlerT struct {
	p_find_handler *CFindHandlerT
}

type CFindHandlerTAccessor interface {
	GetCFindHandlerT() *CFindHandlerT
	SetCFindHandlerT(*CFindHandlerT)
}

func (r RefToCFindHandlerT) GetCFindHandlerT() *CFindHandlerT {
	return r.p_find_handler
}

func (r *RefToCFindHandlerT) SetCFindHandlerT(p *CFindHandlerT) {
	r.p_find_handler = p
}

// Go type CFindHandlerT wraps cef type *C.cef_find_handler_t
func newCFindHandlerT(p *C.cef_find_handler_t) *CFindHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T9061:")
	BaseAddRef(p)
	go_find_handler := CFindHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_find_handler, func(g *CFindHandlerT) {
		Tracef(unsafe.Pointer(g.p_find_handler), "T9065:")
		BaseRelease(g.p_find_handler)
	})
	return &go_find_handler
}

// *C.cef_find_handler_t has refCounted interface
func (find_handler *CFindHandlerT) HasOneRef() bool {
	return BaseHasOneRef(find_handler.p_find_handler)
}

func (p *C.cef_find_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called to report find results returned by cef_browser_host_t::find().
// |identifer| is the identifier passed to find(), |count| is the number of
// matches currently identified, |selectionRect| is the location of where the
// match was found (in window coordinates), |activeMatchOrdinal| is the
// current position in the search results, and |finalUpdate| is true (1) if
// this is the last find notification.
///
type OnFindResultHandler interface {
	OnFindResult(
		self *CFindHandlerT,
		browser *CBrowserT,
		identifier int,
		count int,
		selectionRect *CRectT,
		activeMatchOrdinal int,
		finalUpdate int,
	)
}

var find_handler_handlers = struct {
	on_find_result_handler map[*C.cef_find_handler_t]OnFindResultHandler
}{
	map[*C.cef_find_handler_t]OnFindResultHandler{},
}

// AllocCFindHandlerT allocates CFindHandlerT and construct it
func AllocCFindHandlerT() *CFindHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_find_handler_wrapper_t, "T9108:")
	cefp := C.cefingo_construct_find_handler((*C.cefingo_find_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_find_handler_t itself in DeassocFunc,
		// or cef_find_handler_t is never GCed.
		Tracef(up, "T9114:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(find_handler_handlers.on_find_result_handler, cefp)
	}))

	return newCFindHandlerT(cefp)
}

func (find_handler *CFindHandlerT) Bind(a interface{}) *CFindHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := find_handler.p_find_handler

	if h, ok := a.(OnFindResultHandler); ok {
		find_handler_handlers.on_find_result_handler[cp] = h
	}

	if accessor, ok := a.(CFindHandlerTAccessor); ok {
		accessor.SetCFindHandlerT(find_handler)
		Logf("T9148:")
	}

	return find_handler
}

// cef_focus_handler_capi.h, include/capi/cef_focus_handler_capi.h:86:3,

///
// Implement this structure to handle events related to focus. The functions of
// this structure will be called on the UI thread.
///

// Go type for cef_focus_handler_t
type CFocusHandlerT struct {
	noCopy          noCopy
	p_focus_handler *C.cef_focus_handler_t
}

type RefToCFocusHandlerT struct {
	p_focus_handler *CFocusHandlerT
}

type CFocusHandlerTAccessor interface {
	GetCFocusHandlerT() *CFocusHandlerT
	SetCFocusHandlerT(*CFocusHandlerT)
}

func (r RefToCFocusHandlerT) GetCFocusHandlerT() *CFocusHandlerT {
	return r.p_focus_handler
}

func (r *RefToCFocusHandlerT) SetCFocusHandlerT(p *CFocusHandlerT) {
	r.p_focus_handler = p
}

// Go type CFocusHandlerT wraps cef type *C.cef_focus_handler_t
func newCFocusHandlerT(p *C.cef_focus_handler_t) *CFocusHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T9176:")
	BaseAddRef(p)
	go_focus_handler := CFocusHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_focus_handler, func(g *CFocusHandlerT) {
		Tracef(unsafe.Pointer(g.p_focus_handler), "T9180:")
		BaseRelease(g.p_focus_handler)
	})
	return &go_focus_handler
}

// *C.cef_focus_handler_t has refCounted interface
func (focus_handler *CFocusHandlerT) HasOneRef() bool {
	return BaseHasOneRef(focus_handler.p_focus_handler)
}

func (p *C.cef_focus_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called when the browser component is about to loose focus. For instance, if
// focus was on the last HTML element and the user pressed the TAB key. |next|
// will be true (1) if the browser is giving focus to the next component and
// false (0) if the browser is giving focus to the previous component.
///
type OnTakeFocusHandler interface {
	OnTakeFocus(
		self *CFocusHandlerT,
		browser *CBrowserT,
		next int,
	)
}

///
// Called when the browser component is requesting focus. |source| indicates
// where the focus request is originating from. Return false (0) to allow the
// focus to be set or true (1) to cancel setting the focus.
///
type OnSetFocusHandler interface {
	OnSetFocus(
		self *CFocusHandlerT,
		browser *CBrowserT,
		source CFocusSourceT,
	) (ret bool)
}

///
// Called when the browser component has received focus.
///
type OnGotFocusHandler interface {
	OnGotFocus(
		self *CFocusHandlerT,
		browser *CBrowserT,
	)
}

var focus_handler_handlers = struct {
	on_take_focus_handler map[*C.cef_focus_handler_t]OnTakeFocusHandler
	on_set_focus_handler  map[*C.cef_focus_handler_t]OnSetFocusHandler
	on_got_focus_handler  map[*C.cef_focus_handler_t]OnGotFocusHandler
}{
	map[*C.cef_focus_handler_t]OnTakeFocusHandler{},
	map[*C.cef_focus_handler_t]OnSetFocusHandler{},
	map[*C.cef_focus_handler_t]OnGotFocusHandler{},
}

// AllocCFocusHandlerT allocates CFocusHandlerT and construct it
func AllocCFocusHandlerT() *CFocusHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_focus_handler_wrapper_t, "T9244:")
	cefp := C.cefingo_construct_focus_handler((*C.cefingo_focus_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_focus_handler_t itself in DeassocFunc,
		// or cef_focus_handler_t is never GCed.
		Tracef(up, "T9250:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(focus_handler_handlers.on_take_focus_handler, cefp)
		delete(focus_handler_handlers.on_set_focus_handler, cefp)
		delete(focus_handler_handlers.on_got_focus_handler, cefp)
	}))

	return newCFocusHandlerT(cefp)
}

func (focus_handler *CFocusHandlerT) Bind(a interface{}) *CFocusHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := focus_handler.p_focus_handler

	if h, ok := a.(OnTakeFocusHandler); ok {
		focus_handler_handlers.on_take_focus_handler[cp] = h
	}

	if h, ok := a.(OnSetFocusHandler); ok {
		focus_handler_handlers.on_set_focus_handler[cp] = h
	}

	if h, ok := a.(OnGotFocusHandler); ok {
		focus_handler_handlers.on_got_focus_handler[cp] = h
	}

	if accessor, ok := a.(CFocusHandlerTAccessor); ok {
		accessor.SetCFocusHandlerT(focus_handler)
		Logf("T9294:")
	}

	return focus_handler
}

// cef_frame_capi.h, include/capi/cef_frame_capi.h:254:3,

///
// Structure used to represent a frame in the browser window. When used in the
// browser process the functions of this structure may be called on any thread
// unless otherwise indicated in the comments. When used in the render process
// the functions of this structure may only be called on the main thread.
///

// Go type for cef_frame_t
type CFrameT struct {
	noCopy  noCopy
	p_frame *C.cef_frame_t
}

type RefToCFrameT struct {
	p_frame *CFrameT
}

type CFrameTAccessor interface {
	GetCFrameT() *CFrameT
	SetCFrameT(*CFrameT)
}

func (r RefToCFrameT) GetCFrameT() *CFrameT {
	return r.p_frame
}

func (r *RefToCFrameT) SetCFrameT(p *CFrameT) {
	r.p_frame = p
}

// Go type CFrameT wraps cef type *C.cef_frame_t
func newCFrameT(p *C.cef_frame_t) *CFrameT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T9324:")
	BaseAddRef(p)
	go_frame := CFrameT{noCopy{}, p}
	runtime.SetFinalizer(&go_frame, func(g *CFrameT) {
		Tracef(unsafe.Pointer(g.p_frame), "T9328:")
		BaseRelease(g.p_frame)
	})
	return &go_frame
}

// *C.cef_frame_t has refCounted interface
func (frame *CFrameT) HasOneRef() bool {
	return BaseHasOneRef(frame.p_frame)
}

func (p *C.cef_frame_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// True if this object is currently attached to a valid frame.
///
func (self *CFrameT) IsValid() (ret bool) {

	cRet := C.cefingo_frame_is_valid(self.p_frame)

	ret = cRet == 1
	return ret
}

///
// Execute undo in this frame.
///
func (self *CFrameT) Undo() {

	C.cefingo_frame_undo(self.p_frame)

}

///
// Execute redo in this frame.
///
func (self *CFrameT) Redo() {

	C.cefingo_frame_redo(self.p_frame)

}

///
// Execute cut in this frame.
///
func (self *CFrameT) Cut() {

	C.cefingo_frame_cut(self.p_frame)

}

///
// Execute copy in this frame.
///
func (self *CFrameT) Copy() {

	C.cefingo_frame_copy(self.p_frame)

}

///
// Execute paste in this frame.
///
func (self *CFrameT) Paste() {

	C.cefingo_frame_paste(self.p_frame)

}

///
// Execute delete in this frame.
///
func (self *CFrameT) Del() {

	C.cefingo_frame_del(self.p_frame)

}

///
// Execute select all in this frame.
///
func (self *CFrameT) SelectAll() {

	C.cefingo_frame_select_all(self.p_frame)

}

///
// Save this frame&#39;s HTML source to a temporary file and open it in the
// default text viewing application. This function can only be called from the
// browser process.
///
func (self *CFrameT) ViewSource() {

	C.cefingo_frame_view_source(self.p_frame)

}

///
// Retrieve this frame&#39;s HTML source as a string sent to the specified
// visitor.
///
func (self *CFrameT) GetSource(
	visitor *CStringVisitorT,
) {
	var goTmpvisitor *C.cef_string_visitor_t
	if visitor != nil {
		goTmpvisitor = visitor.p_string_visitor
		BaseAddRef(goTmpvisitor)
	}

	C.cefingo_frame_get_source(self.p_frame, goTmpvisitor)

}

///
// Retrieve this frame&#39;s display text as a string sent to the specified
// visitor.
///
func (self *CFrameT) GetText(
	visitor *CStringVisitorT,
) {
	var goTmpvisitor *C.cef_string_visitor_t
	if visitor != nil {
		goTmpvisitor = visitor.p_string_visitor
		BaseAddRef(goTmpvisitor)
	}

	C.cefingo_frame_get_text(self.p_frame, goTmpvisitor)

}

///
// Load the request represented by the |request| object.
//
// WARNING: This function will fail with &quot;bad IPC message&quot; reason
// INVALID_INITIATOR_ORIGIN (213) unless you first navigate to the request
// origin using some other mechanism (LoadURL, link click, etc).
///
func (self *CFrameT) LoadRequest(
	request *CRequestT,
) {
	var goTmprequest *C.cef_request_t
	if request != nil {
		goTmprequest = request.p_request
		BaseAddRef(goTmprequest)
	}

	C.cefingo_frame_load_request(self.p_frame, goTmprequest)

}

///
// Load the specified |url|.
///
func (self *CFrameT) LoadUrl(
	url string,
) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)

	C.cefingo_frame_load_url(self.p_frame, (*C.cef_string_t)(c_url))

}

///
// Execute a string of JavaScript code in this frame. The |script_url|
// parameter is the URL where the script in question can be found, if any. The
// renderer may request this URL to show the developer the source of the
// error.  The |start_line| parameter is the base line number to use for error
// reporting.
///
func (self *CFrameT) ExecuteJavaScript(
	code string,
	script_url string,
	start_line int,
) {
	c_code := create_cef_string(code)
	defer clear_cef_string(c_code)
	c_script_url := create_cef_string(script_url)
	defer clear_cef_string(c_script_url)

	C.cefingo_frame_execute_java_script(self.p_frame, (*C.cef_string_t)(c_code), (*C.cef_string_t)(c_script_url), (C.int)(start_line))

}

///
// Returns true (1) if this is the main (top-level) frame.
///
func (self *CFrameT) IsMain() (ret bool) {

	cRet := C.cefingo_frame_is_main(self.p_frame)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is the focused frame.
///
func (self *CFrameT) IsFocused() (ret bool) {

	cRet := C.cefingo_frame_is_focused(self.p_frame)

	ret = cRet == 1
	return ret
}

///
// Returns the name for this frame. If the frame has an assigned name (for
// example, set via the iframe &quot;name&quot; attribute) then that value will be
// returned. Otherwise a unique name will be constructed based on the frame
// parent hierarchy. The main (top-level) frame will always have an NULL name
// value.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CFrameT) GetName() (ret string) {

	cRet := C.cefingo_frame_get_name(self.p_frame)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the globally unique identifier for this frame or &lt; 0 if the
// underlying frame does not yet exist.
///
func (self *CFrameT) GetIdentifier() (ret int64) {

	cRet := C.cefingo_frame_get_identifier(self.p_frame)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the parent of this frame or NULL if this is the main (top-level)
// frame.
///
func (self *CFrameT) GetParent() (ret *CFrameT) {

	cRet := C.cefingo_frame_get_parent(self.p_frame)

	ret = newCFrameT(cRet)
	return ret
}

///
// Returns the URL currently loaded in this frame.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CFrameT) GetUrl() (ret string) {

	cRet := C.cefingo_frame_get_url(self.p_frame)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the browser that this frame belongs to.
///
func (self *CFrameT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_frame_get_browser(self.p_frame)

	ret = newCBrowserT(cRet)
	return ret
}

///
// Get the V8 context associated with the frame. This function can only be
// called from the render process.
///
func (self *CFrameT) GetV8context() (ret *CV8contextT) {

	cRet := C.cefingo_frame_get_v8context(self.p_frame)

	ret = newCV8contextT(cRet)
	return ret
}

///
// Visit the DOM document. This function can only be called from the render
// process.
///
func (self *CFrameT) VisitDom(
	visitor *CDomvisitorT,
) {
	var goTmpvisitor *C.cef_domvisitor_t
	if visitor != nil {
		goTmpvisitor = visitor.p_domvisitor
		BaseAddRef(goTmpvisitor)
	}

	C.cefingo_frame_visit_dom(self.p_frame, goTmpvisitor)

}

///
// Create a new URL request that will be treated as originating from this
// frame and the associated browser. This request may be intercepted by the
// client via cef_resource_request_handler_t or cef_scheme_handler_factory_t.
// Use cef_urlrequest_t::Create instead if you do not want the request to have
// this association, in which case it may be handled differently (see
// documentation on that function). Requests may originate from both the
// browser process and the render process.
//
// For requests originating from the browser process:
//   - POST data may only contain a single element of type PDE_TYPE_FILE or
//     PDE_TYPE_BYTES.
// For requests originating from the render process:
//   - POST data may only contain a single element of type PDE_TYPE_BYTES.
//   - If the response contains Content-Disposition or Mime-Type header values
//     that would not normally be rendered then the response may receive
//     special handling inside the browser (for example, via the file download
//     code path instead of the URL request code path).
//
// The |request| object will be marked as read-only after calling this
// function.
///
func (self *CFrameT) CreateUrlrequest(
	request *CRequestT,
	client *CUrlrequestClientT,
) (ret *CUrlrequestT) {
	var goTmprequest *C.cef_request_t
	if request != nil {
		goTmprequest = request.p_request
		BaseAddRef(goTmprequest)
	}
	var goTmpclient *C.cef_urlrequest_client_t
	if client != nil {
		goTmpclient = client.p_urlrequest_client
		BaseAddRef(goTmpclient)
	}

	cRet := C.cefingo_frame_create_urlrequest(self.p_frame, goTmprequest, goTmpclient)

	ret = newCUrlrequestT(cRet)
	return ret
}

///
// Send a message to the specified |target_process|. Message delivery is not
// guaranteed in all cases (for example, if the browser is closing,
// navigating, or if the target process crashes). Send an ACK message back
// from the target process if confirmation is required.
///
func (self *CFrameT) SendProcessMessage(
	target_process CProcessIdT,
	message *CProcessMessageT,
) {
	var goTmpmessage *C.cef_process_message_t
	if message != nil {
		goTmpmessage = message.p_process_message
		BaseAddRef(goTmpmessage)
	}

	C.cefingo_frame_send_process_message(self.p_frame, (C.cef_process_id_t)(target_process), goTmpmessage)

}

// cef_image_capi.h, include/capi/cef_image_capi.h:193:3,

///
// Container for a single image represented at different scale factors. All
// image representations should be the same size in density independent pixel
// (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels
// then the image at scale factor 2.0 should be 200x200 pixels -- both images
// will display with a DIP size of 100x100 units. The functions of this
// structure can be called on any browser process thread.
///

// Go type for cef_image_t
type CImageT struct {
	noCopy  noCopy
	p_image *C.cef_image_t
}

type RefToCImageT struct {
	p_image *CImageT
}

type CImageTAccessor interface {
	GetCImageT() *CImageT
	SetCImageT(*CImageT)
}

func (r RefToCImageT) GetCImageT() *CImageT {
	return r.p_image
}

func (r *RefToCImageT) SetCImageT(p *CImageT) {
	r.p_image = p
}

// Go type CImageT wraps cef type *C.cef_image_t
func newCImageT(p *C.cef_image_t) *CImageT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T9781:")
	BaseAddRef(p)
	go_image := CImageT{noCopy{}, p}
	runtime.SetFinalizer(&go_image, func(g *CImageT) {
		Tracef(unsafe.Pointer(g.p_image), "T9785:")
		BaseRelease(g.p_image)
	})
	return &go_image
}

// *C.cef_image_t has refCounted interface
func (image *CImageT) HasOneRef() bool {
	return BaseHasOneRef(image.p_image)
}

func (p *C.cef_image_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this Image is NULL.
///
func (self *CImageT) IsEmpty() (ret bool) {

	cRet := C.cefingo_image_is_empty(self.p_image)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this Image and |that| Image share the same underlying
// storage. Will also return true (1) if both images are NULL.
///
func (self *CImageT) IsSame(
	that *CImageT,
) (ret bool) {
	var goTmpthat *C.cef_image_t
	if that != nil {
		goTmpthat = that.p_image
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_image_is_same(self.p_image, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Add a bitmap image representation for |scale_factor|. Only 32-bit RGBA/BGRA
// formats are supported. |pixel_width| and |pixel_height| are the bitmap
// representation size in pixel coordinates. |pixel_data| is the array of
// pixel data and should be |pixel_width| x |pixel_height| x 4 bytes in size.
// |color_type| and |alpha_type| values specify the pixel format.
///
func (self *CImageT) AddBitmap(
	scale_factor float32,
	pixel_width int,
	pixel_height int,
	color_type CColorTypeT,
	alpha_type CAlphaTypeT,
	pixel_data unsafe.Pointer,
	pixel_data_size int64,
) (ret bool) {

	cRet := C.cefingo_image_add_bitmap(self.p_image, (C.float)(scale_factor), (C.int)(pixel_width), (C.int)(pixel_height), (C.cef_color_type_t)(color_type), (C.cef_alpha_type_t)(alpha_type), pixel_data, (C.size_t)(pixel_data_size))

	ret = cRet == 1
	return ret
}

///
// Add a PNG image representation for |scale_factor|. |png_data| is the image
// data of size |png_data_size|. Any alpha transparency in the PNG data will
// be maintained.
///
func (self *CImageT) AddPng(
	scale_factor float32,
	png_data unsafe.Pointer,
	png_data_size int64,
) (ret bool) {

	cRet := C.cefingo_image_add_png(self.p_image, (C.float)(scale_factor), png_data, (C.size_t)(png_data_size))

	ret = cRet == 1
	return ret
}

///
// Create a JPEG image representation for |scale_factor|. |jpeg_data| is the
// image data of size |jpeg_data_size|. The JPEG format does not support
// transparency so the alpha byte will be set to 0xFF for all pixels.
///
func (self *CImageT) AddJpeg(
	scale_factor float32,
	jpeg_data unsafe.Pointer,
	jpeg_data_size int64,
) (ret bool) {

	cRet := C.cefingo_image_add_jpeg(self.p_image, (C.float)(scale_factor), jpeg_data, (C.size_t)(jpeg_data_size))

	ret = cRet == 1
	return ret
}

///
// Returns the image width in density independent pixel (DIP) units.
///
func (self *CImageT) GetWidth() (ret int64) {

	cRet := C.cefingo_image_get_width(self.p_image)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the image height in density independent pixel (DIP) units.
///
func (self *CImageT) GetHeight() (ret int64) {

	cRet := C.cefingo_image_get_height(self.p_image)

	ret = (int64)(cRet)
	return ret
}

///
// Returns true (1) if this image contains a representation for
// |scale_factor|.
///
func (self *CImageT) HasRepresentation(
	scale_factor float32,
) (ret bool) {

	cRet := C.cefingo_image_has_representation(self.p_image, (C.float)(scale_factor))

	ret = cRet == 1
	return ret
}

///
// Removes the representation for |scale_factor|. Returns true (1) on success.
///
func (self *CImageT) RemoveRepresentation(
	scale_factor float32,
) (ret bool) {

	cRet := C.cefingo_image_remove_representation(self.p_image, (C.float)(scale_factor))

	ret = cRet == 1
	return ret
}

///
// Returns information for the representation that most closely matches
// |scale_factor|. |actual_scale_factor| is the actual scale factor for the
// representation. |pixel_width| and |pixel_height| are the representation
// size in pixel coordinates. Returns true (1) on success.
///
func (self *CImageT) GetRepresentationInfo(
	scale_factor float32,
) (ret bool, actual_scale_factor float32, pixel_width int, pixel_height int) {
	var tmpactual_scale_factor C.float
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_representation_info(self.p_image, (C.float)(scale_factor), &tmpactual_scale_factor, &tmppixel_width, &tmppixel_height)

	actual_scale_factor = (float32)(tmpactual_scale_factor)
	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = cRet == 1
	return ret, actual_scale_factor, pixel_width, pixel_height
}

///
// Returns the bitmap representation that most closely matches |scale_factor|.
// Only 32-bit RGBA/BGRA formats are supported. |color_type| and |alpha_type|
// values specify the desired output pixel format. |pixel_width| and
// |pixel_height| are the output representation size in pixel coordinates.
// Returns a cef_binary_value_t containing the pixel data on success or NULL
// on failure.
///
func (self *CImageT) GetAsBitmap(
	scale_factor float32,
	color_type CColorTypeT,
	alpha_type CAlphaTypeT,
) (ret *CBinaryValueT, pixel_width int, pixel_height int) {
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_as_bitmap(self.p_image, (C.float)(scale_factor), (C.cef_color_type_t)(color_type), (C.cef_alpha_type_t)(alpha_type), &tmppixel_width, &tmppixel_height)

	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = newCBinaryValueT(cRet)
	return ret, pixel_width, pixel_height
}

///
// Returns the PNG representation that most closely matches |scale_factor|. If
// |with_transparency| is true (1) any alpha transparency in the image will be
// represented in the resulting PNG data. |pixel_width| and |pixel_height| are
// the output representation size in pixel coordinates. Returns a
// cef_binary_value_t containing the PNG image data on success or NULL on
// failure.
///
func (self *CImageT) GetAsPng(
	scale_factor float32,
	with_transparency int,
) (ret *CBinaryValueT, pixel_width int, pixel_height int) {
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_as_png(self.p_image, (C.float)(scale_factor), (C.int)(with_transparency), &tmppixel_width, &tmppixel_height)

	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = newCBinaryValueT(cRet)
	return ret, pixel_width, pixel_height
}

///
// Returns the JPEG representation that most closely matches |scale_factor|.
// |quality| determines the compression level with 0 == lowest and 100 ==
// highest. The JPEG format does not support alpha transparency and the alpha
// channel, if any, will be discarded. |pixel_width| and |pixel_height| are
// the output representation size in pixel coordinates. Returns a
// cef_binary_value_t containing the JPEG image data on success or NULL on
// failure.
///
func (self *CImageT) GetAsJpeg(
	scale_factor float32,
	quality int,
) (ret *CBinaryValueT, pixel_width int, pixel_height int) {
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_as_jpeg(self.p_image, (C.float)(scale_factor), (C.int)(quality), &tmppixel_width, &tmppixel_height)

	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = newCBinaryValueT(cRet)
	return ret, pixel_width, pixel_height
}

///
// Create a new cef_image_t. It will initially be NULL. Use the Add*() functions
// to add representations at different scale factors.
///
func ImageCreate() (ret *CImageT) {

	cRet := C.cef_image_create()

	ret = newCImageT(cRet)
	return ret
}

// cef_jsdialog_handler_capi.h, include/capi/cef_jsdialog_handler_capi.h:67:3,

///
// Callback structure used for asynchronous continuation of JavaScript dialog
// requests.
///

// Go type for cef_jsdialog_callback_t
type CJsdialogCallbackT struct {
	noCopy              noCopy
	p_jsdialog_callback *C.cef_jsdialog_callback_t
}

type RefToCJsdialogCallbackT struct {
	p_jsdialog_callback *CJsdialogCallbackT
}

type CJsdialogCallbackTAccessor interface {
	GetCJsdialogCallbackT() *CJsdialogCallbackT
	SetCJsdialogCallbackT(*CJsdialogCallbackT)
}

func (r RefToCJsdialogCallbackT) GetCJsdialogCallbackT() *CJsdialogCallbackT {
	return r.p_jsdialog_callback
}

func (r *RefToCJsdialogCallbackT) SetCJsdialogCallbackT(p *CJsdialogCallbackT) {
	r.p_jsdialog_callback = p
}

// Go type CJsdialogCallbackT wraps cef type *C.cef_jsdialog_callback_t
func newCJsdialogCallbackT(p *C.cef_jsdialog_callback_t) *CJsdialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T10093:")
	BaseAddRef(p)
	go_jsdialog_callback := CJsdialogCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_jsdialog_callback, func(g *CJsdialogCallbackT) {
		Tracef(unsafe.Pointer(g.p_jsdialog_callback), "T10097:")
		BaseRelease(g.p_jsdialog_callback)
	})
	return &go_jsdialog_callback
}

// *C.cef_jsdialog_callback_t has refCounted interface
func (jsdialog_callback *CJsdialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(jsdialog_callback.p_jsdialog_callback)
}

func (p *C.cef_jsdialog_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Continue the JS dialog request. Set |success| to true (1) if the OK button
// was pressed. The |user_input| value should be specified for prompt dialogs.
///
func (self *CJsdialogCallbackT) Cont(
	success int,
	user_input string,
) {
	c_user_input := create_cef_string(user_input)
	defer clear_cef_string(c_user_input)

	C.cefingo_jsdialog_callback_cont(self.p_jsdialog_callback, (C.int)(success), (*C.cef_string_t)(c_user_input))

}

///
// Implement this structure to handle events related to JavaScript dialogs. The
// functions of this structure will be called on the UI thread.
///

// Go type for cef_jsdialog_handler_t
type CJsdialogHandlerT struct {
	noCopy             noCopy
	p_jsdialog_handler *C.cef_jsdialog_handler_t
}

type RefToCJsdialogHandlerT struct {
	p_jsdialog_handler *CJsdialogHandlerT
}

type CJsdialogHandlerTAccessor interface {
	GetCJsdialogHandlerT() *CJsdialogHandlerT
	SetCJsdialogHandlerT(*CJsdialogHandlerT)
}

func (r RefToCJsdialogHandlerT) GetCJsdialogHandlerT() *CJsdialogHandlerT {
	return r.p_jsdialog_handler
}

func (r *RefToCJsdialogHandlerT) SetCJsdialogHandlerT(p *CJsdialogHandlerT) {
	r.p_jsdialog_handler = p
}

// Go type CJsdialogHandlerT wraps cef type *C.cef_jsdialog_handler_t
func newCJsdialogHandlerT(p *C.cef_jsdialog_handler_t) *CJsdialogHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T10160:")
	BaseAddRef(p)
	go_jsdialog_handler := CJsdialogHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_jsdialog_handler, func(g *CJsdialogHandlerT) {
		Tracef(unsafe.Pointer(g.p_jsdialog_handler), "T10164:")
		BaseRelease(g.p_jsdialog_handler)
	})
	return &go_jsdialog_handler
}

// *C.cef_jsdialog_handler_t has refCounted interface
func (jsdialog_handler *CJsdialogHandlerT) HasOneRef() bool {
	return BaseHasOneRef(jsdialog_handler.p_jsdialog_handler)
}

func (p *C.cef_jsdialog_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
// and user-friendly display string. The |default_prompt_text| value will be
// specified for prompt dialogs only. Set |suppress_message| to true (1) and
// return false (0) to suppress the message (suppressing messages is
// preferable to immediately executing the callback as this is used to detect
// presumably malicious behavior like spamming alert messages in
// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
// to use the default implementation (the default implementation will show one
// modal dialog at a time and suppress any additional dialog requests until
// the displayed dialog is dismissed). Return true (1) if the application will
// use a custom dialog or if the callback has been executed immediately.
// Custom dialogs may be either modal or modeless. If a custom dialog is used
// the application must execute |callback| once the custom dialog is
// dismissed.
///
type OnJsdialogHandler interface {
	OnJsdialog(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
		origin_url string,
		dialog_type CJsdialogTypeT,
		message_text string,
		default_prompt_text string,
		callback *CJsdialogCallbackT,
	) (ret bool, suppress_message int)
}

///
// Called to run a dialog asking the user if they want to leave a page. Return
// false (0) to use the default dialog implementation. Return true (1) if the
// application will use a custom dialog or if the callback has been executed
// immediately. Custom dialogs may be either modal or modeless. If a custom
// dialog is used the application must execute |callback| once the custom
// dialog is dismissed.
///
type OnBeforeUnloadDialogHandler interface {
	OnBeforeUnloadDialog(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
		message_text string,
		is_reload int,
		callback *CJsdialogCallbackT,
	) (ret bool)
}

///
// Called to cancel any pending dialogs and reset any saved dialog state. Will
// be called due to events like page navigation irregardless of whether any
// dialogs are currently pending.
///
type OnResetDialogStateHandler interface {
	OnResetDialogState(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
	)
}

///
// Called when the default implementation dialog is closed.
///
type OnDialogClosedHandler interface {
	OnDialogClosed(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
	)
}

var jsdialog_handler_handlers = struct {
	on_jsdialog_handler             map[*C.cef_jsdialog_handler_t]OnJsdialogHandler
	on_before_unload_dialog_handler map[*C.cef_jsdialog_handler_t]OnBeforeUnloadDialogHandler
	on_reset_dialog_state_handler   map[*C.cef_jsdialog_handler_t]OnResetDialogStateHandler
	on_dialog_closed_handler        map[*C.cef_jsdialog_handler_t]OnDialogClosedHandler
}{
	map[*C.cef_jsdialog_handler_t]OnJsdialogHandler{},
	map[*C.cef_jsdialog_handler_t]OnBeforeUnloadDialogHandler{},
	map[*C.cef_jsdialog_handler_t]OnResetDialogStateHandler{},
	map[*C.cef_jsdialog_handler_t]OnDialogClosedHandler{},
}

// AllocCJsdialogHandlerT allocates CJsdialogHandlerT and construct it
func AllocCJsdialogHandlerT() *CJsdialogHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_jsdialog_handler_wrapper_t, "T10262:")
	cefp := C.cefingo_construct_jsdialog_handler((*C.cefingo_jsdialog_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_jsdialog_handler_t itself in DeassocFunc,
		// or cef_jsdialog_handler_t is never GCed.
		Tracef(up, "T10268:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(jsdialog_handler_handlers.on_jsdialog_handler, cefp)
		delete(jsdialog_handler_handlers.on_before_unload_dialog_handler, cefp)
		delete(jsdialog_handler_handlers.on_reset_dialog_state_handler, cefp)
		delete(jsdialog_handler_handlers.on_dialog_closed_handler, cefp)
	}))

	return newCJsdialogHandlerT(cefp)
}

func (jsdialog_handler *CJsdialogHandlerT) Bind(a interface{}) *CJsdialogHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := jsdialog_handler.p_jsdialog_handler

	if h, ok := a.(OnJsdialogHandler); ok {
		jsdialog_handler_handlers.on_jsdialog_handler[cp] = h
	}

	if h, ok := a.(OnBeforeUnloadDialogHandler); ok {
		jsdialog_handler_handlers.on_before_unload_dialog_handler[cp] = h
	}

	if h, ok := a.(OnResetDialogStateHandler); ok {
		jsdialog_handler_handlers.on_reset_dialog_state_handler[cp] = h
	}

	if h, ok := a.(OnDialogClosedHandler); ok {
		jsdialog_handler_handlers.on_dialog_closed_handler[cp] = h
	}

	if accessor, ok := a.(CJsdialogHandlerTAccessor); ok {
		accessor.SetCJsdialogHandlerT(jsdialog_handler)
		Logf("T10317:")
	}

	return jsdialog_handler
}

// cef_keyboard_handler_capi.h, include/capi/cef_keyboard_handler_capi.h:83:3,

///
// Implement this structure to handle events related to keyboard input. The
// functions of this structure will be called on the UI thread.
///

// Go type for cef_keyboard_handler_t
type CKeyboardHandlerT struct {
	noCopy             noCopy
	p_keyboard_handler *C.cef_keyboard_handler_t
}

type RefToCKeyboardHandlerT struct {
	p_keyboard_handler *CKeyboardHandlerT
}

type CKeyboardHandlerTAccessor interface {
	GetCKeyboardHandlerT() *CKeyboardHandlerT
	SetCKeyboardHandlerT(*CKeyboardHandlerT)
}

func (r RefToCKeyboardHandlerT) GetCKeyboardHandlerT() *CKeyboardHandlerT {
	return r.p_keyboard_handler
}

func (r *RefToCKeyboardHandlerT) SetCKeyboardHandlerT(p *CKeyboardHandlerT) {
	r.p_keyboard_handler = p
}

// Go type CKeyboardHandlerT wraps cef type *C.cef_keyboard_handler_t
func newCKeyboardHandlerT(p *C.cef_keyboard_handler_t) *CKeyboardHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T10345:")
	BaseAddRef(p)
	go_keyboard_handler := CKeyboardHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_keyboard_handler, func(g *CKeyboardHandlerT) {
		Tracef(unsafe.Pointer(g.p_keyboard_handler), "T10349:")
		BaseRelease(g.p_keyboard_handler)
	})
	return &go_keyboard_handler
}

// *C.cef_keyboard_handler_t has refCounted interface
func (keyboard_handler *CKeyboardHandlerT) HasOneRef() bool {
	return BaseHasOneRef(keyboard_handler.p_keyboard_handler)
}

func (p *C.cef_keyboard_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called before a keyboard event is sent to the renderer. |event| contains
// information about the keyboard event. |os_event| is the operating system
// event message, if any. Return true (1) if the event was handled or false
// (0) otherwise. If the event will be handled in on_key_event() as a keyboard
// shortcut set |is_keyboard_shortcut| to true (1) and return false (0).
///
type OnPreKeyEventHandler interface {
	OnPreKeyEvent(
		self *CKeyboardHandlerT,
		browser *CBrowserT,
		event *CKeyEventT,
		os_event CEventHandleT,
	) (ret bool, is_keyboard_shortcut int)
}

///
// Called after the renderer and JavaScript in the page has had a chance to
// handle the event. |event| contains information about the keyboard event.
// |os_event| is the operating system event message, if any. Return true (1)
// if the keyboard event was handled or false (0) otherwise.
///
type CKeyboardHandlerTOnKeyEventHandler interface {
	OnKeyEvent(
		self *CKeyboardHandlerT,
		browser *CBrowserT,
		event *CKeyEventT,
		os_event CEventHandleT,
	) (ret bool)
}

var keyboard_handler_handlers = struct {
	on_pre_key_event_handler map[*C.cef_keyboard_handler_t]OnPreKeyEventHandler
	on_key_event_handler     map[*C.cef_keyboard_handler_t]CKeyboardHandlerTOnKeyEventHandler
}{
	map[*C.cef_keyboard_handler_t]OnPreKeyEventHandler{},
	map[*C.cef_keyboard_handler_t]CKeyboardHandlerTOnKeyEventHandler{},
}

// AllocCKeyboardHandlerT allocates CKeyboardHandlerT and construct it
func AllocCKeyboardHandlerT() *CKeyboardHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_keyboard_handler_wrapper_t, "T10405:")
	cefp := C.cefingo_construct_keyboard_handler((*C.cefingo_keyboard_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_keyboard_handler_t itself in DeassocFunc,
		// or cef_keyboard_handler_t is never GCed.
		Tracef(up, "T10411:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(keyboard_handler_handlers.on_pre_key_event_handler, cefp)
		delete(keyboard_handler_handlers.on_key_event_handler, cefp)
	}))

	return newCKeyboardHandlerT(cefp)
}

func (keyboard_handler *CKeyboardHandlerT) Bind(a interface{}) *CKeyboardHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := keyboard_handler.p_keyboard_handler

	if h, ok := a.(OnPreKeyEventHandler); ok {
		keyboard_handler_handlers.on_pre_key_event_handler[cp] = h
	}

	if h, ok := a.(CKeyboardHandlerTOnKeyEventHandler); ok {
		keyboard_handler_handlers.on_key_event_handler[cp] = h
	}

	if accessor, ok := a.(CKeyboardHandlerTAccessor); ok {
		accessor.SetCKeyboardHandlerT(keyboard_handler)
		Logf("T10450:")
	}

	return keyboard_handler
}

// cef_label_button_capi.h, include/capi/views/cef_label_button_capi.h:146:3,

///
// LabelButton is a button with optional text and/or icon. Methods must be
// called on the browser process UI thread unless otherwise indicated.
///

// Go type for cef_label_button_t
type CLabelButtonT struct {
	noCopy         noCopy
	p_label_button *C.cef_label_button_t
}

type RefToCLabelButtonT struct {
	p_label_button *CLabelButtonT
}

type CLabelButtonTAccessor interface {
	GetCLabelButtonT() *CLabelButtonT
	SetCLabelButtonT(*CLabelButtonT)
}

func (r RefToCLabelButtonT) GetCLabelButtonT() *CLabelButtonT {
	return r.p_label_button
}

func (r *RefToCLabelButtonT) SetCLabelButtonT(p *CLabelButtonT) {
	r.p_label_button = p
}

// Go type CLabelButtonT wraps cef type *C.cef_label_button_t
func newCLabelButtonT(p *C.cef_label_button_t) *CLabelButtonT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T10478:")
	BaseAddRef(p)
	go_label_button := CLabelButtonT{noCopy{}, p}
	runtime.SetFinalizer(&go_label_button, func(g *CLabelButtonT) {
		Tracef(unsafe.Pointer(g.p_label_button), "T10482:")
		BaseRelease(g.p_label_button)
	})
	return &go_label_button
}

// *C.cef_label_button_t has refCounted interface
func (label_button *CLabelButtonT) HasOneRef() bool {
	return BaseHasOneRef(label_button.p_label_button)
}

func (p *C.cef_label_button_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (label_button *CLabelButtonT) ToCButtonT() *CButtonT {
	p := (*C.cef_button_t)(unsafe.Pointer(label_button.p_label_button))
	return newCButtonT(p)
}

///
// Returns this LabelButton as a MenuButton or NULL if this is not a
// MenuButton.
///
func (self *CLabelButtonT) AsMenuButton() (ret *CMenuButtonT) {

	cRet := C.cefingo_label_button_as_menu_button(self.p_label_button)

	ret = newCMenuButtonT(cRet)
	return ret
}

///
// Sets the text shown on the LabelButton. By default |text| will also be used
// as the accessible name.
///
func (self *CLabelButtonT) SetText(
	text string,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_label_button_set_text(self.p_label_button, (*C.cef_string_t)(c_text))

}

///
// Returns the text shown on the LabelButton.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CLabelButtonT) GetText() (ret string) {

	cRet := C.cefingo_label_button_get_text(self.p_label_button)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the image shown for |button_state|. When this Button is drawn if no
// image exists for the current state then the image for
// CEF_BUTTON_STATE_NORMAL, if any, will be shown.
///
func (self *CLabelButtonT) SetImage(
	button_state CButtonStateT,
	image *CImageT,
) {
	var goTmpimage *C.cef_image_t
	if image != nil {
		goTmpimage = image.p_image
		BaseAddRef(goTmpimage)
	}

	C.cefingo_label_button_set_image(self.p_label_button, (C.cef_button_state_t)(button_state), goTmpimage)

}

///
// Returns the image shown for |button_state|. If no image exists for that
// state then the image for CEF_BUTTON_STATE_NORMAL will be returned.
///
func (self *CLabelButtonT) GetImage(
	button_state CButtonStateT,
) (ret *CImageT) {

	cRet := C.cefingo_label_button_get_image(self.p_label_button, (C.cef_button_state_t)(button_state))

	ret = newCImageT(cRet)
	return ret
}

///
// Sets the text color shown for the specified button |for_state| to |color|.
///
func (self *CLabelButtonT) SetTextColor(
	for_state CButtonStateT,
	color CColorT,
) {

	C.cefingo_label_button_set_text_color(self.p_label_button, (C.cef_button_state_t)(for_state), (C.cef_color_t)(color))

}

///
// Sets the text colors shown for the non-disabled states to |color|.
///
func (self *CLabelButtonT) SetEnabledTextColors(
	color CColorT,
) {

	C.cefingo_label_button_set_enabled_text_colors(self.p_label_button, (C.cef_color_t)(color))

}

///
// Sets the font list. The format is &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;,
// where: - FONT_FAMILY_LIST is a comma-separated list of font family names, -
// STYLES is an optional space-separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CLabelButtonT) SetFontList(
	font_list string,
) {
	c_font_list := create_cef_string(font_list)
	defer clear_cef_string(c_font_list)

	C.cefingo_label_button_set_font_list(self.p_label_button, (*C.cef_string_t)(c_font_list))

}

///
// Sets the horizontal alignment; reversed in RTL. Default is
// CEF_HORIZONTAL_ALIGNMENT_CENTER.
///
func (self *CLabelButtonT) SetHorizontalAlignment(
	alignment CHorizontalAlignmentT,
) {

	C.cefingo_label_button_set_horizontal_alignment(self.p_label_button, (C.cef_horizontal_alignment_t)(alignment))

}

///
// Reset the minimum size of this LabelButton to |size|.
///
func (self *CLabelButtonT) SetMinimumSize(
	size *CSizeT,
) {

	C.cefingo_label_button_set_minimum_size(self.p_label_button, (*C.cef_size_t)(size))

}

///
// Reset the maximum size of this LabelButton to |size|.
///
func (self *CLabelButtonT) SetMaximumSize(
	size *CSizeT,
) {

	C.cefingo_label_button_set_maximum_size(self.p_label_button, (*C.cef_size_t)(size))

}

///
// Create a new LabelButton. A |delegate| must be provided to handle the button
// click. |text| will be shown on the LabelButton and used as the default
// accessible name.
///
func LabelButtonCreate(
	delegate *CButtonDelegateT,
	text string,
) (ret *CLabelButtonT) {
	var goTmpdelegate *C.cef_button_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_button_delegate
		BaseAddRef(goTmpdelegate)
	}
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	cRet := C.cef_label_button_create(goTmpdelegate, (*C.cef_string_t)(c_text))

	ret = newCLabelButtonT(cRet)
	return ret
}

// cef_layout_capi.h, include/capi/views/cef_layout_capi.h:79:3,

///
// A Layout handles the sizing of the children of a Panel according to
// implementation-specific heuristics. Methods must be called on the browser
// process UI thread unless otherwise indicated.
///

// Go type for cef_layout_t
type CLayoutT struct {
	noCopy   noCopy
	p_layout *C.cef_layout_t
}

type RefToCLayoutT struct {
	p_layout *CLayoutT
}

type CLayoutTAccessor interface {
	GetCLayoutT() *CLayoutT
	SetCLayoutT(*CLayoutT)
}

func (r RefToCLayoutT) GetCLayoutT() *CLayoutT {
	return r.p_layout
}

func (r *RefToCLayoutT) SetCLayoutT(p *CLayoutT) {
	r.p_layout = p
}

// Go type CLayoutT wraps cef type *C.cef_layout_t
func newCLayoutT(p *C.cef_layout_t) *CLayoutT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T10726:")
	BaseAddRef(p)
	go_layout := CLayoutT{noCopy{}, p}
	runtime.SetFinalizer(&go_layout, func(g *CLayoutT) {
		Tracef(unsafe.Pointer(g.p_layout), "T10730:")
		BaseRelease(g.p_layout)
	})
	return &go_layout
}

// *C.cef_layout_t has refCounted interface
func (layout *CLayoutT) HasOneRef() bool {
	return BaseHasOneRef(layout.p_layout)
}

func (p *C.cef_layout_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns this Layout as a BoxLayout or NULL if this is not a BoxLayout.
///
func (self *CLayoutT) AsBoxLayout() (ret *CBoxLayoutT) {

	cRet := C.cefingo_layout_as_box_layout(self.p_layout)

	ret = newCBoxLayoutT(cRet)
	return ret
}

///
// Returns this Layout as a FillLayout or NULL if this is not a FillLayout.
///
func (self *CLayoutT) AsFillLayout() (ret *CFillLayoutT) {

	cRet := C.cefingo_layout_as_fill_layout(self.p_layout)

	ret = newCFillLayoutT(cRet)
	return ret
}

///
// Returns true (1) if this Layout is valid.
///
func (self *CLayoutT) IsValid() (ret bool) {

	cRet := C.cefingo_layout_is_valid(self.p_layout)

	ret = cRet == 1
	return ret
}

// cef_life_span_handler_capi.h, include/capi/cef_life_span_handler_capi.h:215:3,

///
// Implement this structure to handle events related to browser life span. The
// functions of this structure will be called on the UI thread unless otherwise
// indicated.
///

// Go type for cef_life_span_handler_t
type CLifeSpanHandlerT struct {
	noCopy              noCopy
	p_life_span_handler *C.cef_life_span_handler_t
}

type RefToCLifeSpanHandlerT struct {
	p_life_span_handler *CLifeSpanHandlerT
}

type CLifeSpanHandlerTAccessor interface {
	GetCLifeSpanHandlerT() *CLifeSpanHandlerT
	SetCLifeSpanHandlerT(*CLifeSpanHandlerT)
}

func (r RefToCLifeSpanHandlerT) GetCLifeSpanHandlerT() *CLifeSpanHandlerT {
	return r.p_life_span_handler
}

func (r *RefToCLifeSpanHandlerT) SetCLifeSpanHandlerT(p *CLifeSpanHandlerT) {
	r.p_life_span_handler = p
}

// Go type CLifeSpanHandlerT wraps cef type *C.cef_life_span_handler_t
func newCLifeSpanHandlerT(p *C.cef_life_span_handler_t) *CLifeSpanHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T10819:")
	BaseAddRef(p)
	go_life_span_handler := CLifeSpanHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_life_span_handler, func(g *CLifeSpanHandlerT) {
		Tracef(unsafe.Pointer(g.p_life_span_handler), "T10823:")
		BaseRelease(g.p_life_span_handler)
	})
	return &go_life_span_handler
}

// *C.cef_life_span_handler_t has refCounted interface
func (life_span_handler *CLifeSpanHandlerT) HasOneRef() bool {
	return BaseHasOneRef(life_span_handler.p_life_span_handler)
}

func (p *C.cef_life_span_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the UI thread before a new popup browser is created. The
// |browser| and |frame| values represent the source of the popup request. The
// |target_url| and |target_frame_name| values indicate where the popup
// browser should navigate and may be NULL if not specified with the request.
// The |target_disposition| value indicates where the user intended to open
// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
// be true (1) if the popup was opened via explicit user gesture (e.g.
// clicking a link) or false (0) if the popup opened automatically (e.g. via
// the DomContentLoaded event). The |popupFeatures| structure contains
// additional information about the requested popup window. To allow creation
// of the popup browser optionally modify |windowInfo|, |client|, |settings|
// and |no_javascript_access| and return false (0). To cancel creation of the
// popup browser return true (1). The |client| and |settings| values will
// default to the source browser&#39;s values. If the |no_javascript_access| value
// is set to false (0) the new browser will not be scriptable and may not be
// hosted in the same renderer process as the source browser. Any
// modifications to |windowInfo| will be ignored if the parent browser is
// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
// the parent browser is destroyed before the popup browser creation completes
// (indicated by a call to OnAfterCreated for the popup browser). The
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created popup browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
type OnBeforePopupHandler interface {
	OnBeforePopup(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		target_url string,
		target_frame_name string,
		target_disposition CWindowOpenDispositionT,
		user_gesture int,
		popupFeatures *CPopupFeaturesT,
		windowInfo CWindowInfoT,
		client *CClientT,
		settings CBrowserSettingsT,
		no_javascript_access bool,
	) (ret bool, windowInfoOut CWindowInfoT, clientOut *CClientT, settingsOut CBrowserSettingsT, extra_info *CDictionaryValueT, no_javascript_accessOut bool)
}

///
// Called after a new browser is created. This callback will be the first
// notification that references |browser|.
///
type OnAfterCreatedHandler interface {
	OnAfterCreated(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
	)
}

///
// Called when a browser has recieved a request to close. This may result
// directly from a call to cef_browser_host_t::*close_browser() or indirectly
// if the browser is parented to a top-level window created by CEF and the
// user attempts to close that window (by clicking the &#39;X&#39;, for example). The
// do_close() function will be called after the JavaScript &#39;onunload&#39; event
// has been fired.
//
// An application should handle top-level owner window close notifications by
// calling cef_browser_host_t::try_close_browser() or
// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
// to close immediately (see the examples below). This gives CEF an
// opportunity to process the &#39;onbeforeunload&#39; event and optionally cancel the
// close before do_close() is called.
//
// When windowed rendering is enabled CEF will internally create a window or
// view to host the browser. In that case returning false (0) from do_close()
// will send the standard close notification to the browser&#39;s top-level owner
// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
// Linux or cef_window_delegate_t::can_close() callback from Views). If the
// browser&#39;s host window/view has already been destroyed (via view hierarchy
// tear-down, for example) then do_close() will not be called for that browser
// since is no longer possible to cancel the close.
//
// When windowed rendering is disabled returning false (0) from do_close()
// will cause the browser object to be destroyed immediately.
//
// If the browser&#39;s top-level owner window requires a non-standard close
// notification then send that notification from do_close() and return true
// (1).
//
// The cef_life_span_handler_t::on_before_close() function will be called
// after do_close() (if do_close() is called) and immediately before the
// browser object is destroyed. The application should only exit after
// on_before_close() has been called for all existing browsers.
//
// The below examples describe what should happen during window close when the
// browser is parented to an application-provided top-level window.
//
// Example 1: Using cef_browser_host_t::try_close_browser(). This is
// recommended for clients using standard close handling and windows created
// on the browser process UI thread. 1.  User clicks the window close button
// which sends a close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
//     TryCloseBrowser() returns false so the client cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// CEF sends a close notification to the application&#39;s top-level window
//     (because DoClose() returned false by default).
// 7.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
//     allows the window close.
// 8.  Application&#39;s top-level window is destroyed. 9.  Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 10. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
//
// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
// implementing the do_close() callback. This is recommended for clients using
// non-standard close handling or windows that were not created on the browser
// process UI thread. 1.  User clicks the window close button which sends a
// close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and:
//     A. Calls CefBrowserHost::CloseBrowser(false).
//     B. Cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// Application&#39;s do_close() handler is called. Application will:
//     A. Set a flag to indicate that the next close attempt will be allowed.
//     B. Return false.
// 7.  CEF sends an close notification to the application&#39;s top-level window.
// 8.  Application&#39;s top-level window receives the close notification and
//     allows the window to close based on the flag from #6B.
// 9.  Application&#39;s top-level window is destroyed. 10. Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 11. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
///
type DoCloseHandler interface {
	DoClose(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
	) (ret bool)
}

///
// Called just before a browser is destroyed. Release all references to the
// browser object and do not attempt to execute any functions on the browser
// object (other than GetIdentifier or IsSame) after this callback returns.
// This callback will be the last notification that references |browser| on
// the UI thread. Any in-progress network requests associated with |browser|
// will be aborted when the browser is destroyed, and
// cef_resource_request_handler_t callbacks related to those requests may
// still arrive on the IO thread after this function is called. See do_close()
// documentation for additional usage information.
///
type OnBeforeCloseHandler interface {
	OnBeforeClose(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
	)
}

var life_span_handler_handlers = struct {
	on_before_popup_handler  map[*C.cef_life_span_handler_t]OnBeforePopupHandler
	on_after_created_handler map[*C.cef_life_span_handler_t]OnAfterCreatedHandler
	do_close_handler         map[*C.cef_life_span_handler_t]DoCloseHandler
	on_before_close_handler  map[*C.cef_life_span_handler_t]OnBeforeCloseHandler
}{
	map[*C.cef_life_span_handler_t]OnBeforePopupHandler{},
	map[*C.cef_life_span_handler_t]OnAfterCreatedHandler{},
	map[*C.cef_life_span_handler_t]DoCloseHandler{},
	map[*C.cef_life_span_handler_t]OnBeforeCloseHandler{},
}

// AllocCLifeSpanHandlerT allocates CLifeSpanHandlerT and construct it
func AllocCLifeSpanHandlerT() *CLifeSpanHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_life_span_handler_wrapper_t, "T11019:")
	cefp := C.cefingo_construct_life_span_handler((*C.cefingo_life_span_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_life_span_handler_t itself in DeassocFunc,
		// or cef_life_span_handler_t is never GCed.
		Tracef(up, "T11025:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(life_span_handler_handlers.on_before_popup_handler, cefp)
		delete(life_span_handler_handlers.on_after_created_handler, cefp)
		delete(life_span_handler_handlers.do_close_handler, cefp)
		delete(life_span_handler_handlers.on_before_close_handler, cefp)
	}))

	return newCLifeSpanHandlerT(cefp)
}

func (life_span_handler *CLifeSpanHandlerT) Bind(a interface{}) *CLifeSpanHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := life_span_handler.p_life_span_handler

	if h, ok := a.(OnBeforePopupHandler); ok {
		life_span_handler_handlers.on_before_popup_handler[cp] = h
	}

	if h, ok := a.(OnAfterCreatedHandler); ok {
		life_span_handler_handlers.on_after_created_handler[cp] = h
	}

	if h, ok := a.(DoCloseHandler); ok {
		life_span_handler_handlers.do_close_handler[cp] = h
	}

	if h, ok := a.(OnBeforeCloseHandler); ok {
		life_span_handler_handlers.on_before_close_handler[cp] = h
	}

	if accessor, ok := a.(CLifeSpanHandlerTAccessor); ok {
		accessor.SetCLifeSpanHandlerT(life_span_handler)
		Logf("T11074:")
	}

	return life_span_handler
}

// cef_load_handler_capi.h, include/capi/cef_load_handler_capi.h:120:3,

///
// Implement this structure to handle events related to browser load status. The
// functions of this structure will be called on the browser process UI thread
// or render process main thread (TID_RENDERER).
///

// Go type for cef_load_handler_t
type CLoadHandlerT struct {
	noCopy         noCopy
	p_load_handler *C.cef_load_handler_t
}

type RefToCLoadHandlerT struct {
	p_load_handler *CLoadHandlerT
}

type CLoadHandlerTAccessor interface {
	GetCLoadHandlerT() *CLoadHandlerT
	SetCLoadHandlerT(*CLoadHandlerT)
}

func (r RefToCLoadHandlerT) GetCLoadHandlerT() *CLoadHandlerT {
	return r.p_load_handler
}

func (r *RefToCLoadHandlerT) SetCLoadHandlerT(p *CLoadHandlerT) {
	r.p_load_handler = p
}

// Go type CLoadHandlerT wraps cef type *C.cef_load_handler_t
func newCLoadHandlerT(p *C.cef_load_handler_t) *CLoadHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T11103:")
	BaseAddRef(p)
	go_load_handler := CLoadHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_load_handler, func(g *CLoadHandlerT) {
		Tracef(unsafe.Pointer(g.p_load_handler), "T11107:")
		BaseRelease(g.p_load_handler)
	})
	return &go_load_handler
}

// *C.cef_load_handler_t has refCounted interface
func (load_handler *CLoadHandlerT) HasOneRef() bool {
	return BaseHasOneRef(load_handler.p_load_handler)
}

func (p *C.cef_load_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called when the loading state has changed. This callback will be executed
// twice -- once when loading is initiated either programmatically or by user
// action, and once when loading is terminated due to completion, cancellation
// of failure. It will be called before any calls to OnLoadStart and after all
// calls to OnLoadError and/or OnLoadEnd.
///
type OnLoadingStateChangeHandler interface {
	OnLoadingStateChange(
		self *CLoadHandlerT,
		browser *CBrowserT,
		isLoading bool,
		canGoBack bool,
		canGoForward bool,
	)
}

///
// Called after a navigation has been committed and before the browser begins
// loading contents in the frame. The |frame| value will never be NULL -- call
// the is_main() function to check if this frame is the main frame.
// |transition_type| provides information about the source of the navigation
// and an accurate value is only available in the browser process. Multiple
// frames may be loading at the same time. Sub-frames may start or continue
// loading after the main frame load has ended. This function will not be
// called for same page navigations (fragments, history state, etc.) or for
// navigations that fail or are canceled before commit. For notification of
// overall browser load status use OnLoadingStateChange instead.
///
type OnLoadStartHandler interface {
	OnLoadStart(
		self *CLoadHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		transition_type CTransitionTypeT,
	)
}

///
// Called when the browser is done loading a frame. The |frame| value will
// never be NULL -- call the is_main() function to check if this frame is the
// main frame. Multiple frames may be loading at the same time. Sub-frames may
// start or continue loading after the main frame load has ended. This
// function will not be called for same page navigations (fragments, history
// state, etc.) or for navigations that fail or are canceled before commit.
// For notification of overall browser load status use OnLoadingStateChange
// instead.
///
type OnLoadEndHandler interface {
	OnLoadEnd(
		self *CLoadHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		httpStatusCode int,
	)
}

///
// Called when a navigation fails or is canceled. This function may be called
// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
// after commit. |errorCode| is the error code number, |errorText| is the
// error text and |failedUrl| is the URL that failed to load. See
// net\base\net_error_list.h for complete descriptions of the error codes.
///
type OnLoadErrorHandler interface {
	OnLoadError(
		self *CLoadHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		errorCode CErrorcodeT,
		errorText string,
		failedUrl string,
	)
}

var load_handler_handlers = struct {
	on_loading_state_change_handler map[*C.cef_load_handler_t]OnLoadingStateChangeHandler
	on_load_start_handler           map[*C.cef_load_handler_t]OnLoadStartHandler
	on_load_end_handler             map[*C.cef_load_handler_t]OnLoadEndHandler
	on_load_error_handler           map[*C.cef_load_handler_t]OnLoadErrorHandler
}{
	map[*C.cef_load_handler_t]OnLoadingStateChangeHandler{},
	map[*C.cef_load_handler_t]OnLoadStartHandler{},
	map[*C.cef_load_handler_t]OnLoadEndHandler{},
	map[*C.cef_load_handler_t]OnLoadErrorHandler{},
}

// AllocCLoadHandlerT allocates CLoadHandlerT and construct it
func AllocCLoadHandlerT() *CLoadHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_load_handler_wrapper_t, "T11211:")
	cefp := C.cefingo_construct_load_handler((*C.cefingo_load_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_load_handler_t itself in DeassocFunc,
		// or cef_load_handler_t is never GCed.
		Tracef(up, "T11217:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(load_handler_handlers.on_loading_state_change_handler, cefp)
		delete(load_handler_handlers.on_load_start_handler, cefp)
		delete(load_handler_handlers.on_load_end_handler, cefp)
		delete(load_handler_handlers.on_load_error_handler, cefp)
	}))

	return newCLoadHandlerT(cefp)
}

func (load_handler *CLoadHandlerT) Bind(a interface{}) *CLoadHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := load_handler.p_load_handler

	if h, ok := a.(OnLoadingStateChangeHandler); ok {
		load_handler_handlers.on_loading_state_change_handler[cp] = h
	}

	if h, ok := a.(OnLoadStartHandler); ok {
		load_handler_handlers.on_load_start_handler[cp] = h
	}

	if h, ok := a.(OnLoadEndHandler); ok {
		load_handler_handlers.on_load_end_handler[cp] = h
	}

	if h, ok := a.(OnLoadErrorHandler); ok {
		load_handler_handlers.on_load_error_handler[cp] = h
	}

	if accessor, ok := a.(CLoadHandlerTAccessor); ok {
		accessor.SetCLoadHandlerT(load_handler)
		Logf("T11266:")
	}

	return load_handler
}

// cef_media_router_capi.h, include/capi/cef_media_router_capi.h:109:3,

///
// Supports discovery of and communication with media devices on the local
// network via the Cast and DIAL protocols. The functions of this structure may
// be called on any browser process thread unless otherwise indicated.
///

// Go type for cef_media_router_t
type CMediaRouterT struct {
	noCopy         noCopy
	p_media_router *C.cef_media_router_t
}

type RefToCMediaRouterT struct {
	p_media_router *CMediaRouterT
}

type CMediaRouterTAccessor interface {
	GetCMediaRouterT() *CMediaRouterT
	SetCMediaRouterT(*CMediaRouterT)
}

func (r RefToCMediaRouterT) GetCMediaRouterT() *CMediaRouterT {
	return r.p_media_router
}

func (r *RefToCMediaRouterT) SetCMediaRouterT(p *CMediaRouterT) {
	r.p_media_router = p
}

// Go type CMediaRouterT wraps cef type *C.cef_media_router_t
func newCMediaRouterT(p *C.cef_media_router_t) *CMediaRouterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T11295:")
	BaseAddRef(p)
	go_media_router := CMediaRouterT{noCopy{}, p}
	runtime.SetFinalizer(&go_media_router, func(g *CMediaRouterT) {
		Tracef(unsafe.Pointer(g.p_media_router), "T11299:")
		BaseRelease(g.p_media_router)
	})
	return &go_media_router
}

// *C.cef_media_router_t has refCounted interface
func (media_router *CMediaRouterT) HasOneRef() bool {
	return BaseHasOneRef(media_router.p_media_router)
}

func (p *C.cef_media_router_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Add an observer for MediaRouter events. The observer will remain registered
// until the returned Registration object is destroyed.
///
func (self *CMediaRouterT) AddObserver(
	observer *CMediaObserverT,
) (ret *CRegistrationT) {
	var goTmpobserver *C.cef_media_observer_t
	if observer != nil {
		goTmpobserver = observer.p_media_observer
		BaseAddRef(goTmpobserver)
	}

	cRet := C.cefingo_media_router_add_observer(self.p_media_router, goTmpobserver)

	ret = newCRegistrationT(cRet)
	return ret
}

///
// Returns a MediaSource object for the specified media source URN. Supported
// URN schemes include &quot;cast:&quot; and &quot;dial:&quot;, and will be already known by the
// client application (e.g. &quot;cast:&lt;appId&gt;?clientId=&lt;clientId&gt;&quot;).
///
func (self *CMediaRouterT) GetSource(
	urn string,
) (ret *CMediaSourceT) {
	c_urn := create_cef_string(urn)
	defer clear_cef_string(c_urn)

	cRet := C.cefingo_media_router_get_source(self.p_media_router, (*C.cef_string_t)(c_urn))

	ret = newCMediaSourceT(cRet)
	return ret
}

///
// Trigger an asynchronous call to cef_media_observer_t::OnSinks on all
// registered observers.
///
func (self *CMediaRouterT) NotifyCurrentSinks() {

	C.cefingo_media_router_notify_current_sinks(self.p_media_router)

}

///
// Create a new route between |source| and |sink|. Source and sink must be
// valid, compatible (as reported by cef_media_sink_t::IsCompatibleWith), and
// a route between them must not already exist. |callback| will be executed on
// success or failure. If route creation succeeds it will also trigger an
// asynchronous call to cef_media_observer_t::OnRoutes on all registered
// observers.
///
func (self *CMediaRouterT) CreateRoute(
	source *CMediaSourceT,
	sink *CMediaSinkT,
	callback *CMediaRouteCreateCallbackT,
) {
	var goTmpsource *C.cef_media_source_t
	if source != nil {
		goTmpsource = source.p_media_source
		BaseAddRef(goTmpsource)
	}
	var goTmpsink *C.cef_media_sink_t
	if sink != nil {
		goTmpsink = sink.p_media_sink
		BaseAddRef(goTmpsink)
	}
	var goTmpcallback *C.cef_media_route_create_callback_t
	if callback != nil {
		goTmpcallback = callback.p_media_route_create_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_media_router_create_route(self.p_media_router, goTmpsource, goTmpsink, goTmpcallback)

}

///
// Trigger an asynchronous call to cef_media_observer_t::OnRoutes on all
// registered observers.
///
func (self *CMediaRouterT) NotifyCurrentRoutes() {

	C.cefingo_media_router_notify_current_routes(self.p_media_router)

}

///
// Returns the MediaRouter object associated with the global request context.
// Equivalent to calling cef_request_context_t::cef_request_context_get_global_c
// ontext()->get_media_router().
///
func MediaRouterGetGlobal() (ret *CMediaRouterT) {

	cRet := C.cef_media_router_get_global()

	ret = newCMediaRouterT(cRet)
	return ret
}

///
// Implemented by the client to observe MediaRouter events and registered via
// cef_media_router_t::AddObserver. The functions of this structure will be
// called on the browser process UI thread.
///

// Go type for cef_media_observer_t
type CMediaObserverT struct {
	noCopy           noCopy
	p_media_observer *C.cef_media_observer_t
}

type RefToCMediaObserverT struct {
	p_media_observer *CMediaObserverT
}

type CMediaObserverTAccessor interface {
	GetCMediaObserverT() *CMediaObserverT
	SetCMediaObserverT(*CMediaObserverT)
}

func (r RefToCMediaObserverT) GetCMediaObserverT() *CMediaObserverT {
	return r.p_media_observer
}

func (r *RefToCMediaObserverT) SetCMediaObserverT(p *CMediaObserverT) {
	r.p_media_observer = p
}

// Go type CMediaObserverT wraps cef type *C.cef_media_observer_t
func newCMediaObserverT(p *C.cef_media_observer_t) *CMediaObserverT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T11458:")
	BaseAddRef(p)
	go_media_observer := CMediaObserverT{noCopy{}, p}
	runtime.SetFinalizer(&go_media_observer, func(g *CMediaObserverT) {
		Tracef(unsafe.Pointer(g.p_media_observer), "T11462:")
		BaseRelease(g.p_media_observer)
	})
	return &go_media_observer
}

// *C.cef_media_observer_t has refCounted interface
func (media_observer *CMediaObserverT) HasOneRef() bool {
	return BaseHasOneRef(media_observer.p_media_observer)
}

func (p *C.cef_media_observer_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// The list of available media sinks has changed or
// cef_media_router_t::NotifyCurrentSinks was called.
///
type OnSinksHandler interface {
	OnSinks(
		self *CMediaObserverT,
		sinks []*CMediaSinkT,
	)
}

///
// The list of available media routes has changed or
// cef_media_router_t::NotifyCurrentRoutes was called.
///
type OnRoutesHandler interface {
	OnRoutes(
		self *CMediaObserverT,
		routes []*CMediaRouteT,
	)
}

///
// The connection state of |route| has changed.
///
type OnRouteStateChangedHandler interface {
	OnRouteStateChanged(
		self *CMediaObserverT,
		route *CMediaRouteT,
		state CMediaRouteConnectionStateT,
	)
}

///
// A message was recieved over |route|. |message| is only valid for the scope
// of this callback and should be copied if necessary.
///
type OnRouteMessageReceivedHandler interface {
	OnRouteMessageReceived(
		self *CMediaObserverT,
		route *CMediaRouteT,
		message unsafe.Pointer,
		message_size int64,
	)
}

var media_observer_handlers = struct {
	on_sinks_handler                  map[*C.cef_media_observer_t]OnSinksHandler
	on_routes_handler                 map[*C.cef_media_observer_t]OnRoutesHandler
	on_route_state_changed_handler    map[*C.cef_media_observer_t]OnRouteStateChangedHandler
	on_route_message_received_handler map[*C.cef_media_observer_t]OnRouteMessageReceivedHandler
}{
	map[*C.cef_media_observer_t]OnSinksHandler{},
	map[*C.cef_media_observer_t]OnRoutesHandler{},
	map[*C.cef_media_observer_t]OnRouteStateChangedHandler{},
	map[*C.cef_media_observer_t]OnRouteMessageReceivedHandler{},
}

// AllocCMediaObserverT allocates CMediaObserverT and construct it
func AllocCMediaObserverT() *CMediaObserverT {
	up := c_calloc(1, C.sizeof_cefingo_media_observer_wrapper_t, "T11537:")
	cefp := C.cefingo_construct_media_observer((*C.cefingo_media_observer_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_media_observer_t itself in DeassocFunc,
		// or cef_media_observer_t is never GCed.
		Tracef(up, "T11543:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(media_observer_handlers.on_sinks_handler, cefp)
		delete(media_observer_handlers.on_routes_handler, cefp)
		delete(media_observer_handlers.on_route_state_changed_handler, cefp)
		delete(media_observer_handlers.on_route_message_received_handler, cefp)
	}))

	return newCMediaObserverT(cefp)
}

func (media_observer *CMediaObserverT) Bind(a interface{}) *CMediaObserverT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := media_observer.p_media_observer

	if h, ok := a.(OnSinksHandler); ok {
		media_observer_handlers.on_sinks_handler[cp] = h
	}

	if h, ok := a.(OnRoutesHandler); ok {
		media_observer_handlers.on_routes_handler[cp] = h
	}

	if h, ok := a.(OnRouteStateChangedHandler); ok {
		media_observer_handlers.on_route_state_changed_handler[cp] = h
	}

	if h, ok := a.(OnRouteMessageReceivedHandler); ok {
		media_observer_handlers.on_route_message_received_handler[cp] = h
	}

	if accessor, ok := a.(CMediaObserverTAccessor); ok {
		accessor.SetCMediaObserverT(media_observer)
		Logf("T11592:")
	}

	return media_observer
}

///
// Represents the route between a media source and sink. Instances of this
// object are created via cef_media_router_t::CreateRoute and retrieved via
// cef_media_observer_t::OnRoutes. Contains the status and metadata of a routing
// operation. The functions of this structure may be called on any browser
// process thread unless otherwise indicated.
///

// Go type for cef_media_route_t
type CMediaRouteT struct {
	noCopy        noCopy
	p_media_route *C.cef_media_route_t
}

type RefToCMediaRouteT struct {
	p_media_route *CMediaRouteT
}

type CMediaRouteTAccessor interface {
	GetCMediaRouteT() *CMediaRouteT
	SetCMediaRouteT(*CMediaRouteT)
}

func (r RefToCMediaRouteT) GetCMediaRouteT() *CMediaRouteT {
	return r.p_media_route
}

func (r *RefToCMediaRouteT) SetCMediaRouteT(p *CMediaRouteT) {
	r.p_media_route = p
}

// Go type CMediaRouteT wraps cef type *C.cef_media_route_t
func newCMediaRouteT(p *C.cef_media_route_t) *CMediaRouteT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T11621:")
	BaseAddRef(p)
	go_media_route := CMediaRouteT{noCopy{}, p}
	runtime.SetFinalizer(&go_media_route, func(g *CMediaRouteT) {
		Tracef(unsafe.Pointer(g.p_media_route), "T11625:")
		BaseRelease(g.p_media_route)
	})
	return &go_media_route
}

// *C.cef_media_route_t has refCounted interface
func (media_route *CMediaRouteT) HasOneRef() bool {
	return BaseHasOneRef(media_route.p_media_route)
}

func (p *C.cef_media_route_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the ID for this route.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaRouteT) GetId() (ret string) {

	cRet := C.cefingo_media_route_get_id(self.p_media_route)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the source associated with this route.
///
func (self *CMediaRouteT) GetSource() (ret *CMediaSourceT) {

	cRet := C.cefingo_media_route_get_source(self.p_media_route)

	ret = newCMediaSourceT(cRet)
	return ret
}

///
// Returns the sink associated with this route.
///
func (self *CMediaRouteT) GetSink() (ret *CMediaSinkT) {

	cRet := C.cefingo_media_route_get_sink(self.p_media_route)

	ret = newCMediaSinkT(cRet)
	return ret
}

///
// Send a message over this route. |message| will be copied if necessary.
///
func (self *CMediaRouteT) SendRouteMessage(
	message unsafe.Pointer,
	message_size int64,
) {

	C.cefingo_media_route_send_route_message(self.p_media_route, message, (C.size_t)(message_size))

}

///
// Terminate this route. Will result in an asynchronous call to
// cef_media_observer_t::OnRoutes on all registered observers.
///
func (self *CMediaRouteT) Terminate() {

	C.cefingo_media_route_terminate(self.p_media_route)

}

///
// Callback structure for cef_media_router_t::CreateRoute. The functions of this
// structure will be called on the browser process UI thread.
///

// Go type for cef_media_route_create_callback_t
type CMediaRouteCreateCallbackT struct {
	noCopy                        noCopy
	p_media_route_create_callback *C.cef_media_route_create_callback_t
}

type RefToCMediaRouteCreateCallbackT struct {
	p_media_route_create_callback *CMediaRouteCreateCallbackT
}

type CMediaRouteCreateCallbackTAccessor interface {
	GetCMediaRouteCreateCallbackT() *CMediaRouteCreateCallbackT
	SetCMediaRouteCreateCallbackT(*CMediaRouteCreateCallbackT)
}

func (r RefToCMediaRouteCreateCallbackT) GetCMediaRouteCreateCallbackT() *CMediaRouteCreateCallbackT {
	return r.p_media_route_create_callback
}

func (r *RefToCMediaRouteCreateCallbackT) SetCMediaRouteCreateCallbackT(p *CMediaRouteCreateCallbackT) {
	r.p_media_route_create_callback = p
}

// Go type CMediaRouteCreateCallbackT wraps cef type *C.cef_media_route_create_callback_t
func newCMediaRouteCreateCallbackT(p *C.cef_media_route_create_callback_t) *CMediaRouteCreateCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T11741:")
	BaseAddRef(p)
	go_media_route_create_callback := CMediaRouteCreateCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_media_route_create_callback, func(g *CMediaRouteCreateCallbackT) {
		Tracef(unsafe.Pointer(g.p_media_route_create_callback), "T11745:")
		BaseRelease(g.p_media_route_create_callback)
	})
	return &go_media_route_create_callback
}

// *C.cef_media_route_create_callback_t has refCounted interface
func (media_route_create_callback *CMediaRouteCreateCallbackT) HasOneRef() bool {
	return BaseHasOneRef(media_route_create_callback.p_media_route_create_callback)
}

func (p *C.cef_media_route_create_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be executed when the route creation has finished. |result|
// will be CEF_MRCR_OK if the route creation succeeded. |error| will be a
// description of the error if the route creation failed. |route| is the
// resulting route, or NULL if the route creation failed.
///
func (self *CMediaRouteCreateCallbackT) OnMediaRouteCreateFinished(
	result CMediaRouteCreateResultT,
	error string,
	route *CMediaRouteT,
) {
	c_error := create_cef_string(error)
	defer clear_cef_string(c_error)
	var goTmproute *C.cef_media_route_t
	if route != nil {
		goTmproute = route.p_media_route
		BaseAddRef(goTmproute)
	}

	C.cefingo_media_route_create_callback_on_media_route_create_finished(self.p_media_route_create_callback, (C.cef_media_route_create_result_t)(result), (*C.cef_string_t)(c_error), goTmproute)

}

///
// Represents a sink to which media can be routed. Instances of this object are
// retrieved via cef_media_observer_t::OnSinks. The functions of this structure
// may be called on any browser process thread unless otherwise indicated.
///

// Go type for cef_media_sink_t
type CMediaSinkT struct {
	noCopy       noCopy
	p_media_sink *C.cef_media_sink_t
}

type RefToCMediaSinkT struct {
	p_media_sink *CMediaSinkT
}

type CMediaSinkTAccessor interface {
	GetCMediaSinkT() *CMediaSinkT
	SetCMediaSinkT(*CMediaSinkT)
}

func (r RefToCMediaSinkT) GetCMediaSinkT() *CMediaSinkT {
	return r.p_media_sink
}

func (r *RefToCMediaSinkT) SetCMediaSinkT(p *CMediaSinkT) {
	r.p_media_sink = p
}

// Go type CMediaSinkT wraps cef type *C.cef_media_sink_t
func newCMediaSinkT(p *C.cef_media_sink_t) *CMediaSinkT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T11817:")
	BaseAddRef(p)
	go_media_sink := CMediaSinkT{noCopy{}, p}
	runtime.SetFinalizer(&go_media_sink, func(g *CMediaSinkT) {
		Tracef(unsafe.Pointer(g.p_media_sink), "T11821:")
		BaseRelease(g.p_media_sink)
	})
	return &go_media_sink
}

// *C.cef_media_sink_t has refCounted interface
func (media_sink *CMediaSinkT) HasOneRef() bool {
	return BaseHasOneRef(media_sink.p_media_sink)
}

func (p *C.cef_media_sink_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the ID for this sink.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSinkT) GetId() (ret string) {

	cRet := C.cefingo_media_sink_get_id(self.p_media_sink)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this sink is valid.
///
func (self *CMediaSinkT) IsValid() (ret bool) {

	cRet := C.cefingo_media_sink_is_valid(self.p_media_sink)

	ret = cRet == 1
	return ret
}

///
// Returns the name of this sink.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSinkT) GetName() (ret string) {

	cRet := C.cefingo_media_sink_get_name(self.p_media_sink)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the description of this sink.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSinkT) GetDescription() (ret string) {

	cRet := C.cefingo_media_sink_get_description(self.p_media_sink)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the icon type for this sink.
///
func (self *CMediaSinkT) GetIconType() (ret CMediaSinkIconTypeT) {

	cRet := C.cefingo_media_sink_get_icon_type(self.p_media_sink)

	ret = CMediaSinkIconTypeT(cRet)
	return ret
}

///
// Returns true (1) if this sink accepts content via Cast.
///
func (self *CMediaSinkT) IsCastSink() (ret bool) {

	cRet := C.cefingo_media_sink_is_cast_sink(self.p_media_sink)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this sink accepts content via DIAL.
///
func (self *CMediaSinkT) IsDialSink() (ret bool) {

	cRet := C.cefingo_media_sink_is_dial_sink(self.p_media_sink)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this sink is compatible with |source|.
///
func (self *CMediaSinkT) IsCompatibleWith(
	source *CMediaSourceT,
) (ret bool) {
	var goTmpsource *C.cef_media_source_t
	if source != nil {
		goTmpsource = source.p_media_source
		BaseAddRef(goTmpsource)
	}

	cRet := C.cefingo_media_sink_is_compatible_with(self.p_media_sink, goTmpsource)

	ret = cRet == 1
	return ret
}

///
// Represents a source from which media can be routed. Instances of this object
// are retrieved via cef_media_router_t::GetSource. The functions of this
// structure may be called on any browser process thread unless otherwise
// indicated.
///

// Go type for cef_media_source_t
type CMediaSourceT struct {
	noCopy         noCopy
	p_media_source *C.cef_media_source_t
}

type RefToCMediaSourceT struct {
	p_media_source *CMediaSourceT
}

type CMediaSourceTAccessor interface {
	GetCMediaSourceT() *CMediaSourceT
	SetCMediaSourceT(*CMediaSourceT)
}

func (r RefToCMediaSourceT) GetCMediaSourceT() *CMediaSourceT {
	return r.p_media_source
}

func (r *RefToCMediaSourceT) SetCMediaSourceT(p *CMediaSourceT) {
	r.p_media_source = p
}

// Go type CMediaSourceT wraps cef type *C.cef_media_source_t
func newCMediaSourceT(p *C.cef_media_source_t) *CMediaSourceT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T11995:")
	BaseAddRef(p)
	go_media_source := CMediaSourceT{noCopy{}, p}
	runtime.SetFinalizer(&go_media_source, func(g *CMediaSourceT) {
		Tracef(unsafe.Pointer(g.p_media_source), "T11999:")
		BaseRelease(g.p_media_source)
	})
	return &go_media_source
}

// *C.cef_media_source_t has refCounted interface
func (media_source *CMediaSourceT) HasOneRef() bool {
	return BaseHasOneRef(media_source.p_media_source)
}

func (p *C.cef_media_source_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the ID (media source URN or URL) for this source.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSourceT) GetId() (ret string) {

	cRet := C.cefingo_media_source_get_id(self.p_media_source)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this source is valid.
///
func (self *CMediaSourceT) IsValid() (ret bool) {

	cRet := C.cefingo_media_source_is_valid(self.p_media_source)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this source outputs its content via Cast.
///
func (self *CMediaSourceT) IsCastSource() (ret bool) {

	cRet := C.cefingo_media_source_is_cast_source(self.p_media_source)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this source outputs its content via DIAL.
///
func (self *CMediaSourceT) IsDialSource() (ret bool) {

	cRet := C.cefingo_media_source_is_dial_source(self.p_media_source)

	ret = cRet == 1
	return ret
}

// cef_menu_button_capi.h, include/capi/views/cef_menu_button_capi.h:79:3,

///
// MenuButton is a button with optional text, icon and/or menu marker that shows
// a menu when clicked with the left mouse button. All size and position values
// are in density independent pixels (DIP) unless otherwise indicated. Methods
// must be called on the browser process UI thread unless otherwise indicated.
///

// Go type for cef_menu_button_t
type CMenuButtonT struct {
	noCopy        noCopy
	p_menu_button *C.cef_menu_button_t
}

type RefToCMenuButtonT struct {
	p_menu_button *CMenuButtonT
}

type CMenuButtonTAccessor interface {
	GetCMenuButtonT() *CMenuButtonT
	SetCMenuButtonT(*CMenuButtonT)
}

func (r RefToCMenuButtonT) GetCMenuButtonT() *CMenuButtonT {
	return r.p_menu_button
}

func (r *RefToCMenuButtonT) SetCMenuButtonT(p *CMenuButtonT) {
	r.p_menu_button = p
}

// Go type CMenuButtonT wraps cef type *C.cef_menu_button_t
func newCMenuButtonT(p *C.cef_menu_button_t) *CMenuButtonT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T12107:")
	BaseAddRef(p)
	go_menu_button := CMenuButtonT{noCopy{}, p}
	runtime.SetFinalizer(&go_menu_button, func(g *CMenuButtonT) {
		Tracef(unsafe.Pointer(g.p_menu_button), "T12111:")
		BaseRelease(g.p_menu_button)
	})
	return &go_menu_button
}

// *C.cef_menu_button_t has refCounted interface
func (menu_button *CMenuButtonT) HasOneRef() bool {
	return BaseHasOneRef(menu_button.p_menu_button)
}

func (p *C.cef_menu_button_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (menu_button *CMenuButtonT) ToCLabelButtonT() *CLabelButtonT {
	p := (*C.cef_label_button_t)(unsafe.Pointer(menu_button.p_menu_button))
	return newCLabelButtonT(p)
}

///
// Show a menu with contents |menu_model|. |screen_point| specifies the menu
// position in screen coordinates. |anchor_position| specifies how the menu
// will be anchored relative to |screen_point|. This function should be called
// from cef_menu_button_delegate_t::on_menu_button_pressed().
///
func (self *CMenuButtonT) ShowMenu(
	menu_model *CMenuModelT,
	screen_point *CPointT,
	anchor_position CMenuAnchorPositionT,
) {
	var goTmpmenu_model *C.cef_menu_model_t
	if menu_model != nil {
		goTmpmenu_model = menu_model.p_menu_model
		BaseAddRef(goTmpmenu_model)
	}

	C.cefingo_menu_button_show_menu(self.p_menu_button, goTmpmenu_model, (*C.cef_point_t)(screen_point), (C.cef_menu_anchor_position_t)(anchor_position))

}

///
// Show the menu for this button. Results in a call to
// cef_menu_button_delegate_t::on_menu_button_pressed().
///
func (self *CMenuButtonT) TriggerMenu() {

	C.cefingo_menu_button_trigger_menu(self.p_menu_button)

}

///
// Create a new MenuButton. A |delegate| must be provided to call show_menu()
// when the button is clicked. |text| will be shown on the MenuButton and used
// as the default accessible name. If |with_frame| is true (1) the button will
// have a visible frame at all times, center alignment, additional padding and a
// default minimum size of 70x33 DIP. If |with_frame| is false (0) the button
// will only have a visible frame on hover/press, left alignment, less padding
// and no default minimum size.
///
func MenuButtonCreate(
	delegate *CMenuButtonDelegateT,
	text string,
) (ret *CMenuButtonT) {
	var goTmpdelegate *C.cef_menu_button_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_menu_button_delegate
		BaseAddRef(goTmpdelegate)
	}
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	cRet := C.cef_menu_button_create(goTmpdelegate, (*C.cef_string_t)(c_text))

	ret = newCMenuButtonT(cRet)
	return ret
}

// cef_menu_button_delegate_capi.h, include/capi/views/cef_menu_button_delegate_capi.h:59:3,

///
// MenuButton pressed lock is released when this object is destroyed.
///

// Go type for cef_menu_button_pressed_lock_t
type CMenuButtonPressedLockT struct {
	noCopy                     noCopy
	p_menu_button_pressed_lock *C.cef_menu_button_pressed_lock_t
}

type RefToCMenuButtonPressedLockT struct {
	p_menu_button_pressed_lock *CMenuButtonPressedLockT
}

type CMenuButtonPressedLockTAccessor interface {
	GetCMenuButtonPressedLockT() *CMenuButtonPressedLockT
	SetCMenuButtonPressedLockT(*CMenuButtonPressedLockT)
}

func (r RefToCMenuButtonPressedLockT) GetCMenuButtonPressedLockT() *CMenuButtonPressedLockT {
	return r.p_menu_button_pressed_lock
}

func (r *RefToCMenuButtonPressedLockT) SetCMenuButtonPressedLockT(p *CMenuButtonPressedLockT) {
	r.p_menu_button_pressed_lock = p
}

// Go type CMenuButtonPressedLockT wraps cef type *C.cef_menu_button_pressed_lock_t
func newCMenuButtonPressedLockT(p *C.cef_menu_button_pressed_lock_t) *CMenuButtonPressedLockT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T12226:")
	BaseAddRef(p)
	go_menu_button_pressed_lock := CMenuButtonPressedLockT{noCopy{}, p}
	runtime.SetFinalizer(&go_menu_button_pressed_lock, func(g *CMenuButtonPressedLockT) {
		Tracef(unsafe.Pointer(g.p_menu_button_pressed_lock), "T12230:")
		BaseRelease(g.p_menu_button_pressed_lock)
	})
	return &go_menu_button_pressed_lock
}

// *C.cef_menu_button_pressed_lock_t has refCounted interface
func (menu_button_pressed_lock *CMenuButtonPressedLockT) HasOneRef() bool {
	return BaseHasOneRef(menu_button_pressed_lock.p_menu_button_pressed_lock)
}

func (p *C.cef_menu_button_pressed_lock_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Implement this structure to handle MenuButton events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_menu_button_delegate_t
type CMenuButtonDelegateT struct {
	noCopy                 noCopy
	p_menu_button_delegate *C.cef_menu_button_delegate_t
}

type RefToCMenuButtonDelegateT struct {
	p_menu_button_delegate *CMenuButtonDelegateT
}

type CMenuButtonDelegateTAccessor interface {
	GetCMenuButtonDelegateT() *CMenuButtonDelegateT
	SetCMenuButtonDelegateT(*CMenuButtonDelegateT)
}

func (r RefToCMenuButtonDelegateT) GetCMenuButtonDelegateT() *CMenuButtonDelegateT {
	return r.p_menu_button_delegate
}

func (r *RefToCMenuButtonDelegateT) SetCMenuButtonDelegateT(p *CMenuButtonDelegateT) {
	r.p_menu_button_delegate = p
}

// Go type CMenuButtonDelegateT wraps cef type *C.cef_menu_button_delegate_t
func newCMenuButtonDelegateT(p *C.cef_menu_button_delegate_t) *CMenuButtonDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T12278:")
	BaseAddRef(p)
	go_menu_button_delegate := CMenuButtonDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_menu_button_delegate, func(g *CMenuButtonDelegateT) {
		Tracef(unsafe.Pointer(g.p_menu_button_delegate), "T12282:")
		BaseRelease(g.p_menu_button_delegate)
	})
	return &go_menu_button_delegate
}

// *C.cef_menu_button_delegate_t has refCounted interface
func (menu_button_delegate *CMenuButtonDelegateT) HasOneRef() bool {
	return BaseHasOneRef(menu_button_delegate.p_menu_button_delegate)
}

func (p *C.cef_menu_button_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (menu_button_delegate *CMenuButtonDelegateT) ToCButtonDelegateT() *CButtonDelegateT {
	p := (*C.cef_button_delegate_t)(unsafe.Pointer(menu_button_delegate.p_menu_button_delegate))
	return newCButtonDelegateT(p)
}

///
// Called when |button| is pressed. Call cef_menu_button_t::show_menu() to
// show a popup menu at |screen_point|. When showing a custom popup such as a
// window keep a reference to |button_pressed_lock| until the popup is hidden
// to maintain the pressed button state.
///
type OnMenuButtonPressedHandler interface {
	OnMenuButtonPressed(
		self *CMenuButtonDelegateT,
		menu_button *CMenuButtonT,
		screen_point *CPointT,
		button_pressed_lock *CMenuButtonPressedLockT,
	)
}

var menu_button_delegate_handlers = struct {
	on_menu_button_pressed_handler  map[*C.cef_menu_button_delegate_t]OnMenuButtonPressedHandler
	on_button_pressed_handler       map[*C.cef_menu_button_delegate_t]OnButtonPressedHandler
	on_button_state_changed_handler map[*C.cef_menu_button_delegate_t]OnButtonStateChangedHandler
	get_preferred_size_handler      map[*C.cef_menu_button_delegate_t]GetPreferredSizeHandler
	get_minimum_size_handler        map[*C.cef_menu_button_delegate_t]GetMinimumSizeHandler
	get_maximum_size_handler        map[*C.cef_menu_button_delegate_t]GetMaximumSizeHandler
	get_height_for_width_handler    map[*C.cef_menu_button_delegate_t]GetHeightForWidthHandler
	on_parent_view_changed_handler  map[*C.cef_menu_button_delegate_t]OnParentViewChangedHandler
	on_child_view_changed_handler   map[*C.cef_menu_button_delegate_t]OnChildViewChangedHandler
	on_focus_handler                map[*C.cef_menu_button_delegate_t]OnFocusHandler
	on_blur_handler                 map[*C.cef_menu_button_delegate_t]OnBlurHandler
}{
	map[*C.cef_menu_button_delegate_t]OnMenuButtonPressedHandler{},
	map[*C.cef_menu_button_delegate_t]OnButtonPressedHandler{},
	map[*C.cef_menu_button_delegate_t]OnButtonStateChangedHandler{},
	map[*C.cef_menu_button_delegate_t]GetPreferredSizeHandler{},
	map[*C.cef_menu_button_delegate_t]GetMinimumSizeHandler{},
	map[*C.cef_menu_button_delegate_t]GetMaximumSizeHandler{},
	map[*C.cef_menu_button_delegate_t]GetHeightForWidthHandler{},
	map[*C.cef_menu_button_delegate_t]OnParentViewChangedHandler{},
	map[*C.cef_menu_button_delegate_t]OnChildViewChangedHandler{},
	map[*C.cef_menu_button_delegate_t]OnFocusHandler{},
	map[*C.cef_menu_button_delegate_t]OnBlurHandler{},
}

// AllocCMenuButtonDelegateT allocates CMenuButtonDelegateT and construct it
func AllocCMenuButtonDelegateT() *CMenuButtonDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_menu_button_delegate_wrapper_t, "T12345:")
	cefp := C.cefingo_construct_menu_button_delegate((*C.cefingo_menu_button_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_menu_button_delegate_t itself in DeassocFunc,
		// or cef_menu_button_delegate_t is never GCed.
		Tracef(up, "T12351:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(menu_button_delegate_handlers.on_menu_button_pressed_handler, cefp)
		delete(menu_button_delegate_handlers.on_button_pressed_handler, cefp)
		delete(menu_button_delegate_handlers.on_button_state_changed_handler, cefp)
		delete(menu_button_delegate_handlers.get_preferred_size_handler, cefp)
		delete(menu_button_delegate_handlers.get_minimum_size_handler, cefp)
		delete(menu_button_delegate_handlers.get_maximum_size_handler, cefp)
		delete(menu_button_delegate_handlers.get_height_for_width_handler, cefp)
		delete(menu_button_delegate_handlers.on_parent_view_changed_handler, cefp)
		delete(menu_button_delegate_handlers.on_child_view_changed_handler, cefp)
		delete(menu_button_delegate_handlers.on_focus_handler, cefp)
		delete(menu_button_delegate_handlers.on_blur_handler, cefp)
	}))

	return newCMenuButtonDelegateT(cefp)
}

func (menu_button_delegate *CMenuButtonDelegateT) Bind(a interface{}) *CMenuButtonDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := menu_button_delegate.p_menu_button_delegate

	if h, ok := a.(OnMenuButtonPressedHandler); ok {
		menu_button_delegate_handlers.on_menu_button_pressed_handler[cp] = h
	}

	if h, ok := a.(OnButtonPressedHandler); ok {
		menu_button_delegate_handlers.on_button_pressed_handler[cp] = h
	}

	if h, ok := a.(OnButtonStateChangedHandler); ok {
		menu_button_delegate_handlers.on_button_state_changed_handler[cp] = h
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		menu_button_delegate_handlers.get_preferred_size_handler[cp] = h
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		menu_button_delegate_handlers.get_minimum_size_handler[cp] = h
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		menu_button_delegate_handlers.get_maximum_size_handler[cp] = h
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		menu_button_delegate_handlers.get_height_for_width_handler[cp] = h
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		menu_button_delegate_handlers.on_parent_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		menu_button_delegate_handlers.on_child_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnFocusHandler); ok {
		menu_button_delegate_handlers.on_focus_handler[cp] = h
	}

	if h, ok := a.(OnBlurHandler); ok {
		menu_button_delegate_handlers.on_blur_handler[cp] = h
	}

	if accessor, ok := a.(CMenuButtonDelegateTAccessor); ok {
		accessor.SetCMenuButtonDelegateT(menu_button_delegate)
		Logf("T12435:")
	}

	return menu_button_delegate
}

// cef_menu_model_capi.h, include/capi/cef_menu_model_capi.h:499:3,

///
// Supports creation and modification of menus. See cef_menu_id_t for the
// command ids that have default implementations. All user-defined command ids
// should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of
// this structure can only be accessed on the browser process the UI thread.
///

// Go type for cef_menu_model_t
type CMenuModelT struct {
	noCopy       noCopy
	p_menu_model *C.cef_menu_model_t
}

type RefToCMenuModelT struct {
	p_menu_model *CMenuModelT
}

type CMenuModelTAccessor interface {
	GetCMenuModelT() *CMenuModelT
	SetCMenuModelT(*CMenuModelT)
}

func (r RefToCMenuModelT) GetCMenuModelT() *CMenuModelT {
	return r.p_menu_model
}

func (r *RefToCMenuModelT) SetCMenuModelT(p *CMenuModelT) {
	r.p_menu_model = p
}

// Go type CMenuModelT wraps cef type *C.cef_menu_model_t
func newCMenuModelT(p *C.cef_menu_model_t) *CMenuModelT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T12465:")
	BaseAddRef(p)
	go_menu_model := CMenuModelT{noCopy{}, p}
	runtime.SetFinalizer(&go_menu_model, func(g *CMenuModelT) {
		Tracef(unsafe.Pointer(g.p_menu_model), "T12469:")
		BaseRelease(g.p_menu_model)
	})
	return &go_menu_model
}

// *C.cef_menu_model_t has refCounted interface
func (menu_model *CMenuModelT) HasOneRef() bool {
	return BaseHasOneRef(menu_model.p_menu_model)
}

func (p *C.cef_menu_model_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this menu is a submenu.
///
func (self *CMenuModelT) IsSubMenu() (ret bool) {

	cRet := C.cefingo_menu_model_is_sub_menu(self.p_menu_model)

	ret = cRet == 1
	return ret
}

///
// Clears the menu. Returns true (1) on success.
///
func (self *CMenuModelT) Clear() (ret bool) {

	cRet := C.cefingo_menu_model_clear(self.p_menu_model)

	ret = cRet == 1
	return ret
}

///
// Returns the number of items in this menu.
///
func (self *CMenuModelT) GetCount() (ret bool) {

	cRet := C.cefingo_menu_model_get_count(self.p_menu_model)

	ret = cRet == 1
	return ret
}

///
// Add a separator to the menu. Returns true (1) on success.
///
func (self *CMenuModelT) AddSeparator() (ret bool) {

	cRet := C.cefingo_menu_model_add_separator(self.p_menu_model)

	ret = cRet == 1
	return ret
}

///
// Add an item to the menu. Returns true (1) on success.
///
func (self *CMenuModelT) AddItem(
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_add_item(self.p_menu_model, (C.int)(command_id), (*C.cef_string_t)(c_label))

	ret = cRet == 1
	return ret
}

///
// Add a check item to the menu. Returns true (1) on success.
///
func (self *CMenuModelT) AddCheckItem(
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_add_check_item(self.p_menu_model, (C.int)(command_id), (*C.cef_string_t)(c_label))

	ret = cRet == 1
	return ret
}

///
// Add a radio item to the menu. Only a single item with the specified
// |group_id| can be checked at a time. Returns true (1) on success.
///
func (self *CMenuModelT) AddRadioItem(
	command_id int,
	label string,
	group_id int,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_add_radio_item(self.p_menu_model, (C.int)(command_id), (*C.cef_string_t)(c_label), (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Add a sub-menu to the menu. The new sub-menu is returned.
///
func (self *CMenuModelT) AddSubMenu(
	command_id int,
	label string,
) (ret *CMenuModelT) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_add_sub_menu(self.p_menu_model, (C.int)(command_id), (*C.cef_string_t)(c_label))

	ret = newCMenuModelT(cRet)
	return ret
}

///
// Insert a separator in the menu at the specified |index|. Returns true (1)
// on success.
///
func (self *CMenuModelT) InsertSeparatorAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_insert_separator_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Insert an item in the menu at the specified |index|. Returns true (1) on
// success.
///
func (self *CMenuModelT) InsertItemAt(
	index int,
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_insert_item_at(self.p_menu_model, (C.int)(index), (C.int)(command_id), (*C.cef_string_t)(c_label))

	ret = cRet == 1
	return ret
}

///
// Insert a check item in the menu at the specified |index|. Returns true (1)
// on success.
///
func (self *CMenuModelT) InsertCheckItemAt(
	index int,
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_insert_check_item_at(self.p_menu_model, (C.int)(index), (C.int)(command_id), (*C.cef_string_t)(c_label))

	ret = cRet == 1
	return ret
}

///
// Insert a radio item in the menu at the specified |index|. Only a single
// item with the specified |group_id| can be checked at a time. Returns true
// (1) on success.
///
func (self *CMenuModelT) InsertRadioItemAt(
	index int,
	command_id int,
	label string,
	group_id int,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_insert_radio_item_at(self.p_menu_model, (C.int)(index), (C.int)(command_id), (*C.cef_string_t)(c_label), (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Insert a sub-menu in the menu at the specified |index|. The new sub-menu is
// returned.
///
func (self *CMenuModelT) InsertSubMenuAt(
	index int,
	command_id int,
	label string,
) (ret *CMenuModelT) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_insert_sub_menu_at(self.p_menu_model, (C.int)(index), (C.int)(command_id), (*C.cef_string_t)(c_label))

	ret = newCMenuModelT(cRet)
	return ret
}

///
// Removes the item with the specified |command_id|. Returns true (1) on
// success.
///
func (self *CMenuModelT) Remove(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Removes the item at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) RemoveAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the index associated with the specified |command_id| or -1 if not
// found due to the command id not existing in the menu.
///
func (self *CMenuModelT) GetIndexOf(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_index_of(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns the command id at the specified |index| or -1 if not found due to
// invalid range or the index being a separator.
///
func (self *CMenuModelT) GetCommandIdAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_command_id_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Sets the command id at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) SetCommandIdAt(
	index int,
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_command_id_at(self.p_menu_model, (C.int)(index), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns the label for the specified |command_id| or NULL if not found.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMenuModelT) GetLabel(
	command_id int,
) (ret string) {

	cRet := C.cefingo_menu_model_get_label(self.p_menu_model, (C.int)(command_id))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the label at the specified |index| or NULL if not found due to
// invalid range or the index being a separator.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMenuModelT) GetLabelAt(
	index int,
) (ret string) {

	cRet := C.cefingo_menu_model_get_label_at(self.p_menu_model, (C.int)(index))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the label for the specified |command_id|. Returns true (1) on success.
///
func (self *CMenuModelT) SetLabel(
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_set_label(self.p_menu_model, (C.int)(command_id), (*C.cef_string_t)(c_label))

	ret = cRet == 1
	return ret
}

///
// Set the label at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) SetLabelAt(
	index int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)
	defer clear_cef_string(c_label)

	cRet := C.cefingo_menu_model_set_label_at(self.p_menu_model, (C.int)(index), (*C.cef_string_t)(c_label))

	ret = cRet == 1
	return ret
}

///
// Returns the item type for the specified |command_id|.
///
func (self *CMenuModelT) GetType(
	command_id int,
) (ret CMenuItemTypeT) {

	cRet := C.cefingo_menu_model_get_type(self.p_menu_model, (C.int)(command_id))

	ret = CMenuItemTypeT(cRet)
	return ret
}

///
// Returns the item type at the specified |index|.
///
func (self *CMenuModelT) GetTypeAt(
	index int,
) (ret CMenuItemTypeT) {

	cRet := C.cefingo_menu_model_get_type_at(self.p_menu_model, (C.int)(index))

	ret = CMenuItemTypeT(cRet)
	return ret
}

///
// Returns the group id for the specified |command_id| or -1 if invalid.
///
func (self *CMenuModelT) GetGroupId(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_group_id(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns the group id at the specified |index| or -1 if invalid.
///
func (self *CMenuModelT) GetGroupIdAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_group_id_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Sets the group id for the specified |command_id|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetGroupId(
	command_id int,
	group_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_group_id(self.p_menu_model, (C.int)(command_id), (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Sets the group id at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) SetGroupIdAt(
	index int,
	group_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_group_id_at(self.p_menu_model, (C.int)(index), (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Returns the submenu for the specified |command_id| or NULL if invalid.
///
func (self *CMenuModelT) GetSubMenu(
	command_id int,
) (ret *CMenuModelT) {

	cRet := C.cefingo_menu_model_get_sub_menu(self.p_menu_model, (C.int)(command_id))

	ret = newCMenuModelT(cRet)
	return ret
}

///
// Returns the submenu at the specified |index| or NULL if invalid.
///
func (self *CMenuModelT) GetSubMenuAt(
	index int,
) (ret *CMenuModelT) {

	cRet := C.cefingo_menu_model_get_sub_menu_at(self.p_menu_model, (C.int)(index))

	ret = newCMenuModelT(cRet)
	return ret
}

///
// Returns true (1) if the specified |command_id| is visible.
///
func (self *CMenuModelT) IsVisible(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_visible(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| is visible.
///
func (self *CMenuModelT) IsVisibleAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_visible_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Change the visibility of the specified |command_id|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetVisible(
	command_id int,
	visible int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_visible(self.p_menu_model, (C.int)(command_id), (C.int)(visible))

	ret = cRet == 1
	return ret
}

///
// Change the visibility at the specified |index|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetVisibleAt(
	index int,
	visible int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_visible_at(self.p_menu_model, (C.int)(index), (C.int)(visible))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |command_id| is enabled.
///
func (self *CMenuModelT) IsEnabled(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_enabled(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| is enabled.
///
func (self *CMenuModelT) IsEnabledAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_enabled_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Change the enabled status of the specified |command_id|. Returns true (1)
// on success.
///
func (self *CMenuModelT) SetEnabled(
	command_id int,
	enabled int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_enabled(self.p_menu_model, (C.int)(command_id), (C.int)(enabled))

	ret = cRet == 1
	return ret
}

///
// Change the enabled status at the specified |index|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetEnabledAt(
	index int,
	enabled int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_enabled_at(self.p_menu_model, (C.int)(index), (C.int)(enabled))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |command_id| is checked. Only applies to
// check and radio items.
///
func (self *CMenuModelT) IsChecked(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_checked(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| is checked. Only applies to check
// and radio items.
///
func (self *CMenuModelT) IsCheckedAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_checked_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Check the specified |command_id|. Only applies to check and radio items.
// Returns true (1) on success.
///
func (self *CMenuModelT) SetChecked(
	command_id int,
	checked int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_checked(self.p_menu_model, (C.int)(command_id), (C.int)(checked))

	ret = cRet == 1
	return ret
}

///
// Check the specified |index|. Only applies to check and radio items. Returns
// true (1) on success.
///
func (self *CMenuModelT) SetCheckedAt(
	index int,
	checked int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_checked_at(self.p_menu_model, (C.int)(index), (C.int)(checked))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |command_id| has a keyboard accelerator
// assigned.
///
func (self *CMenuModelT) HasAccelerator(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_has_accelerator(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| has a keyboard accelerator
// assigned.
///
func (self *CMenuModelT) HasAcceleratorAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_has_accelerator_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Set the keyboard accelerator for the specified |command_id|. |key_code| can
// be any virtual key or character value. Returns true (1) on success.
///
func (self *CMenuModelT) SetAccelerator(
	command_id int,
	key_code int,
	shift_pressed int,
	ctrl_pressed int,
	alt_pressed int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_accelerator(self.p_menu_model, (C.int)(command_id), (C.int)(key_code), (C.int)(shift_pressed), (C.int)(ctrl_pressed), (C.int)(alt_pressed))

	ret = cRet == 1
	return ret
}

///
// Set the keyboard accelerator at the specified |index|. |key_code| can be
// any virtual key or character value. Returns true (1) on success.
///
func (self *CMenuModelT) SetAcceleratorAt(
	index int,
	key_code int,
	shift_pressed int,
	ctrl_pressed int,
	alt_pressed int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_accelerator_at(self.p_menu_model, (C.int)(index), (C.int)(key_code), (C.int)(shift_pressed), (C.int)(ctrl_pressed), (C.int)(alt_pressed))

	ret = cRet == 1
	return ret
}

///
// Remove the keyboard accelerator for the specified |command_id|. Returns
// true (1) on success.
///
func (self *CMenuModelT) RemoveAccelerator(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove_accelerator(self.p_menu_model, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Remove the keyboard accelerator at the specified |index|. Returns true (1)
// on success.
///
func (self *CMenuModelT) RemoveAcceleratorAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove_accelerator_at(self.p_menu_model, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Retrieves the keyboard accelerator for the specified |command_id|. Returns
// true (1) on success.
///
func (self *CMenuModelT) GetAccelerator(
	command_id int,
) (ret bool, key_code int, shift_pressed int, ctrl_pressed int, alt_pressed int) {
	var tmpkey_code C.int
	var tmpshift_pressed C.int
	var tmpctrl_pressed C.int
	var tmpalt_pressed C.int

	cRet := C.cefingo_menu_model_get_accelerator(self.p_menu_model, (C.int)(command_id), &tmpkey_code, &tmpshift_pressed, &tmpctrl_pressed, &tmpalt_pressed)

	key_code = (int)(tmpkey_code)
	shift_pressed = (int)(tmpshift_pressed)
	ctrl_pressed = (int)(tmpctrl_pressed)
	alt_pressed = (int)(tmpalt_pressed)

	ret = cRet == 1
	return ret, key_code, shift_pressed, ctrl_pressed, alt_pressed
}

///
// Retrieves the keyboard accelerator for the specified |index|. Returns true
// (1) on success.
///
func (self *CMenuModelT) GetAcceleratorAt(
	index int,
) (ret bool, key_code int, shift_pressed int, ctrl_pressed int, alt_pressed int) {
	var tmpkey_code C.int
	var tmpshift_pressed C.int
	var tmpctrl_pressed C.int
	var tmpalt_pressed C.int

	cRet := C.cefingo_menu_model_get_accelerator_at(self.p_menu_model, (C.int)(index), &tmpkey_code, &tmpshift_pressed, &tmpctrl_pressed, &tmpalt_pressed)

	key_code = (int)(tmpkey_code)
	shift_pressed = (int)(tmpshift_pressed)
	ctrl_pressed = (int)(tmpctrl_pressed)
	alt_pressed = (int)(tmpalt_pressed)

	ret = cRet == 1
	return ret, key_code, shift_pressed, ctrl_pressed, alt_pressed
}

///
// Set the explicit color for |command_id| and |color_type| to |color|.
// Specify a |color| value of 0 to remove the explicit color. If no explicit
// color or default color is set for |color_type| then the system color will
// be used. Returns true (1) on success.
///
func (self *CMenuModelT) SetColor(
	command_id int,
	color_type CMenuColorTypeT,
	color CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_color(self.p_menu_model, (C.int)(command_id), (C.cef_menu_color_type_t)(color_type), (C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Set the explicit color for |command_id| and |index| to |color|. Specify a
// |color| value of 0 to remove the explicit color. Specify an |index| value
// of -1 to set the default color for items that do not have an explicit color
// set. If no explicit color or default color is set for |color_type| then the
// system color will be used. Returns true (1) on success.
///
func (self *CMenuModelT) SetColorAt(
	index int,
	color_type CMenuColorTypeT,
	color CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_color_at(self.p_menu_model, (C.int)(index), (C.cef_menu_color_type_t)(color_type), (C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Returns in |color| the color that was explicitly set for |command_id| and
// |color_type|. If a color was not set then 0 will be returned in |color|.
// Returns true (1) on success.
///
func (self *CMenuModelT) GetColor(
	command_id int,
	color_type CMenuColorTypeT,
	color *CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_color(self.p_menu_model, (C.int)(command_id), (C.cef_menu_color_type_t)(color_type), (*C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Returns in |color| the color that was explicitly set for |command_id| and
// |color_type|. Specify an |index| value of -1 to return the default color in
// |color|. If a color was not set then 0 will be returned in |color|. Returns
// true (1) on success.
///
func (self *CMenuModelT) GetColorAt(
	index int,
	color_type CMenuColorTypeT,
	color *CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_color_at(self.p_menu_model, (C.int)(index), (C.cef_menu_color_type_t)(color_type), (*C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Sets the font list for the specified |command_id|. If |font_list| is NULL
// the system font will be used. Returns true (1) on success. The format is
// &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;, where: - FONT_FAMILY_LIST is a comma-
// separated list of font family names, - STYLES is an optional space-
// separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CMenuModelT) SetFontList(
	command_id int,
	font_list string,
) (ret bool) {
	c_font_list := create_cef_string(font_list)
	defer clear_cef_string(c_font_list)

	cRet := C.cefingo_menu_model_set_font_list(self.p_menu_model, (C.int)(command_id), (*C.cef_string_t)(c_font_list))

	ret = cRet == 1
	return ret
}

///
// Sets the font list for the specified |index|. Specify an |index| value of
// -1 to set the default font. If |font_list| is NULL the system font will be
// used. Returns true (1) on success. The format is
// &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;, where: - FONT_FAMILY_LIST is a comma-
// separated list of font family names, - STYLES is an optional space-
// separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CMenuModelT) SetFontListAt(
	index int,
	font_list string,
) (ret bool) {
	c_font_list := create_cef_string(font_list)
	defer clear_cef_string(c_font_list)

	cRet := C.cefingo_menu_model_set_font_list_at(self.p_menu_model, (C.int)(index), (*C.cef_string_t)(c_font_list))

	ret = cRet == 1
	return ret
}

///
// Create a new MenuModel with the specified |delegate|.
///
func MenuModelCreate(
	delegate *CMenuModelDelegateT,
) (ret *CMenuModelT) {
	var goTmpdelegate *C.cef_menu_model_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_menu_model_delegate
		BaseAddRef(goTmpdelegate)
	}

	cRet := C.cef_menu_model_create(goTmpdelegate)

	ret = newCMenuModelT(cRet)
	return ret
}

// cef_menu_model_delegate_capi.h, include/capi/cef_menu_model_delegate_capi.h:117:3,

///
// Implement this structure to handle menu model events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_menu_model_delegate_t
type CMenuModelDelegateT struct {
	noCopy                noCopy
	p_menu_model_delegate *C.cef_menu_model_delegate_t
}

type RefToCMenuModelDelegateT struct {
	p_menu_model_delegate *CMenuModelDelegateT
}

type CMenuModelDelegateTAccessor interface {
	GetCMenuModelDelegateT() *CMenuModelDelegateT
	SetCMenuModelDelegateT(*CMenuModelDelegateT)
}

func (r RefToCMenuModelDelegateT) GetCMenuModelDelegateT() *CMenuModelDelegateT {
	return r.p_menu_model_delegate
}

func (r *RefToCMenuModelDelegateT) SetCMenuModelDelegateT(p *CMenuModelDelegateT) {
	r.p_menu_model_delegate = p
}

// Go type CMenuModelDelegateT wraps cef type *C.cef_menu_model_delegate_t
func newCMenuModelDelegateT(p *C.cef_menu_model_delegate_t) *CMenuModelDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T13470:")
	BaseAddRef(p)
	go_menu_model_delegate := CMenuModelDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_menu_model_delegate, func(g *CMenuModelDelegateT) {
		Tracef(unsafe.Pointer(g.p_menu_model_delegate), "T13474:")
		BaseRelease(g.p_menu_model_delegate)
	})
	return &go_menu_model_delegate
}

// *C.cef_menu_model_delegate_t has refCounted interface
func (menu_model_delegate *CMenuModelDelegateT) HasOneRef() bool {
	return BaseHasOneRef(menu_model_delegate.p_menu_model_delegate)
}

func (p *C.cef_menu_model_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Perform the action associated with the specified |command_id| and optional
// |event_flags|.
///
type ExecuteCommandHandler interface {
	ExecuteCommand(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		command_id int,
		event_flags CEventFlagsT,
	)
}

///
// Called when the user moves the mouse outside the menu and over the owning
// window.
///
type MouseOutsideMenuHandler interface {
	MouseOutsideMenu(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		screen_point *CPointT,
	)
}

///
// Called on unhandled open submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
type UnhandledOpenSubmenuHandler interface {
	UnhandledOpenSubmenu(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		is_rtl int,
	)
}

///
// Called on unhandled close submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
type UnhandledCloseSubmenuHandler interface {
	UnhandledCloseSubmenu(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		is_rtl int,
	)
}

///
// The menu is about to show.
///
type MenuWillShowHandler interface {
	MenuWillShow(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
	)
}

///
// The menu has closed.
///
type MenuClosedHandler interface {
	MenuClosed(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
	)
}

///
// Optionally modify a menu item label. Return true (1) if |label| was
// modified.
///
type FormatLabelHandler interface {
	FormatLabel(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		label string,
	) (ret bool, labelOut string)
}

var menu_model_delegate_handlers = struct {
	execute_command_handler         map[*C.cef_menu_model_delegate_t]ExecuteCommandHandler
	mouse_outside_menu_handler      map[*C.cef_menu_model_delegate_t]MouseOutsideMenuHandler
	unhandled_open_submenu_handler  map[*C.cef_menu_model_delegate_t]UnhandledOpenSubmenuHandler
	unhandled_close_submenu_handler map[*C.cef_menu_model_delegate_t]UnhandledCloseSubmenuHandler
	menu_will_show_handler          map[*C.cef_menu_model_delegate_t]MenuWillShowHandler
	menu_closed_handler             map[*C.cef_menu_model_delegate_t]MenuClosedHandler
	format_label_handler            map[*C.cef_menu_model_delegate_t]FormatLabelHandler
}{
	map[*C.cef_menu_model_delegate_t]ExecuteCommandHandler{},
	map[*C.cef_menu_model_delegate_t]MouseOutsideMenuHandler{},
	map[*C.cef_menu_model_delegate_t]UnhandledOpenSubmenuHandler{},
	map[*C.cef_menu_model_delegate_t]UnhandledCloseSubmenuHandler{},
	map[*C.cef_menu_model_delegate_t]MenuWillShowHandler{},
	map[*C.cef_menu_model_delegate_t]MenuClosedHandler{},
	map[*C.cef_menu_model_delegate_t]FormatLabelHandler{},
}

// AllocCMenuModelDelegateT allocates CMenuModelDelegateT and construct it
func AllocCMenuModelDelegateT() *CMenuModelDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_menu_model_delegate_wrapper_t, "T13590:")
	cefp := C.cefingo_construct_menu_model_delegate((*C.cefingo_menu_model_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_menu_model_delegate_t itself in DeassocFunc,
		// or cef_menu_model_delegate_t is never GCed.
		Tracef(up, "T13596:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(menu_model_delegate_handlers.execute_command_handler, cefp)
		delete(menu_model_delegate_handlers.mouse_outside_menu_handler, cefp)
		delete(menu_model_delegate_handlers.unhandled_open_submenu_handler, cefp)
		delete(menu_model_delegate_handlers.unhandled_close_submenu_handler, cefp)
		delete(menu_model_delegate_handlers.menu_will_show_handler, cefp)
		delete(menu_model_delegate_handlers.menu_closed_handler, cefp)
		delete(menu_model_delegate_handlers.format_label_handler, cefp)
	}))

	return newCMenuModelDelegateT(cefp)
}

func (menu_model_delegate *CMenuModelDelegateT) Bind(a interface{}) *CMenuModelDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := menu_model_delegate.p_menu_model_delegate

	if h, ok := a.(ExecuteCommandHandler); ok {
		menu_model_delegate_handlers.execute_command_handler[cp] = h
	}

	if h, ok := a.(MouseOutsideMenuHandler); ok {
		menu_model_delegate_handlers.mouse_outside_menu_handler[cp] = h
	}

	if h, ok := a.(UnhandledOpenSubmenuHandler); ok {
		menu_model_delegate_handlers.unhandled_open_submenu_handler[cp] = h
	}

	if h, ok := a.(UnhandledCloseSubmenuHandler); ok {
		menu_model_delegate_handlers.unhandled_close_submenu_handler[cp] = h
	}

	if h, ok := a.(MenuWillShowHandler); ok {
		menu_model_delegate_handlers.menu_will_show_handler[cp] = h
	}

	if h, ok := a.(MenuClosedHandler); ok {
		menu_model_delegate_handlers.menu_closed_handler[cp] = h
	}

	if h, ok := a.(FormatLabelHandler); ok {
		menu_model_delegate_handlers.format_label_handler[cp] = h
	}

	if accessor, ok := a.(CMenuModelDelegateTAccessor); ok {
		accessor.SetCMenuModelDelegateT(menu_model_delegate)
		Logf("T13660:")
	}

	return menu_model_delegate
}

// cef_navigation_entry_capi.h, include/capi/cef_navigation_entry_capi.h:126:3,

///
// Structure used to represent an entry in navigation history.
///

// Go type for cef_navigation_entry_t
type CNavigationEntryT struct {
	noCopy             noCopy
	p_navigation_entry *C.cef_navigation_entry_t
}

type RefToCNavigationEntryT struct {
	p_navigation_entry *CNavigationEntryT
}

type CNavigationEntryTAccessor interface {
	GetCNavigationEntryT() *CNavigationEntryT
	SetCNavigationEntryT(*CNavigationEntryT)
}

func (r RefToCNavigationEntryT) GetCNavigationEntryT() *CNavigationEntryT {
	return r.p_navigation_entry
}

func (r *RefToCNavigationEntryT) SetCNavigationEntryT(p *CNavigationEntryT) {
	r.p_navigation_entry = p
}

// Go type CNavigationEntryT wraps cef type *C.cef_navigation_entry_t
func newCNavigationEntryT(p *C.cef_navigation_entry_t) *CNavigationEntryT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T13687:")
	BaseAddRef(p)
	go_navigation_entry := CNavigationEntryT{noCopy{}, p}
	runtime.SetFinalizer(&go_navigation_entry, func(g *CNavigationEntryT) {
		Tracef(unsafe.Pointer(g.p_navigation_entry), "T13691:")
		BaseRelease(g.p_navigation_entry)
	})
	return &go_navigation_entry
}

// *C.cef_navigation_entry_t has refCounted interface
func (navigation_entry *CNavigationEntryT) HasOneRef() bool {
	return BaseHasOneRef(navigation_entry.p_navigation_entry)
}

func (p *C.cef_navigation_entry_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CNavigationEntryT) IsValid() (ret bool) {

	cRet := C.cefingo_navigation_entry_is_valid(self.p_navigation_entry)

	ret = cRet == 1
	return ret
}

///
// Returns the actual URL of the page. For some pages this may be data: URL or
// similar. Use get_display_url() to return a display-friendly version.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetUrl() (ret string) {

	cRet := C.cefingo_navigation_entry_get_url(self.p_navigation_entry)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a display-friendly version of the URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetDisplayUrl() (ret string) {

	cRet := C.cefingo_navigation_entry_get_display_url(self.p_navigation_entry)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the original URL that was entered by the user before any redirects.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetOriginalUrl() (ret string) {

	cRet := C.cefingo_navigation_entry_get_original_url(self.p_navigation_entry)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the title set by the page. This value may be NULL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetTitle() (ret string) {

	cRet := C.cefingo_navigation_entry_get_title(self.p_navigation_entry)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the transition type which indicates what the user did to move to
// this page from the previous page.
///
func (self *CNavigationEntryT) GetTransitionType() (ret CTransitionTypeT) {

	cRet := C.cefingo_navigation_entry_get_transition_type(self.p_navigation_entry)

	ret = CTransitionTypeT(cRet)
	return ret
}

///
// Returns true (1) if this navigation includes post data.
///
func (self *CNavigationEntryT) HasPostData() (ret bool) {

	cRet := C.cefingo_navigation_entry_has_post_data(self.p_navigation_entry)

	ret = cRet == 1
	return ret
}

///
// Returns the time for the last known successful navigation completion. A
// navigation may be completed more than once if the page is reloaded. May be
// 0 if the navigation has not yet completed.
///
func (self *CNavigationEntryT) GetCompletionTime() (ret CTimeT) {

	cRet := C.cefingo_navigation_entry_get_completion_time(self.p_navigation_entry)

	ret = (CTimeT)(cRet)
	return ret
}

///
// Returns the HTTP status code for the last known successful navigation
// response. May be 0 if the response has not yet been received or if the
// navigation has not yet completed.
///
func (self *CNavigationEntryT) GetHttpStatusCode() (ret bool) {

	cRet := C.cefingo_navigation_entry_get_http_status_code(self.p_navigation_entry)

	ret = cRet == 1
	return ret
}

///
// Returns the SSL information for this navigation entry.
///
func (self *CNavigationEntryT) GetSslstatus() (ret *CSslstatusT) {

	cRet := C.cefingo_navigation_entry_get_sslstatus(self.p_navigation_entry)

	ret = newCSslstatusT(cRet)
	return ret
}

// cef_panel_capi.h, include/capi/views/cef_panel_capi.h:139:3,

///
// A Panel is a container in the views hierarchy that can contain other Views as
// children. Methods must be called on the browser process UI thread unless
// otherwise indicated.
///

// Go type for cef_panel_t
type CPanelT struct {
	noCopy  noCopy
	p_panel *C.cef_panel_t
}

type RefToCPanelT struct {
	p_panel *CPanelT
}

type CPanelTAccessor interface {
	GetCPanelT() *CPanelT
	SetCPanelT(*CPanelT)
}

func (r RefToCPanelT) GetCPanelT() *CPanelT {
	return r.p_panel
}

func (r *RefToCPanelT) SetCPanelT(p *CPanelT) {
	r.p_panel = p
}

// Go type CPanelT wraps cef type *C.cef_panel_t
func newCPanelT(p *C.cef_panel_t) *CPanelT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T13898:")
	BaseAddRef(p)
	go_panel := CPanelT{noCopy{}, p}
	runtime.SetFinalizer(&go_panel, func(g *CPanelT) {
		Tracef(unsafe.Pointer(g.p_panel), "T13902:")
		BaseRelease(g.p_panel)
	})
	return &go_panel
}

// *C.cef_panel_t has refCounted interface
func (panel *CPanelT) HasOneRef() bool {
	return BaseHasOneRef(panel.p_panel)
}

func (p *C.cef_panel_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (panel *CPanelT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(panel.p_panel))
	return newCViewT(p)
}

///
// Returns this Panel as a Window or NULL if this is not a Window.
///
func (self *CPanelT) AsWindow() (ret *CWindowT) {

	cRet := C.cefingo_panel_as_window(self.p_panel)

	ret = newCWindowT(cRet)
	return ret
}

///
// Set this Panel&#39;s Layout to FillLayout and return the FillLayout object.
///
func (self *CPanelT) SetToFillLayout() (ret *CFillLayoutT) {

	cRet := C.cefingo_panel_set_to_fill_layout(self.p_panel)

	ret = newCFillLayoutT(cRet)
	return ret
}

///
// Set this Panel&#39;s Layout to BoxLayout and return the BoxLayout object.
///
func (self *CPanelT) SetToBoxLayout(
	settings *CBoxLayoutSettingsT,
) (ret *CBoxLayoutT) {

	cRet := C.cefingo_panel_set_to_box_layout(self.p_panel, (*C.cef_box_layout_settings_t)(settings))

	ret = newCBoxLayoutT(cRet)
	return ret
}

///
// Get the Layout.
///
func (self *CPanelT) GetLayout() (ret *CLayoutT) {

	cRet := C.cefingo_panel_get_layout(self.p_panel)

	ret = newCLayoutT(cRet)
	return ret
}

///
// Lay out the child Views (set their bounds based on sizing heuristics
// specific to the current Layout).
///
func (self *CPanelT) Layout() {

	C.cefingo_panel_layout(self.p_panel)

}

///
// Add a child View.
///
func (self *CPanelT) AddChildView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	C.cefingo_panel_add_child_view(self.p_panel, goTmpview)

}

///
// Add a child View at the specified |index|. If |index| matches the result of
// GetChildCount() then the View will be added at the end.
///
func (self *CPanelT) AddChildViewAt(
	view *CViewT,
	index int,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	C.cefingo_panel_add_child_view_at(self.p_panel, goTmpview, (C.int)(index))

}

///
// Move the child View to the specified |index|. A negative value for |index|
// will move the View to the end.
///
func (self *CPanelT) ReorderChildView(
	view *CViewT,
	index int,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	C.cefingo_panel_reorder_child_view(self.p_panel, goTmpview, (C.int)(index))

}

///
// Remove a child View. The View can then be added to another Panel.
///
func (self *CPanelT) RemoveChildView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	C.cefingo_panel_remove_child_view(self.p_panel, goTmpview)

}

///
// Remove all child Views. The removed Views will be deleted if the client
// holds no references to them.
///
func (self *CPanelT) RemoveAllChildViews() {

	C.cefingo_panel_remove_all_child_views(self.p_panel)

}

///
// Returns the number of child Views.
///
func (self *CPanelT) GetChildViewCount() (ret int64) {

	cRet := C.cefingo_panel_get_child_view_count(self.p_panel)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the child View at the specified |index|.
///
func (self *CPanelT) GetChildViewAt(
	index int,
) (ret *CViewT) {

	cRet := C.cefingo_panel_get_child_view_at(self.p_panel, (C.int)(index))

	ret = newCViewT(cRet)
	return ret
}

///
// Create a new Panel.
///
func PanelCreate(
	delegate *CPanelDelegateT,
) (ret *CPanelT) {
	var goTmpdelegate *C.cef_panel_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_panel_delegate
		BaseAddRef(goTmpdelegate)
	}

	cRet := C.cef_panel_create(goTmpdelegate)

	ret = newCPanelT(cRet)
	return ret
}

// cef_panel_delegate_capi.h, include/capi/views/cef_panel_delegate_capi.h:59:3,

///
// Implement this structure to handle Panel events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_panel_delegate_t
type CPanelDelegateT struct {
	noCopy           noCopy
	p_panel_delegate *C.cef_panel_delegate_t
}

type RefToCPanelDelegateT struct {
	p_panel_delegate *CPanelDelegateT
}

type CPanelDelegateTAccessor interface {
	GetCPanelDelegateT() *CPanelDelegateT
	SetCPanelDelegateT(*CPanelDelegateT)
}

func (r RefToCPanelDelegateT) GetCPanelDelegateT() *CPanelDelegateT {
	return r.p_panel_delegate
}

func (r *RefToCPanelDelegateT) SetCPanelDelegateT(p *CPanelDelegateT) {
	r.p_panel_delegate = p
}

// Go type CPanelDelegateT wraps cef type *C.cef_panel_delegate_t
func newCPanelDelegateT(p *C.cef_panel_delegate_t) *CPanelDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T14152:")
	BaseAddRef(p)
	go_panel_delegate := CPanelDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_panel_delegate, func(g *CPanelDelegateT) {
		Tracef(unsafe.Pointer(g.p_panel_delegate), "T14156:")
		BaseRelease(g.p_panel_delegate)
	})
	return &go_panel_delegate
}

// *C.cef_panel_delegate_t has refCounted interface
func (panel_delegate *CPanelDelegateT) HasOneRef() bool {
	return BaseHasOneRef(panel_delegate.p_panel_delegate)
}

func (p *C.cef_panel_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (panel_delegate *CPanelDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(panel_delegate.p_panel_delegate))
	return newCViewDelegateT(p)
}

var panel_delegate_handlers = struct {
	get_preferred_size_handler     map[*C.cef_panel_delegate_t]GetPreferredSizeHandler
	get_minimum_size_handler       map[*C.cef_panel_delegate_t]GetMinimumSizeHandler
	get_maximum_size_handler       map[*C.cef_panel_delegate_t]GetMaximumSizeHandler
	get_height_for_width_handler   map[*C.cef_panel_delegate_t]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*C.cef_panel_delegate_t]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*C.cef_panel_delegate_t]OnChildViewChangedHandler
	on_focus_handler               map[*C.cef_panel_delegate_t]OnFocusHandler
	on_blur_handler                map[*C.cef_panel_delegate_t]OnBlurHandler
}{
	map[*C.cef_panel_delegate_t]GetPreferredSizeHandler{},
	map[*C.cef_panel_delegate_t]GetMinimumSizeHandler{},
	map[*C.cef_panel_delegate_t]GetMaximumSizeHandler{},
	map[*C.cef_panel_delegate_t]GetHeightForWidthHandler{},
	map[*C.cef_panel_delegate_t]OnParentViewChangedHandler{},
	map[*C.cef_panel_delegate_t]OnChildViewChangedHandler{},
	map[*C.cef_panel_delegate_t]OnFocusHandler{},
	map[*C.cef_panel_delegate_t]OnBlurHandler{},
}

// AllocCPanelDelegateT allocates CPanelDelegateT and construct it
func AllocCPanelDelegateT() *CPanelDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_panel_delegate_wrapper_t, "T14198:")
	cefp := C.cefingo_construct_panel_delegate((*C.cefingo_panel_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_panel_delegate_t itself in DeassocFunc,
		// or cef_panel_delegate_t is never GCed.
		Tracef(up, "T14204:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(panel_delegate_handlers.get_preferred_size_handler, cefp)
		delete(panel_delegate_handlers.get_minimum_size_handler, cefp)
		delete(panel_delegate_handlers.get_maximum_size_handler, cefp)
		delete(panel_delegate_handlers.get_height_for_width_handler, cefp)
		delete(panel_delegate_handlers.on_parent_view_changed_handler, cefp)
		delete(panel_delegate_handlers.on_child_view_changed_handler, cefp)
		delete(panel_delegate_handlers.on_focus_handler, cefp)
		delete(panel_delegate_handlers.on_blur_handler, cefp)
	}))

	return newCPanelDelegateT(cefp)
}

func (panel_delegate *CPanelDelegateT) Bind(a interface{}) *CPanelDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := panel_delegate.p_panel_delegate

	if h, ok := a.(GetPreferredSizeHandler); ok {
		panel_delegate_handlers.get_preferred_size_handler[cp] = h
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		panel_delegate_handlers.get_minimum_size_handler[cp] = h
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		panel_delegate_handlers.get_maximum_size_handler[cp] = h
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		panel_delegate_handlers.get_height_for_width_handler[cp] = h
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		panel_delegate_handlers.on_parent_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		panel_delegate_handlers.on_child_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnFocusHandler); ok {
		panel_delegate_handlers.on_focus_handler[cp] = h
	}

	if h, ok := a.(OnBlurHandler); ok {
		panel_delegate_handlers.on_blur_handler[cp] = h
	}

	if accessor, ok := a.(CPanelDelegateTAccessor); ok {
		accessor.SetCPanelDelegateT(panel_delegate)
		Logf("T14273:")
	}

	return panel_delegate
}

// cef_print_handler_capi.h, include/capi/cef_print_handler_capi.h:70:3,

///
// Callback structure for asynchronous continuation of print dialog requests.
///

// Go type for cef_print_dialog_callback_t
type CPrintDialogCallbackT struct {
	noCopy                  noCopy
	p_print_dialog_callback *C.cef_print_dialog_callback_t
}

type RefToCPrintDialogCallbackT struct {
	p_print_dialog_callback *CPrintDialogCallbackT
}

type CPrintDialogCallbackTAccessor interface {
	GetCPrintDialogCallbackT() *CPrintDialogCallbackT
	SetCPrintDialogCallbackT(*CPrintDialogCallbackT)
}

func (r RefToCPrintDialogCallbackT) GetCPrintDialogCallbackT() *CPrintDialogCallbackT {
	return r.p_print_dialog_callback
}

func (r *RefToCPrintDialogCallbackT) SetCPrintDialogCallbackT(p *CPrintDialogCallbackT) {
	r.p_print_dialog_callback = p
}

// Go type CPrintDialogCallbackT wraps cef type *C.cef_print_dialog_callback_t
func newCPrintDialogCallbackT(p *C.cef_print_dialog_callback_t) *CPrintDialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T14300:")
	BaseAddRef(p)
	go_print_dialog_callback := CPrintDialogCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_print_dialog_callback, func(g *CPrintDialogCallbackT) {
		Tracef(unsafe.Pointer(g.p_print_dialog_callback), "T14304:")
		BaseRelease(g.p_print_dialog_callback)
	})
	return &go_print_dialog_callback
}

// *C.cef_print_dialog_callback_t has refCounted interface
func (print_dialog_callback *CPrintDialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(print_dialog_callback.p_print_dialog_callback)
}

func (p *C.cef_print_dialog_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Continue printing with the specified |settings|.
///
func (self *CPrintDialogCallbackT) Cont(
	settings *CPrintSettingsT,
) {
	var goTmpsettings *C.cef_print_settings_t
	if settings != nil {
		goTmpsettings = settings.p_print_settings
		BaseAddRef(goTmpsettings)
	}

	C.cefingo_print_dialog_callback_cont(self.p_print_dialog_callback, goTmpsettings)

}

///
// Cancel the printing.
///
func (self *CPrintDialogCallbackT) Cancel() {

	C.cefingo_print_dialog_callback_cancel(self.p_print_dialog_callback)

}

///
// Callback structure for asynchronous continuation of print job requests.
///

// Go type for cef_print_job_callback_t
type CPrintJobCallbackT struct {
	noCopy               noCopy
	p_print_job_callback *C.cef_print_job_callback_t
}

type RefToCPrintJobCallbackT struct {
	p_print_job_callback *CPrintJobCallbackT
}

type CPrintJobCallbackTAccessor interface {
	GetCPrintJobCallbackT() *CPrintJobCallbackT
	SetCPrintJobCallbackT(*CPrintJobCallbackT)
}

func (r RefToCPrintJobCallbackT) GetCPrintJobCallbackT() *CPrintJobCallbackT {
	return r.p_print_job_callback
}

func (r *RefToCPrintJobCallbackT) SetCPrintJobCallbackT(p *CPrintJobCallbackT) {
	r.p_print_job_callback = p
}

// Go type CPrintJobCallbackT wraps cef type *C.cef_print_job_callback_t
func newCPrintJobCallbackT(p *C.cef_print_job_callback_t) *CPrintJobCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T14378:")
	BaseAddRef(p)
	go_print_job_callback := CPrintJobCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_print_job_callback, func(g *CPrintJobCallbackT) {
		Tracef(unsafe.Pointer(g.p_print_job_callback), "T14382:")
		BaseRelease(g.p_print_job_callback)
	})
	return &go_print_job_callback
}

// *C.cef_print_job_callback_t has refCounted interface
func (print_job_callback *CPrintJobCallbackT) HasOneRef() bool {
	return BaseHasOneRef(print_job_callback.p_print_job_callback)
}

func (p *C.cef_print_job_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Indicate completion of the print job.
///
func (self *CPrintJobCallbackT) Cont() {

	C.cefingo_print_job_callback_cont(self.p_print_job_callback)

}

///
// Implement this structure to handle printing on Linux. Each browser will have
// only one print job in progress at a time. The functions of this structure
// will be called on the browser process UI thread.
///

// Go type for cef_print_handler_t
type CPrintHandlerT struct {
	noCopy          noCopy
	p_print_handler *C.cef_print_handler_t
}

type RefToCPrintHandlerT struct {
	p_print_handler *CPrintHandlerT
}

type CPrintHandlerTAccessor interface {
	GetCPrintHandlerT() *CPrintHandlerT
	SetCPrintHandlerT(*CPrintHandlerT)
}

func (r RefToCPrintHandlerT) GetCPrintHandlerT() *CPrintHandlerT {
	return r.p_print_handler
}

func (r *RefToCPrintHandlerT) SetCPrintHandlerT(p *CPrintHandlerT) {
	r.p_print_handler = p
}

// Go type CPrintHandlerT wraps cef type *C.cef_print_handler_t
func newCPrintHandlerT(p *C.cef_print_handler_t) *CPrintHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T14441:")
	BaseAddRef(p)
	go_print_handler := CPrintHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_print_handler, func(g *CPrintHandlerT) {
		Tracef(unsafe.Pointer(g.p_print_handler), "T14445:")
		BaseRelease(g.p_print_handler)
	})
	return &go_print_handler
}

// *C.cef_print_handler_t has refCounted interface
func (print_handler *CPrintHandlerT) HasOneRef() bool {
	return BaseHasOneRef(print_handler.p_print_handler)
}

func (p *C.cef_print_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called when printing has started for the specified |browser|. This function
// will be called before the other OnPrint*() functions and irrespective of
// how printing was initiated (e.g. cef_browser_host_t::print(), JavaScript
// window.print() or PDF extension print button).
///
type OnPrintStartHandler interface {
	OnPrintStart(
		self *CPrintHandlerT,
		browser *CBrowserT,
	)
}

///
// Synchronize |settings| with client state. If |get_defaults| is true (1)
// then populate |settings| with the default print settings. Do not keep a
// reference to |settings| outside of this callback.
///
type OnPrintSettingsHandler interface {
	OnPrintSettings(
		self *CPrintHandlerT,
		browser *CBrowserT,
		settings *CPrintSettingsT,
		get_defaults int,
	)
}

///
// Show the print dialog. Execute |callback| once the dialog is dismissed.
// Return true (1) if the dialog will be displayed or false (0) to cancel the
// printing immediately.
///
type OnPrintDialogHandler interface {
	OnPrintDialog(
		self *CPrintHandlerT,
		browser *CBrowserT,
		has_selection int,
		callback *CPrintDialogCallbackT,
	) (ret bool)
}

///
// Send the print job to the printer. Execute |callback| once the job is
// completed. Return true (1) if the job will proceed or false (0) to cancel
// the job immediately.
///
type OnPrintJobHandler interface {
	OnPrintJob(
		self *CPrintHandlerT,
		browser *CBrowserT,
		document_name string,
		pdf_file_path string,
		callback *CPrintJobCallbackT,
	) (ret bool)
}

///
// Reset client state related to printing.
///
type OnPrintResetHandler interface {
	OnPrintReset(
		self *CPrintHandlerT,
		browser *CBrowserT,
	)
}

///
// Return the PDF paper size in device units. Used in combination with
// cef_browser_host_t::print_to_pdf().
///
type GetPdfPaperSizeHandler interface {
	GetPdfPaperSize(
		self *CPrintHandlerT,
		device_units_per_inch int,
	) (ret CSizeT)
}

var print_handler_handlers = struct {
	on_print_start_handler     map[*C.cef_print_handler_t]OnPrintStartHandler
	on_print_settings_handler  map[*C.cef_print_handler_t]OnPrintSettingsHandler
	on_print_dialog_handler    map[*C.cef_print_handler_t]OnPrintDialogHandler
	on_print_job_handler       map[*C.cef_print_handler_t]OnPrintJobHandler
	on_print_reset_handler     map[*C.cef_print_handler_t]OnPrintResetHandler
	get_pdf_paper_size_handler map[*C.cef_print_handler_t]GetPdfPaperSizeHandler
}{
	map[*C.cef_print_handler_t]OnPrintStartHandler{},
	map[*C.cef_print_handler_t]OnPrintSettingsHandler{},
	map[*C.cef_print_handler_t]OnPrintDialogHandler{},
	map[*C.cef_print_handler_t]OnPrintJobHandler{},
	map[*C.cef_print_handler_t]OnPrintResetHandler{},
	map[*C.cef_print_handler_t]GetPdfPaperSizeHandler{},
}

// AllocCPrintHandlerT allocates CPrintHandlerT and construct it
func AllocCPrintHandlerT() *CPrintHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_print_handler_wrapper_t, "T14555:")
	cefp := C.cefingo_construct_print_handler((*C.cefingo_print_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_print_handler_t itself in DeassocFunc,
		// or cef_print_handler_t is never GCed.
		Tracef(up, "T14561:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(print_handler_handlers.on_print_start_handler, cefp)
		delete(print_handler_handlers.on_print_settings_handler, cefp)
		delete(print_handler_handlers.on_print_dialog_handler, cefp)
		delete(print_handler_handlers.on_print_job_handler, cefp)
		delete(print_handler_handlers.on_print_reset_handler, cefp)
		delete(print_handler_handlers.get_pdf_paper_size_handler, cefp)
	}))

	return newCPrintHandlerT(cefp)
}

func (print_handler *CPrintHandlerT) Bind(a interface{}) *CPrintHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := print_handler.p_print_handler

	if h, ok := a.(OnPrintStartHandler); ok {
		print_handler_handlers.on_print_start_handler[cp] = h
	}

	if h, ok := a.(OnPrintSettingsHandler); ok {
		print_handler_handlers.on_print_settings_handler[cp] = h
	}

	if h, ok := a.(OnPrintDialogHandler); ok {
		print_handler_handlers.on_print_dialog_handler[cp] = h
	}

	if h, ok := a.(OnPrintJobHandler); ok {
		print_handler_handlers.on_print_job_handler[cp] = h
	}

	if h, ok := a.(OnPrintResetHandler); ok {
		print_handler_handlers.on_print_reset_handler[cp] = h
	}

	if h, ok := a.(GetPdfPaperSizeHandler); ok {
		print_handler_handlers.get_pdf_paper_size_handler[cp] = h
	}

	if accessor, ok := a.(CPrintHandlerTAccessor); ok {
		accessor.SetCPrintHandlerT(print_handler)
		Logf("T14620:")
	}

	return print_handler
}

// cef_print_settings_capi.h, include/capi/cef_print_settings_capi.h:191:3,

///
// Structure representing print settings.
///

// Go type for cef_print_settings_t
type CPrintSettingsT struct {
	noCopy           noCopy
	p_print_settings *C.cef_print_settings_t
}

type RefToCPrintSettingsT struct {
	p_print_settings *CPrintSettingsT
}

type CPrintSettingsTAccessor interface {
	GetCPrintSettingsT() *CPrintSettingsT
	SetCPrintSettingsT(*CPrintSettingsT)
}

func (r RefToCPrintSettingsT) GetCPrintSettingsT() *CPrintSettingsT {
	return r.p_print_settings
}

func (r *RefToCPrintSettingsT) SetCPrintSettingsT(p *CPrintSettingsT) {
	r.p_print_settings = p
}

// Go type CPrintSettingsT wraps cef type *C.cef_print_settings_t
func newCPrintSettingsT(p *C.cef_print_settings_t) *CPrintSettingsT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T14647:")
	BaseAddRef(p)
	go_print_settings := CPrintSettingsT{noCopy{}, p}
	runtime.SetFinalizer(&go_print_settings, func(g *CPrintSettingsT) {
		Tracef(unsafe.Pointer(g.p_print_settings), "T14651:")
		BaseRelease(g.p_print_settings)
	})
	return &go_print_settings
}

// *C.cef_print_settings_t has refCounted interface
func (print_settings *CPrintSettingsT) HasOneRef() bool {
	return BaseHasOneRef(print_settings.p_print_settings)
}

func (p *C.cef_print_settings_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CPrintSettingsT) IsValid() (ret bool) {

	cRet := C.cefingo_print_settings_is_valid(self.p_print_settings)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CPrintSettingsT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_print_settings_is_read_only(self.p_print_settings)

	ret = cRet == 1
	return ret
}

///
// Set the page orientation.
///
func (self *CPrintSettingsT) SetOrientation(
	landscape int,
) {

	C.cefingo_print_settings_set_orientation(self.p_print_settings, (C.int)(landscape))

}

///
// Returns true (1) if the orientation is landscape.
///
func (self *CPrintSettingsT) IsLandscape() (ret bool) {

	cRet := C.cefingo_print_settings_is_landscape(self.p_print_settings)

	ret = cRet == 1
	return ret
}

///
// Set the printer printable area in device units. Some platforms already
// provide flipped area. Set |landscape_needs_flip| to false (0) on those
// platforms to avoid double flipping.
///
func (self *CPrintSettingsT) SetPrinterPrintableArea(
	physical_size_device_units *CSizeT,
	printable_area_device_units *CRectT,
	landscape_needs_flip int,
) {

	C.cefingo_print_settings_set_printer_printable_area(self.p_print_settings, (*C.cef_size_t)(physical_size_device_units), (*C.cef_rect_t)(printable_area_device_units), (C.int)(landscape_needs_flip))

}

///
// Set the device name.
///
func (self *CPrintSettingsT) SetDeviceName(
	name string,
) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	C.cefingo_print_settings_set_device_name(self.p_print_settings, (*C.cef_string_t)(c_name))

}

///
// Get the device name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CPrintSettingsT) GetDeviceName() (ret string) {

	cRet := C.cefingo_print_settings_get_device_name(self.p_print_settings)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the DPI (dots per inch).
///
func (self *CPrintSettingsT) SetDpi(
	dpi int,
) {

	C.cefingo_print_settings_set_dpi(self.p_print_settings, (C.int)(dpi))

}

///
// Get the DPI (dots per inch).
///
func (self *CPrintSettingsT) GetDpi() (ret bool) {

	cRet := C.cefingo_print_settings_get_dpi(self.p_print_settings)

	ret = cRet == 1
	return ret
}

///
// Set the page ranges.
///
func (self *CPrintSettingsT) SetPageRanges(
	rangesCount int64,
	ranges *CRangeT,
) {

	C.cefingo_print_settings_set_page_ranges(self.p_print_settings, (C.size_t)(rangesCount), (*C.cef_range_t)(ranges))

}

///
// Returns the number of page ranges that currently exist.
///
func (self *CPrintSettingsT) GetPageRangesCount() (ret int64) {

	cRet := C.cefingo_print_settings_get_page_ranges_count(self.p_print_settings)

	ret = (int64)(cRet)
	return ret
}

///
// Set whether only the selection will be printed.
///
func (self *CPrintSettingsT) SetSelectionOnly(
	selection_only int,
) {

	C.cefingo_print_settings_set_selection_only(self.p_print_settings, (C.int)(selection_only))

}

///
// Returns true (1) if only the selection will be printed.
///
func (self *CPrintSettingsT) IsSelectionOnly() (ret bool) {

	cRet := C.cefingo_print_settings_is_selection_only(self.p_print_settings)

	ret = cRet == 1
	return ret
}

///
// Set whether pages will be collated.
///
func (self *CPrintSettingsT) SetCollate(
	collate int,
) {

	C.cefingo_print_settings_set_collate(self.p_print_settings, (C.int)(collate))

}

///
// Returns true (1) if pages will be collated.
///
func (self *CPrintSettingsT) WillCollate() (ret bool) {

	cRet := C.cefingo_print_settings_will_collate(self.p_print_settings)

	ret = cRet == 1
	return ret
}

///
// Set the color model.
///
func (self *CPrintSettingsT) SetColorModel(
	model CColorModelT,
) {

	C.cefingo_print_settings_set_color_model(self.p_print_settings, (C.cef_color_model_t)(model))

}

///
// Get the color model.
///
func (self *CPrintSettingsT) GetColorModel() (ret CColorModelT) {

	cRet := C.cefingo_print_settings_get_color_model(self.p_print_settings)

	ret = CColorModelT(cRet)
	return ret
}

///
// Set the number of copies.
///
func (self *CPrintSettingsT) SetCopies(
	copies int,
) {

	C.cefingo_print_settings_set_copies(self.p_print_settings, (C.int)(copies))

}

///
// Get the number of copies.
///
func (self *CPrintSettingsT) GetCopies() (ret bool) {

	cRet := C.cefingo_print_settings_get_copies(self.p_print_settings)

	ret = cRet == 1
	return ret
}

///
// Set the duplex mode.
///
func (self *CPrintSettingsT) SetDuplexMode(
	mode CDuplexModeT,
) {

	C.cefingo_print_settings_set_duplex_mode(self.p_print_settings, (C.cef_duplex_mode_t)(mode))

}

///
// Get the duplex mode.
///
func (self *CPrintSettingsT) GetDuplexMode() (ret CDuplexModeT) {

	cRet := C.cefingo_print_settings_get_duplex_mode(self.p_print_settings)

	ret = CDuplexModeT(cRet)
	return ret
}

///
// Create a new cef_print_settings_t object.
///
func PrintSettingsCreate() (ret *CPrintSettingsT) {

	cRet := C.cef_print_settings_create()

	ret = newCPrintSettingsT(cRet)
	return ret
}

// cef_process_message_capi.h, include/capi/cef_process_message_capi.h:89:3,

///
// Structure representing a message. Can be used on any process and thread.
///

// Go type for cef_process_message_t
type CProcessMessageT struct {
	noCopy            noCopy
	p_process_message *C.cef_process_message_t
}

type RefToCProcessMessageT struct {
	p_process_message *CProcessMessageT
}

type CProcessMessageTAccessor interface {
	GetCProcessMessageT() *CProcessMessageT
	SetCProcessMessageT(*CProcessMessageT)
}

func (r RefToCProcessMessageT) GetCProcessMessageT() *CProcessMessageT {
	return r.p_process_message
}

func (r *RefToCProcessMessageT) SetCProcessMessageT(p *CProcessMessageT) {
	r.p_process_message = p
}

// Go type CProcessMessageT wraps cef type *C.cef_process_message_t
func newCProcessMessageT(p *C.cef_process_message_t) *CProcessMessageT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T14989:")
	BaseAddRef(p)
	go_process_message := CProcessMessageT{noCopy{}, p}
	runtime.SetFinalizer(&go_process_message, func(g *CProcessMessageT) {
		Tracef(unsafe.Pointer(g.p_process_message), "T14993:")
		BaseRelease(g.p_process_message)
	})
	return &go_process_message
}

// *C.cef_process_message_t has refCounted interface
func (process_message *CProcessMessageT) HasOneRef() bool {
	return BaseHasOneRef(process_message.p_process_message)
}

func (p *C.cef_process_message_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CProcessMessageT) IsValid() (ret bool) {

	cRet := C.cefingo_process_message_is_valid(self.p_process_message)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CProcessMessageT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_process_message_is_read_only(self.p_process_message)

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object.
///
func (self *CProcessMessageT) Copy() (ret *CProcessMessageT) {

	cRet := C.cefingo_process_message_copy(self.p_process_message)

	ret = newCProcessMessageT(cRet)
	return ret
}

///
// Returns the message name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CProcessMessageT) GetName() (ret string) {

	cRet := C.cefingo_process_message_get_name(self.p_process_message)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the list of arguments.
///
func (self *CProcessMessageT) GetArgumentList() (ret *CListValueT) {

	cRet := C.cefingo_process_message_get_argument_list(self.p_process_message)

	ret = newCListValueT(cRet)
	return ret
}

///
// Create a new cef_process_message_t object with the specified name.
///
func ProcessMessageCreate(
	name string,
) (ret *CProcessMessageT) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cef_process_message_create((*C.cef_string_t)(c_name))

	ret = newCProcessMessageT(cRet)
	return ret
}

// cef_registration_capi.h, include/capi/cef_registration_capi.h:57:3,

///
// Generic callback structure used for managing the lifespan of a registration.
///

// Go type for cef_registration_t
type CRegistrationT struct {
	noCopy         noCopy
	p_registration *C.cef_registration_t
}

type RefToCRegistrationT struct {
	p_registration *CRegistrationT
}

type CRegistrationTAccessor interface {
	GetCRegistrationT() *CRegistrationT
	SetCRegistrationT(*CRegistrationT)
}

func (r RefToCRegistrationT) GetCRegistrationT() *CRegistrationT {
	return r.p_registration
}

func (r *RefToCRegistrationT) SetCRegistrationT(p *CRegistrationT) {
	r.p_registration = p
}

// Go type CRegistrationT wraps cef type *C.cef_registration_t
func newCRegistrationT(p *C.cef_registration_t) *CRegistrationT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T15129:")
	BaseAddRef(p)
	go_registration := CRegistrationT{noCopy{}, p}
	runtime.SetFinalizer(&go_registration, func(g *CRegistrationT) {
		Tracef(unsafe.Pointer(g.p_registration), "T15133:")
		BaseRelease(g.p_registration)
	})
	return &go_registration
}

// *C.cef_registration_t has refCounted interface
func (registration *CRegistrationT) HasOneRef() bool {
	return BaseHasOneRef(registration.p_registration)
}

func (p *C.cef_registration_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

// cef_render_handler_capi.h, include/capi/cef_render_handler_capi.h:245:3,

///
// Implement this structure to handle events when window rendering is disabled.
// The functions of this structure will be called on the UI thread.
///

// Go type for cef_render_handler_t
type CRenderHandlerT struct {
	noCopy           noCopy
	p_render_handler *C.cef_render_handler_t
}

type RefToCRenderHandlerT struct {
	p_render_handler *CRenderHandlerT
}

type CRenderHandlerTAccessor interface {
	GetCRenderHandlerT() *CRenderHandlerT
	SetCRenderHandlerT(*CRenderHandlerT)
}

func (r RefToCRenderHandlerT) GetCRenderHandlerT() *CRenderHandlerT {
	return r.p_render_handler
}

func (r *RefToCRenderHandlerT) SetCRenderHandlerT(p *CRenderHandlerT) {
	r.p_render_handler = p
}

// Go type CRenderHandlerT wraps cef type *C.cef_render_handler_t
func newCRenderHandlerT(p *C.cef_render_handler_t) *CRenderHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T15182:")
	BaseAddRef(p)
	go_render_handler := CRenderHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_render_handler, func(g *CRenderHandlerT) {
		Tracef(unsafe.Pointer(g.p_render_handler), "T15186:")
		BaseRelease(g.p_render_handler)
	})
	return &go_render_handler
}

// *C.cef_render_handler_t has refCounted interface
func (render_handler *CRenderHandlerT) HasOneRef() bool {
	return BaseHasOneRef(render_handler.p_render_handler)
}

func (p *C.cef_render_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called to retrieve the root window rectangle in screen coordinates. Return
// true (1) if the rectangle was provided. If this function returns false (0)
// the rectangle from GetViewRect will be used.
///
type GetRootScreenRectHandler interface {
	GetRootScreenRect(
		self *CRenderHandlerT,
		browser *CBrowserT,
	) (ret bool, rect CRectT)
}

///
// Called to retrieve the view rectangle which is relative to screen
// coordinates. This function must always provide a non-NULL rectangle.
///
type GetViewRectHandler interface {
	GetViewRect(
		self *CRenderHandlerT,
		browser *CBrowserT,
	) (rect CRectT)
}

///
// Called to retrieve the translation from view coordinates to actual screen
// coordinates. Return true (1) if the screen coordinates were provided.
///
type GetScreenPointHandler interface {
	GetScreenPoint(
		self *CRenderHandlerT,
		browser *CBrowserT,
		viewX int,
		viewY int,
	) (ret bool, screenX int, screenY int)
}

///
// Called to allow the client to fill in the CefScreenInfo object with
// appropriate values. Return true (1) if the |screen_info| structure has been
// modified.
//
// If the screen info rectangle is left NULL the rectangle from GetViewRect
// will be used. If the rectangle is still NULL or invalid popups may not be
// drawn correctly.
///
type GetScreenInfoHandler interface {
	GetScreenInfo(
		self *CRenderHandlerT,
		browser *CBrowserT,
		screen_info *CScreenInfoT,
	) (ret bool)
}

///
// Called when the browser wants to show or hide the popup widget. The popup
// should be shown if |show| is true (1) and hidden if |show| is false (0).
///
type OnPopupShowHandler interface {
	OnPopupShow(
		self *CRenderHandlerT,
		browser *CBrowserT,
		show int,
	)
}

///
// Called when the browser wants to move or resize the popup widget. |rect|
// contains the new location and size in view coordinates.
///
type OnPopupSizeHandler interface {
	OnPopupSize(
		self *CRenderHandlerT,
		browser *CBrowserT,
		rect *CRectT,
	)
}

///
// Called when an element should be painted. Pixel values passed to this
// function are scaled relative to view coordinates based on the value of
// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
// indicates whether the element is the view or the popup widget. |buffer|
// contains the pixel data for the whole image. |dirtyRects| contains the set
// of rectangles in pixel coordinates that need to be repainted. |buffer| will
// be |width|*|height|*4 bytes in size and represents a BGRA image with an
// upper-left origin. This function is only called when
// cef_window_tInfo::shared_texture_enabled is set to false (0).
///
type OnPaintHandler interface {
	OnPaint(
		self *CRenderHandlerT,
		browser *CBrowserT,
		ctype CPaintElementTypeT,
		dirtyRectsCount int64,
		dirtyRects *CRectT,
		buffer unsafe.Pointer,
		width int,
		height int,
	)
}

///
// Called when an element has been rendered to the shared texture handle.
// |type| indicates whether the element is the view or the popup widget.
// |dirtyRects| contains the set of rectangles in pixel coordinates that need
// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
// can be accessed via ID3D11Device using the OpenSharedResource function.
// This function is only called when cef_window_tInfo::shared_texture_enabled
// is set to true (1), and is currently only supported on Windows.
///
type OnAcceleratedPaintHandler interface {
	OnAcceleratedPaint(
		self *CRenderHandlerT,
		browser *CBrowserT,
		ctype CPaintElementTypeT,
		dirtyRectsCount int64,
		dirtyRects *CRectT,
		shared_handle unsafe.Pointer,
	)
}

///
// Called when the browser&#39;s cursor has changed. If |type| is CT_CUSTOM then
// |custom_cursor_info| will be populated with the custom cursor information.
///
type OnCursorChangeHandler interface {
	OnCursorChange(
		self *CRenderHandlerT,
		browser *CBrowserT,
		cursor CCursorHandleT,
		ctype CCursorTypeT,
		custom_cursor_info *CCursorInfoT,
	)
}

///
// Called when the user starts dragging content in the web view. Contextual
// information about the dragged content is supplied by |drag_data|. (|x|,
// |y|) is the drag start location in screen coordinates. OS APIs that run a
// system message loop may be used within the StartDragging call.
//
// Return false (0) to abort the drag operation. Don&#39;t call any of
// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
//
// Return true (1) to handle the drag operation. Call
// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
// synchronously or asynchronously to inform the web view that the drag
// operation has ended.
///
type StartDraggingHandler interface {
	StartDragging(
		self *CRenderHandlerT,
		browser *CBrowserT,
		drag_data *CDragDataT,
		allowed_ops CDragOperationsMaskT,
		x int,
		y int,
	) (ret bool)
}

///
// Called when the web view wants to update the mouse cursor during a drag &amp;
// drop operation. |operation| describes the allowed operation (none, move,
// copy, link).
///
type UpdateDragCursorHandler interface {
	UpdateDragCursor(
		self *CRenderHandlerT,
		browser *CBrowserT,
		operation CDragOperationsMaskT,
	)
}

///
// Called when the scroll offset has changed.
///
type OnScrollOffsetChangedHandler interface {
	OnScrollOffsetChanged(
		self *CRenderHandlerT,
		browser *CBrowserT,
		x float64,
		y float64,
	)
}

///
// Called when the IME composition range has changed. |selected_range| is the
// range of characters that have been selected. |character_bounds| is the
// bounds of each character in view coordinates.
///
type OnImeCompositionRangeChangedHandler interface {
	OnImeCompositionRangeChanged(
		self *CRenderHandlerT,
		browser *CBrowserT,
		selected_range *CRangeT,
		character_boundsCount int64,
		character_bounds *CRectT,
	)
}

///
// Called when text selection has changed for the specified |browser|.
// |selected_text| is the currently selected text and |selected_range| is the
// character range.
///
type OnTextSelectionChangedHandler interface {
	OnTextSelectionChanged(
		self *CRenderHandlerT,
		browser *CBrowserT,
		selected_text string,
		selected_range *CRangeT,
	)
}

///
// Called when an on-screen keyboard should be shown or hidden for the
// specified |browser|. |input_mode| specifies what kind of keyboard should be
// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
// for this browser should be hidden.
///
type OnVirtualKeyboardRequestedHandler interface {
	OnVirtualKeyboardRequested(
		self *CRenderHandlerT,
		browser *CBrowserT,
		input_mode CTextInputModeT,
	)
}

var render_handler_handlers = struct {
	accessibility_handler                    map[*C.cef_render_handler_t]*CAccessibilityHandlerT
	get_root_screen_rect_handler             map[*C.cef_render_handler_t]GetRootScreenRectHandler
	get_view_rect_handler                    map[*C.cef_render_handler_t]GetViewRectHandler
	get_screen_point_handler                 map[*C.cef_render_handler_t]GetScreenPointHandler
	get_screen_info_handler                  map[*C.cef_render_handler_t]GetScreenInfoHandler
	on_popup_show_handler                    map[*C.cef_render_handler_t]OnPopupShowHandler
	on_popup_size_handler                    map[*C.cef_render_handler_t]OnPopupSizeHandler
	on_paint_handler                         map[*C.cef_render_handler_t]OnPaintHandler
	on_accelerated_paint_handler             map[*C.cef_render_handler_t]OnAcceleratedPaintHandler
	on_cursor_change_handler                 map[*C.cef_render_handler_t]OnCursorChangeHandler
	start_dragging_handler                   map[*C.cef_render_handler_t]StartDraggingHandler
	update_drag_cursor_handler               map[*C.cef_render_handler_t]UpdateDragCursorHandler
	on_scroll_offset_changed_handler         map[*C.cef_render_handler_t]OnScrollOffsetChangedHandler
	on_ime_composition_range_changed_handler map[*C.cef_render_handler_t]OnImeCompositionRangeChangedHandler
	on_text_selection_changed_handler        map[*C.cef_render_handler_t]OnTextSelectionChangedHandler
	on_virtual_keyboard_requested_handler    map[*C.cef_render_handler_t]OnVirtualKeyboardRequestedHandler
}{
	map[*C.cef_render_handler_t]*CAccessibilityHandlerT{},
	map[*C.cef_render_handler_t]GetRootScreenRectHandler{},
	map[*C.cef_render_handler_t]GetViewRectHandler{},
	map[*C.cef_render_handler_t]GetScreenPointHandler{},
	map[*C.cef_render_handler_t]GetScreenInfoHandler{},
	map[*C.cef_render_handler_t]OnPopupShowHandler{},
	map[*C.cef_render_handler_t]OnPopupSizeHandler{},
	map[*C.cef_render_handler_t]OnPaintHandler{},
	map[*C.cef_render_handler_t]OnAcceleratedPaintHandler{},
	map[*C.cef_render_handler_t]OnCursorChangeHandler{},
	map[*C.cef_render_handler_t]StartDraggingHandler{},
	map[*C.cef_render_handler_t]UpdateDragCursorHandler{},
	map[*C.cef_render_handler_t]OnScrollOffsetChangedHandler{},
	map[*C.cef_render_handler_t]OnImeCompositionRangeChangedHandler{},
	map[*C.cef_render_handler_t]OnTextSelectionChangedHandler{},
	map[*C.cef_render_handler_t]OnVirtualKeyboardRequestedHandler{},
}

// AllocCRenderHandlerT allocates CRenderHandlerT and construct it
func AllocCRenderHandlerT() *CRenderHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_render_handler_wrapper_t, "T15467:")
	cefp := C.cefingo_construct_render_handler((*C.cefingo_render_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_render_handler_t itself in DeassocFunc,
		// or cef_render_handler_t is never GCed.
		Tracef(up, "T15473:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(render_handler_handlers.accessibility_handler, cefp)
		delete(render_handler_handlers.get_root_screen_rect_handler, cefp)
		delete(render_handler_handlers.get_view_rect_handler, cefp)
		delete(render_handler_handlers.get_screen_point_handler, cefp)
		delete(render_handler_handlers.get_screen_info_handler, cefp)
		delete(render_handler_handlers.on_popup_show_handler, cefp)
		delete(render_handler_handlers.on_popup_size_handler, cefp)
		delete(render_handler_handlers.on_paint_handler, cefp)
		delete(render_handler_handlers.on_accelerated_paint_handler, cefp)
		delete(render_handler_handlers.on_cursor_change_handler, cefp)
		delete(render_handler_handlers.start_dragging_handler, cefp)
		delete(render_handler_handlers.update_drag_cursor_handler, cefp)
		delete(render_handler_handlers.on_scroll_offset_changed_handler, cefp)
		delete(render_handler_handlers.on_ime_composition_range_changed_handler, cefp)
		delete(render_handler_handlers.on_text_selection_changed_handler, cefp)
		delete(render_handler_handlers.on_virtual_keyboard_requested_handler, cefp)
	}))

	return newCRenderHandlerT(cefp)
}

func (render_handler *CRenderHandlerT) Bind(a interface{}) *CRenderHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := render_handler.p_render_handler

	if h, ok := a.(GetRootScreenRectHandler); ok {
		render_handler_handlers.get_root_screen_rect_handler[cp] = h
	}

	if h, ok := a.(GetViewRectHandler); ok {
		render_handler_handlers.get_view_rect_handler[cp] = h
	}

	if h, ok := a.(GetScreenPointHandler); ok {
		render_handler_handlers.get_screen_point_handler[cp] = h
	}

	if h, ok := a.(GetScreenInfoHandler); ok {
		render_handler_handlers.get_screen_info_handler[cp] = h
	}

	if h, ok := a.(OnPopupShowHandler); ok {
		render_handler_handlers.on_popup_show_handler[cp] = h
	}

	if h, ok := a.(OnPopupSizeHandler); ok {
		render_handler_handlers.on_popup_size_handler[cp] = h
	}

	if h, ok := a.(OnPaintHandler); ok {
		render_handler_handlers.on_paint_handler[cp] = h
	}

	if h, ok := a.(OnAcceleratedPaintHandler); ok {
		render_handler_handlers.on_accelerated_paint_handler[cp] = h
	}

	if h, ok := a.(OnCursorChangeHandler); ok {
		render_handler_handlers.on_cursor_change_handler[cp] = h
	}

	if h, ok := a.(StartDraggingHandler); ok {
		render_handler_handlers.start_dragging_handler[cp] = h
	}

	if h, ok := a.(UpdateDragCursorHandler); ok {
		render_handler_handlers.update_drag_cursor_handler[cp] = h
	}

	if h, ok := a.(OnScrollOffsetChangedHandler); ok {
		render_handler_handlers.on_scroll_offset_changed_handler[cp] = h
	}

	if h, ok := a.(OnImeCompositionRangeChangedHandler); ok {
		render_handler_handlers.on_ime_composition_range_changed_handler[cp] = h
	}

	if h, ok := a.(OnTextSelectionChangedHandler); ok {
		render_handler_handlers.on_text_selection_changed_handler[cp] = h
	}

	if h, ok := a.(OnVirtualKeyboardRequestedHandler); ok {
		render_handler_handlers.on_virtual_keyboard_requested_handler[cp] = h
	}

	if accessor, ok := a.(CRenderHandlerTAccessor); ok {
		accessor.SetCRenderHandlerT(render_handler)
		Logf("T15578:")
	}

	return render_handler
}

func (render_handler *CRenderHandlerT) AssocAccessibilityHandlerT(handler *CAccessibilityHandlerT) {
	cp := render_handler.p_render_handler
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	render_handler_handlers.accessibility_handler[cp] = handler
}

// cef_render_process_handler_capi.h, include/capi/cef_render_process_handler_capi.h:172:3,

///
// Structure used to implement render process callbacks. The functions of this
// structure will be called on the render process main thread (TID_RENDERER)
// unless otherwise indicated.
///

// Go type for cef_render_process_handler_t
type CRenderProcessHandlerT struct {
	noCopy                   noCopy
	p_render_process_handler *C.cef_render_process_handler_t
}

type RefToCRenderProcessHandlerT struct {
	p_render_process_handler *CRenderProcessHandlerT
}

type CRenderProcessHandlerTAccessor interface {
	GetCRenderProcessHandlerT() *CRenderProcessHandlerT
	SetCRenderProcessHandlerT(*CRenderProcessHandlerT)
}

func (r RefToCRenderProcessHandlerT) GetCRenderProcessHandlerT() *CRenderProcessHandlerT {
	return r.p_render_process_handler
}

func (r *RefToCRenderProcessHandlerT) SetCRenderProcessHandlerT(p *CRenderProcessHandlerT) {
	r.p_render_process_handler = p
}

// Go type CRenderProcessHandlerT wraps cef type *C.cef_render_process_handler_t
func newCRenderProcessHandlerT(p *C.cef_render_process_handler_t) *CRenderProcessHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T15615:")
	BaseAddRef(p)
	go_render_process_handler := CRenderProcessHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_render_process_handler, func(g *CRenderProcessHandlerT) {
		Tracef(unsafe.Pointer(g.p_render_process_handler), "T15619:")
		BaseRelease(g.p_render_process_handler)
	})
	return &go_render_process_handler
}

// *C.cef_render_process_handler_t has refCounted interface
func (render_process_handler *CRenderProcessHandlerT) HasOneRef() bool {
	return BaseHasOneRef(render_process_handler.p_render_process_handler)
}

func (p *C.cef_render_process_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called after the render process main thread has been created. |extra_info|
// is a read-only value originating from
// cef_browser_process_handler_t::on_render_process_thread_created(). Do not
// keep a reference to |extra_info| outside of this function.
///
type OnRenderThreadCreatedHandler interface {
	OnRenderThreadCreated(
		self *CRenderProcessHandlerT,
		extra_info *CListValueT,
	)
}

///
// Called after WebKit has been initialized.
///
type OnWebKitInitializedHandler interface {
	OnWebKitInitialized(
		self *CRenderProcessHandlerT,
	)
}

///
// Called after a browser has been created. When browsing cross-origin a new
// browser will be created before the old browser with the same identifier is
// destroyed. |extra_info| is a read-only value originating from
// cef_browser_host_t::cef_browser_host_create_browser(),
// cef_browser_host_t::cef_browser_host_create_browser_sync(),
// cef_life_span_handler_t::on_before_popup() or
// cef_browser_view_t::cef_browser_view_create().
///
type CRenderProcessHandlerTOnBrowserCreatedHandler interface {
	OnBrowserCreated(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		extra_info *CDictionaryValueT,
	)
}

///
// Called before a browser is destroyed.
///
type CRenderProcessHandlerTOnBrowserDestroyedHandler interface {
	OnBrowserDestroyed(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
	)
}

///
// Called immediately after the V8 context for a frame has been created. To
// retrieve the JavaScript &#39;window&#39; object use the
// cef_v8context_t::get_global() function. V8 handles can only be accessed
// from the thread on which they are created. A task runner for posting tasks
// on the associated thread can be retrieved via the
// cef_v8context_t::get_task_runner() function.
///
type OnContextCreatedHandler interface {
	OnContextCreated(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		context *CV8contextT,
	)
}

///
// Called immediately before the V8 context for a frame is released. No
// references to the context should be kept after this function is called.
///
type OnContextReleasedHandler interface {
	OnContextReleased(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		context *CV8contextT,
	)
}

///
// Called for global uncaught exceptions in a frame. Execution of this
// callback is disabled by default. To enable set
// CefSettings.uncaught_exception_stack_size &gt; 0.
///
type OnUncaughtExceptionHandler interface {
	OnUncaughtException(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		context *CV8contextT,
		exception *CV8exceptionT,
		stackTrace *CV8stackTraceT,
	)
}

///
// Called when a new node in the the browser gets focus. The |node| value may
// be NULL if no specific node has gained focus. The node object passed to
// this function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
type OnFocusedNodeChangedHandler interface {
	OnFocusedNodeChanged(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		node *CDomnodeT,
	)
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. Do not keep a
// reference to or attempt to access the message outside of this callback.
///
type CRenderProcessHandlerTOnProcessMessageReceivedHandler interface {
	OnProcessMessageReceived(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		source_process CProcessIdT,
		message *CProcessMessageT,
	) (ret bool)
}

var render_process_handler_handlers = struct {
	on_render_thread_created_handler    map[*C.cef_render_process_handler_t]OnRenderThreadCreatedHandler
	on_web_kit_initialized_handler      map[*C.cef_render_process_handler_t]OnWebKitInitializedHandler
	on_browser_created_handler          map[*C.cef_render_process_handler_t]CRenderProcessHandlerTOnBrowserCreatedHandler
	on_browser_destroyed_handler        map[*C.cef_render_process_handler_t]CRenderProcessHandlerTOnBrowserDestroyedHandler
	load_handler                        map[*C.cef_render_process_handler_t]*CLoadHandlerT
	on_context_created_handler          map[*C.cef_render_process_handler_t]OnContextCreatedHandler
	on_context_released_handler         map[*C.cef_render_process_handler_t]OnContextReleasedHandler
	on_uncaught_exception_handler       map[*C.cef_render_process_handler_t]OnUncaughtExceptionHandler
	on_focused_node_changed_handler     map[*C.cef_render_process_handler_t]OnFocusedNodeChangedHandler
	on_process_message_received_handler map[*C.cef_render_process_handler_t]CRenderProcessHandlerTOnProcessMessageReceivedHandler
}{
	map[*C.cef_render_process_handler_t]OnRenderThreadCreatedHandler{},
	map[*C.cef_render_process_handler_t]OnWebKitInitializedHandler{},
	map[*C.cef_render_process_handler_t]CRenderProcessHandlerTOnBrowserCreatedHandler{},
	map[*C.cef_render_process_handler_t]CRenderProcessHandlerTOnBrowserDestroyedHandler{},
	map[*C.cef_render_process_handler_t]*CLoadHandlerT{},
	map[*C.cef_render_process_handler_t]OnContextCreatedHandler{},
	map[*C.cef_render_process_handler_t]OnContextReleasedHandler{},
	map[*C.cef_render_process_handler_t]OnUncaughtExceptionHandler{},
	map[*C.cef_render_process_handler_t]OnFocusedNodeChangedHandler{},
	map[*C.cef_render_process_handler_t]CRenderProcessHandlerTOnProcessMessageReceivedHandler{},
}

// AllocCRenderProcessHandlerT allocates CRenderProcessHandlerT and construct it
func AllocCRenderProcessHandlerT() *CRenderProcessHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_render_process_handler_wrapper_t, "T15787:")
	cefp := C.cefingo_construct_render_process_handler((*C.cefingo_render_process_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_render_process_handler_t itself in DeassocFunc,
		// or cef_render_process_handler_t is never GCed.
		Tracef(up, "T15793:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(render_process_handler_handlers.on_render_thread_created_handler, cefp)
		delete(render_process_handler_handlers.on_web_kit_initialized_handler, cefp)
		delete(render_process_handler_handlers.on_browser_created_handler, cefp)
		delete(render_process_handler_handlers.on_browser_destroyed_handler, cefp)
		delete(render_process_handler_handlers.load_handler, cefp)
		delete(render_process_handler_handlers.on_context_created_handler, cefp)
		delete(render_process_handler_handlers.on_context_released_handler, cefp)
		delete(render_process_handler_handlers.on_uncaught_exception_handler, cefp)
		delete(render_process_handler_handlers.on_focused_node_changed_handler, cefp)
		delete(render_process_handler_handlers.on_process_message_received_handler, cefp)
	}))

	return newCRenderProcessHandlerT(cefp)
}

func (render_process_handler *CRenderProcessHandlerT) Bind(a interface{}) *CRenderProcessHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := render_process_handler.p_render_process_handler

	if h, ok := a.(OnRenderThreadCreatedHandler); ok {
		render_process_handler_handlers.on_render_thread_created_handler[cp] = h
	}

	if h, ok := a.(OnWebKitInitializedHandler); ok {
		render_process_handler_handlers.on_web_kit_initialized_handler[cp] = h
	}

	if h, ok := a.(CRenderProcessHandlerTOnBrowserCreatedHandler); ok {
		render_process_handler_handlers.on_browser_created_handler[cp] = h
	}

	if h, ok := a.(CRenderProcessHandlerTOnBrowserDestroyedHandler); ok {
		render_process_handler_handlers.on_browser_destroyed_handler[cp] = h
	}

	if h, ok := a.(OnContextCreatedHandler); ok {
		render_process_handler_handlers.on_context_created_handler[cp] = h
	}

	if h, ok := a.(OnContextReleasedHandler); ok {
		render_process_handler_handlers.on_context_released_handler[cp] = h
	}

	if h, ok := a.(OnUncaughtExceptionHandler); ok {
		render_process_handler_handlers.on_uncaught_exception_handler[cp] = h
	}

	if h, ok := a.(OnFocusedNodeChangedHandler); ok {
		render_process_handler_handlers.on_focused_node_changed_handler[cp] = h
	}

	if h, ok := a.(CRenderProcessHandlerTOnProcessMessageReceivedHandler); ok {
		render_process_handler_handlers.on_process_message_received_handler[cp] = h
	}

	if accessor, ok := a.(CRenderProcessHandlerTAccessor); ok {
		accessor.SetCRenderProcessHandlerT(render_process_handler)
		Logf("T15868:")
	}

	return render_process_handler
}

func (render_process_handler *CRenderProcessHandlerT) AssocLoadHandlerT(handler *CLoadHandlerT) {
	cp := render_process_handler.p_render_process_handler
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	render_process_handler_handlers.load_handler[cp] = handler
}

// cef_request_callback_capi.h, include/capi/cef_request_callback_capi.h:68:3,

///
// Callback structure used for asynchronous continuation of url requests.
///

// Go type for cef_request_callback_t
type CRequestCallbackT struct {
	noCopy             noCopy
	p_request_callback *C.cef_request_callback_t
}

type RefToCRequestCallbackT struct {
	p_request_callback *CRequestCallbackT
}

type CRequestCallbackTAccessor interface {
	GetCRequestCallbackT() *CRequestCallbackT
	SetCRequestCallbackT(*CRequestCallbackT)
}

func (r RefToCRequestCallbackT) GetCRequestCallbackT() *CRequestCallbackT {
	return r.p_request_callback
}

func (r *RefToCRequestCallbackT) SetCRequestCallbackT(p *CRequestCallbackT) {
	r.p_request_callback = p
}

// Go type CRequestCallbackT wraps cef type *C.cef_request_callback_t
func newCRequestCallbackT(p *C.cef_request_callback_t) *CRequestCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T15903:")
	BaseAddRef(p)
	go_request_callback := CRequestCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_request_callback, func(g *CRequestCallbackT) {
		Tracef(unsafe.Pointer(g.p_request_callback), "T15907:")
		BaseRelease(g.p_request_callback)
	})
	return &go_request_callback
}

// *C.cef_request_callback_t has refCounted interface
func (request_callback *CRequestCallbackT) HasOneRef() bool {
	return BaseHasOneRef(request_callback.p_request_callback)
}

func (p *C.cef_request_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Continue the url request. If |allow| is true (1) the request will be
// continued. Otherwise, the request will be canceled.
///
func (self *CRequestCallbackT) Cont(
	allow int,
) {

	C.cefingo_request_callback_cont(self.p_request_callback, (C.int)(allow))

}

///
// Cancel the url request.
///
func (self *CRequestCallbackT) Cancel() {

	C.cefingo_request_callback_cancel(self.p_request_callback)

}

// cef_request_capi.h, include/capi/cef_request_capi.h:217:3,

///
// Structure used to represent a web request. The functions of this structure
// may be called on any thread.
///

// Go type for cef_request_t
type CRequestT struct {
	noCopy    noCopy
	p_request *C.cef_request_t
}

type RefToCRequestT struct {
	p_request *CRequestT
}

type CRequestTAccessor interface {
	GetCRequestT() *CRequestT
	SetCRequestT(*CRequestT)
}

func (r RefToCRequestT) GetCRequestT() *CRequestT {
	return r.p_request
}

func (r *RefToCRequestT) SetCRequestT(p *CRequestT) {
	r.p_request = p
}

// Go type CRequestT wraps cef type *C.cef_request_t
func newCRequestT(p *C.cef_request_t) *CRequestT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T15980:")
	BaseAddRef(p)
	go_request := CRequestT{noCopy{}, p}
	runtime.SetFinalizer(&go_request, func(g *CRequestT) {
		Tracef(unsafe.Pointer(g.p_request), "T15984:")
		BaseRelease(g.p_request)
	})
	return &go_request
}

// *C.cef_request_t has refCounted interface
func (request *CRequestT) HasOneRef() bool {
	return BaseHasOneRef(request.p_request)
}

func (p *C.cef_request_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is read-only.
///
func (self *CRequestT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_request_is_read_only(self.p_request)

	ret = cRet == 1
	return ret
}

///
// Get the fully qualified URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetUrl() (ret string) {

	cRet := C.cefingo_request_get_url(self.p_request)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the fully qualified URL.
///
func (self *CRequestT) SetUrl(
	url string,
) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)

	C.cefingo_request_set_url(self.p_request, (*C.cef_string_t)(c_url))

}

///
// Get the request function type. The value will default to POST if post data
// is provided and GET otherwise.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetMethod() (ret string) {

	cRet := C.cefingo_request_get_method(self.p_request)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the request function type.
///
func (self *CRequestT) SetMethod(
	method string,
) {
	c_method := create_cef_string(method)
	defer clear_cef_string(c_method)

	C.cefingo_request_set_method(self.p_request, (*C.cef_string_t)(c_method))

}

///
// Set the referrer URL and policy. If non-NULL the referrer URL must be fully
// qualified with an HTTP or HTTPS scheme component. Any username, password or
// ref component will be removed.
///
func (self *CRequestT) SetReferrer(
	referrer_url string,
	policy CReferrerPolicyT,
) {
	c_referrer_url := create_cef_string(referrer_url)
	defer clear_cef_string(c_referrer_url)

	C.cefingo_request_set_referrer(self.p_request, (*C.cef_string_t)(c_referrer_url), (C.cef_referrer_policy_t)(policy))

}

///
// Get the referrer URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetReferrerUrl() (ret string) {

	cRet := C.cefingo_request_get_referrer_url(self.p_request)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Get the referrer policy.
///
func (self *CRequestT) GetReferrerPolicy() (ret CReferrerPolicyT) {

	cRet := C.cefingo_request_get_referrer_policy(self.p_request)

	ret = CReferrerPolicyT(cRet)
	return ret
}

///
// Get the post data.
///
func (self *CRequestT) GetPostData() (ret *CPostDataT) {

	cRet := C.cefingo_request_get_post_data(self.p_request)

	ret = newCPostDataT(cRet)
	return ret
}

///
// Set the post data.
///
func (self *CRequestT) SetPostData(
	postData *CPostDataT,
) {
	var goTmppostData *C.cef_post_data_t
	if postData != nil {
		goTmppostData = postData.p_post_data
		BaseAddRef(goTmppostData)
	}

	C.cefingo_request_set_post_data(self.p_request, goTmppostData)

}

///
// Get the header values. Will not include the Referer value if any.
///
func (self *CRequestT) GetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_request_get_header_map(self.p_request, (C.cef_string_multimap_t)(headerMap))

}

///
// Set the header values. If a Referer value exists in the header map it will
// be removed and ignored.
///
func (self *CRequestT) SetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_request_set_header_map(self.p_request, (C.cef_string_multimap_t)(headerMap))

}

///
// Returns the first header value for |name| or an NULL string if not found.
// Will not return the Referer value if any. Use GetHeaderMap instead if
// |name| might have multiple values.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetHeaderByName(
	name string,
) (ret string) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_request_get_header_by_name(self.p_request, (*C.cef_string_t)(c_name))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the header |name| to |value|. If |overwrite| is true (1) any existing
// values will be replaced with the new value. If |overwrite| is false (0) any
// existing values will not be overwritten. The Referer value cannot be set
// using this function.
///
func (self *CRequestT) SetHeaderByName(
	name string,
	value string,
	overwrite int,
) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	C.cefingo_request_set_header_by_name(self.p_request, (*C.cef_string_t)(c_name), (*C.cef_string_t)(c_value), (C.int)(overwrite))

}

///
// Set all values at one time.
///
func (self *CRequestT) Set(
	url string,
	method string,
	postData *CPostDataT,
	headerMap CStringMultimapT,
) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)
	c_method := create_cef_string(method)
	defer clear_cef_string(c_method)
	var goTmppostData *C.cef_post_data_t
	if postData != nil {
		goTmppostData = postData.p_post_data
		BaseAddRef(goTmppostData)
	}

	C.cefingo_request_set(self.p_request, (*C.cef_string_t)(c_url), (*C.cef_string_t)(c_method), goTmppostData, (C.cef_string_multimap_t)(headerMap))

}

///
// Get the flags used in combination with cef_urlrequest_t. See
// cef_urlrequest_flags_t for supported values.
///
func (self *CRequestT) GetFlags() (ret bool) {

	cRet := C.cefingo_request_get_flags(self.p_request)

	ret = cRet == 1
	return ret
}

///
// Set the flags used in combination with cef_urlrequest_t.  See
// cef_urlrequest_flags_t for supported values.
///
func (self *CRequestT) SetFlags(
	flags int,
) {

	C.cefingo_request_set_flags(self.p_request, (C.int)(flags))

}

///
// Get the URL to the first party for cookies used in combination with
// cef_urlrequest_t.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetFirstPartyForCookies() (ret string) {

	cRet := C.cefingo_request_get_first_party_for_cookies(self.p_request)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the URL to the first party for cookies used in combination with
// cef_urlrequest_t.
///
func (self *CRequestT) SetFirstPartyForCookies(
	url string,
) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)

	C.cefingo_request_set_first_party_for_cookies(self.p_request, (*C.cef_string_t)(c_url))

}

///
// Get the resource type for this request. Only available in the browser
// process.
///
func (self *CRequestT) GetResourceType() (ret CResourceTypeT) {

	cRet := C.cefingo_request_get_resource_type(self.p_request)

	ret = CResourceTypeT(cRet)
	return ret
}

///
// Get the transition type for this request. Only available in the browser
// process and only applies to requests that represent a main frame or sub-
// frame navigation.
///
func (self *CRequestT) GetTransitionType() (ret CTransitionTypeT) {

	cRet := C.cefingo_request_get_transition_type(self.p_request)

	ret = CTransitionTypeT(cRet)
	return ret
}

///
// Returns the globally unique identifier for this request or 0 if not
// specified. Can be used by cef_resource_request_handler_t implementations in
// the browser process to track a single request across multiple callbacks.
///
func (self *CRequestT) GetIdentifier() (ret uint64) {

	cRet := C.cefingo_request_get_identifier(self.p_request)

	ret = (uint64)(cRet)
	return ret
}

///
// Create a new cef_request_t object.
///
func RequestCreate() (ret *CRequestT) {

	cRet := C.cef_request_create()

	ret = newCRequestT(cRet)
	return ret
}

///
// Structure used to represent post data for a web request. The functions of
// this structure may be called on any thread.
///

// Go type for cef_post_data_t
type CPostDataT struct {
	noCopy      noCopy
	p_post_data *C.cef_post_data_t
}

type RefToCPostDataT struct {
	p_post_data *CPostDataT
}

type CPostDataTAccessor interface {
	GetCPostDataT() *CPostDataT
	SetCPostDataT(*CPostDataT)
}

func (r RefToCPostDataT) GetCPostDataT() *CPostDataT {
	return r.p_post_data
}

func (r *RefToCPostDataT) SetCPostDataT(p *CPostDataT) {
	r.p_post_data = p
}

// Go type CPostDataT wraps cef type *C.cef_post_data_t
func newCPostDataT(p *C.cef_post_data_t) *CPostDataT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T16398:")
	BaseAddRef(p)
	go_post_data := CPostDataT{noCopy{}, p}
	runtime.SetFinalizer(&go_post_data, func(g *CPostDataT) {
		Tracef(unsafe.Pointer(g.p_post_data), "T16402:")
		BaseRelease(g.p_post_data)
	})
	return &go_post_data
}

// *C.cef_post_data_t has refCounted interface
func (post_data *CPostDataT) HasOneRef() bool {
	return BaseHasOneRef(post_data.p_post_data)
}

func (p *C.cef_post_data_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is read-only.
///
func (self *CPostDataT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_post_data_is_read_only(self.p_post_data)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the underlying POST data includes elements that are not
// represented by this cef_post_data_t object (for example, multi-part file
// upload data). Modifying cef_post_data_t objects with excluded elements may
// result in the request failing.
///
func (self *CPostDataT) HasExcludedElements() (ret bool) {

	cRet := C.cefingo_post_data_has_excluded_elements(self.p_post_data)

	ret = cRet == 1
	return ret
}

///
// Returns the number of existing post data elements.
///
func (self *CPostDataT) GetElementCount() (ret int64) {

	cRet := C.cefingo_post_data_get_element_count(self.p_post_data)

	ret = (int64)(cRet)
	return ret
}

///
// Retrieve the post data elements.
///
func (self *CPostDataT) GetElements() (elements []*CPostDataElementT) {
	var _elementsCount C.size_t
	elementsCount := &_elementsCount
	var tmpelements *C.cef_post_data_element_t

	C.cefingo_post_data_get_elements(self.p_post_data, (*C.size_t)(elementsCount), &tmpelements)

	elements = make([]*CPostDataElementT, *elementsCount)
	_tmpelements := (*[1 << 30](*C.cef_post_data_element_t))(unsafe.Pointer(tmpelements))[:*elementsCount:*elementsCount]
	for i := C.size_t(0); i < *elementsCount; i++ {
		elements[i] = newCPostDataElementT(_tmpelements[i])
	}
	return elements
}

///
// Remove the specified post data element.  Returns true (1) if the removal
// succeeds.
///
func (self *CPostDataT) RemoveElement(
	element *CPostDataElementT,
) (ret bool) {
	var goTmpelement *C.cef_post_data_element_t
	if element != nil {
		goTmpelement = element.p_post_data_element
		BaseAddRef(goTmpelement)
	}

	cRet := C.cefingo_post_data_remove_element(self.p_post_data, goTmpelement)

	ret = cRet == 1
	return ret
}

///
// Add the specified post data element.  Returns true (1) if the add succeeds.
///
func (self *CPostDataT) AddElement(
	element *CPostDataElementT,
) (ret bool) {
	var goTmpelement *C.cef_post_data_element_t
	if element != nil {
		goTmpelement = element.p_post_data_element
		BaseAddRef(goTmpelement)
	}

	cRet := C.cefingo_post_data_add_element(self.p_post_data, goTmpelement)

	ret = cRet == 1
	return ret
}

///
// Remove all existing post data elements.
///
func (self *CPostDataT) RemoveElements() {

	C.cefingo_post_data_remove_elements(self.p_post_data)

}

///
// Create a new cef_post_data_t object.
///
func PostDataCreate() (ret *CPostDataT) {

	cRet := C.cef_post_data_create()

	ret = newCPostDataT(cRet)
	return ret
}

///
// Structure used to represent a single element in the request post data. The
// functions of this structure may be called on any thread.
///

// Go type for cef_post_data_element_t
type CPostDataElementT struct {
	noCopy              noCopy
	p_post_data_element *C.cef_post_data_element_t
}

type RefToCPostDataElementT struct {
	p_post_data_element *CPostDataElementT
}

type CPostDataElementTAccessor interface {
	GetCPostDataElementT() *CPostDataElementT
	SetCPostDataElementT(*CPostDataElementT)
}

func (r RefToCPostDataElementT) GetCPostDataElementT() *CPostDataElementT {
	return r.p_post_data_element
}

func (r *RefToCPostDataElementT) SetCPostDataElementT(p *CPostDataElementT) {
	r.p_post_data_element = p
}

// Go type CPostDataElementT wraps cef type *C.cef_post_data_element_t
func newCPostDataElementT(p *C.cef_post_data_element_t) *CPostDataElementT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T16573:")
	BaseAddRef(p)
	go_post_data_element := CPostDataElementT{noCopy{}, p}
	runtime.SetFinalizer(&go_post_data_element, func(g *CPostDataElementT) {
		Tracef(unsafe.Pointer(g.p_post_data_element), "T16577:")
		BaseRelease(g.p_post_data_element)
	})
	return &go_post_data_element
}

// *C.cef_post_data_element_t has refCounted interface
func (post_data_element *CPostDataElementT) HasOneRef() bool {
	return BaseHasOneRef(post_data_element.p_post_data_element)
}

func (p *C.cef_post_data_element_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is read-only.
///
func (self *CPostDataElementT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_post_data_element_is_read_only(self.p_post_data_element)

	ret = cRet == 1
	return ret
}

///
// Remove all contents from the post data element.
///
func (self *CPostDataElementT) SetToEmpty() {

	C.cefingo_post_data_element_set_to_empty(self.p_post_data_element)

}

///
// The post data element will represent a file.
///
func (self *CPostDataElementT) SetToFile(
	fileName string,
) {
	c_fileName := create_cef_string(fileName)
	defer clear_cef_string(c_fileName)

	C.cefingo_post_data_element_set_to_file(self.p_post_data_element, (*C.cef_string_t)(c_fileName))

}

///
// The post data element will represent bytes.  The bytes passed in will be
// copied.
///
func (self *CPostDataElementT) SetToBytes(
	size int64,
	bytes unsafe.Pointer,
) {

	C.cefingo_post_data_element_set_to_bytes(self.p_post_data_element, (C.size_t)(size), bytes)

}

///
// Return the type of this post data element.
///
func (self *CPostDataElementT) GetType() (ret CPostdataelementTypeT) {

	cRet := C.cefingo_post_data_element_get_type(self.p_post_data_element)

	ret = CPostdataelementTypeT(cRet)
	return ret
}

///
// Return the file name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CPostDataElementT) GetFile() (ret string) {

	cRet := C.cefingo_post_data_element_get_file(self.p_post_data_element)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the number of bytes.
///
func (self *CPostDataElementT) GetBytesCount() (ret int64) {

	cRet := C.cefingo_post_data_element_get_bytes_count(self.p_post_data_element)

	ret = (int64)(cRet)
	return ret
}

///
// Read up to |size| bytes into |bytes| and return the number of bytes
// actually read.
///
func (self *CPostDataElementT) GetBytes(
	size int64,
	bytes unsafe.Pointer,
) (ret int64) {

	cRet := C.cefingo_post_data_element_get_bytes(self.p_post_data_element, (C.size_t)(size), bytes)

	ret = (int64)(cRet)
	return ret
}

///
// Create a new cef_post_data_element_t object.
///
func PostDataElementCreate() (ret *CPostDataElementT) {

	cRet := C.cef_post_data_element_create()

	ret = newCPostDataElementT(cRet)
	return ret
}

// cef_request_context_capi.h, include/capi/cef_request_context_capi.h:74:3,

///
// Callback structure for cef_request_context_t::ResolveHost.
///

// Go type for cef_resolve_callback_t
type CResolveCallbackT struct {
	noCopy             noCopy
	p_resolve_callback *C.cef_resolve_callback_t
}

type RefToCResolveCallbackT struct {
	p_resolve_callback *CResolveCallbackT
}

type CResolveCallbackTAccessor interface {
	GetCResolveCallbackT() *CResolveCallbackT
	SetCResolveCallbackT(*CResolveCallbackT)
}

func (r RefToCResolveCallbackT) GetCResolveCallbackT() *CResolveCallbackT {
	return r.p_resolve_callback
}

func (r *RefToCResolveCallbackT) SetCResolveCallbackT(p *CResolveCallbackT) {
	r.p_resolve_callback = p
}

// Go type CResolveCallbackT wraps cef type *C.cef_resolve_callback_t
func newCResolveCallbackT(p *C.cef_resolve_callback_t) *CResolveCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T16750:")
	BaseAddRef(p)
	go_resolve_callback := CResolveCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_resolve_callback, func(g *CResolveCallbackT) {
		Tracef(unsafe.Pointer(g.p_resolve_callback), "T16754:")
		BaseRelease(g.p_resolve_callback)
	})
	return &go_resolve_callback
}

// *C.cef_resolve_callback_t has refCounted interface
func (resolve_callback *CResolveCallbackT) HasOneRef() bool {
	return BaseHasOneRef(resolve_callback.p_resolve_callback)
}

func (p *C.cef_resolve_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the UI thread after the ResolveHost request has completed.
// |result| will be the result code. |resolved_ips| will be the list of
// resolved IP addresses or NULL if the resolution failed.
///
func (self *CResolveCallbackT) OnResolveCompleted(
	result CErrorcodeT,
	resolved_ips CStringListT,
) {

	C.cefingo_resolve_callback_on_resolve_completed(self.p_resolve_callback, (C.cef_errorcode_t)(result), (C.cef_string_list_t)(resolved_ips))

}

///
// A request context provides request handling for a set of related browser or
// URL request objects. A request context can be specified when creating a new
// browser via the cef_browser_host_t static factory functions or when creating
// a new URL request via the cef_urlrequest_t static factory functions. Browser
// objects with different request contexts will never be hosted in the same
// render process. Browser objects with the same request context may or may not
// be hosted in the same render process depending on the process model. Browser
// objects created indirectly via the JavaScript window.open function or
// targeted links will share the same render process and the same request
// context as the source browser. When running in single-process mode there is
// only a single render process (the main process) and so all browsers created
// in single-process mode will share the same request context. This will be the
// first request context passed into a cef_browser_host_t static factory
// function and all other request context objects will be ignored.
///

// Go type for cef_request_context_t
type CRequestContextT struct {
	noCopy            noCopy
	p_request_context *C.cef_request_context_t
}

type RefToCRequestContextT struct {
	p_request_context *CRequestContextT
}

type CRequestContextTAccessor interface {
	GetCRequestContextT() *CRequestContextT
	SetCRequestContextT(*CRequestContextT)
}

func (r RefToCRequestContextT) GetCRequestContextT() *CRequestContextT {
	return r.p_request_context
}

func (r *RefToCRequestContextT) SetCRequestContextT(p *CRequestContextT) {
	r.p_request_context = p
}

// Go type CRequestContextT wraps cef type *C.cef_request_context_t
func newCRequestContextT(p *C.cef_request_context_t) *CRequestContextT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T16828:")
	BaseAddRef(p)
	go_request_context := CRequestContextT{noCopy{}, p}
	runtime.SetFinalizer(&go_request_context, func(g *CRequestContextT) {
		Tracef(unsafe.Pointer(g.p_request_context), "T16832:")
		BaseRelease(g.p_request_context)
	})
	return &go_request_context
}

// *C.cef_request_context_t has refCounted interface
func (request_context *CRequestContextT) HasOneRef() bool {
	return BaseHasOneRef(request_context.p_request_context)
}

func (p *C.cef_request_context_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is pointing to the same context as |that|
// object.
///
func (self *CRequestContextT) IsSame(
	other *CRequestContextT,
) (ret bool) {
	var goTmpother *C.cef_request_context_t
	if other != nil {
		goTmpother = other.p_request_context
		BaseAddRef(goTmpother)
	}

	cRet := C.cefingo_request_context_is_same(self.p_request_context, goTmpother)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is sharing the same storage as |that|
// object.
///
func (self *CRequestContextT) IsSharingWith(
	other *CRequestContextT,
) (ret bool) {
	var goTmpother *C.cef_request_context_t
	if other != nil {
		goTmpother = other.p_request_context
		BaseAddRef(goTmpother)
	}

	cRet := C.cefingo_request_context_is_sharing_with(self.p_request_context, goTmpother)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is the global context. The global context
// is used by default when creating a browser or URL request with a NULL
// context argument.
///
func (self *CRequestContextT) IsGlobal() (ret bool) {

	cRet := C.cefingo_request_context_is_global(self.p_request_context)

	ret = cRet == 1
	return ret
}

///
// Returns the handler for this context if any.
///
func (self *CRequestContextT) GetHandler() (ret *CRequestContextHandlerT) {

	cRet := C.cefingo_request_context_get_handler(self.p_request_context)

	ret = newCRequestContextHandlerT(cRet)
	return ret
}

///
// Returns the cache path for this object. If NULL an &quot;incognito mode&quot; in-
// memory cache is being used.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestContextT) GetCachePath() (ret string) {

	cRet := C.cefingo_request_context_get_cache_path(self.p_request_context)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the cookie manager for this object. If |callback| is non-NULL it
// will be executed asnychronously on the IO thread after the manager&#39;s
// storage has been initialized.
///
func (self *CRequestContextT) GetCookieManager(
	callback *CCompletionCallbackT,
) (ret *CCookieManagerT) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		goTmpcallback = callback.p_completion_callback
		BaseAddRef(goTmpcallback)
	}

	cRet := C.cefingo_request_context_get_cookie_manager(self.p_request_context, goTmpcallback)

	ret = newCCookieManagerT(cRet)
	return ret
}

///
// Register a scheme handler factory for the specified |scheme_name| and
// optional |domain_name|. An NULL |domain_name| value for a standard scheme
// will cause the factory to match all domain names. The |domain_name| value
// will be ignored for non-standard schemes. If |scheme_name| is a built-in
// scheme and no handler is returned by |factory| then the built-in scheme
// handler factory will be called. If |scheme_name| is a custom scheme then
// you must also implement the cef_app_t::on_register_custom_schemes()
// function in all processes. This function may be called multiple times to
// change or remove the factory that matches the specified |scheme_name| and
// optional |domain_name|. Returns false (0) if an error occurs. This function
// may be called on any thread in the browser process.
///
func (self *CRequestContextT) RegisterSchemeHandlerFactory(
	scheme_name string,
	domain_name string,
	factory *CSchemeHandlerFactoryT,
) (ret bool) {
	c_scheme_name := create_cef_string(scheme_name)
	defer clear_cef_string(c_scheme_name)
	c_domain_name := create_cef_string(domain_name)
	defer clear_cef_string(c_domain_name)
	var goTmpfactory *C.cef_scheme_handler_factory_t
	if factory != nil {
		goTmpfactory = factory.p_scheme_handler_factory
		BaseAddRef(goTmpfactory)
	}

	cRet := C.cefingo_request_context_register_scheme_handler_factory(self.p_request_context, (*C.cef_string_t)(c_scheme_name), (*C.cef_string_t)(c_domain_name), goTmpfactory)

	ret = cRet == 1
	return ret
}

///
// Clear all registered scheme handler factories. Returns false (0) on error.
// This function may be called on any thread in the browser process.
///
func (self *CRequestContextT) ClearSchemeHandlerFactories() (ret bool) {

	cRet := C.cefingo_request_context_clear_scheme_handler_factories(self.p_request_context)

	ret = cRet == 1
	return ret
}

///
// Tells all renderer processes associated with this context to throw away
// their plugin list cache. If |reload_pages| is true (1) they will also
// reload all pages with plugins.
// cef_request_context_handler_t::OnBeforePluginLoad may be called to rebuild
// the plugin list cache.
///
func (self *CRequestContextT) PurgePluginListCache(
	reload_pages int,
) {

	C.cefingo_request_context_purge_plugin_list_cache(self.p_request_context, (C.int)(reload_pages))

}

///
// Returns true (1) if a preference with the specified |name| exists. This
// function must be called on the browser process UI thread.
///
func (self *CRequestContextT) HasPreference(
	name string,
) (ret bool) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_request_context_has_preference(self.p_request_context, (*C.cef_string_t)(c_name))

	ret = cRet == 1
	return ret
}

///
// Returns the value for the preference with the specified |name|. Returns
// NULL if the preference does not exist. The returned object contains a copy
// of the underlying preference value and modifications to the returned object
// will not modify the underlying preference value. This function must be
// called on the browser process UI thread.
///
func (self *CRequestContextT) GetPreference(
	name string,
) (ret *CValueT) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_request_context_get_preference(self.p_request_context, (*C.cef_string_t)(c_name))

	ret = newCValueT(cRet)
	return ret
}

///
// Returns all preferences as a dictionary. If |include_defaults| is true (1)
// then preferences currently at their default value will be included. The
// returned object contains a copy of the underlying preference values and
// modifications to the returned object will not modify the underlying
// preference values. This function must be called on the browser process UI
// thread.
///
func (self *CRequestContextT) GetAllPreferences(
	include_defaults int,
) (ret *CDictionaryValueT) {

	cRet := C.cefingo_request_context_get_all_preferences(self.p_request_context, (C.int)(include_defaults))

	ret = newCDictionaryValueT(cRet)
	return ret
}

///
// Returns true (1) if the preference with the specified |name| can be
// modified using SetPreference. As one example preferences set via the
// command-line usually cannot be modified. This function must be called on
// the browser process UI thread.
///
func (self *CRequestContextT) CanSetPreference(
	name string,
) (ret bool) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_request_context_can_set_preference(self.p_request_context, (*C.cef_string_t)(c_name))

	ret = cRet == 1
	return ret
}

///
// Set the |value| associated with preference |name|. Returns true (1) if the
// value is set successfully and false (0) otherwise. If |value| is NULL the
// preference will be restored to its default value. If setting the preference
// fails then |error| will be populated with a detailed description of the
// problem. This function must be called on the browser process UI thread.
///
func (self *CRequestContextT) SetPreference(
	name string,
	value *CValueT,
) (ret bool, error string) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)
	var goTmpvalue *C.cef_value_t
	if value != nil {
		goTmpvalue = value.p_value
		BaseAddRef(goTmpvalue)
	}
	tmpc_error := create_cef_string("")
	defer clear_cef_string(tmpc_error)

	cRet := C.cefingo_request_context_set_preference(self.p_request_context, (*C.cef_string_t)(c_name), goTmpvalue, tmpc_error)

	error = string_from_cef_string(tmpc_error)

	ret = cRet == 1
	return ret, error
}

///
// Clears all certificate exceptions that were added as part of handling
// cef_request_handler_t::on_certificate_error(). If you call this it is
// recommended that you also call close_all_connections() or you risk not
// being prompted again for server certificates if you reconnect quickly. If
// |callback| is non-NULL it will be executed on the UI thread after
// completion.
///
func (self *CRequestContextT) ClearCertificateExceptions(
	callback *CCompletionCallbackT,
) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		goTmpcallback = callback.p_completion_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_request_context_clear_certificate_exceptions(self.p_request_context, goTmpcallback)

}

///
// Clears all HTTP authentication credentials that were added as part of
// handling GetAuthCredentials. If |callback| is non-NULL it will be executed
// on the UI thread after completion.
///
func (self *CRequestContextT) ClearHttpAuthCredentials(
	callback *CCompletionCallbackT,
) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		goTmpcallback = callback.p_completion_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_request_context_clear_http_auth_credentials(self.p_request_context, goTmpcallback)

}

///
// Clears all active and idle connections that Chromium currently has. This is
// only recommended if you have released all other CEF objects but don&#39;t yet
// want to call cef_shutdown(). If |callback| is non-NULL it will be executed
// on the UI thread after completion.
///
func (self *CRequestContextT) CloseAllConnections(
	callback *CCompletionCallbackT,
) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		goTmpcallback = callback.p_completion_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_request_context_close_all_connections(self.p_request_context, goTmpcallback)

}

///
// Attempts to resolve |origin| to a list of associated IP addresses.
// |callback| will be executed on the UI thread after completion.
///
func (self *CRequestContextT) ResolveHost(
	origin string,
	callback *CResolveCallbackT,
) {
	c_origin := create_cef_string(origin)
	defer clear_cef_string(c_origin)
	var goTmpcallback *C.cef_resolve_callback_t
	if callback != nil {
		goTmpcallback = callback.p_resolve_callback
		BaseAddRef(goTmpcallback)
	}

	C.cefingo_request_context_resolve_host(self.p_request_context, (*C.cef_string_t)(c_origin), goTmpcallback)

}

///
// Load an extension.
//
// If extension resources will be read from disk using the default load
// implementation then |root_directory| should be the absolute path to the
// extension resources directory and |manifest| should be NULL. If extension
// resources will be provided by the client (e.g. via cef_request_handler_t
// and/or cef_extension_handler_t) then |root_directory| should be a path
// component unique to the extension (if not absolute this will be internally
// prefixed with the PK_DIR_RESOURCES path) and |manifest| should contain the
// contents that would otherwise be read from the &quot;manifest.json&quot; file on
// disk.
//
// The loaded extension will be accessible in all contexts sharing the same
// storage (HasExtension returns true (1)). However, only the context on which
// this function was called is considered the loader (DidLoadExtension returns
// true (1)) and only the loader will receive cef_request_context_handler_t
// callbacks for the extension.
//
// cef_extension_handler_t::OnExtensionLoaded will be called on load success
// or cef_extension_handler_t::OnExtensionLoadFailed will be called on load
// failure.
//
// If the extension specifies a background script via the &quot;background&quot;
// manifest key then cef_extension_handler_t::OnBeforeBackgroundBrowser will
// be called to create the background browser. See that function for
// additional information about background scripts.
//
// For visible extension views the client application should evaluate the
// manifest to determine the correct extension URL to load and then pass that
// URL to the cef_browser_host_t::CreateBrowser* function after the extension
// has loaded. For example, the client can look for the &quot;browser_action&quot;
// manifest key as documented at
// https://developer.chrome.com/extensions/browserAction. Extension URLs take
// the form &quot;chrome-extension://&lt;extension_id&gt;/&lt;path&gt;&quot;.
//
// Browsers that host extensions differ from normal browsers as follows:
//  - Can access chrome.* JavaScript APIs if allowed by the manifest. Visit
//    chrome://extensions-support for the list of extension APIs currently
//    supported by CEF.
//  - Main frame navigation to non-extension content is blocked.
//  - Pinch-zooming is disabled.
//  - CefBrowserHost::GetExtension returns the hosted extension.
//  - CefBrowserHost::IsBackgroundHost returns true for background hosts.
//
// See https://developer.chrome.com/extensions for extension implementation
// and usage documentation.
///
func (self *CRequestContextT) LoadExtension(
	root_directory string,
	manifest *CDictionaryValueT,
	handler *CExtensionHandlerT,
) {
	c_root_directory := create_cef_string(root_directory)
	defer clear_cef_string(c_root_directory)
	var goTmpmanifest *C.cef_dictionary_value_t
	if manifest != nil {
		goTmpmanifest = manifest.p_dictionary_value
		BaseAddRef(goTmpmanifest)
	}
	var goTmphandler *C.cef_extension_handler_t
	if handler != nil {
		goTmphandler = handler.p_extension_handler
		BaseAddRef(goTmphandler)
	}

	C.cefingo_request_context_load_extension(self.p_request_context, (*C.cef_string_t)(c_root_directory), goTmpmanifest, goTmphandler)

}

///
// Returns true (1) if this context was used to load the extension identified
// by |extension_id|. Other contexts sharing the same storage will also have
// access to the extension (see HasExtension). This function must be called on
// the browser process UI thread.
///
func (self *CRequestContextT) DidLoadExtension(
	extension_id string,
) (ret bool) {
	c_extension_id := create_cef_string(extension_id)
	defer clear_cef_string(c_extension_id)

	cRet := C.cefingo_request_context_did_load_extension(self.p_request_context, (*C.cef_string_t)(c_extension_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this context has access to the extension identified by
// |extension_id|. This may not be the context that was used to load the
// extension (see DidLoadExtension). This function must be called on the
// browser process UI thread.
///
func (self *CRequestContextT) HasExtension(
	extension_id string,
) (ret bool) {
	c_extension_id := create_cef_string(extension_id)
	defer clear_cef_string(c_extension_id)

	cRet := C.cefingo_request_context_has_extension(self.p_request_context, (*C.cef_string_t)(c_extension_id))

	ret = cRet == 1
	return ret
}

///
// Retrieve the list of all extensions that this context has access to (see
// HasExtension). |extension_ids| will be populated with the list of extension
// ID values. Returns true (1) on success. This function must be called on the
// browser process UI thread.
///
func (self *CRequestContextT) GetExtensions(
	extension_ids CStringListT,
) (ret bool) {

	cRet := C.cefingo_request_context_get_extensions(self.p_request_context, (C.cef_string_list_t)(extension_ids))

	ret = cRet == 1
	return ret
}

///
// Returns the extension matching |extension_id| or NULL if no matching
// extension is accessible in this context (see HasExtension). This function
// must be called on the browser process UI thread.
///
func (self *CRequestContextT) GetExtension(
	extension_id string,
) (ret *CExtensionT) {
	c_extension_id := create_cef_string(extension_id)
	defer clear_cef_string(c_extension_id)

	cRet := C.cefingo_request_context_get_extension(self.p_request_context, (*C.cef_string_t)(c_extension_id))

	ret = newCExtensionT(cRet)
	return ret
}

///
// Returns the MediaRouter object associated with this context.
///
func (self *CRequestContextT) GetMediaRouter() (ret *CMediaRouterT) {

	cRet := C.cefingo_request_context_get_media_router(self.p_request_context)

	ret = newCMediaRouterT(cRet)
	return ret
}

///
// Returns the global context object.
///
func RequestContextGetGlobalContext() (ret *CRequestContextT) {

	cRet := C.cef_request_context_get_global_context()

	ret = newCRequestContextT(cRet)
	return ret
}

///
// Creates a new context object with the specified |settings| and optional
// |handler|.
///
func RequestContextCreateContext(
	settings *CRequestContextSettingsT,
	handler *CRequestContextHandlerT,
) (ret *CRequestContextT) {
	var goTmphandler *C.cef_request_context_handler_t
	if handler != nil {
		goTmphandler = handler.p_request_context_handler
		BaseAddRef(goTmphandler)
	}

	cRet := C.cef_request_context_create_context((*C.cef_request_context_settings_t)(settings), goTmphandler)

	ret = newCRequestContextT(cRet)
	return ret
}

///
// Creates a new context object that shares storage with |other| and uses an
// optional |handler|.
///
func CreateContextShared(
	other *CRequestContextT,
	handler *CRequestContextHandlerT,
) (ret *CRequestContextT) {
	var goTmpother *C.cef_request_context_t
	if other != nil {
		goTmpother = other.p_request_context
		BaseAddRef(goTmpother)
	}
	var goTmphandler *C.cef_request_context_handler_t
	if handler != nil {
		goTmphandler = handler.p_request_context_handler
		BaseAddRef(goTmphandler)
	}

	cRet := C.cef_create_context_shared(goTmpother, goTmphandler)

	ret = newCRequestContextT(cRet)
	return ret
}

// cef_request_context_handler_capi.h, include/capi/cef_request_context_handler_capi.h:129:3,

///
// Implement this structure to provide handler implementations. The handler
// instance will not be released until all objects related to the context have
// been destroyed.
///

// Go type for cef_request_context_handler_t
type CRequestContextHandlerT struct {
	noCopy                    noCopy
	p_request_context_handler *C.cef_request_context_handler_t
}

type RefToCRequestContextHandlerT struct {
	p_request_context_handler *CRequestContextHandlerT
}

type CRequestContextHandlerTAccessor interface {
	GetCRequestContextHandlerT() *CRequestContextHandlerT
	SetCRequestContextHandlerT(*CRequestContextHandlerT)
}

func (r RefToCRequestContextHandlerT) GetCRequestContextHandlerT() *CRequestContextHandlerT {
	return r.p_request_context_handler
}

func (r *RefToCRequestContextHandlerT) SetCRequestContextHandlerT(p *CRequestContextHandlerT) {
	r.p_request_context_handler = p
}

// Go type CRequestContextHandlerT wraps cef type *C.cef_request_context_handler_t
func newCRequestContextHandlerT(p *C.cef_request_context_handler_t) *CRequestContextHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T17458:")
	BaseAddRef(p)
	go_request_context_handler := CRequestContextHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_request_context_handler, func(g *CRequestContextHandlerT) {
		Tracef(unsafe.Pointer(g.p_request_context_handler), "T17462:")
		BaseRelease(g.p_request_context_handler)
	})
	return &go_request_context_handler
}

// *C.cef_request_context_handler_t has refCounted interface
func (request_context_handler *CRequestContextHandlerT) HasOneRef() bool {
	return BaseHasOneRef(request_context_handler.p_request_context_handler)
}

func (p *C.cef_request_context_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the browser process UI thread immediately after the request
// context has been initialized.
///
type OnRequestContextInitializedHandler interface {
	OnRequestContextInitialized(
		self *CRequestContextHandlerT,
		request_context *CRequestContextT,
	)
}

///
// Called on multiple browser process threads before a plugin instance is
// loaded. |mime_type| is the mime type of the plugin that will be loaded.
// |plugin_url| is the content URL that the plugin will load and may be NULL.
// |is_main_frame| will be true (1) if the plugin is being loaded in the main
// (top-level) frame, |top_origin_url| is the URL for the top-level frame that
// contains the plugin when loading a specific plugin instance or NULL when
// building the initial list of enabled plugins for &#39;navigator.plugins&#39;
// JavaScript state. |plugin_info| includes additional information about the
// plugin that will be loaded. |plugin_policy| is the recommended policy.
// Modify |plugin_policy| and return true (1) to change the policy. Return
// false (0) to use the recommended policy. The default plugin policy can be
// set at runtime using the `--plugin-policy=[allow|detect|block]` command-
// line flag. Decisions to mark a plugin as disabled by setting
// |plugin_policy| to PLUGIN_POLICY_DISABLED may be cached when
// |top_origin_url| is NULL. To purge the plugin list cache and potentially
// trigger new calls to this function call
// cef_request_context_t::PurgePluginListCache.
///
type OnBeforePluginLoadHandler interface {
	OnBeforePluginLoad(
		self *CRequestContextHandlerT,
		mime_type string,
		plugin_url string,
		is_main_frame int,
		top_origin_url string,
		plugin_info *CWebPluginInfoT,
	) (ret bool, plugin_policy CPluginPolicyT)
}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request, and may be NULL for requests originating from service workers or
// cef_urlrequest_t. |request| represents the request contents and cannot be
// modified in this callback. |is_navigation| will be true (1) if the resource
// request is a navigation. |is_download| will be true (1) if the resource
// request is a download. |request_initiator| is the origin (scheme + domain)
// of the page that initiated the request. Set |disable_default_handling| to
// true (1) to disable default handling of the request, in which case it will
// need to be handled via cef_resource_request_handler_t::GetResourceHandler
// or it will be canceled. To allow the resource load to proceed with default
// handling return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. This function will not be called if
// the client associated with |browser| returns a non-NULL value from
// cef_request_handler_t::GetResourceRequestHandler for the same request
// (identified by cef_request_t::GetIdentifier).
///
type CRequestContextHandlerTGetResourceRequestHandlerHandler interface {
	GetResourceRequestHandler(
		self *CRequestContextHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		is_navigation int,
		is_download int,
		request_initiator string,
	) (ret *CResourceRequestHandlerT, disable_default_handling int)
}

var request_context_handler_handlers = struct {
	on_request_context_initialized_handler map[*C.cef_request_context_handler_t]OnRequestContextInitializedHandler
	on_before_plugin_load_handler          map[*C.cef_request_context_handler_t]OnBeforePluginLoadHandler
	get_resource_request_handler_handler   map[*C.cef_request_context_handler_t]CRequestContextHandlerTGetResourceRequestHandlerHandler
}{
	map[*C.cef_request_context_handler_t]OnRequestContextInitializedHandler{},
	map[*C.cef_request_context_handler_t]OnBeforePluginLoadHandler{},
	map[*C.cef_request_context_handler_t]CRequestContextHandlerTGetResourceRequestHandlerHandler{},
}

// AllocCRequestContextHandlerT allocates CRequestContextHandlerT and construct it
func AllocCRequestContextHandlerT() *CRequestContextHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_request_context_handler_wrapper_t, "T17560:")
	cefp := C.cefingo_construct_request_context_handler((*C.cefingo_request_context_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_request_context_handler_t itself in DeassocFunc,
		// or cef_request_context_handler_t is never GCed.
		Tracef(up, "T17566:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(request_context_handler_handlers.on_request_context_initialized_handler, cefp)
		delete(request_context_handler_handlers.on_before_plugin_load_handler, cefp)
		delete(request_context_handler_handlers.get_resource_request_handler_handler, cefp)
	}))

	return newCRequestContextHandlerT(cefp)
}

func (request_context_handler *CRequestContextHandlerT) Bind(a interface{}) *CRequestContextHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := request_context_handler.p_request_context_handler

	if h, ok := a.(OnRequestContextInitializedHandler); ok {
		request_context_handler_handlers.on_request_context_initialized_handler[cp] = h
	}

	if h, ok := a.(OnBeforePluginLoadHandler); ok {
		request_context_handler_handlers.on_before_plugin_load_handler[cp] = h
	}

	if h, ok := a.(CRequestContextHandlerTGetResourceRequestHandlerHandler); ok {
		request_context_handler_handlers.get_resource_request_handler_handler[cp] = h
	}

	if accessor, ok := a.(CRequestContextHandlerTAccessor); ok {
		accessor.SetCRequestContextHandlerT(request_context_handler)
		Logf("T17610:")
	}

	return request_context_handler
}

// cef_request_handler_capi.h, include/capi/cef_request_handler_capi.h:73:3,

///
// Callback structure used to select a client certificate for authentication.
///

// Go type for cef_select_client_certificate_callback_t
type CSelectClientCertificateCallbackT struct {
	noCopy                               noCopy
	p_select_client_certificate_callback *C.cef_select_client_certificate_callback_t
}

type RefToCSelectClientCertificateCallbackT struct {
	p_select_client_certificate_callback *CSelectClientCertificateCallbackT
}

type CSelectClientCertificateCallbackTAccessor interface {
	GetCSelectClientCertificateCallbackT() *CSelectClientCertificateCallbackT
	SetCSelectClientCertificateCallbackT(*CSelectClientCertificateCallbackT)
}

func (r RefToCSelectClientCertificateCallbackT) GetCSelectClientCertificateCallbackT() *CSelectClientCertificateCallbackT {
	return r.p_select_client_certificate_callback
}

func (r *RefToCSelectClientCertificateCallbackT) SetCSelectClientCertificateCallbackT(p *CSelectClientCertificateCallbackT) {
	r.p_select_client_certificate_callback = p
}

// Go type CSelectClientCertificateCallbackT wraps cef type *C.cef_select_client_certificate_callback_t
func newCSelectClientCertificateCallbackT(p *C.cef_select_client_certificate_callback_t) *CSelectClientCertificateCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T17637:")
	BaseAddRef(p)
	go_select_client_certificate_callback := CSelectClientCertificateCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_select_client_certificate_callback, func(g *CSelectClientCertificateCallbackT) {
		Tracef(unsafe.Pointer(g.p_select_client_certificate_callback), "T17641:")
		BaseRelease(g.p_select_client_certificate_callback)
	})
	return &go_select_client_certificate_callback
}

// *C.cef_select_client_certificate_callback_t has refCounted interface
func (select_client_certificate_callback *CSelectClientCertificateCallbackT) HasOneRef() bool {
	return BaseHasOneRef(select_client_certificate_callback.p_select_client_certificate_callback)
}

func (p *C.cef_select_client_certificate_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Chooses the specified certificate for client certificate authentication.
// NULL value means that no client certificate should be used.
///
func (self *CSelectClientCertificateCallbackT) Select(
	cert *CX509certificateT,
) {
	var goTmpcert *C.cef_x509certificate_t
	if cert != nil {
		goTmpcert = cert.p_x509certificate
		BaseAddRef(goTmpcert)
	}

	C.cefingo_select_client_certificate_callback_select(self.p_select_client_certificate_callback, goTmpcert)

}

///
// Implement this structure to handle events related to browser requests. The
// functions of this structure will be called on the thread indicated.
///

// Go type for cef_request_handler_t
type CRequestHandlerT struct {
	noCopy            noCopy
	p_request_handler *C.cef_request_handler_t
}

type RefToCRequestHandlerT struct {
	p_request_handler *CRequestHandlerT
}

type CRequestHandlerTAccessor interface {
	GetCRequestHandlerT() *CRequestHandlerT
	SetCRequestHandlerT(*CRequestHandlerT)
}

func (r RefToCRequestHandlerT) GetCRequestHandlerT() *CRequestHandlerT {
	return r.p_request_handler
}

func (r *RefToCRequestHandlerT) SetCRequestHandlerT(p *CRequestHandlerT) {
	r.p_request_handler = p
}

// Go type CRequestHandlerT wraps cef type *C.cef_request_handler_t
func newCRequestHandlerT(p *C.cef_request_handler_t) *CRequestHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T17706:")
	BaseAddRef(p)
	go_request_handler := CRequestHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_request_handler, func(g *CRequestHandlerT) {
		Tracef(unsafe.Pointer(g.p_request_handler), "T17710:")
		BaseRelease(g.p_request_handler)
	})
	return &go_request_handler
}

// *C.cef_request_handler_t has refCounted interface
func (request_handler *CRequestHandlerT) HasOneRef() bool {
	return BaseHasOneRef(request_handler.p_request_handler)
}

func (p *C.cef_request_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the UI thread before browser navigation. Return true (1) to
// cancel the navigation or false (0) to allow the navigation to proceed. The
// |request| object cannot be modified in this callback.
// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
// If the navigation is allowed cef_load_handler_t::OnLoadStart and
// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event).
///
type OnBeforeBrowseHandler interface {
	OnBeforeBrowse(
		self *CRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		user_gesture int,
		is_redirect int,
	) (ret bool)
}

///
// Called on the UI thread before OnBeforeBrowse in certain limited cases
// where navigating a new or different browser might be desirable. This
// includes user-initiated navigation that might open in a special way (e.g.
// links clicked via middle-click or ctrl + left-click) and certain types of
// cross-origin navigation initiated from the renderer process (e.g.
// navigating the top-level frame to/from a file URL). The |browser| and
// |frame| values represent the source of the navigation. The
// |target_disposition| value indicates where the user intended to navigate
// the browser based on standard Chromium behaviors (e.g. current tab, new
// tab, etc). The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event). Return
// true (1) to cancel the navigation or false (0) to allow the navigation to
// proceed in the source browser&#39;s top-level frame.
///
type OnOpenUrlfromTabHandler interface {
	OnOpenUrlfromTab(
		self *CRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		target_url string,
		target_disposition CWindowOpenDispositionT,
		user_gesture int,
	) (ret bool)
}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request. |request| represents the request contents and cannot be modified
// in this callback. |is_navigation| will be true (1) if the resource request
// is a navigation. |is_download| will be true (1) if the resource request is
// a download. |request_initiator| is the origin (scheme + domain) of the page
// that initiated the request. Set |disable_default_handling| to true (1) to
// disable default handling of the request, in which case it will need to be
// handled via cef_resource_request_handler_t::GetResourceHandler or it will
// be canceled. To allow the resource load to proceed with default handling
// return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. If this callback returns NULL the
// same function will be called on the associated
// cef_request_context_handler_t, if any.
///
type CRequestHandlerTGetResourceRequestHandlerHandler interface {
	GetResourceRequestHandler(
		self *CRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		is_navigation int,
		is_download int,
		request_initiator string,
	) (ret *CResourceRequestHandlerT, disable_default_handling int)
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |origin_url| is the origin making this authentication request. |isProxy|
// indicates whether the host is a proxy server. |host| contains the hostname
// and |port| contains the port number. |realm| is the realm of the challenge
// and may be NULL. |scheme| is the authentication scheme used, such as
// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
// FTP server. Return true (1) to continue the request and call
// cef_auth_callback_t::cont() either in this function or at a later time when
// the authentication information is available. Return false (0) to cancel the
// request immediately.
///
type CRequestHandlerTGetAuthCredentialsHandler interface {
	GetAuthCredentials(
		self *CRequestHandlerT,
		browser *CBrowserT,
		origin_url string,
		isProxy int,
		host string,
		port int,
		realm string,
		scheme string,
		callback *CAuthCallbackT,
	) (ret bool)
}

///
// Called on the IO thread when JavaScript requests a specific storage quota
// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
// origin of the page making the request. |new_size| is the requested quota
// size in bytes. Return true (1) to continue the request and call
// cef_request_callback_t::cont() either in this function or at a later time
// to grant or deny the request. Return false (0) to cancel the request
// immediately.
///
type OnQuotaRequestHandler interface {
	OnQuotaRequest(
		self *CRequestHandlerT,
		browser *CBrowserT,
		origin_url string,
		new_size int64,
		callback *CRequestCallbackT,
	) (ret bool)
}

///
// Called on the UI thread to handle requests for URLs with an invalid SSL
// certificate. Return true (1) and call cef_request_callback_t::cont() either
// in this function or at a later time to continue or cancel the request.
// Return false (0) to cancel the request immediately. If
// CefSettings.ignore_certificate_errors is set all invalid certificates will
// be accepted without calling this function.
///
type OnCertificateErrorHandler interface {
	OnCertificateError(
		self *CRequestHandlerT,
		browser *CBrowserT,
		cert_error CErrorcodeT,
		request_url string,
		ssl_info *CSslinfoT,
		callback *CRequestCallbackT,
	) (ret bool)
}

///
// Called on the UI thread when a client certificate is being requested for
// authentication. Return false (0) to use the default behavior and
// automatically select the first certificate available. Return true (1) and
// call cef_select_client_certificate_callback_t::Select either in this
// function or at a later time to select a certificate. Do not call Select or
// call it with NULL to continue without using any certificate. |isProxy|
// indicates whether the host is an HTTPS proxy or the origin server. |host|
// and |port| contains the hostname and port of the SSL server. |certificates|
// is the list of certificates to choose from; this list has already been
// pruned by Chromium so that it only contains certificates from issuers that
// the server trusts.
///
type OnSelectClientCertificateHandler interface {
	OnSelectClientCertificate(
		self *CRequestHandlerT,
		browser *CBrowserT,
		isProxy int,
		host string,
		port int,
		certificates []*CX509certificateT,
		callback *CSelectClientCertificateCallbackT,
	) (ret bool)
}

///
// Called on the browser process UI thread when a plugin has crashed.
// |plugin_path| is the path of the plugin that crashed.
///
type OnPluginCrashedHandler interface {
	OnPluginCrashed(
		self *CRequestHandlerT,
		browser *CBrowserT,
		plugin_path string,
	)
}

///
// Called on the browser process UI thread when the render view associated
// with |browser| is ready to receive/handle IPC messages in the render
// process.
///
type OnRenderViewReadyHandler interface {
	OnRenderViewReady(
		self *CRequestHandlerT,
		browser *CBrowserT,
	)
}

///
// Called on the browser process UI thread when the render process terminates
// unexpectedly. |status| indicates how the process terminated.
///
type OnRenderProcessTerminatedHandler interface {
	OnRenderProcessTerminated(
		self *CRequestHandlerT,
		browser *CBrowserT,
		status CTerminationStatusT,
	)
}

///
// Called on the browser process UI thread when the window.document object of
// the main frame has been created.
///
type OnDocumentAvailableInMainFrameHandler interface {
	OnDocumentAvailableInMainFrame(
		self *CRequestHandlerT,
		browser *CBrowserT,
	)
}

var request_handler_handlers = struct {
	on_before_browse_handler                    map[*C.cef_request_handler_t]OnBeforeBrowseHandler
	on_open_urlfrom_tab_handler                 map[*C.cef_request_handler_t]OnOpenUrlfromTabHandler
	get_resource_request_handler_handler        map[*C.cef_request_handler_t]CRequestHandlerTGetResourceRequestHandlerHandler
	get_auth_credentials_handler                map[*C.cef_request_handler_t]CRequestHandlerTGetAuthCredentialsHandler
	on_quota_request_handler                    map[*C.cef_request_handler_t]OnQuotaRequestHandler
	on_certificate_error_handler                map[*C.cef_request_handler_t]OnCertificateErrorHandler
	on_select_client_certificate_handler        map[*C.cef_request_handler_t]OnSelectClientCertificateHandler
	on_plugin_crashed_handler                   map[*C.cef_request_handler_t]OnPluginCrashedHandler
	on_render_view_ready_handler                map[*C.cef_request_handler_t]OnRenderViewReadyHandler
	on_render_process_terminated_handler        map[*C.cef_request_handler_t]OnRenderProcessTerminatedHandler
	on_document_available_in_main_frame_handler map[*C.cef_request_handler_t]OnDocumentAvailableInMainFrameHandler
}{
	map[*C.cef_request_handler_t]OnBeforeBrowseHandler{},
	map[*C.cef_request_handler_t]OnOpenUrlfromTabHandler{},
	map[*C.cef_request_handler_t]CRequestHandlerTGetResourceRequestHandlerHandler{},
	map[*C.cef_request_handler_t]CRequestHandlerTGetAuthCredentialsHandler{},
	map[*C.cef_request_handler_t]OnQuotaRequestHandler{},
	map[*C.cef_request_handler_t]OnCertificateErrorHandler{},
	map[*C.cef_request_handler_t]OnSelectClientCertificateHandler{},
	map[*C.cef_request_handler_t]OnPluginCrashedHandler{},
	map[*C.cef_request_handler_t]OnRenderViewReadyHandler{},
	map[*C.cef_request_handler_t]OnRenderProcessTerminatedHandler{},
	map[*C.cef_request_handler_t]OnDocumentAvailableInMainFrameHandler{},
}

// AllocCRequestHandlerT allocates CRequestHandlerT and construct it
func AllocCRequestHandlerT() *CRequestHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_request_handler_wrapper_t, "T17967:")
	cefp := C.cefingo_construct_request_handler((*C.cefingo_request_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_request_handler_t itself in DeassocFunc,
		// or cef_request_handler_t is never GCed.
		Tracef(up, "T17973:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(request_handler_handlers.on_before_browse_handler, cefp)
		delete(request_handler_handlers.on_open_urlfrom_tab_handler, cefp)
		delete(request_handler_handlers.get_resource_request_handler_handler, cefp)
		delete(request_handler_handlers.get_auth_credentials_handler, cefp)
		delete(request_handler_handlers.on_quota_request_handler, cefp)
		delete(request_handler_handlers.on_certificate_error_handler, cefp)
		delete(request_handler_handlers.on_select_client_certificate_handler, cefp)
		delete(request_handler_handlers.on_plugin_crashed_handler, cefp)
		delete(request_handler_handlers.on_render_view_ready_handler, cefp)
		delete(request_handler_handlers.on_render_process_terminated_handler, cefp)
		delete(request_handler_handlers.on_document_available_in_main_frame_handler, cefp)
	}))

	return newCRequestHandlerT(cefp)
}

func (request_handler *CRequestHandlerT) Bind(a interface{}) *CRequestHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := request_handler.p_request_handler

	if h, ok := a.(OnBeforeBrowseHandler); ok {
		request_handler_handlers.on_before_browse_handler[cp] = h
	}

	if h, ok := a.(OnOpenUrlfromTabHandler); ok {
		request_handler_handlers.on_open_urlfrom_tab_handler[cp] = h
	}

	if h, ok := a.(CRequestHandlerTGetResourceRequestHandlerHandler); ok {
		request_handler_handlers.get_resource_request_handler_handler[cp] = h
	}

	if h, ok := a.(CRequestHandlerTGetAuthCredentialsHandler); ok {
		request_handler_handlers.get_auth_credentials_handler[cp] = h
	}

	if h, ok := a.(OnQuotaRequestHandler); ok {
		request_handler_handlers.on_quota_request_handler[cp] = h
	}

	if h, ok := a.(OnCertificateErrorHandler); ok {
		request_handler_handlers.on_certificate_error_handler[cp] = h
	}

	if h, ok := a.(OnSelectClientCertificateHandler); ok {
		request_handler_handlers.on_select_client_certificate_handler[cp] = h
	}

	if h, ok := a.(OnPluginCrashedHandler); ok {
		request_handler_handlers.on_plugin_crashed_handler[cp] = h
	}

	if h, ok := a.(OnRenderViewReadyHandler); ok {
		request_handler_handlers.on_render_view_ready_handler[cp] = h
	}

	if h, ok := a.(OnRenderProcessTerminatedHandler); ok {
		request_handler_handlers.on_render_process_terminated_handler[cp] = h
	}

	if h, ok := a.(OnDocumentAvailableInMainFrameHandler); ok {
		request_handler_handlers.on_document_available_in_main_frame_handler[cp] = h
	}

	if accessor, ok := a.(CRequestHandlerTAccessor); ok {
		accessor.SetCRequestHandlerT(request_handler)
		Logf("T18057:")
	}

	return request_handler
}

// cef_resource_bundle_handler_capi.h, include/capi/cef_resource_bundle_handler_capi.h:99:3,

///
// Structure used to implement a custom resource bundle structure. See
// CefSettings for additional options related to resource bundle loading. The
// functions of this structure may be called on multiple threads.
///

// Go type for cef_resource_bundle_handler_t
type CResourceBundleHandlerT struct {
	noCopy                    noCopy
	p_resource_bundle_handler *C.cef_resource_bundle_handler_t
}

type RefToCResourceBundleHandlerT struct {
	p_resource_bundle_handler *CResourceBundleHandlerT
}

type CResourceBundleHandlerTAccessor interface {
	GetCResourceBundleHandlerT() *CResourceBundleHandlerT
	SetCResourceBundleHandlerT(*CResourceBundleHandlerT)
}

func (r RefToCResourceBundleHandlerT) GetCResourceBundleHandlerT() *CResourceBundleHandlerT {
	return r.p_resource_bundle_handler
}

func (r *RefToCResourceBundleHandlerT) SetCResourceBundleHandlerT(p *CResourceBundleHandlerT) {
	r.p_resource_bundle_handler = p
}

// Go type CResourceBundleHandlerT wraps cef type *C.cef_resource_bundle_handler_t
func newCResourceBundleHandlerT(p *C.cef_resource_bundle_handler_t) *CResourceBundleHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T18086:")
	BaseAddRef(p)
	go_resource_bundle_handler := CResourceBundleHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_resource_bundle_handler, func(g *CResourceBundleHandlerT) {
		Tracef(unsafe.Pointer(g.p_resource_bundle_handler), "T18090:")
		BaseRelease(g.p_resource_bundle_handler)
	})
	return &go_resource_bundle_handler
}

// *C.cef_resource_bundle_handler_t has refCounted interface
func (resource_bundle_handler *CResourceBundleHandlerT) HasOneRef() bool {
	return BaseHasOneRef(resource_bundle_handler.p_resource_bundle_handler)
}

func (p *C.cef_resource_bundle_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called to retrieve a localized translation for the specified |string_id|.
// To provide the translation set |string| to the translation string and
// return true (1). To use the default translation return false (0). Include
// cef_pack_strings.h for a listing of valid string ID values.
///
type GetLocalizedStringHandler interface {
	GetLocalizedString(
		self *CResourceBundleHandlerT,
		string_id int,
	) (ret bool, cstring string)
}

///
// Called to retrieve data for the specified scale independent |resource_id|.
// To provide the resource data set |data| and |data_size| to the data pointer
// and size respectively and return true (1). To use the default resource data
// return false (0). The resource data will not be copied and must remain
// resident in memory. Include cef_pack_resources.h for a listing of valid
// resource ID values.
///
type GetDataResourceHandler interface {
	GetDataResource(
		self *CResourceBundleHandlerT,
		resource_id int,
	) (ret bool, data []byte)
}

///
// Called to retrieve data for the specified |resource_id| nearest the scale
// factor |scale_factor|. To provide the resource data set |data| and
// |data_size| to the data pointer and size respectively and return true (1).
// To use the default resource data return false (0). The resource data will
// not be copied and must remain resident in memory. Include
// cef_pack_resources.h for a listing of valid resource ID values.
///
type GetDataResourceForScaleHandler interface {
	GetDataResourceForScale(
		self *CResourceBundleHandlerT,
		resource_id int,
		scale_factor CScaleFactorT,
	) (ret bool, data []byte)
}

var resource_bundle_handler_handlers = struct {
	get_localized_string_handler        map[*C.cef_resource_bundle_handler_t]GetLocalizedStringHandler
	get_data_resource_handler           map[*C.cef_resource_bundle_handler_t]GetDataResourceHandler
	get_data_resource_for_scale_handler map[*C.cef_resource_bundle_handler_t]GetDataResourceForScaleHandler
}{
	map[*C.cef_resource_bundle_handler_t]GetLocalizedStringHandler{},
	map[*C.cef_resource_bundle_handler_t]GetDataResourceHandler{},
	map[*C.cef_resource_bundle_handler_t]GetDataResourceForScaleHandler{},
}

// AllocCResourceBundleHandlerT allocates CResourceBundleHandlerT and construct it
func AllocCResourceBundleHandlerT() *CResourceBundleHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_resource_bundle_handler_wrapper_t, "T18161:")
	cefp := C.cefingo_construct_resource_bundle_handler((*C.cefingo_resource_bundle_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_resource_bundle_handler_t itself in DeassocFunc,
		// or cef_resource_bundle_handler_t is never GCed.
		Tracef(up, "T18167:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(resource_bundle_handler_handlers.get_localized_string_handler, cefp)
		delete(resource_bundle_handler_handlers.get_data_resource_handler, cefp)
		delete(resource_bundle_handler_handlers.get_data_resource_for_scale_handler, cefp)
	}))

	return newCResourceBundleHandlerT(cefp)
}

func (resource_bundle_handler *CResourceBundleHandlerT) Bind(a interface{}) *CResourceBundleHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := resource_bundle_handler.p_resource_bundle_handler

	if h, ok := a.(GetLocalizedStringHandler); ok {
		resource_bundle_handler_handlers.get_localized_string_handler[cp] = h
	}

	if h, ok := a.(GetDataResourceHandler); ok {
		resource_bundle_handler_handlers.get_data_resource_handler[cp] = h
	}

	if h, ok := a.(GetDataResourceForScaleHandler); ok {
		resource_bundle_handler_handlers.get_data_resource_for_scale_handler[cp] = h
	}

	if accessor, ok := a.(CResourceBundleHandlerTAccessor); ok {
		accessor.SetCResourceBundleHandlerT(resource_bundle_handler)
		Logf("T18211:")
	}

	return resource_bundle_handler
}

// cef_resource_handler_capi.h, include/capi/cef_resource_handler_capi.h:71:3,

///
// Callback for asynchronous continuation of cef_resource_handler_t::skip().
///

// Go type for cef_resource_skip_callback_t
type CResourceSkipCallbackT struct {
	noCopy                   noCopy
	p_resource_skip_callback *C.cef_resource_skip_callback_t
}

type RefToCResourceSkipCallbackT struct {
	p_resource_skip_callback *CResourceSkipCallbackT
}

type CResourceSkipCallbackTAccessor interface {
	GetCResourceSkipCallbackT() *CResourceSkipCallbackT
	SetCResourceSkipCallbackT(*CResourceSkipCallbackT)
}

func (r RefToCResourceSkipCallbackT) GetCResourceSkipCallbackT() *CResourceSkipCallbackT {
	return r.p_resource_skip_callback
}

func (r *RefToCResourceSkipCallbackT) SetCResourceSkipCallbackT(p *CResourceSkipCallbackT) {
	r.p_resource_skip_callback = p
}

// Go type CResourceSkipCallbackT wraps cef type *C.cef_resource_skip_callback_t
func newCResourceSkipCallbackT(p *C.cef_resource_skip_callback_t) *CResourceSkipCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T18238:")
	BaseAddRef(p)
	go_resource_skip_callback := CResourceSkipCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_resource_skip_callback, func(g *CResourceSkipCallbackT) {
		Tracef(unsafe.Pointer(g.p_resource_skip_callback), "T18242:")
		BaseRelease(g.p_resource_skip_callback)
	})
	return &go_resource_skip_callback
}

// *C.cef_resource_skip_callback_t has refCounted interface
func (resource_skip_callback *CResourceSkipCallbackT) HasOneRef() bool {
	return BaseHasOneRef(resource_skip_callback.p_resource_skip_callback)
}

func (p *C.cef_resource_skip_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Callback for asynchronous continuation of skip(). If |bytes_skipped| &gt; 0
// then either skip() will be called again until the requested number of bytes
// have been skipped or the request will proceed. If |bytes_skipped| &lt;= 0 the
// request will fail with ERR_REQUEST_RANGE_NOT_SATISFIABLE.
///
func (self *CResourceSkipCallbackT) Cont(
	bytes_skipped int64,
) {

	C.cefingo_resource_skip_callback_cont(self.p_resource_skip_callback, (C.int64)(bytes_skipped))

}

///
// Callback for asynchronous continuation of cef_resource_handler_t::read().
///

// Go type for cef_resource_read_callback_t
type CResourceReadCallbackT struct {
	noCopy                   noCopy
	p_resource_read_callback *C.cef_resource_read_callback_t
}

type RefToCResourceReadCallbackT struct {
	p_resource_read_callback *CResourceReadCallbackT
}

type CResourceReadCallbackTAccessor interface {
	GetCResourceReadCallbackT() *CResourceReadCallbackT
	SetCResourceReadCallbackT(*CResourceReadCallbackT)
}

func (r RefToCResourceReadCallbackT) GetCResourceReadCallbackT() *CResourceReadCallbackT {
	return r.p_resource_read_callback
}

func (r *RefToCResourceReadCallbackT) SetCResourceReadCallbackT(p *CResourceReadCallbackT) {
	r.p_resource_read_callback = p
}

// Go type CResourceReadCallbackT wraps cef type *C.cef_resource_read_callback_t
func newCResourceReadCallbackT(p *C.cef_resource_read_callback_t) *CResourceReadCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T18303:")
	BaseAddRef(p)
	go_resource_read_callback := CResourceReadCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_resource_read_callback, func(g *CResourceReadCallbackT) {
		Tracef(unsafe.Pointer(g.p_resource_read_callback), "T18307:")
		BaseRelease(g.p_resource_read_callback)
	})
	return &go_resource_read_callback
}

// *C.cef_resource_read_callback_t has refCounted interface
func (resource_read_callback *CResourceReadCallbackT) HasOneRef() bool {
	return BaseHasOneRef(resource_read_callback.p_resource_read_callback)
}

func (p *C.cef_resource_read_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Callback for asynchronous continuation of read(). If |bytes_read| == 0 the
// response will be considered complete. If |bytes_read| &gt; 0 then read() will
// be called again until the request is complete (based on either the result
// or the expected content length). If |bytes_read| &lt; 0 then the request will
// fail and the |bytes_read| value will be treated as the error code.
///
func (self *CResourceReadCallbackT) Cont(
	bytes_read int,
) {

	C.cefingo_resource_read_callback_cont(self.p_resource_read_callback, (C.int)(bytes_read))

}

///
// Structure used to implement a custom request handler structure. The functions
// of this structure will be called on the IO thread unless otherwise indicated.
///

// Go type for cef_resource_handler_t
type CResourceHandlerT struct {
	noCopy             noCopy
	p_resource_handler *C.cef_resource_handler_t
}

type RefToCResourceHandlerT struct {
	p_resource_handler *CResourceHandlerT
}

type CResourceHandlerTAccessor interface {
	GetCResourceHandlerT() *CResourceHandlerT
	SetCResourceHandlerT(*CResourceHandlerT)
}

func (r RefToCResourceHandlerT) GetCResourceHandlerT() *CResourceHandlerT {
	return r.p_resource_handler
}

func (r *RefToCResourceHandlerT) SetCResourceHandlerT(p *CResourceHandlerT) {
	r.p_resource_handler = p
}

// Go type CResourceHandlerT wraps cef type *C.cef_resource_handler_t
func newCResourceHandlerT(p *C.cef_resource_handler_t) *CResourceHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T18370:")
	BaseAddRef(p)
	go_resource_handler := CResourceHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_resource_handler, func(g *CResourceHandlerT) {
		Tracef(unsafe.Pointer(g.p_resource_handler), "T18374:")
		BaseRelease(g.p_resource_handler)
	})
	return &go_resource_handler
}

// *C.cef_resource_handler_t has refCounted interface
func (resource_handler *CResourceHandlerT) HasOneRef() bool {
	return BaseHasOneRef(resource_handler.p_resource_handler)
}

func (p *C.cef_resource_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Open the response stream. To handle the request immediately set
// |handle_request| to true (1) and return true (1). To decide at a later time
// set |handle_request| to false (0), return true (1), and execute |callback|
// to continue or cancel the request. To cancel the request immediately set
// |handle_request| to true (1) and return false (0). This function will be
// called in sequence but not from a dedicated thread. For backwards
// compatibility set |handle_request| to false (0) and return false (0) and
// the ProcessRequest function will be called.
///
type OpenHandler interface {
	Open(
		self *CResourceHandlerT,
		request *CRequestT,
		callback *CCallbackT,
	) (ret bool, handle_request int)
}

///
// Begin processing the request. To handle the request return true (1) and
// call cef_callback_t::cont() once the response header information is
// available (cef_callback_t::cont() can also be called from inside this
// function if header information is available immediately). To cancel the
// request return false (0).
//
// WARNING: This function is deprecated. Use Open instead.
///
type ProcessRequestHandler interface {
	ProcessRequest(
		self *CResourceHandlerT,
		request *CRequestT,
		callback *CCallbackT,
	) (ret bool)
}

///
// Retrieve response header information. If the response length is not known
// set |response_length| to -1 and read_response() will be called until it
// returns false (0). If the response length is known set |response_length| to
// a positive value and read_response() will be called until it returns false
// (0) or the specified number of bytes have been read. Use the |response|
// object to set the mime type, http status code and other optional header
// values. To redirect the request to a new URL set |redirectUrl| to the new
// URL. |redirectUrl| can be either a relative or fully qualified URL. It is
// also possible to set |response| to a redirect http status code and pass the
// new URL via a Location header. Likewise with |redirectUrl| it is valid to
// set a relative or fully qualified URL as the Location header value. If an
// error occured while setting up the request you can call set_error() on
// |response| to indicate the error condition.
///
type GetResponseHeadersHandler interface {
	GetResponseHeaders(
		self *CResourceHandlerT,
		response *CResponseT,
	) (response_length int64, redirectUrl string)
}

///
// Skip response data when requested by a Range header. Skip over and discard
// |bytes_to_skip| bytes of response data. If data is available immediately
// set |bytes_skipped| to the number of bytes skipped and return true (1). To
// read the data at a later time set |bytes_skipped| to 0, return true (1) and
// execute |callback| when the data is available. To indicate failure set
// |bytes_skipped| to &lt; 0 (e.g. -2 for ERR_FAILED) and return false (0). This
// function will be called in sequence but not from a dedicated thread.
///
type SkipHandler interface {
	Skip(
		self *CResourceHandlerT,
		bytes_to_skip int64,
		callback *CResourceSkipCallbackT,
	) (ret bool, bytes_skipped int64)
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time keep a
// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
// |callback| when the data is available (|data_out| will remain valid until
// the callback is executed). To indicate response completion set |bytes_read|
// to 0 and return false (0). To indicate failure set |bytes_read| to &lt; 0
// (e.g. -2 for ERR_FAILED) and return false (0). This function will be called
// in sequence but not from a dedicated thread. For backwards compatibility
// set |bytes_read| to -1 and return false (0) and the ReadResponse function
// will be called.
///
type CResourceHandlerTReadHandler interface {
	Read(
		self *CResourceHandlerT,
		data_out []byte,
		callback *CResourceReadCallbackT,
	) (ret bool, bytes_read int)
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time set
// |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when the
// data is available. To indicate response completion return false (0).
//
// WARNING: This function is deprecated. Use Skip and Read instead.
///
type ReadResponseHandler interface {
	ReadResponse(
		self *CResourceHandlerT,
		data_out []byte,
		callback *CCallbackT,
	) (ret bool, bytes_read int)
}

///
// Request processing has been canceled.
///
type CancelHandler interface {
	Cancel(
		self *CResourceHandlerT,
	)
}

var resource_handler_handlers = struct {
	open_handler                 map[*C.cef_resource_handler_t]OpenHandler
	process_request_handler      map[*C.cef_resource_handler_t]ProcessRequestHandler
	get_response_headers_handler map[*C.cef_resource_handler_t]GetResponseHeadersHandler
	skip_handler                 map[*C.cef_resource_handler_t]SkipHandler
	read_handler                 map[*C.cef_resource_handler_t]CResourceHandlerTReadHandler
	read_response_handler        map[*C.cef_resource_handler_t]ReadResponseHandler
	cancel_handler               map[*C.cef_resource_handler_t]CancelHandler
}{
	map[*C.cef_resource_handler_t]OpenHandler{},
	map[*C.cef_resource_handler_t]ProcessRequestHandler{},
	map[*C.cef_resource_handler_t]GetResponseHeadersHandler{},
	map[*C.cef_resource_handler_t]SkipHandler{},
	map[*C.cef_resource_handler_t]CResourceHandlerTReadHandler{},
	map[*C.cef_resource_handler_t]ReadResponseHandler{},
	map[*C.cef_resource_handler_t]CancelHandler{},
}

// AllocCResourceHandlerT allocates CResourceHandlerT and construct it
func AllocCResourceHandlerT() *CResourceHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_resource_handler_wrapper_t, "T18530:")
	cefp := C.cefingo_construct_resource_handler((*C.cefingo_resource_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_resource_handler_t itself in DeassocFunc,
		// or cef_resource_handler_t is never GCed.
		Tracef(up, "T18536:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(resource_handler_handlers.open_handler, cefp)
		delete(resource_handler_handlers.process_request_handler, cefp)
		delete(resource_handler_handlers.get_response_headers_handler, cefp)
		delete(resource_handler_handlers.skip_handler, cefp)
		delete(resource_handler_handlers.read_handler, cefp)
		delete(resource_handler_handlers.read_response_handler, cefp)
		delete(resource_handler_handlers.cancel_handler, cefp)
	}))

	return newCResourceHandlerT(cefp)
}

func (resource_handler *CResourceHandlerT) Bind(a interface{}) *CResourceHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := resource_handler.p_resource_handler

	if h, ok := a.(OpenHandler); ok {
		resource_handler_handlers.open_handler[cp] = h
	}

	if h, ok := a.(ProcessRequestHandler); ok {
		resource_handler_handlers.process_request_handler[cp] = h
	}

	if h, ok := a.(GetResponseHeadersHandler); ok {
		resource_handler_handlers.get_response_headers_handler[cp] = h
	}

	if h, ok := a.(SkipHandler); ok {
		resource_handler_handlers.skip_handler[cp] = h
	}

	if h, ok := a.(CResourceHandlerTReadHandler); ok {
		resource_handler_handlers.read_handler[cp] = h
	}

	if h, ok := a.(ReadResponseHandler); ok {
		resource_handler_handlers.read_response_handler[cp] = h
	}

	if h, ok := a.(CancelHandler); ok {
		resource_handler_handlers.cancel_handler[cp] = h
	}

	if accessor, ok := a.(CResourceHandlerTAccessor); ok {
		accessor.SetCResourceHandlerT(resource_handler)
		Logf("T18600:")
	}

	return resource_handler
}

// cef_resource_request_handler_capi.h, include/capi/cef_resource_request_handler_capi.h:208:3,

///
// Implement this structure to handle events related to browser requests. The
// functions of this structure will be called on the IO thread unless otherwise
// indicated.
///

// Go type for cef_resource_request_handler_t
type CResourceRequestHandlerT struct {
	noCopy                     noCopy
	p_resource_request_handler *C.cef_resource_request_handler_t
}

type RefToCResourceRequestHandlerT struct {
	p_resource_request_handler *CResourceRequestHandlerT
}

type CResourceRequestHandlerTAccessor interface {
	GetCResourceRequestHandlerT() *CResourceRequestHandlerT
	SetCResourceRequestHandlerT(*CResourceRequestHandlerT)
}

func (r RefToCResourceRequestHandlerT) GetCResourceRequestHandlerT() *CResourceRequestHandlerT {
	return r.p_resource_request_handler
}

func (r *RefToCResourceRequestHandlerT) SetCResourceRequestHandlerT(p *CResourceRequestHandlerT) {
	r.p_resource_request_handler = p
}

// Go type CResourceRequestHandlerT wraps cef type *C.cef_resource_request_handler_t
func newCResourceRequestHandlerT(p *C.cef_resource_request_handler_t) *CResourceRequestHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T18629:")
	BaseAddRef(p)
	go_resource_request_handler := CResourceRequestHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_resource_request_handler, func(g *CResourceRequestHandlerT) {
		Tracef(unsafe.Pointer(g.p_resource_request_handler), "T18633:")
		BaseRelease(g.p_resource_request_handler)
	})
	return &go_resource_request_handler
}

// *C.cef_resource_request_handler_t has refCounted interface
func (resource_request_handler *CResourceRequestHandlerT) HasOneRef() bool {
	return BaseHasOneRef(resource_request_handler.p_resource_request_handler)
}

func (p *C.cef_resource_request_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To
// optionally filter cookies for the request return a
// cef_cookie_access_filter_t object. The |request| object cannot not be
// modified in this callback.
///
type GetCookieAccessFilterHandler interface {
	GetCookieAccessFilter(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
	) (ret *CCookieAccessFilterT)
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To redirect
// or change the resource load optionally modify |request|. Modification of
// the request URL will be treated as a redirect. Return RV_CONTINUE to
// continue the request immediately. Return RV_CONTINUE_ASYNC and call
// cef_request_callback_t:: cont() at a later time to continue or cancel the
// request asynchronously. Return RV_CANCEL to cancel the request immediately.
//
///
type OnBeforeResourceLoadHandler interface {
	OnBeforeResourceLoad(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		callback *CRequestCallbackT,
	) (ret CReturnValueT)
}

///
// Called on the IO thread before a resource is loaded. The |browser| and
// |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource to load using the default network loader return NULL. To specify a
// handler for the resource return a cef_resource_handler_t object. The
// |request| object cannot not be modified in this callback.
///
type GetResourceHandlerHandler interface {
	GetResourceHandler(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
	) (ret *CResourceHandlerT)
}

///
// Called on the IO thread when a resource load is redirected. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. The
// |request| parameter will contain the old URL and other request-related
// information. The |response| parameter will contain the response that
// resulted in the redirect. The |new_url| parameter will contain the new URL
// and can be changed if desired. The |request| and |response| objects cannot
// be modified in this callback.
///
type OnResourceRedirectHandler interface {
	OnResourceRedirect(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
	) (new_url string)
}

///
// Called on the IO thread when a resource response is received. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource load to proceed without modification return false (0). To redirect
// or retry the resource load optionally modify |request| and return true (1).
// Modification of the request URL will be treated as a redirect. Requests
// handled using the default network loader cannot be redirected in this
// callback. The |response| object cannot be modified in this callback.
//
// WARNING: Redirecting using this function is deprecated. Use
// OnBeforeResourceLoad or GetResourceHandler to perform redirects.
///
type OnResourceResponseHandler interface {
	OnResourceResponse(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
	) (ret bool)
}

///
// Called on the IO thread to optionally filter resource response content. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| and |response| represent the request and response respectively
// and cannot be modified in this callback.
///
type GetResourceResponseFilterHandler interface {
	GetResourceResponseFilter(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
	) (ret *CResponseFilterT)
}

///
// Called on the IO thread when a resource load has completed. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// and |response| represent the request and response respectively and cannot
// be modified in this callback. |status| indicates the load completion
// status. |received_content_length| is the number of response bytes actually
// read. This function will be called for all requests, including requests
// that are aborted due to CEF shutdown or destruction of the associated
// browser. In cases where the associated browser is destroyed this callback
// may arrive after the cef_life_span_handler_t::OnBeforeClose callback for
// that browser. The cef_frame_t::IsValid function can be used to test for
// this situation, and care should be taken not to call |browser| or |frame|
// functions that modify state (like LoadURL, SendProcessMessage, etc.) if the
// frame is invalid.
///
type OnResourceLoadCompleteHandler interface {
	OnResourceLoadComplete(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
		status CUrlrequestStatusT,
		received_content_length int64,
	)
}

///
// Called on the IO thread to handle requests for URLs with an unknown
// protocol component. The |browser| and |frame| values represent the source
// of the request, and may be NULL for requests originating from service
// workers or cef_urlrequest_t. |request| cannot be modified in this callback.
// Set |allow_os_execution| to true (1) to attempt execution via the
// registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD USE
// THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL
// ANALYSIS BEFORE ALLOWING OS EXECUTION.
///
type OnProtocolExecutionHandler interface {
	OnProtocolExecution(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
	) (allow_os_execution int)
}

var resource_request_handler_handlers = struct {
	get_cookie_access_filter_handler     map[*C.cef_resource_request_handler_t]GetCookieAccessFilterHandler
	on_before_resource_load_handler      map[*C.cef_resource_request_handler_t]OnBeforeResourceLoadHandler
	get_resource_handler_handler         map[*C.cef_resource_request_handler_t]GetResourceHandlerHandler
	on_resource_redirect_handler         map[*C.cef_resource_request_handler_t]OnResourceRedirectHandler
	on_resource_response_handler         map[*C.cef_resource_request_handler_t]OnResourceResponseHandler
	get_resource_response_filter_handler map[*C.cef_resource_request_handler_t]GetResourceResponseFilterHandler
	on_resource_load_complete_handler    map[*C.cef_resource_request_handler_t]OnResourceLoadCompleteHandler
	on_protocol_execution_handler        map[*C.cef_resource_request_handler_t]OnProtocolExecutionHandler
}{
	map[*C.cef_resource_request_handler_t]GetCookieAccessFilterHandler{},
	map[*C.cef_resource_request_handler_t]OnBeforeResourceLoadHandler{},
	map[*C.cef_resource_request_handler_t]GetResourceHandlerHandler{},
	map[*C.cef_resource_request_handler_t]OnResourceRedirectHandler{},
	map[*C.cef_resource_request_handler_t]OnResourceResponseHandler{},
	map[*C.cef_resource_request_handler_t]GetResourceResponseFilterHandler{},
	map[*C.cef_resource_request_handler_t]OnResourceLoadCompleteHandler{},
	map[*C.cef_resource_request_handler_t]OnProtocolExecutionHandler{},
}

// AllocCResourceRequestHandlerT allocates CResourceRequestHandlerT and construct it
func AllocCResourceRequestHandlerT() *CResourceRequestHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_resource_request_handler_wrapper_t, "T18832:")
	cefp := C.cefingo_construct_resource_request_handler((*C.cefingo_resource_request_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_resource_request_handler_t itself in DeassocFunc,
		// or cef_resource_request_handler_t is never GCed.
		Tracef(up, "T18838:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(resource_request_handler_handlers.get_cookie_access_filter_handler, cefp)
		delete(resource_request_handler_handlers.on_before_resource_load_handler, cefp)
		delete(resource_request_handler_handlers.get_resource_handler_handler, cefp)
		delete(resource_request_handler_handlers.on_resource_redirect_handler, cefp)
		delete(resource_request_handler_handlers.on_resource_response_handler, cefp)
		delete(resource_request_handler_handlers.get_resource_response_filter_handler, cefp)
		delete(resource_request_handler_handlers.on_resource_load_complete_handler, cefp)
		delete(resource_request_handler_handlers.on_protocol_execution_handler, cefp)
	}))

	return newCResourceRequestHandlerT(cefp)
}

func (resource_request_handler *CResourceRequestHandlerT) Bind(a interface{}) *CResourceRequestHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := resource_request_handler.p_resource_request_handler

	if h, ok := a.(GetCookieAccessFilterHandler); ok {
		resource_request_handler_handlers.get_cookie_access_filter_handler[cp] = h
	}

	if h, ok := a.(OnBeforeResourceLoadHandler); ok {
		resource_request_handler_handlers.on_before_resource_load_handler[cp] = h
	}

	if h, ok := a.(GetResourceHandlerHandler); ok {
		resource_request_handler_handlers.get_resource_handler_handler[cp] = h
	}

	if h, ok := a.(OnResourceRedirectHandler); ok {
		resource_request_handler_handlers.on_resource_redirect_handler[cp] = h
	}

	if h, ok := a.(OnResourceResponseHandler); ok {
		resource_request_handler_handlers.on_resource_response_handler[cp] = h
	}

	if h, ok := a.(GetResourceResponseFilterHandler); ok {
		resource_request_handler_handlers.get_resource_response_filter_handler[cp] = h
	}

	if h, ok := a.(OnResourceLoadCompleteHandler); ok {
		resource_request_handler_handlers.on_resource_load_complete_handler[cp] = h
	}

	if h, ok := a.(OnProtocolExecutionHandler); ok {
		resource_request_handler_handlers.on_protocol_execution_handler[cp] = h
	}

	if accessor, ok := a.(CResourceRequestHandlerTAccessor); ok {
		accessor.SetCResourceRequestHandlerT(resource_request_handler)
		Logf("T18907:")
	}

	return resource_request_handler
}

///
// Implement this structure to filter cookies that may be sent or received from
// resource requests. The functions of this structure will be called on the IO
// thread unless otherwise indicated.
///

// Go type for cef_cookie_access_filter_t
type CCookieAccessFilterT struct {
	noCopy                 noCopy
	p_cookie_access_filter *C.cef_cookie_access_filter_t
}

type RefToCCookieAccessFilterT struct {
	p_cookie_access_filter *CCookieAccessFilterT
}

type CCookieAccessFilterTAccessor interface {
	GetCCookieAccessFilterT() *CCookieAccessFilterT
	SetCCookieAccessFilterT(*CCookieAccessFilterT)
}

func (r RefToCCookieAccessFilterT) GetCCookieAccessFilterT() *CCookieAccessFilterT {
	return r.p_cookie_access_filter
}

func (r *RefToCCookieAccessFilterT) SetCCookieAccessFilterT(p *CCookieAccessFilterT) {
	r.p_cookie_access_filter = p
}

// Go type CCookieAccessFilterT wraps cef type *C.cef_cookie_access_filter_t
func newCCookieAccessFilterT(p *C.cef_cookie_access_filter_t) *CCookieAccessFilterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T18934:")
	BaseAddRef(p)
	go_cookie_access_filter := CCookieAccessFilterT{noCopy{}, p}
	runtime.SetFinalizer(&go_cookie_access_filter, func(g *CCookieAccessFilterT) {
		Tracef(unsafe.Pointer(g.p_cookie_access_filter), "T18938:")
		BaseRelease(g.p_cookie_access_filter)
	})
	return &go_cookie_access_filter
}

// *C.cef_cookie_access_filter_t has refCounted interface
func (cookie_access_filter *CCookieAccessFilterT) HasOneRef() bool {
	return BaseHasOneRef(cookie_access_filter.p_cookie_access_filter)
}

func (p *C.cef_cookie_access_filter_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called on the IO thread before a resource request is sent. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// cannot be modified in this callback. Return true (1) if the specified
// cookie can be sent with the request or false (0) otherwise.
///
type CanSendCookieHandler interface {
	CanSendCookie(
		self *CCookieAccessFilterT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		cookie *CCookieT,
	) (ret bool)
}

///
// Called on the IO thread after a resource response is received. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| cannot be modified in this callback. Return true (1) if the
// specified cookie returned with the response can be saved or false (0)
// otherwise.
///
type CanSaveCookieHandler interface {
	CanSaveCookie(
		self *CCookieAccessFilterT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
		cookie *CCookieT,
	) (ret bool)
}

var cookie_access_filter_handlers = struct {
	can_send_cookie_handler map[*C.cef_cookie_access_filter_t]CanSendCookieHandler
	can_save_cookie_handler map[*C.cef_cookie_access_filter_t]CanSaveCookieHandler
}{
	map[*C.cef_cookie_access_filter_t]CanSendCookieHandler{},
	map[*C.cef_cookie_access_filter_t]CanSaveCookieHandler{},
}

// AllocCCookieAccessFilterT allocates CCookieAccessFilterT and construct it
func AllocCCookieAccessFilterT() *CCookieAccessFilterT {
	up := c_calloc(1, C.sizeof_cefingo_cookie_access_filter_wrapper_t, "T18999:")
	cefp := C.cefingo_construct_cookie_access_filter((*C.cefingo_cookie_access_filter_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_cookie_access_filter_t itself in DeassocFunc,
		// or cef_cookie_access_filter_t is never GCed.
		Tracef(up, "T19005:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(cookie_access_filter_handlers.can_send_cookie_handler, cefp)
		delete(cookie_access_filter_handlers.can_save_cookie_handler, cefp)
	}))

	return newCCookieAccessFilterT(cefp)
}

func (cookie_access_filter *CCookieAccessFilterT) Bind(a interface{}) *CCookieAccessFilterT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := cookie_access_filter.p_cookie_access_filter

	if h, ok := a.(CanSendCookieHandler); ok {
		cookie_access_filter_handlers.can_send_cookie_handler[cp] = h
	}

	if h, ok := a.(CanSaveCookieHandler); ok {
		cookie_access_filter_handlers.can_save_cookie_handler[cp] = h
	}

	if accessor, ok := a.(CCookieAccessFilterTAccessor); ok {
		accessor.SetCCookieAccessFilterT(cookie_access_filter)
		Logf("T19044:")
	}

	return cookie_access_filter
}

// cef_response_capi.h, include/capi/cef_response_capi.h:166:3,

///
// Structure used to represent a web response. The functions of this structure
// may be called on any thread.
///

// Go type for cef_response_t
type CResponseT struct {
	noCopy     noCopy
	p_response *C.cef_response_t
}

type RefToCResponseT struct {
	p_response *CResponseT
}

type CResponseTAccessor interface {
	GetCResponseT() *CResponseT
	SetCResponseT(*CResponseT)
}

func (r RefToCResponseT) GetCResponseT() *CResponseT {
	return r.p_response
}

func (r *RefToCResponseT) SetCResponseT(p *CResponseT) {
	r.p_response = p
}

// Go type CResponseT wraps cef type *C.cef_response_t
func newCResponseT(p *C.cef_response_t) *CResponseT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T19072:")
	BaseAddRef(p)
	go_response := CResponseT{noCopy{}, p}
	runtime.SetFinalizer(&go_response, func(g *CResponseT) {
		Tracef(unsafe.Pointer(g.p_response), "T19076:")
		BaseRelease(g.p_response)
	})
	return &go_response
}

// *C.cef_response_t has refCounted interface
func (response *CResponseT) HasOneRef() bool {
	return BaseHasOneRef(response.p_response)
}

func (p *C.cef_response_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is read-only.
///
func (self *CResponseT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_response_is_read_only(self.p_response)

	ret = cRet == 1
	return ret
}

///
// Get the response error code. Returns ERR_NONE if there was no error.
///
func (self *CResponseT) GetError() (ret CErrorcodeT) {

	cRet := C.cefingo_response_get_error(self.p_response)

	ret = CErrorcodeT(cRet)
	return ret
}

///
// Set the response error code. This can be used by custom scheme handlers to
// return errors during initial request processing.
///
func (self *CResponseT) SetError(
	error CErrorcodeT,
) {

	C.cefingo_response_set_error(self.p_response, (C.cef_errorcode_t)(error))

}

///
// Get the response status code.
///
func (self *CResponseT) GetStatus() (ret bool) {

	cRet := C.cefingo_response_get_status(self.p_response)

	ret = cRet == 1
	return ret
}

///
// Set the response status code.
///
func (self *CResponseT) SetStatus(
	status int,
) {

	C.cefingo_response_set_status(self.p_response, (C.int)(status))

}

///
// Get the response status text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetStatusText() (ret string) {

	cRet := C.cefingo_response_get_status_text(self.p_response)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the response status text.
///
func (self *CResponseT) SetStatusText(
	statusText string,
) {
	c_statusText := create_cef_string(statusText)
	defer clear_cef_string(c_statusText)

	C.cefingo_response_set_status_text(self.p_response, (*C.cef_string_t)(c_statusText))

}

///
// Get the response mime type.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetMimeType() (ret string) {

	cRet := C.cefingo_response_get_mime_type(self.p_response)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the response mime type.
///
func (self *CResponseT) SetMimeType(
	mimeType string,
) {
	c_mimeType := create_cef_string(mimeType)
	defer clear_cef_string(c_mimeType)

	C.cefingo_response_set_mime_type(self.p_response, (*C.cef_string_t)(c_mimeType))

}

///
// Get the response charset.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetCharset() (ret string) {

	cRet := C.cefingo_response_get_charset(self.p_response)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the response charset.
///
func (self *CResponseT) SetCharset(
	charset string,
) {
	c_charset := create_cef_string(charset)
	defer clear_cef_string(c_charset)

	C.cefingo_response_set_charset(self.p_response, (*C.cef_string_t)(c_charset))

}

///
// Get the value for the specified response header field.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetHeaderByName(
	name string,
) (ret string) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	cRet := C.cefingo_response_get_header_by_name(self.p_response, (*C.cef_string_t)(c_name))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the header |name| to |value|. If |overwrite| is true (1) any existing
// values will be replaced with the new value. If |overwrite| is false (0) any
// existing values will not be overwritten.
///
func (self *CResponseT) SetHeaderByName(
	name string,
	value string,
	overwrite int,
) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	C.cefingo_response_set_header_by_name(self.p_response, (*C.cef_string_t)(c_name), (*C.cef_string_t)(c_value), (C.int)(overwrite))

}

///
// Get all response header fields.
///
func (self *CResponseT) GetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_response_get_header_map(self.p_response, (C.cef_string_multimap_t)(headerMap))

}

///
// Set all response header fields.
///
func (self *CResponseT) SetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_response_set_header_map(self.p_response, (C.cef_string_multimap_t)(headerMap))

}

///
// Get the resolved URL after redirects or changed as a result of HSTS.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetUrl() (ret string) {

	cRet := C.cefingo_response_get_url(self.p_response)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the resolved URL after redirects or changed as a result of HSTS.
///
func (self *CResponseT) SetUrl(
	url string,
) {
	c_url := create_cef_string(url)
	defer clear_cef_string(c_url)

	C.cefingo_response_set_url(self.p_response, (*C.cef_string_t)(c_url))

}

///
// Create a new cef_response_t object.
///
func ResponseCreate() (ret *CResponseT) {

	cRet := C.cef_response_create()

	ret = newCResponseT(cRet)
	return ret
}

// cef_response_filter_capi.h, include/capi/cef_response_filter_capi.h:104:3,

///
// Implement this structure to filter resource response content. The functions
// of this structure will be called on the browser process IO thread.
///

// Go type for cef_response_filter_t
type CResponseFilterT struct {
	noCopy            noCopy
	p_response_filter *C.cef_response_filter_t
}

type RefToCResponseFilterT struct {
	p_response_filter *CResponseFilterT
}

type CResponseFilterTAccessor interface {
	GetCResponseFilterT() *CResponseFilterT
	SetCResponseFilterT(*CResponseFilterT)
}

func (r RefToCResponseFilterT) GetCResponseFilterT() *CResponseFilterT {
	return r.p_response_filter
}

func (r *RefToCResponseFilterT) SetCResponseFilterT(p *CResponseFilterT) {
	r.p_response_filter = p
}

// Go type CResponseFilterT wraps cef type *C.cef_response_filter_t
func newCResponseFilterT(p *C.cef_response_filter_t) *CResponseFilterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T19395:")
	BaseAddRef(p)
	go_response_filter := CResponseFilterT{noCopy{}, p}
	runtime.SetFinalizer(&go_response_filter, func(g *CResponseFilterT) {
		Tracef(unsafe.Pointer(g.p_response_filter), "T19399:")
		BaseRelease(g.p_response_filter)
	})
	return &go_response_filter
}

// *C.cef_response_filter_t has refCounted interface
func (response_filter *CResponseFilterT) HasOneRef() bool {
	return BaseHasOneRef(response_filter.p_response_filter)
}

func (p *C.cef_response_filter_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Initialize the response filter. Will only be called a single time. The
// filter will not be installed if this function returns false (0).
///
type InitFilterHandler interface {
	InitFilter(
		self *CResponseFilterT,
	) (ret bool)
}

///
// Called to filter a chunk of data. Expected usage is as follows:
//
//  A. Read input data from |data_in| and set |data_in_read| to the number of
//     bytes that were read up to a maximum of |data_in_size|. |data_in| will
//     be NULL if |data_in_size| is zero.
//  B. Write filtered output data to |data_out| and set |data_out_written| to
//     the number of bytes that were written up to a maximum of
//     |data_out_size|. If no output data was written then all data must be
//     read from |data_in| (user must set |data_in_read| = |data_in_size|).
//  C. Return RESPONSE_FILTER_DONE if all output data was written or
//     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
//
// This function will be called repeatedly until the input buffer has been
// fully read (user sets |data_in_read| = |data_in_size|) and there is no more
// input data to filter (the resource response is complete). This function may
// then be called an additional time with an NULL input buffer if the user
// filled the output buffer (set |data_out_written| = |data_out_size|) and
// returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is
// still pending.
//
// Calls to this function will stop when one of the following conditions is
// met:
//
//  A. There is no more input data to filter (the resource response is
//     complete) and the user sets |data_out_written| = 0 or returns
//     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
//  B. The user returns RESPONSE_FILTER_ERROR to indicate an error.
//
// Do not keep a reference to the buffers passed to this function.
///
type FilterHandler interface {
	Filter(
		self *CResponseFilterT,
		data_in []byte,
		data_out []byte,
	) (ret CResponseFilterStatusT, data_in_read int64, data_out_written int64)
}

var response_filter_handlers = struct {
	init_filter_handler map[*C.cef_response_filter_t]InitFilterHandler
	filter_handler      map[*C.cef_response_filter_t]FilterHandler
}{
	map[*C.cef_response_filter_t]InitFilterHandler{},
	map[*C.cef_response_filter_t]FilterHandler{},
}

// AllocCResponseFilterT allocates CResponseFilterT and construct it
func AllocCResponseFilterT() *CResponseFilterT {
	up := c_calloc(1, C.sizeof_cefingo_response_filter_wrapper_t, "T19473:")
	cefp := C.cefingo_construct_response_filter((*C.cefingo_response_filter_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_response_filter_t itself in DeassocFunc,
		// or cef_response_filter_t is never GCed.
		Tracef(up, "T19479:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(response_filter_handlers.init_filter_handler, cefp)
		delete(response_filter_handlers.filter_handler, cefp)
	}))

	return newCResponseFilterT(cefp)
}

func (response_filter *CResponseFilterT) Bind(a interface{}) *CResponseFilterT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := response_filter.p_response_filter

	if h, ok := a.(InitFilterHandler); ok {
		response_filter_handlers.init_filter_handler[cp] = h
	}

	if h, ok := a.(FilterHandler); ok {
		response_filter_handlers.filter_handler[cp] = h
	}

	if accessor, ok := a.(CResponseFilterTAccessor); ok {
		accessor.SetCResponseFilterT(response_filter)
		Logf("T19518:")
	}

	return response_filter
}

// cef_scheme_capi.h, include/capi/cef_scheme_capi.h:78:3,

///
// Structure that manages custom scheme registrations.
///

// Go type for cef_scheme_registrar_t
type CSchemeRegistrarT struct {
	noCopy             noCopy
	p_scheme_registrar *C.cef_scheme_registrar_t
}

type RefToCSchemeRegistrarT struct {
	p_scheme_registrar *CSchemeRegistrarT
}

type CSchemeRegistrarTAccessor interface {
	GetCSchemeRegistrarT() *CSchemeRegistrarT
	SetCSchemeRegistrarT(*CSchemeRegistrarT)
}

func (r RefToCSchemeRegistrarT) GetCSchemeRegistrarT() *CSchemeRegistrarT {
	return r.p_scheme_registrar
}

func (r *RefToCSchemeRegistrarT) SetCSchemeRegistrarT(p *CSchemeRegistrarT) {
	r.p_scheme_registrar = p
}

// Go type CSchemeRegistrarT wraps cef type *C.cef_scheme_registrar_t
func newCSchemeRegistrarT(p *C.cef_scheme_registrar_t) *CSchemeRegistrarT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T19545:")
	go_scheme_registrar := CSchemeRegistrarT{noCopy{}, p}
	return &go_scheme_registrar
}

///
// Register a custom scheme. This function should not be called for the built-
// in HTTP, HTTPS, FILE, FTP, ABOUT and DATA schemes.
//
// See cef_scheme_options_t for possible values for |options|.
//
// This function may be called on any thread. It should only be called once
// per unique |scheme_name| value. If |scheme_name| is already registered or
// if an error occurs this function will return false (0).
///
func (self *CSchemeRegistrarT) AddCustomScheme(
	scheme_name string,
	options int,
) (ret bool) {
	c_scheme_name := create_cef_string(scheme_name)
	defer clear_cef_string(c_scheme_name)

	cRet := C.cefingo_scheme_registrar_add_custom_scheme(self.p_scheme_registrar, (*C.cef_string_t)(c_scheme_name), (C.int)(options))

	ret = cRet == 1
	return ret
}

///
// Structure that creates cef_resource_handler_t instances for handling scheme
// requests. The functions of this structure will always be called on the IO
// thread.
///

// Go type for cef_scheme_handler_factory_t
type CSchemeHandlerFactoryT struct {
	noCopy                   noCopy
	p_scheme_handler_factory *C.cef_scheme_handler_factory_t
}

type RefToCSchemeHandlerFactoryT struct {
	p_scheme_handler_factory *CSchemeHandlerFactoryT
}

type CSchemeHandlerFactoryTAccessor interface {
	GetCSchemeHandlerFactoryT() *CSchemeHandlerFactoryT
	SetCSchemeHandlerFactoryT(*CSchemeHandlerFactoryT)
}

func (r RefToCSchemeHandlerFactoryT) GetCSchemeHandlerFactoryT() *CSchemeHandlerFactoryT {
	return r.p_scheme_handler_factory
}

func (r *RefToCSchemeHandlerFactoryT) SetCSchemeHandlerFactoryT(p *CSchemeHandlerFactoryT) {
	r.p_scheme_handler_factory = p
}

// Go type CSchemeHandlerFactoryT wraps cef type *C.cef_scheme_handler_factory_t
func newCSchemeHandlerFactoryT(p *C.cef_scheme_handler_factory_t) *CSchemeHandlerFactoryT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T19608:")
	BaseAddRef(p)
	go_scheme_handler_factory := CSchemeHandlerFactoryT{noCopy{}, p}
	runtime.SetFinalizer(&go_scheme_handler_factory, func(g *CSchemeHandlerFactoryT) {
		Tracef(unsafe.Pointer(g.p_scheme_handler_factory), "T19612:")
		BaseRelease(g.p_scheme_handler_factory)
	})
	return &go_scheme_handler_factory
}

// *C.cef_scheme_handler_factory_t has refCounted interface
func (scheme_handler_factory *CSchemeHandlerFactoryT) HasOneRef() bool {
	return BaseHasOneRef(scheme_handler_factory.p_scheme_handler_factory)
}

func (p *C.cef_scheme_handler_factory_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Return a new resource handler instance to handle the request or an NULL
// reference to allow default handling of the request. |browser| and |frame|
// will be the browser window and frame respectively that originated the
// request or NULL if the request did not originate from a browser window (for
// example, if the request came from cef_urlrequest_t). The |request| object
// passed to this function cannot be modified.
///
type CreateHandler interface {
	Create(
		self *CSchemeHandlerFactoryT,
		browser *CBrowserT,
		frame *CFrameT,
		scheme_name string,
		request *CRequestT,
	) (ret *CResourceHandlerT)
}

var scheme_handler_factory_handlers = struct {
	create_handler map[*C.cef_scheme_handler_factory_t]CreateHandler
}{
	map[*C.cef_scheme_handler_factory_t]CreateHandler{},
}

// AllocCSchemeHandlerFactoryT allocates CSchemeHandlerFactoryT and construct it
func AllocCSchemeHandlerFactoryT() *CSchemeHandlerFactoryT {
	up := c_calloc(1, C.sizeof_cefingo_scheme_handler_factory_wrapper_t, "T19653:")
	cefp := C.cefingo_construct_scheme_handler_factory((*C.cefingo_scheme_handler_factory_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_scheme_handler_factory_t itself in DeassocFunc,
		// or cef_scheme_handler_factory_t is never GCed.
		Tracef(up, "T19659:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(scheme_handler_factory_handlers.create_handler, cefp)
	}))

	return newCSchemeHandlerFactoryT(cefp)
}

func (scheme_handler_factory *CSchemeHandlerFactoryT) Bind(a interface{}) *CSchemeHandlerFactoryT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := scheme_handler_factory.p_scheme_handler_factory

	if h, ok := a.(CreateHandler); ok {
		scheme_handler_factory_handlers.create_handler[cp] = h
	}

	if accessor, ok := a.(CSchemeHandlerFactoryTAccessor); ok {
		accessor.SetCSchemeHandlerFactoryT(scheme_handler_factory)
		Logf("T19693:")
	}

	return scheme_handler_factory
}

///
// Register a scheme handler factory with the global request context. An NULL
// |domain_name| value for a standard scheme will cause the factory to match all
// domain names. The |domain_name| value will be ignored for non-standard
// schemes. If |scheme_name| is a built-in scheme and no handler is returned by
// |factory| then the built-in scheme handler factory will be called. If
// |scheme_name| is a custom scheme then you must also implement the
// cef_app_t::on_register_custom_schemes() function in all processes. This
// function may be called multiple times to change or remove the factory that
// matches the specified |scheme_name| and optional |domain_name|. Returns false
// (0) if an error occurs. This function may be called on any thread in the
// browser process. Using this function is equivalent to calling cef_request_con
// text_t::cef_request_context_get_global_context()->register_scheme_handler_fac
// tory().
///
func RegisterSchemeHandlerFactory(
	scheme_name string,
	domain_name string,
	factory *CSchemeHandlerFactoryT,
) (ret bool) {
	c_scheme_name := create_cef_string(scheme_name)
	defer clear_cef_string(c_scheme_name)
	c_domain_name := create_cef_string(domain_name)
	defer clear_cef_string(c_domain_name)
	var goTmpfactory *C.cef_scheme_handler_factory_t
	if factory != nil {
		goTmpfactory = factory.p_scheme_handler_factory
		BaseAddRef(goTmpfactory)
	}

	cRet := C.cef_register_scheme_handler_factory((*C.cef_string_t)(c_scheme_name), (*C.cef_string_t)(c_domain_name), goTmpfactory)

	ret = cRet == 1
	return ret
}

///
// Clear all scheme handler factories registered with the global request
// context. Returns false (0) on error. This function may be called on any
// thread in the browser process. Using this function is equivalent to calling c
// ef_request_context_t::cef_request_context_get_global_context()->clear_scheme_
// handler_factories().
///
func ClearSchemeHandlerFactories() (ret bool) {

	cRet := C.cef_clear_scheme_handler_factories()

	ret = cRet == 1
	return ret
}

// cef_scroll_view_capi.h, include/capi/views/cef_scroll_view_capi.h:100:3,

///
// A ScrollView will show horizontal and/or vertical scrollbars when necessary
// based on the size of the attached content view. Methods must be called on the
// browser process UI thread unless otherwise indicated.
///

// Go type for cef_scroll_view_t
type CScrollViewT struct {
	noCopy        noCopy
	p_scroll_view *C.cef_scroll_view_t
}

type RefToCScrollViewT struct {
	p_scroll_view *CScrollViewT
}

type CScrollViewTAccessor interface {
	GetCScrollViewT() *CScrollViewT
	SetCScrollViewT(*CScrollViewT)
}

func (r RefToCScrollViewT) GetCScrollViewT() *CScrollViewT {
	return r.p_scroll_view
}

func (r *RefToCScrollViewT) SetCScrollViewT(p *CScrollViewT) {
	r.p_scroll_view = p
}

// Go type CScrollViewT wraps cef type *C.cef_scroll_view_t
func newCScrollViewT(p *C.cef_scroll_view_t) *CScrollViewT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T19776:")
	BaseAddRef(p)
	go_scroll_view := CScrollViewT{noCopy{}, p}
	runtime.SetFinalizer(&go_scroll_view, func(g *CScrollViewT) {
		Tracef(unsafe.Pointer(g.p_scroll_view), "T19780:")
		BaseRelease(g.p_scroll_view)
	})
	return &go_scroll_view
}

// *C.cef_scroll_view_t has refCounted interface
func (scroll_view *CScrollViewT) HasOneRef() bool {
	return BaseHasOneRef(scroll_view.p_scroll_view)
}

func (p *C.cef_scroll_view_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (scroll_view *CScrollViewT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(scroll_view.p_scroll_view))
	return newCViewT(p)
}

///
// Set the content View. The content View must have a specified size (e.g. via
// cef_view_t::SetBounds or cef_view_delegate_t::GetPreferredSize).
///
func (self *CScrollViewT) SetContentView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	C.cefingo_scroll_view_set_content_view(self.p_scroll_view, goTmpview)

}

///
// Returns the content View.
///
func (self *CScrollViewT) GetContentView() (ret *CViewT) {

	cRet := C.cefingo_scroll_view_get_content_view(self.p_scroll_view)

	ret = newCViewT(cRet)
	return ret
}

///
// Returns the visible region of the content View.
///
func (self *CScrollViewT) GetVisibleContentRect() (ret CRectT) {

	cRet := C.cefingo_scroll_view_get_visible_content_rect(self.p_scroll_view)

	ret = (CRectT)(cRet)
	return ret
}

///
// Returns true (1) if the horizontal scrollbar is currently showing.
///
func (self *CScrollViewT) HasHorizontalScrollbar() (ret bool) {

	cRet := C.cefingo_scroll_view_has_horizontal_scrollbar(self.p_scroll_view)

	ret = cRet == 1
	return ret
}

///
// Returns the height of the horizontal scrollbar.
///
func (self *CScrollViewT) GetHorizontalScrollbarHeight() (ret bool) {

	cRet := C.cefingo_scroll_view_get_horizontal_scrollbar_height(self.p_scroll_view)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the vertical scrollbar is currently showing.
///
func (self *CScrollViewT) HasVerticalScrollbar() (ret bool) {

	cRet := C.cefingo_scroll_view_has_vertical_scrollbar(self.p_scroll_view)

	ret = cRet == 1
	return ret
}

///
// Returns the width of the vertical scrollbar.
///
func (self *CScrollViewT) GetVerticalScrollbarWidth() (ret bool) {

	cRet := C.cefingo_scroll_view_get_vertical_scrollbar_width(self.p_scroll_view)

	ret = cRet == 1
	return ret
}

///
// Create a new ScrollView.
///
func ScrollViewCreate(
	delegate *CViewDelegateT,
) (ret *CScrollViewT) {
	var goTmpdelegate *C.cef_view_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_view_delegate
		BaseAddRef(goTmpdelegate)
	}

	cRet := C.cef_scroll_view_create(goTmpdelegate)

	ret = newCScrollViewT(cRet)
	return ret
}

// cef_ssl_info_capi.h, include/capi/cef_ssl_info_capi.h:71:3,

///
// Structure representing SSL information.
///

// Go type for cef_sslinfo_t
type CSslinfoT struct {
	noCopy    noCopy
	p_sslinfo *C.cef_sslinfo_t
}

type RefToCSslinfoT struct {
	p_sslinfo *CSslinfoT
}

type CSslinfoTAccessor interface {
	GetCSslinfoT() *CSslinfoT
	SetCSslinfoT(*CSslinfoT)
}

func (r RefToCSslinfoT) GetCSslinfoT() *CSslinfoT {
	return r.p_sslinfo
}

func (r *RefToCSslinfoT) SetCSslinfoT(p *CSslinfoT) {
	r.p_sslinfo = p
}

// Go type CSslinfoT wraps cef type *C.cef_sslinfo_t
func newCSslinfoT(p *C.cef_sslinfo_t) *CSslinfoT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T19948:")
	BaseAddRef(p)
	go_sslinfo := CSslinfoT{noCopy{}, p}
	runtime.SetFinalizer(&go_sslinfo, func(g *CSslinfoT) {
		Tracef(unsafe.Pointer(g.p_sslinfo), "T19952:")
		BaseRelease(g.p_sslinfo)
	})
	return &go_sslinfo
}

// *C.cef_sslinfo_t has refCounted interface
func (sslinfo *CSslinfoT) HasOneRef() bool {
	return BaseHasOneRef(sslinfo.p_sslinfo)
}

func (p *C.cef_sslinfo_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns a bitmask containing any and all problems verifying the server
// certificate.
///
func (self *CSslinfoT) GetCertStatus() (ret CCertStatusT) {

	cRet := C.cefingo_sslinfo_get_cert_status(self.p_sslinfo)

	ret = CCertStatusT(cRet)
	return ret
}

///
// Returns the X.509 certificate.
///
func (self *CSslinfoT) GetX509certificate() (ret *CX509certificateT) {

	cRet := C.cefingo_sslinfo_get_x509certificate(self.p_sslinfo)

	ret = newCX509certificateT(cRet)
	return ret
}

///
// Returns true (1) if the certificate status represents an error.
///
func IsCertStatusError(
	status CCertStatusT,
) (ret bool) {

	cRet := C.cef_is_cert_status_error((C.cef_cert_status_t)(status))

	ret = cRet == 1
	return ret
}

// cef_ssl_status_capi.h, include/capi/cef_ssl_status_capi.h:89:3,

///
// Structure representing the SSL information for a navigation entry.
///

// Go type for cef_sslstatus_t
type CSslstatusT struct {
	noCopy      noCopy
	p_sslstatus *C.cef_sslstatus_t
}

type RefToCSslstatusT struct {
	p_sslstatus *CSslstatusT
}

type CSslstatusTAccessor interface {
	GetCSslstatusT() *CSslstatusT
	SetCSslstatusT(*CSslstatusT)
}

func (r RefToCSslstatusT) GetCSslstatusT() *CSslstatusT {
	return r.p_sslstatus
}

func (r *RefToCSslstatusT) SetCSslstatusT(p *CSslstatusT) {
	r.p_sslstatus = p
}

// Go type CSslstatusT wraps cef type *C.cef_sslstatus_t
func newCSslstatusT(p *C.cef_sslstatus_t) *CSslstatusT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T20041:")
	BaseAddRef(p)
	go_sslstatus := CSslstatusT{noCopy{}, p}
	runtime.SetFinalizer(&go_sslstatus, func(g *CSslstatusT) {
		Tracef(unsafe.Pointer(g.p_sslstatus), "T20045:")
		BaseRelease(g.p_sslstatus)
	})
	return &go_sslstatus
}

// *C.cef_sslstatus_t has refCounted interface
func (sslstatus *CSslstatusT) HasOneRef() bool {
	return BaseHasOneRef(sslstatus.p_sslstatus)
}

func (p *C.cef_sslstatus_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if the status is related to a secure SSL/TLS connection.
///
func (self *CSslstatusT) IsSecureConnection() (ret bool) {

	cRet := C.cefingo_sslstatus_is_secure_connection(self.p_sslstatus)

	ret = cRet == 1
	return ret
}

///
// Returns a bitmask containing any and all problems verifying the server
// certificate.
///
func (self *CSslstatusT) GetCertStatus() (ret CCertStatusT) {

	cRet := C.cefingo_sslstatus_get_cert_status(self.p_sslstatus)

	ret = CCertStatusT(cRet)
	return ret
}

///
// Returns the SSL version used for the SSL connection.
///
func (self *CSslstatusT) GetSslversion() (ret CSslVersionT) {

	cRet := C.cefingo_sslstatus_get_sslversion(self.p_sslstatus)

	ret = CSslVersionT(cRet)
	return ret
}

///
// Returns a bitmask containing the page security content status.
///
func (self *CSslstatusT) GetContentStatus() (ret CSslContentStatusT) {

	cRet := C.cefingo_sslstatus_get_content_status(self.p_sslstatus)

	ret = CSslContentStatusT(cRet)
	return ret
}

///
// Returns the X.509 certificate.
///
func (self *CSslstatusT) GetX509certificate() (ret *CX509certificateT) {

	cRet := C.cefingo_sslstatus_get_x509certificate(self.p_sslstatus)

	ret = newCX509certificateT(cRet)
	return ret
}

// cef_stream_capi.h, include/capi/cef_stream_capi.h:91:3,

///
// Structure the client can implement to provide a custom stream reader. The
// functions of this structure may be called on any thread.
///

// Go type for cef_read_handler_t
type CReadHandlerT struct {
	noCopy         noCopy
	p_read_handler *C.cef_read_handler_t
}

type RefToCReadHandlerT struct {
	p_read_handler *CReadHandlerT
}

type CReadHandlerTAccessor interface {
	GetCReadHandlerT() *CReadHandlerT
	SetCReadHandlerT(*CReadHandlerT)
}

func (r RefToCReadHandlerT) GetCReadHandlerT() *CReadHandlerT {
	return r.p_read_handler
}

func (r *RefToCReadHandlerT) SetCReadHandlerT(p *CReadHandlerT) {
	r.p_read_handler = p
}

// Go type CReadHandlerT wraps cef type *C.cef_read_handler_t
func newCReadHandlerT(p *C.cef_read_handler_t) *CReadHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T20160:")
	BaseAddRef(p)
	go_read_handler := CReadHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_read_handler, func(g *CReadHandlerT) {
		Tracef(unsafe.Pointer(g.p_read_handler), "T20164:")
		BaseRelease(g.p_read_handler)
	})
	return &go_read_handler
}

// *C.cef_read_handler_t has refCounted interface
func (read_handler *CReadHandlerT) HasOneRef() bool {
	return BaseHasOneRef(read_handler.p_read_handler)
}

func (p *C.cef_read_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Read raw binary data.
///
type CReadHandlerTReadHandler interface {
	Read(
		self *CReadHandlerT,
		ptr unsafe.Pointer,
		size int64,
		n int64,
	) (ret int64)
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
type CReadHandlerTSeekHandler interface {
	Seek(
		self *CReadHandlerT,
		offset int64,
		whence int,
	) (ret bool)
}

///
// Return the current offset position.
///
type CReadHandlerTTellHandler interface {
	Tell(
		self *CReadHandlerT,
	) (ret int64)
}

///
// Return non-zero if at end of file.
///
type EofHandler interface {
	Eof(
		self *CReadHandlerT,
	) (ret bool)
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
type CReadHandlerTMayBlockHandler interface {
	MayBlock(
		self *CReadHandlerT,
	) (ret bool)
}

var read_handler_handlers = struct {
	read_handler      map[*C.cef_read_handler_t]CReadHandlerTReadHandler
	seek_handler      map[*C.cef_read_handler_t]CReadHandlerTSeekHandler
	tell_handler      map[*C.cef_read_handler_t]CReadHandlerTTellHandler
	eof_handler       map[*C.cef_read_handler_t]EofHandler
	may_block_handler map[*C.cef_read_handler_t]CReadHandlerTMayBlockHandler
}{
	map[*C.cef_read_handler_t]CReadHandlerTReadHandler{},
	map[*C.cef_read_handler_t]CReadHandlerTSeekHandler{},
	map[*C.cef_read_handler_t]CReadHandlerTTellHandler{},
	map[*C.cef_read_handler_t]EofHandler{},
	map[*C.cef_read_handler_t]CReadHandlerTMayBlockHandler{},
}

// AllocCReadHandlerT allocates CReadHandlerT and construct it
func AllocCReadHandlerT() *CReadHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_read_handler_wrapper_t, "T20248:")
	cefp := C.cefingo_construct_read_handler((*C.cefingo_read_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_read_handler_t itself in DeassocFunc,
		// or cef_read_handler_t is never GCed.
		Tracef(up, "T20254:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(read_handler_handlers.read_handler, cefp)
		delete(read_handler_handlers.seek_handler, cefp)
		delete(read_handler_handlers.tell_handler, cefp)
		delete(read_handler_handlers.eof_handler, cefp)
		delete(read_handler_handlers.may_block_handler, cefp)
	}))

	return newCReadHandlerT(cefp)
}

func (read_handler *CReadHandlerT) Bind(a interface{}) *CReadHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := read_handler.p_read_handler

	if h, ok := a.(CReadHandlerTReadHandler); ok {
		read_handler_handlers.read_handler[cp] = h
	}

	if h, ok := a.(CReadHandlerTSeekHandler); ok {
		read_handler_handlers.seek_handler[cp] = h
	}

	if h, ok := a.(CReadHandlerTTellHandler); ok {
		read_handler_handlers.tell_handler[cp] = h
	}

	if h, ok := a.(EofHandler); ok {
		read_handler_handlers.eof_handler[cp] = h
	}

	if h, ok := a.(CReadHandlerTMayBlockHandler); ok {
		read_handler_handlers.may_block_handler[cp] = h
	}

	if accessor, ok := a.(CReadHandlerTAccessor); ok {
		accessor.SetCReadHandlerT(read_handler)
		Logf("T20308:")
	}

	return read_handler
}

///
// Structure used to read data from a stream. The functions of this structure
// may be called on any thread.
///

// Go type for cef_stream_reader_t
type CStreamReaderT struct {
	noCopy          noCopy
	p_stream_reader *C.cef_stream_reader_t
}

type RefToCStreamReaderT struct {
	p_stream_reader *CStreamReaderT
}

type CStreamReaderTAccessor interface {
	GetCStreamReaderT() *CStreamReaderT
	SetCStreamReaderT(*CStreamReaderT)
}

func (r RefToCStreamReaderT) GetCStreamReaderT() *CStreamReaderT {
	return r.p_stream_reader
}

func (r *RefToCStreamReaderT) SetCStreamReaderT(p *CStreamReaderT) {
	r.p_stream_reader = p
}

// Go type CStreamReaderT wraps cef type *C.cef_stream_reader_t
func newCStreamReaderT(p *C.cef_stream_reader_t) *CStreamReaderT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T20334:")
	BaseAddRef(p)
	go_stream_reader := CStreamReaderT{noCopy{}, p}
	runtime.SetFinalizer(&go_stream_reader, func(g *CStreamReaderT) {
		Tracef(unsafe.Pointer(g.p_stream_reader), "T20338:")
		BaseRelease(g.p_stream_reader)
	})
	return &go_stream_reader
}

// *C.cef_stream_reader_t has refCounted interface
func (stream_reader *CStreamReaderT) HasOneRef() bool {
	return BaseHasOneRef(stream_reader.p_stream_reader)
}

func (p *C.cef_stream_reader_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Read raw binary data.
///
func (self *CStreamReaderT) Read(
	ptr unsafe.Pointer,
	size int64,
	n int64,
) (ret int64) {

	cRet := C.cefingo_stream_reader_read(self.p_stream_reader, ptr, (C.size_t)(size), (C.size_t)(n))

	ret = (int64)(cRet)
	return ret
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure.
///
func (self *CStreamReaderT) Seek(
	offset int64,
	whence int,
) (ret bool) {

	cRet := C.cefingo_stream_reader_seek(self.p_stream_reader, (C.int64)(offset), (C.int)(whence))

	ret = cRet == 1
	return ret
}

///
// Return the current offset position.
///
func (self *CStreamReaderT) Tell() (ret int64) {

	cRet := C.cefingo_stream_reader_tell(self.p_stream_reader)

	ret = (int64)(cRet)
	return ret
}

///
// Return non-zero if at end of file.
///
func (self *CStreamReaderT) Eof() (ret bool) {

	cRet := C.cefingo_stream_reader_eof(self.p_stream_reader)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this reader performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the reader from.
///
func (self *CStreamReaderT) MayBlock() (ret bool) {

	cRet := C.cefingo_stream_reader_may_block(self.p_stream_reader)

	ret = cRet == 1
	return ret
}

///
// Create a new cef_stream_reader_t object from a file.
///
func StreamReaderCreateForFile(
	fileName string,
) (ret *CStreamReaderT) {
	c_fileName := create_cef_string(fileName)
	defer clear_cef_string(c_fileName)

	cRet := C.cef_stream_reader_create_for_file((*C.cef_string_t)(c_fileName))

	ret = newCStreamReaderT(cRet)
	return ret
}

///
// Create a new cef_stream_reader_t object from data.
///
func StreamReaderCreateForData(
	data unsafe.Pointer,
	size int64,
) (ret *CStreamReaderT) {

	cRet := C.cef_stream_reader_create_for_data(data, (C.size_t)(size))

	ret = newCStreamReaderT(cRet)
	return ret
}

///
// Create a new cef_stream_reader_t object from a custom handler.
///
func StreamReaderCreateForHandler(
	handler *CReadHandlerT,
) (ret *CStreamReaderT) {
	var goTmphandler *C.cef_read_handler_t
	if handler != nil {
		goTmphandler = handler.p_read_handler
		BaseAddRef(goTmphandler)
	}

	cRet := C.cef_stream_reader_create_for_handler(goTmphandler)

	ret = newCStreamReaderT(cRet)
	return ret
}

///
// Structure the client can implement to provide a custom stream writer. The
// functions of this structure may be called on any thread.
///

// Go type for cef_write_handler_t
type CWriteHandlerT struct {
	noCopy          noCopy
	p_write_handler *C.cef_write_handler_t
}

type RefToCWriteHandlerT struct {
	p_write_handler *CWriteHandlerT
}

type CWriteHandlerTAccessor interface {
	GetCWriteHandlerT() *CWriteHandlerT
	SetCWriteHandlerT(*CWriteHandlerT)
}

func (r RefToCWriteHandlerT) GetCWriteHandlerT() *CWriteHandlerT {
	return r.p_write_handler
}

func (r *RefToCWriteHandlerT) SetCWriteHandlerT(p *CWriteHandlerT) {
	r.p_write_handler = p
}

// Go type CWriteHandlerT wraps cef type *C.cef_write_handler_t
func newCWriteHandlerT(p *C.cef_write_handler_t) *CWriteHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T20508:")
	BaseAddRef(p)
	go_write_handler := CWriteHandlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_write_handler, func(g *CWriteHandlerT) {
		Tracef(unsafe.Pointer(g.p_write_handler), "T20512:")
		BaseRelease(g.p_write_handler)
	})
	return &go_write_handler
}

// *C.cef_write_handler_t has refCounted interface
func (write_handler *CWriteHandlerT) HasOneRef() bool {
	return BaseHasOneRef(write_handler.p_write_handler)
}

func (p *C.cef_write_handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Write raw binary data.
///
type WriteHandler interface {
	Write(
		self *CWriteHandlerT,
		ptr unsafe.Pointer,
		size int64,
		n int64,
	) (ret int64)
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
type CWriteHandlerTSeekHandler interface {
	Seek(
		self *CWriteHandlerT,
		offset int64,
		whence int,
	) (ret bool)
}

///
// Return the current offset position.
///
type CWriteHandlerTTellHandler interface {
	Tell(
		self *CWriteHandlerT,
	) (ret int64)
}

///
// Flush the stream.
///
type FlushHandler interface {
	Flush(
		self *CWriteHandlerT,
	) (ret bool)
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
type CWriteHandlerTMayBlockHandler interface {
	MayBlock(
		self *CWriteHandlerT,
	) (ret bool)
}

var write_handler_handlers = struct {
	write_handler     map[*C.cef_write_handler_t]WriteHandler
	seek_handler      map[*C.cef_write_handler_t]CWriteHandlerTSeekHandler
	tell_handler      map[*C.cef_write_handler_t]CWriteHandlerTTellHandler
	flush_handler     map[*C.cef_write_handler_t]FlushHandler
	may_block_handler map[*C.cef_write_handler_t]CWriteHandlerTMayBlockHandler
}{
	map[*C.cef_write_handler_t]WriteHandler{},
	map[*C.cef_write_handler_t]CWriteHandlerTSeekHandler{},
	map[*C.cef_write_handler_t]CWriteHandlerTTellHandler{},
	map[*C.cef_write_handler_t]FlushHandler{},
	map[*C.cef_write_handler_t]CWriteHandlerTMayBlockHandler{},
}

// AllocCWriteHandlerT allocates CWriteHandlerT and construct it
func AllocCWriteHandlerT() *CWriteHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_write_handler_wrapper_t, "T20596:")
	cefp := C.cefingo_construct_write_handler((*C.cefingo_write_handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_write_handler_t itself in DeassocFunc,
		// or cef_write_handler_t is never GCed.
		Tracef(up, "T20602:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(write_handler_handlers.write_handler, cefp)
		delete(write_handler_handlers.seek_handler, cefp)
		delete(write_handler_handlers.tell_handler, cefp)
		delete(write_handler_handlers.flush_handler, cefp)
		delete(write_handler_handlers.may_block_handler, cefp)
	}))

	return newCWriteHandlerT(cefp)
}

func (write_handler *CWriteHandlerT) Bind(a interface{}) *CWriteHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := write_handler.p_write_handler

	if h, ok := a.(WriteHandler); ok {
		write_handler_handlers.write_handler[cp] = h
	}

	if h, ok := a.(CWriteHandlerTSeekHandler); ok {
		write_handler_handlers.seek_handler[cp] = h
	}

	if h, ok := a.(CWriteHandlerTTellHandler); ok {
		write_handler_handlers.tell_handler[cp] = h
	}

	if h, ok := a.(FlushHandler); ok {
		write_handler_handlers.flush_handler[cp] = h
	}

	if h, ok := a.(CWriteHandlerTMayBlockHandler); ok {
		write_handler_handlers.may_block_handler[cp] = h
	}

	if accessor, ok := a.(CWriteHandlerTAccessor); ok {
		accessor.SetCWriteHandlerT(write_handler)
		Logf("T20656:")
	}

	return write_handler
}

///
// Structure used to write data to a stream. The functions of this structure may
// be called on any thread.
///

// Go type for cef_stream_writer_t
type CStreamWriterT struct {
	noCopy          noCopy
	p_stream_writer *C.cef_stream_writer_t
}

type RefToCStreamWriterT struct {
	p_stream_writer *CStreamWriterT
}

type CStreamWriterTAccessor interface {
	GetCStreamWriterT() *CStreamWriterT
	SetCStreamWriterT(*CStreamWriterT)
}

func (r RefToCStreamWriterT) GetCStreamWriterT() *CStreamWriterT {
	return r.p_stream_writer
}

func (r *RefToCStreamWriterT) SetCStreamWriterT(p *CStreamWriterT) {
	r.p_stream_writer = p
}

// Go type CStreamWriterT wraps cef type *C.cef_stream_writer_t
func newCStreamWriterT(p *C.cef_stream_writer_t) *CStreamWriterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T20682:")
	BaseAddRef(p)
	go_stream_writer := CStreamWriterT{noCopy{}, p}
	runtime.SetFinalizer(&go_stream_writer, func(g *CStreamWriterT) {
		Tracef(unsafe.Pointer(g.p_stream_writer), "T20686:")
		BaseRelease(g.p_stream_writer)
	})
	return &go_stream_writer
}

// *C.cef_stream_writer_t has refCounted interface
func (stream_writer *CStreamWriterT) HasOneRef() bool {
	return BaseHasOneRef(stream_writer.p_stream_writer)
}

func (p *C.cef_stream_writer_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Write raw binary data.
///
func (self *CStreamWriterT) Write(
	ptr unsafe.Pointer,
	size int64,
	n int64,
) (ret int64) {

	cRet := C.cefingo_stream_writer_write(self.p_stream_writer, ptr, (C.size_t)(size), (C.size_t)(n))

	ret = (int64)(cRet)
	return ret
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure.
///
func (self *CStreamWriterT) Seek(
	offset int64,
	whence int,
) (ret bool) {

	cRet := C.cefingo_stream_writer_seek(self.p_stream_writer, (C.int64)(offset), (C.int)(whence))

	ret = cRet == 1
	return ret
}

///
// Return the current offset position.
///
func (self *CStreamWriterT) Tell() (ret int64) {

	cRet := C.cefingo_stream_writer_tell(self.p_stream_writer)

	ret = (int64)(cRet)
	return ret
}

///
// Flush the stream.
///
func (self *CStreamWriterT) Flush() (ret bool) {

	cRet := C.cefingo_stream_writer_flush(self.p_stream_writer)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this writer performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the writer from.
///
func (self *CStreamWriterT) MayBlock() (ret bool) {

	cRet := C.cefingo_stream_writer_may_block(self.p_stream_writer)

	ret = cRet == 1
	return ret
}

///
// Create a new cef_stream_writer_t object for a file.
///
func StreamWriterCreateForFile(
	fileName string,
) (ret *CStreamWriterT) {
	c_fileName := create_cef_string(fileName)
	defer clear_cef_string(c_fileName)

	cRet := C.cef_stream_writer_create_for_file((*C.cef_string_t)(c_fileName))

	ret = newCStreamWriterT(cRet)
	return ret
}

///
// Create a new cef_stream_writer_t object for a custom handler.
///
func StreamWriterCreateForHandler(
	handler *CWriteHandlerT,
) (ret *CStreamWriterT) {
	var goTmphandler *C.cef_write_handler_t
	if handler != nil {
		goTmphandler = handler.p_write_handler
		BaseAddRef(goTmphandler)
	}

	cRet := C.cef_stream_writer_create_for_handler(goTmphandler)

	ret = newCStreamWriterT(cRet)
	return ret
}

// cef_string_visitor_capi.h, include/capi/cef_string_visitor_capi.h:63:3,

///
// Implement this structure to receive string values asynchronously.
///

// Go type for cef_string_visitor_t
type CStringVisitorT struct {
	noCopy           noCopy
	p_string_visitor *C.cef_string_visitor_t
}

type RefToCStringVisitorT struct {
	p_string_visitor *CStringVisitorT
}

type CStringVisitorTAccessor interface {
	GetCStringVisitorT() *CStringVisitorT
	SetCStringVisitorT(*CStringVisitorT)
}

func (r RefToCStringVisitorT) GetCStringVisitorT() *CStringVisitorT {
	return r.p_string_visitor
}

func (r *RefToCStringVisitorT) SetCStringVisitorT(p *CStringVisitorT) {
	r.p_string_visitor = p
}

// Go type CStringVisitorT wraps cef type *C.cef_string_visitor_t
func newCStringVisitorT(p *C.cef_string_visitor_t) *CStringVisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T20842:")
	BaseAddRef(p)
	go_string_visitor := CStringVisitorT{noCopy{}, p}
	runtime.SetFinalizer(&go_string_visitor, func(g *CStringVisitorT) {
		Tracef(unsafe.Pointer(g.p_string_visitor), "T20846:")
		BaseRelease(g.p_string_visitor)
	})
	return &go_string_visitor
}

// *C.cef_string_visitor_t has refCounted interface
func (string_visitor *CStringVisitorT) HasOneRef() bool {
	return BaseHasOneRef(string_visitor.p_string_visitor)
}

func (p *C.cef_string_visitor_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be executed.
///
type CStringVisitorTVisitHandler interface {
	Visit(
		self *CStringVisitorT,
		cstring string,
	)
}

var string_visitor_handlers = struct {
	visit_handler map[*C.cef_string_visitor_t]CStringVisitorTVisitHandler
}{
	map[*C.cef_string_visitor_t]CStringVisitorTVisitHandler{},
}

// AllocCStringVisitorT allocates CStringVisitorT and construct it
func AllocCStringVisitorT() *CStringVisitorT {
	up := c_calloc(1, C.sizeof_cefingo_string_visitor_wrapper_t, "T20879:")
	cefp := C.cefingo_construct_string_visitor((*C.cefingo_string_visitor_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_string_visitor_t itself in DeassocFunc,
		// or cef_string_visitor_t is never GCed.
		Tracef(up, "T20885:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(string_visitor_handlers.visit_handler, cefp)
	}))

	return newCStringVisitorT(cefp)
}

func (string_visitor *CStringVisitorT) Bind(a interface{}) *CStringVisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := string_visitor.p_string_visitor

	if h, ok := a.(CStringVisitorTVisitHandler); ok {
		string_visitor_handlers.visit_handler[cp] = h
	}

	if accessor, ok := a.(CStringVisitorTAccessor); ok {
		accessor.SetCStringVisitorT(string_visitor)
		Logf("T20919:")
	}

	return string_visitor
}

// cef_task_capi.h, include/capi/cef_task_capi.h:67:3,

///
// Implement this structure for asynchronous task execution. If the task is
// posted successfully and if the associated message loop is still running then
// the execute() function will be called on the target thread. If the task fails
// to post then the task object may be destroyed on the source thread instead of
// the target thread. For this reason be cautious when performing work in the
// task object destructor.
///

// Go type for cef_task_t
type CTaskT struct {
	noCopy noCopy
	p_task *C.cef_task_t
}

type RefToCTaskT struct {
	p_task *CTaskT
}

type CTaskTAccessor interface {
	GetCTaskT() *CTaskT
	SetCTaskT(*CTaskT)
}

func (r RefToCTaskT) GetCTaskT() *CTaskT {
	return r.p_task
}

func (r *RefToCTaskT) SetCTaskT(p *CTaskT) {
	r.p_task = p
}

// Go type CTaskT wraps cef type *C.cef_task_t
func newCTaskT(p *C.cef_task_t) *CTaskT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T20951:")
	BaseAddRef(p)
	go_task := CTaskT{noCopy{}, p}
	runtime.SetFinalizer(&go_task, func(g *CTaskT) {
		Tracef(unsafe.Pointer(g.p_task), "T20955:")
		BaseRelease(g.p_task)
	})
	return &go_task
}

// *C.cef_task_t has refCounted interface
func (task *CTaskT) HasOneRef() bool {
	return BaseHasOneRef(task.p_task)
}

func (p *C.cef_task_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be executed on the target thread.
///
type CTaskTExecuteHandler interface {
	Execute(
		self *CTaskT,
	)
}

var task_handlers = struct {
	execute_handler map[*C.cef_task_t]CTaskTExecuteHandler
}{
	map[*C.cef_task_t]CTaskTExecuteHandler{},
}

// AllocCTaskT allocates CTaskT and construct it
func AllocCTaskT() *CTaskT {
	up := c_calloc(1, C.sizeof_cefingo_task_wrapper_t, "T20987:")
	cefp := C.cefingo_construct_task((*C.cefingo_task_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_task_t itself in DeassocFunc,
		// or cef_task_t is never GCed.
		Tracef(up, "T20993:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(task_handlers.execute_handler, cefp)
	}))

	return newCTaskT(cefp)
}

func (task *CTaskT) Bind(a interface{}) *CTaskT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := task.p_task

	if h, ok := a.(CTaskTExecuteHandler); ok {
		task_handlers.execute_handler[cp] = h
	}

	if accessor, ok := a.(CTaskTAccessor); ok {
		accessor.SetCTaskT(task)
		Logf("T21027:")
	}

	return task
}

///
// Structure that asynchronously executes tasks on the associated thread. It is
// safe to call the functions of this structure on any thread.
//
// CEF maintains multiple internal threads that are used for handling different
// types of tasks in different processes. The cef_thread_id_t definitions in
// cef_types.h list the common CEF threads. Task runners are also available for
// other CEF threads as appropriate (for example, V8 WebWorker threads).
///

// Go type for cef_task_runner_t
type CTaskRunnerT struct {
	noCopy        noCopy
	p_task_runner *C.cef_task_runner_t
}

type RefToCTaskRunnerT struct {
	p_task_runner *CTaskRunnerT
}

type CTaskRunnerTAccessor interface {
	GetCTaskRunnerT() *CTaskRunnerT
	SetCTaskRunnerT(*CTaskRunnerT)
}

func (r RefToCTaskRunnerT) GetCTaskRunnerT() *CTaskRunnerT {
	return r.p_task_runner
}

func (r *RefToCTaskRunnerT) SetCTaskRunnerT(p *CTaskRunnerT) {
	r.p_task_runner = p
}

// Go type CTaskRunnerT wraps cef type *C.cef_task_runner_t
func newCTaskRunnerT(p *C.cef_task_runner_t) *CTaskRunnerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T21058:")
	BaseAddRef(p)
	go_task_runner := CTaskRunnerT{noCopy{}, p}
	runtime.SetFinalizer(&go_task_runner, func(g *CTaskRunnerT) {
		Tracef(unsafe.Pointer(g.p_task_runner), "T21062:")
		BaseRelease(g.p_task_runner)
	})
	return &go_task_runner
}

// *C.cef_task_runner_t has refCounted interface
func (task_runner *CTaskRunnerT) HasOneRef() bool {
	return BaseHasOneRef(task_runner.p_task_runner)
}

func (p *C.cef_task_runner_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is pointing to the same task runner as
// |that| object.
///
func (self *CTaskRunnerT) IsSame(
	that *CTaskRunnerT,
) (ret bool) {
	var goTmpthat *C.cef_task_runner_t
	if that != nil {
		goTmpthat = that.p_task_runner
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_task_runner_is_same(self.p_task_runner, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this task runner belongs to the current thread.
///
func (self *CTaskRunnerT) BelongsToCurrentThread() (ret bool) {

	cRet := C.cefingo_task_runner_belongs_to_current_thread(self.p_task_runner)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this task runner is for the specified CEF thread.
///
func (self *CTaskRunnerT) BelongsToThread(
	threadId CThreadIdT,
) (ret bool) {

	cRet := C.cefingo_task_runner_belongs_to_thread(self.p_task_runner, (C.cef_thread_id_t)(threadId))

	ret = cRet == 1
	return ret
}

///
// Post a task for execution on the thread associated with this task runner.
// Execution will occur asynchronously.
///
func (self *CTaskRunnerT) PostTask(
	task *CTaskT,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		goTmptask = task.p_task
		BaseAddRef(goTmptask)
	}

	cRet := C.cefingo_task_runner_post_task(self.p_task_runner, goTmptask)

	ret = cRet == 1
	return ret
}

///
// Post a task for delayed execution on the thread associated with this task
// runner. Execution will occur asynchronously. Delayed tasks are not
// supported on V8 WebWorker threads and will be executed without the
// specified delay.
///
func (self *CTaskRunnerT) PostDelayedTask(
	task *CTaskT,
	delay_ms int64,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		goTmptask = task.p_task
		BaseAddRef(goTmptask)
	}

	cRet := C.cefingo_task_runner_post_delayed_task(self.p_task_runner, goTmptask, (C.int64)(delay_ms))

	ret = cRet == 1
	return ret
}

///
// Returns the task runner for the current thread. Only CEF threads will have
// task runners. An NULL reference will be returned if this function is called
// on an invalid thread.
///
func TaskRunnerGetForCurrentThread() (ret *CTaskRunnerT) {

	cRet := C.cef_task_runner_get_for_current_thread()

	ret = newCTaskRunnerT(cRet)
	return ret
}

///
// Returns the task runner for the specified CEF thread.
///
func TaskRunnerGetForThread(
	threadId CThreadIdT,
) (ret *CTaskRunnerT) {

	cRet := C.cef_task_runner_get_for_thread((C.cef_thread_id_t)(threadId))

	ret = newCTaskRunnerT(cRet)
	return ret
}

///
// Returns true (1) if called on the specified thread. Equivalent to using
// cef_task_runner_t::GetForThread(threadId)->belongs_to_current_thread().
///
func CurrentlyOn(
	threadId CThreadIdT,
) (ret bool) {

	cRet := C.cef_currently_on((C.cef_thread_id_t)(threadId))

	ret = cRet == 1
	return ret
}

///
// Post a task for execution on the specified thread. Equivalent to using
// cef_task_runner_t::GetForThread(threadId)->PostTask(task).
///
func PostTask(
	threadId CThreadIdT,
	task *CTaskT,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		goTmptask = task.p_task
		BaseAddRef(goTmptask)
	}

	cRet := C.cef_post_task((C.cef_thread_id_t)(threadId), goTmptask)

	ret = cRet == 1
	return ret
}

///
// Post a task for delayed execution on the specified thread. Equivalent to
// using cef_task_runner_t::GetForThread(threadId)->PostDelayedTask(task,
// delay_ms).
///
func PostDelayedTask(
	threadId CThreadIdT,
	task *CTaskT,
	delay_ms int64,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		goTmptask = task.p_task
		BaseAddRef(goTmptask)
	}

	cRet := C.cef_post_delayed_task((C.cef_thread_id_t)(threadId), goTmptask, (C.int64)(delay_ms))

	ret = cRet == 1
	return ret
}

// cef_textfield_capi.h, include/capi/views/cef_textfield_capi.h:264:3,

///
// A Textfield supports editing of text. This control is custom rendered with no
// platform-specific code. Methods must be called on the browser process UI
// thread unless otherwise indicated.
///

// Go type for cef_textfield_t
type CTextfieldT struct {
	noCopy      noCopy
	p_textfield *C.cef_textfield_t
}

type RefToCTextfieldT struct {
	p_textfield *CTextfieldT
}

type CTextfieldTAccessor interface {
	GetCTextfieldT() *CTextfieldT
	SetCTextfieldT(*CTextfieldT)
}

func (r RefToCTextfieldT) GetCTextfieldT() *CTextfieldT {
	return r.p_textfield
}

func (r *RefToCTextfieldT) SetCTextfieldT(p *CTextfieldT) {
	r.p_textfield = p
}

// Go type CTextfieldT wraps cef type *C.cef_textfield_t
func newCTextfieldT(p *C.cef_textfield_t) *CTextfieldT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T21290:")
	BaseAddRef(p)
	go_textfield := CTextfieldT{noCopy{}, p}
	runtime.SetFinalizer(&go_textfield, func(g *CTextfieldT) {
		Tracef(unsafe.Pointer(g.p_textfield), "T21294:")
		BaseRelease(g.p_textfield)
	})
	return &go_textfield
}

// *C.cef_textfield_t has refCounted interface
func (textfield *CTextfieldT) HasOneRef() bool {
	return BaseHasOneRef(textfield.p_textfield)
}

func (p *C.cef_textfield_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (textfield *CTextfieldT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(textfield.p_textfield))
	return newCViewT(p)
}

///
// Sets whether the text will be displayed as asterisks.
///
func (self *CTextfieldT) SetPasswordInput(
	password_input int,
) {

	C.cefingo_textfield_set_password_input(self.p_textfield, (C.int)(password_input))

}

///
// Returns true (1) if the text will be displayed as asterisks.
///
func (self *CTextfieldT) IsPasswordInput() (ret bool) {

	cRet := C.cefingo_textfield_is_password_input(self.p_textfield)

	ret = cRet == 1
	return ret
}

///
// Sets whether the text will read-only.
///
func (self *CTextfieldT) SetReadOnly(
	read_only int,
) {

	C.cefingo_textfield_set_read_only(self.p_textfield, (C.int)(read_only))

}

///
// Returns true (1) if the text is read-only.
///
func (self *CTextfieldT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_textfield_is_read_only(self.p_textfield)

	ret = cRet == 1
	return ret
}

///
// Returns the currently displayed text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CTextfieldT) GetText() (ret string) {

	cRet := C.cefingo_textfield_get_text(self.p_textfield)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the contents to |text|. The cursor will be moved to end of the text if
// the current position is outside of the text range.
///
func (self *CTextfieldT) SetText(
	text string,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_textfield_set_text(self.p_textfield, (*C.cef_string_t)(c_text))

}

///
// Appends |text| to the previously-existing text.
///
func (self *CTextfieldT) AppendText(
	text string,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_textfield_append_text(self.p_textfield, (*C.cef_string_t)(c_text))

}

///
// Inserts |text| at the current cursor position replacing any selected text.
///
func (self *CTextfieldT) InsertOrReplaceText(
	text string,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_textfield_insert_or_replace_text(self.p_textfield, (*C.cef_string_t)(c_text))

}

///
// Returns true (1) if there is any selected text.
///
func (self *CTextfieldT) HasSelection() (ret bool) {

	cRet := C.cefingo_textfield_has_selection(self.p_textfield)

	ret = cRet == 1
	return ret
}

///
// Returns the currently selected text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CTextfieldT) GetSelectedText() (ret string) {

	cRet := C.cefingo_textfield_get_selected_text(self.p_textfield)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Selects all text. If |reversed| is true (1) the range will end at the
// logical beginning of the text; this generally shows the leading portion of
// text that overflows its display area.
///
func (self *CTextfieldT) SelectAll(
	reversed int,
) {

	C.cefingo_textfield_select_all(self.p_textfield, (C.int)(reversed))

}

///
// Clears the text selection and sets the caret to the end.
///
func (self *CTextfieldT) ClearSelection() {

	C.cefingo_textfield_clear_selection(self.p_textfield)

}

///
// Returns the selected logical text range.
///
func (self *CTextfieldT) GetSelectedRange() (ret CRangeT) {

	cRet := C.cefingo_textfield_get_selected_range(self.p_textfield)

	ret = (CRangeT)(cRet)
	return ret
}

///
// Selects the specified logical text range.
///
func (self *CTextfieldT) SelectRange(
	crange *CRangeT,
) {

	C.cefingo_textfield_select_range(self.p_textfield, (*C.cef_range_t)(crange))

}

///
// Returns the current cursor position.
///
func (self *CTextfieldT) GetCursorPosition() (ret int64) {

	cRet := C.cefingo_textfield_get_cursor_position(self.p_textfield)

	ret = (int64)(cRet)
	return ret
}

///
// Sets the text color.
///
func (self *CTextfieldT) SetTextColor(
	color CColorT,
) {

	C.cefingo_textfield_set_text_color(self.p_textfield, (C.cef_color_t)(color))

}

///
// Returns the text color.
///
func (self *CTextfieldT) GetTextColor() (ret CColorT) {

	cRet := C.cefingo_textfield_get_text_color(self.p_textfield)

	ret = (CColorT)(cRet)
	return ret
}

///
// Sets the selection text color.
///
func (self *CTextfieldT) SetSelectionTextColor(
	color CColorT,
) {

	C.cefingo_textfield_set_selection_text_color(self.p_textfield, (C.cef_color_t)(color))

}

///
// Returns the selection text color.
///
func (self *CTextfieldT) GetSelectionTextColor() (ret CColorT) {

	cRet := C.cefingo_textfield_get_selection_text_color(self.p_textfield)

	ret = (CColorT)(cRet)
	return ret
}

///
// Sets the selection background color.
///
func (self *CTextfieldT) SetSelectionBackgroundColor(
	color CColorT,
) {

	C.cefingo_textfield_set_selection_background_color(self.p_textfield, (C.cef_color_t)(color))

}

///
// Returns the selection background color.
///
func (self *CTextfieldT) GetSelectionBackgroundColor() (ret CColorT) {

	cRet := C.cefingo_textfield_get_selection_background_color(self.p_textfield)

	ret = (CColorT)(cRet)
	return ret
}

///
// Sets the font list. The format is &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;,
// where: - FONT_FAMILY_LIST is a comma-separated list of font family names, -
// STYLES is an optional space-separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CTextfieldT) SetFontList(
	font_list string,
) {
	c_font_list := create_cef_string(font_list)
	defer clear_cef_string(c_font_list)

	C.cefingo_textfield_set_font_list(self.p_textfield, (*C.cef_string_t)(c_font_list))

}

///
// Applies |color| to the specified |range| without changing the default
// color. If |range| is NULL the color will be set on the complete text
// contents.
///
func (self *CTextfieldT) ApplyTextColor(
	color CColorT,
	crange *CRangeT,
) {

	C.cefingo_textfield_apply_text_color(self.p_textfield, (C.cef_color_t)(color), (*C.cef_range_t)(crange))

}

///
// Applies |style| to the specified |range| without changing the default
// style. If |add| is true (1) the style will be added, otherwise the style
// will be removed. If |range| is NULL the style will be set on the complete
// text contents.
///
func (self *CTextfieldT) ApplyTextStyle(
	style CTextStyleT,
	add int,
	crange *CRangeT,
) {

	C.cefingo_textfield_apply_text_style(self.p_textfield, (C.cef_text_style_t)(style), (C.int)(add), (*C.cef_range_t)(crange))

}

///
// Returns true (1) if the action associated with the specified command id is
// enabled. See additional comments on execute_command().
///
func (self *CTextfieldT) IsCommandEnabled(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_textfield_is_command_enabled(self.p_textfield, (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Performs the action associated with the specified command id. Valid values
// include IDS_APP_UNDO, IDS_APP_REDO, IDS_APP_CUT, IDS_APP_COPY,
// IDS_APP_PASTE, IDS_APP_DELETE, IDS_APP_SELECT_ALL, IDS_DELETE_* and
// IDS_MOVE_*. See include/cef_pack_strings.h for definitions.
///
func (self *CTextfieldT) ExecuteCommand(
	command_id int,
) {

	C.cefingo_textfield_execute_command(self.p_textfield, (C.int)(command_id))

}

///
// Clears Edit history.
///
func (self *CTextfieldT) ClearEditHistory() {

	C.cefingo_textfield_clear_edit_history(self.p_textfield)

}

///
// Sets the placeholder text that will be displayed when the Textfield is
// NULL.
///
func (self *CTextfieldT) SetPlaceholderText(
	text string,
) {
	c_text := create_cef_string(text)
	defer clear_cef_string(c_text)

	C.cefingo_textfield_set_placeholder_text(self.p_textfield, (*C.cef_string_t)(c_text))

}

///
// Returns the placeholder text that will be displayed when the Textfield is
// NULL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CTextfieldT) GetPlaceholderText() (ret string) {

	cRet := C.cefingo_textfield_get_placeholder_text(self.p_textfield)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the placeholder text color.
///
func (self *CTextfieldT) SetPlaceholderTextColor(
	color CColorT,
) {

	C.cefingo_textfield_set_placeholder_text_color(self.p_textfield, (C.cef_color_t)(color))

}

///
// Set the accessible name that will be exposed to assistive technology (AT).
///
func (self *CTextfieldT) SetAccessibleName(
	name string,
) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)

	C.cefingo_textfield_set_accessible_name(self.p_textfield, (*C.cef_string_t)(c_name))

}

///
// Create a new Textfield.
///
func TextfieldCreate(
	delegate *CTextfieldDelegateT,
) (ret *CTextfieldT) {
	var goTmpdelegate *C.cef_textfield_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_textfield_delegate
		BaseAddRef(goTmpdelegate)
	}

	cRet := C.cef_textfield_create(goTmpdelegate)

	ret = newCTextfieldT(cRet)
	return ret
}

// cef_textfield_delegate_capi.h, include/capi/views/cef_textfield_delegate_capi.h:77:3,

///
// Implement this structure to handle Textfield events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_textfield_delegate_t
type CTextfieldDelegateT struct {
	noCopy               noCopy
	p_textfield_delegate *C.cef_textfield_delegate_t
}

type RefToCTextfieldDelegateT struct {
	p_textfield_delegate *CTextfieldDelegateT
}

type CTextfieldDelegateTAccessor interface {
	GetCTextfieldDelegateT() *CTextfieldDelegateT
	SetCTextfieldDelegateT(*CTextfieldDelegateT)
}

func (r RefToCTextfieldDelegateT) GetCTextfieldDelegateT() *CTextfieldDelegateT {
	return r.p_textfield_delegate
}

func (r *RefToCTextfieldDelegateT) SetCTextfieldDelegateT(p *CTextfieldDelegateT) {
	r.p_textfield_delegate = p
}

// Go type CTextfieldDelegateT wraps cef type *C.cef_textfield_delegate_t
func newCTextfieldDelegateT(p *C.cef_textfield_delegate_t) *CTextfieldDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T21802:")
	BaseAddRef(p)
	go_textfield_delegate := CTextfieldDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_textfield_delegate, func(g *CTextfieldDelegateT) {
		Tracef(unsafe.Pointer(g.p_textfield_delegate), "T21806:")
		BaseRelease(g.p_textfield_delegate)
	})
	return &go_textfield_delegate
}

// *C.cef_textfield_delegate_t has refCounted interface
func (textfield_delegate *CTextfieldDelegateT) HasOneRef() bool {
	return BaseHasOneRef(textfield_delegate.p_textfield_delegate)
}

func (p *C.cef_textfield_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (textfield_delegate *CTextfieldDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(textfield_delegate.p_textfield_delegate))
	return newCViewDelegateT(p)
}

///
// Called when |textfield| recieves a keyboard event. |event| contains
// information about the keyboard event. Return true (1) if the keyboard event
// was handled or false (0) otherwise for default handling.
///
type CTextfieldDelegateTOnKeyEventHandler interface {
	OnKeyEvent(
		self *CTextfieldDelegateT,
		textfield *CTextfieldT,
		event *CKeyEventT,
	) (ret bool)
}

///
// Called after performing a user action that may change |textfield|.
///
type OnAfterUserActionHandler interface {
	OnAfterUserAction(
		self *CTextfieldDelegateT,
		textfield *CTextfieldT,
	)
}

var textfield_delegate_handlers = struct {
	on_key_event_handler           map[*C.cef_textfield_delegate_t]CTextfieldDelegateTOnKeyEventHandler
	on_after_user_action_handler   map[*C.cef_textfield_delegate_t]OnAfterUserActionHandler
	get_preferred_size_handler     map[*C.cef_textfield_delegate_t]GetPreferredSizeHandler
	get_minimum_size_handler       map[*C.cef_textfield_delegate_t]GetMinimumSizeHandler
	get_maximum_size_handler       map[*C.cef_textfield_delegate_t]GetMaximumSizeHandler
	get_height_for_width_handler   map[*C.cef_textfield_delegate_t]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*C.cef_textfield_delegate_t]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*C.cef_textfield_delegate_t]OnChildViewChangedHandler
	on_focus_handler               map[*C.cef_textfield_delegate_t]OnFocusHandler
	on_blur_handler                map[*C.cef_textfield_delegate_t]OnBlurHandler
}{
	map[*C.cef_textfield_delegate_t]CTextfieldDelegateTOnKeyEventHandler{},
	map[*C.cef_textfield_delegate_t]OnAfterUserActionHandler{},
	map[*C.cef_textfield_delegate_t]GetPreferredSizeHandler{},
	map[*C.cef_textfield_delegate_t]GetMinimumSizeHandler{},
	map[*C.cef_textfield_delegate_t]GetMaximumSizeHandler{},
	map[*C.cef_textfield_delegate_t]GetHeightForWidthHandler{},
	map[*C.cef_textfield_delegate_t]OnParentViewChangedHandler{},
	map[*C.cef_textfield_delegate_t]OnChildViewChangedHandler{},
	map[*C.cef_textfield_delegate_t]OnFocusHandler{},
	map[*C.cef_textfield_delegate_t]OnBlurHandler{},
}

// AllocCTextfieldDelegateT allocates CTextfieldDelegateT and construct it
func AllocCTextfieldDelegateT() *CTextfieldDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_textfield_delegate_wrapper_t, "T21875:")
	cefp := C.cefingo_construct_textfield_delegate((*C.cefingo_textfield_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_textfield_delegate_t itself in DeassocFunc,
		// or cef_textfield_delegate_t is never GCed.
		Tracef(up, "T21881:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(textfield_delegate_handlers.on_key_event_handler, cefp)
		delete(textfield_delegate_handlers.on_after_user_action_handler, cefp)
		delete(textfield_delegate_handlers.get_preferred_size_handler, cefp)
		delete(textfield_delegate_handlers.get_minimum_size_handler, cefp)
		delete(textfield_delegate_handlers.get_maximum_size_handler, cefp)
		delete(textfield_delegate_handlers.get_height_for_width_handler, cefp)
		delete(textfield_delegate_handlers.on_parent_view_changed_handler, cefp)
		delete(textfield_delegate_handlers.on_child_view_changed_handler, cefp)
		delete(textfield_delegate_handlers.on_focus_handler, cefp)
		delete(textfield_delegate_handlers.on_blur_handler, cefp)
	}))

	return newCTextfieldDelegateT(cefp)
}

func (textfield_delegate *CTextfieldDelegateT) Bind(a interface{}) *CTextfieldDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := textfield_delegate.p_textfield_delegate

	if h, ok := a.(CTextfieldDelegateTOnKeyEventHandler); ok {
		textfield_delegate_handlers.on_key_event_handler[cp] = h
	}

	if h, ok := a.(OnAfterUserActionHandler); ok {
		textfield_delegate_handlers.on_after_user_action_handler[cp] = h
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		textfield_delegate_handlers.get_preferred_size_handler[cp] = h
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		textfield_delegate_handlers.get_minimum_size_handler[cp] = h
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		textfield_delegate_handlers.get_maximum_size_handler[cp] = h
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		textfield_delegate_handlers.get_height_for_width_handler[cp] = h
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		textfield_delegate_handlers.on_parent_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		textfield_delegate_handlers.on_child_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnFocusHandler); ok {
		textfield_delegate_handlers.on_focus_handler[cp] = h
	}

	if h, ok := a.(OnBlurHandler); ok {
		textfield_delegate_handlers.on_blur_handler[cp] = h
	}

	if accessor, ok := a.(CTextfieldDelegateTAccessor); ok {
		accessor.SetCTextfieldDelegateT(textfield_delegate)
		Logf("T21960:")
	}

	return textfield_delegate
}

// cef_urlrequest_capi.h, include/capi/cef_urlrequest_capi.h:112:3,

///
// Structure used to make a URL request. URL requests are not associated with a
// browser instance so no cef_client_t callbacks will be executed. URL requests
// can be created on any valid CEF thread in either the browser or render
// process. Once created the functions of the URL request object must be
// accessed on the same thread that created it.
///

// Go type for cef_urlrequest_t
type CUrlrequestT struct {
	noCopy       noCopy
	p_urlrequest *C.cef_urlrequest_t
}

type RefToCUrlrequestT struct {
	p_urlrequest *CUrlrequestT
}

type CUrlrequestTAccessor interface {
	GetCUrlrequestT() *CUrlrequestT
	SetCUrlrequestT(*CUrlrequestT)
}

func (r RefToCUrlrequestT) GetCUrlrequestT() *CUrlrequestT {
	return r.p_urlrequest
}

func (r *RefToCUrlrequestT) SetCUrlrequestT(p *CUrlrequestT) {
	r.p_urlrequest = p
}

// Go type CUrlrequestT wraps cef type *C.cef_urlrequest_t
func newCUrlrequestT(p *C.cef_urlrequest_t) *CUrlrequestT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T21991:")
	BaseAddRef(p)
	go_urlrequest := CUrlrequestT{noCopy{}, p}
	runtime.SetFinalizer(&go_urlrequest, func(g *CUrlrequestT) {
		Tracef(unsafe.Pointer(g.p_urlrequest), "T21995:")
		BaseRelease(g.p_urlrequest)
	})
	return &go_urlrequest
}

// *C.cef_urlrequest_t has refCounted interface
func (urlrequest *CUrlrequestT) HasOneRef() bool {
	return BaseHasOneRef(urlrequest.p_urlrequest)
}

func (p *C.cef_urlrequest_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the request object used to create this URL request. The returned
// object is read-only and should not be modified.
///
func (self *CUrlrequestT) GetRequest() (ret *CRequestT) {

	cRet := C.cefingo_urlrequest_get_request(self.p_urlrequest)

	ret = newCRequestT(cRet)
	return ret
}

///
// Returns the client.
///
func (self *CUrlrequestT) GetClient() (ret *CUrlrequestClientT) {

	cRet := C.cefingo_urlrequest_get_client(self.p_urlrequest)

	ret = newCUrlrequestClientT(cRet)
	return ret
}

///
// Returns the request status.
///
func (self *CUrlrequestT) GetRequestStatus() (ret CUrlrequestStatusT) {

	cRet := C.cefingo_urlrequest_get_request_status(self.p_urlrequest)

	ret = CUrlrequestStatusT(cRet)
	return ret
}

///
// Returns the request error if status is UR_CANCELED or UR_FAILED, or 0
// otherwise.
///
func (self *CUrlrequestT) GetRequestError() (ret CErrorcodeT) {

	cRet := C.cefingo_urlrequest_get_request_error(self.p_urlrequest)

	ret = CErrorcodeT(cRet)
	return ret
}

///
// Returns the response, or NULL if no response information is available.
// Response information will only be available after the upload has completed.
// The returned object is read-only and should not be modified.
///
func (self *CUrlrequestT) GetResponse() (ret *CResponseT) {

	cRet := C.cefingo_urlrequest_get_response(self.p_urlrequest)

	ret = newCResponseT(cRet)
	return ret
}

///
// Returns true (1) if the response body was served from the cache. This
// includes responses for which revalidation was required.
///
func (self *CUrlrequestT) ResponseWasCached() (ret bool) {

	cRet := C.cefingo_urlrequest_response_was_cached(self.p_urlrequest)

	ret = cRet == 1
	return ret
}

///
// Cancel the request.
///
func (self *CUrlrequestT) Cancel() {

	C.cefingo_urlrequest_cancel(self.p_urlrequest)

}

///
// Create a new URL request that is not associated with a specific browser or
// frame. Use cef_frame_t::CreateURLRequest instead if you want the request to
// have this association, in which case it may be handled differently (see
// documentation on that function). Requests may originate from the both browser
// process and the render process.
//
// For requests originating from the browser process:
//   - It may be intercepted by the client via CefResourceRequestHandler or
//     CefSchemeHandlerFactory.
//   - POST data may only contain only a single element of type PDE_TYPE_FILE
//     or PDE_TYPE_BYTES.
//   - If |request_context| is empty the global request context will be used.
// For requests originating from the render process:
//   - It cannot be intercepted by the client so only http(s) and blob schemes
//     are supported.
//   - POST data may only contain a single element of type PDE_TYPE_BYTES.
//   - The |request_context| parameter must be NULL.
//
// The |request| object will be marked as read-only after calling this function.
///
func UrlrequestCreate(
	request *CRequestT,
	client *CUrlrequestClientT,
	request_context *CRequestContextT,
) (ret *CUrlrequestT) {
	var goTmprequest *C.cef_request_t
	if request != nil {
		goTmprequest = request.p_request
		BaseAddRef(goTmprequest)
	}
	var goTmpclient *C.cef_urlrequest_client_t
	if client != nil {
		goTmpclient = client.p_urlrequest_client
		BaseAddRef(goTmpclient)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		goTmprequest_context = request_context.p_request_context
		BaseAddRef(goTmprequest_context)
	}

	cRet := C.cef_urlrequest_create(goTmprequest, goTmpclient, goTmprequest_context)

	ret = newCUrlrequestT(cRet)
	return ret
}

///
// Structure that should be implemented by the cef_urlrequest_t client. The
// functions of this structure will be called on the same thread that created
// the request unless otherwise documented.
///

// Go type for cef_urlrequest_client_t
type CUrlrequestClientT struct {
	noCopy              noCopy
	p_urlrequest_client *C.cef_urlrequest_client_t
}

type RefToCUrlrequestClientT struct {
	p_urlrequest_client *CUrlrequestClientT
}

type CUrlrequestClientTAccessor interface {
	GetCUrlrequestClientT() *CUrlrequestClientT
	SetCUrlrequestClientT(*CUrlrequestClientT)
}

func (r RefToCUrlrequestClientT) GetCUrlrequestClientT() *CUrlrequestClientT {
	return r.p_urlrequest_client
}

func (r *RefToCUrlrequestClientT) SetCUrlrequestClientT(p *CUrlrequestClientT) {
	r.p_urlrequest_client = p
}

// Go type CUrlrequestClientT wraps cef type *C.cef_urlrequest_client_t
func newCUrlrequestClientT(p *C.cef_urlrequest_client_t) *CUrlrequestClientT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T22186:")
	BaseAddRef(p)
	go_urlrequest_client := CUrlrequestClientT{noCopy{}, p}
	runtime.SetFinalizer(&go_urlrequest_client, func(g *CUrlrequestClientT) {
		Tracef(unsafe.Pointer(g.p_urlrequest_client), "T22190:")
		BaseRelease(g.p_urlrequest_client)
	})
	return &go_urlrequest_client
}

// *C.cef_urlrequest_client_t has refCounted interface
func (urlrequest_client *CUrlrequestClientT) HasOneRef() bool {
	return BaseHasOneRef(urlrequest_client.p_urlrequest_client)
}

func (p *C.cef_urlrequest_client_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Notifies the client that the request has completed. Use the
// cef_urlrequest_t::GetRequestStatus function to determine if the request was
// successful or not.
///
type OnRequestCompleteHandler interface {
	OnRequestComplete(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
	)
}

///
// Notifies the client of upload progress. |current| denotes the number of
// bytes sent so far and |total| is the total size of uploading data (or -1 if
// chunked upload is enabled). This function will only be called if the
// UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request.
///
type OnUploadProgressHandler interface {
	OnUploadProgress(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
		current int64,
		total int64,
	)
}

///
// Notifies the client of download progress. |current| denotes the number of
// bytes received up to the call and |total| is the expected total size of the
// response (or -1 if not determined).
///
type OnDownloadProgressHandler interface {
	OnDownloadProgress(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
		current int64,
		total int64,
	)
}

///
// Called when some part of the response is read. |data| contains the current
// bytes received since the last call. This function will not be called if the
// UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request.
///
type OnDownloadDataHandler interface {
	OnDownloadData(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
		data unsafe.Pointer,
		data_length int64,
	)
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |isProxy| indicates whether the host is a proxy server. |host| contains the
// hostname and |port| contains the port number. Return true (1) to continue
// the request and call cef_auth_callback_t::cont() when the authentication
// information is available. If the request has an associated browser/frame
// then returning false (0) will result in a call to GetAuthCredentials on the
// cef_request_handler_t associated with that browser, if any. Otherwise,
// returning false (0) will cancel the request immediately. This function will
// only be called for requests initiated from the browser process.
///
type CUrlrequestClientTGetAuthCredentialsHandler interface {
	GetAuthCredentials(
		self *CUrlrequestClientT,
		isProxy int,
		host string,
		port int,
		realm string,
		scheme string,
		callback *CAuthCallbackT,
	) (ret bool)
}

var urlrequest_client_handlers = struct {
	on_request_complete_handler  map[*C.cef_urlrequest_client_t]OnRequestCompleteHandler
	on_upload_progress_handler   map[*C.cef_urlrequest_client_t]OnUploadProgressHandler
	on_download_progress_handler map[*C.cef_urlrequest_client_t]OnDownloadProgressHandler
	on_download_data_handler     map[*C.cef_urlrequest_client_t]OnDownloadDataHandler
	get_auth_credentials_handler map[*C.cef_urlrequest_client_t]CUrlrequestClientTGetAuthCredentialsHandler
}{
	map[*C.cef_urlrequest_client_t]OnRequestCompleteHandler{},
	map[*C.cef_urlrequest_client_t]OnUploadProgressHandler{},
	map[*C.cef_urlrequest_client_t]OnDownloadProgressHandler{},
	map[*C.cef_urlrequest_client_t]OnDownloadDataHandler{},
	map[*C.cef_urlrequest_client_t]CUrlrequestClientTGetAuthCredentialsHandler{},
}

// AllocCUrlrequestClientT allocates CUrlrequestClientT and construct it
func AllocCUrlrequestClientT() *CUrlrequestClientT {
	up := c_calloc(1, C.sizeof_cefingo_urlrequest_client_wrapper_t, "T22299:")
	cefp := C.cefingo_construct_urlrequest_client((*C.cefingo_urlrequest_client_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_urlrequest_client_t itself in DeassocFunc,
		// or cef_urlrequest_client_t is never GCed.
		Tracef(up, "T22305:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(urlrequest_client_handlers.on_request_complete_handler, cefp)
		delete(urlrequest_client_handlers.on_upload_progress_handler, cefp)
		delete(urlrequest_client_handlers.on_download_progress_handler, cefp)
		delete(urlrequest_client_handlers.on_download_data_handler, cefp)
		delete(urlrequest_client_handlers.get_auth_credentials_handler, cefp)
	}))

	return newCUrlrequestClientT(cefp)
}

func (urlrequest_client *CUrlrequestClientT) Bind(a interface{}) *CUrlrequestClientT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := urlrequest_client.p_urlrequest_client

	if h, ok := a.(OnRequestCompleteHandler); ok {
		urlrequest_client_handlers.on_request_complete_handler[cp] = h
	}

	if h, ok := a.(OnUploadProgressHandler); ok {
		urlrequest_client_handlers.on_upload_progress_handler[cp] = h
	}

	if h, ok := a.(OnDownloadProgressHandler); ok {
		urlrequest_client_handlers.on_download_progress_handler[cp] = h
	}

	if h, ok := a.(OnDownloadDataHandler); ok {
		urlrequest_client_handlers.on_download_data_handler[cp] = h
	}

	if h, ok := a.(CUrlrequestClientTGetAuthCredentialsHandler); ok {
		urlrequest_client_handlers.get_auth_credentials_handler[cp] = h
	}

	if accessor, ok := a.(CUrlrequestClientTAccessor); ok {
		accessor.SetCUrlrequestClientT(urlrequest_client)
		Logf("T22359:")
	}

	return urlrequest_client
}

// cef_v8_capi.h, include/capi/cef_v8_capi.h:141:3,

///
// Structure representing a V8 context handle. V8 handles can only be accessed
// from the thread on which they are created. Valid threads for creating a V8
// handle include the render process main thread (TID_RENDERER) and WebWorker
// threads. A task runner for posting tasks on the associated thread can be
// retrieved via the cef_v8context_t::get_task_runner() function.
///

// Go type for cef_v8context_t
type CV8contextT struct {
	noCopy      noCopy
	p_v8context *C.cef_v8context_t
}

type RefToCV8contextT struct {
	p_v8context *CV8contextT
}

type CV8contextTAccessor interface {
	GetCV8contextT() *CV8contextT
	SetCV8contextT(*CV8contextT)
}

func (r RefToCV8contextT) GetCV8contextT() *CV8contextT {
	return r.p_v8context
}

func (r *RefToCV8contextT) SetCV8contextT(p *CV8contextT) {
	r.p_v8context = p
}

// Go type CV8contextT wraps cef type *C.cef_v8context_t
func newCV8contextT(p *C.cef_v8context_t) *CV8contextT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T22390:")
	BaseAddRef(p)
	go_v8context := CV8contextT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8context, func(g *CV8contextT) {
		Tracef(unsafe.Pointer(g.p_v8context), "T22394:")
		BaseRelease(g.p_v8context)
	})
	return &go_v8context
}

// *C.cef_v8context_t has refCounted interface
func (v8context *CV8contextT) HasOneRef() bool {
	return BaseHasOneRef(v8context.p_v8context)
}

func (p *C.cef_v8context_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the task runner associated with this context. V8 handles can only
// be accessed from the thread on which they are created. This function can be
// called on any render process thread.
///
func (self *CV8contextT) GetTaskRunner() (ret *CTaskRunnerT) {

	cRet := C.cefingo_v8context_get_task_runner(self.p_v8context)

	ret = newCTaskRunnerT(cRet)
	return ret
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8contextT) IsValid() (ret bool) {

	cRet := C.cefingo_v8context_is_valid(self.p_v8context)

	ret = cRet == 1
	return ret
}

///
// Returns the browser for this context. This function will return an NULL
// reference for WebWorker contexts.
///
func (self *CV8contextT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_v8context_get_browser(self.p_v8context)

	ret = newCBrowserT(cRet)
	return ret
}

///
// Returns the frame for this context. This function will return an NULL
// reference for WebWorker contexts.
///
func (self *CV8contextT) GetFrame() (ret *CFrameT) {

	cRet := C.cefingo_v8context_get_frame(self.p_v8context)

	ret = newCFrameT(cRet)
	return ret
}

///
// Returns the global object for this context. The context must be entered
// before calling this function.
///
func (self *CV8contextT) GetGlobal() (ret *CV8valueT) {

	cRet := C.cefingo_v8context_get_global(self.p_v8context)

	ret = newCV8valueT(cRet)
	return ret
}

///
// Enter this context. A context must be explicitly entered before creating a
// V8 Object, Array, Function or Date asynchronously. exit() must be called
// the same number of times as enter() before releasing this context. V8
// objects belong to the context in which they are created. Returns true (1)
// if the scope was entered successfully.
///
func (self *CV8contextT) Enter() (ret bool) {

	cRet := C.cefingo_v8context_enter(self.p_v8context)

	ret = cRet == 1
	return ret
}

///
// Exit this context. Call this function only after calling enter(). Returns
// true (1) if the scope was exited successfully.
///
func (self *CV8contextT) Exit() (ret bool) {

	cRet := C.cefingo_v8context_exit(self.p_v8context)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CV8contextT) IsSame(
	that *CV8contextT,
) (ret bool) {
	var goTmpthat *C.cef_v8context_t
	if that != nil {
		goTmpthat = that.p_v8context
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_v8context_is_same(self.p_v8context, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Execute a string of JavaScript code in this V8 context. The |script_url|
// parameter is the URL where the script in question can be found, if any. The
// |start_line| parameter is the base line number to use for error reporting.
// On success |retval| will be set to the return value, if any, and the
// function will return true (1). On failure |exception| will be set to the
// exception, if any, and the function will return false (0).
///
func (self *CV8contextT) Eval(
	code string,
	script_url string,
	start_line int,
) (ret bool, retval *CV8valueT, exception *CV8exceptionT) {
	c_code := create_cef_string(code)
	defer clear_cef_string(c_code)
	c_script_url := create_cef_string(script_url)
	defer clear_cef_string(c_script_url)
	var tmpretval *C.cef_v8value_t
	var tmpexception *C.cef_v8exception_t

	cRet := C.cefingo_v8context_eval(self.p_v8context, (*C.cef_string_t)(c_code), (*C.cef_string_t)(c_script_url), (C.int)(start_line), &tmpretval, &tmpexception)

	retval = newCV8valueT(tmpretval)
	exception = newCV8exceptionT(tmpexception)

	ret = cRet == 1
	return ret, retval, exception
}

///
// Returns the current (top) context object in the V8 context stack.
///
func V8contextGetCurrentContext() (ret *CV8contextT) {

	cRet := C.cef_v8context_get_current_context()

	ret = newCV8contextT(cRet)
	return ret
}

///
// Returns the entered (bottom) context object in the V8 context stack.
///
func V8contextGetEnteredContext() (ret *CV8contextT) {

	cRet := C.cef_v8context_get_entered_context()

	ret = newCV8contextT(cRet)
	return ret
}

///
// Returns true (1) if V8 is currently inside a context.
///
func V8contextInContext() (ret bool) {

	cRet := C.cef_v8context_in_context()

	ret = cRet == 1
	return ret
}

///
// Structure that should be implemented to handle V8 function calls. The
// functions of this structure will be called on the thread associated with the
// V8 function.
///

// Go type for cef_v8handler_t
type CV8handlerT struct {
	noCopy      noCopy
	p_v8handler *C.cef_v8handler_t
}

type RefToCV8handlerT struct {
	p_v8handler *CV8handlerT
}

type CV8handlerTAccessor interface {
	GetCV8handlerT() *CV8handlerT
	SetCV8handlerT(*CV8handlerT)
}

func (r RefToCV8handlerT) GetCV8handlerT() *CV8handlerT {
	return r.p_v8handler
}

func (r *RefToCV8handlerT) SetCV8handlerT(p *CV8handlerT) {
	r.p_v8handler = p
}

// Go type CV8handlerT wraps cef type *C.cef_v8handler_t
func newCV8handlerT(p *C.cef_v8handler_t) *CV8handlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T22633:")
	BaseAddRef(p)
	go_v8handler := CV8handlerT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8handler, func(g *CV8handlerT) {
		Tracef(unsafe.Pointer(g.p_v8handler), "T22637:")
		BaseRelease(g.p_v8handler)
	})
	return &go_v8handler
}

// *C.cef_v8handler_t has refCounted interface
func (v8handler *CV8handlerT) HasOneRef() bool {
	return BaseHasOneRef(v8handler.p_v8handler)
}

func (p *C.cef_v8handler_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Handle execution of the function identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the function. |arguments| is the list of
// arguments passed to the function. If execution succeeds set |retval| to the
// function return value. If execution fails set |exception| to the exception
// that will be thrown. Return true (1) if execution was handled.
///
type CV8handlerTExecuteHandler interface {
	Execute(
		self *CV8handlerT,
		name string,
		object *CV8valueT,
		arguments []*CV8valueT,
	) (ret bool, retval *CV8valueT, exception string)
}

var v8handler_handlers = struct {
	execute_handler map[*C.cef_v8handler_t]CV8handlerTExecuteHandler
}{
	map[*C.cef_v8handler_t]CV8handlerTExecuteHandler{},
}

// AllocCV8handlerT allocates CV8handlerT and construct it
func AllocCV8handlerT() *CV8handlerT {
	up := c_calloc(1, C.sizeof_cefingo_v8handler_wrapper_t, "T22676:")
	cefp := C.cefingo_construct_v8handler((*C.cefingo_v8handler_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_v8handler_t itself in DeassocFunc,
		// or cef_v8handler_t is never GCed.
		Tracef(up, "T22682:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(v8handler_handlers.execute_handler, cefp)
	}))

	return newCV8handlerT(cefp)
}

func (v8handler *CV8handlerT) Bind(a interface{}) *CV8handlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := v8handler.p_v8handler

	if h, ok := a.(CV8handlerTExecuteHandler); ok {
		v8handler_handlers.execute_handler[cp] = h
	}

	if accessor, ok := a.(CV8handlerTAccessor); ok {
		accessor.SetCV8handlerT(v8handler)
		Logf("T22716:")
	}

	return v8handler
}

///
// Structure that should be implemented to handle V8 accessor calls. Accessor
// identifiers are registered by calling cef_v8value_t::set_value(). The
// functions of this structure will be called on the thread associated with the
// V8 accessor.
///

// Go type for cef_v8accessor_t
type CV8accessorT struct {
	noCopy       noCopy
	p_v8accessor *C.cef_v8accessor_t
}

type RefToCV8accessorT struct {
	p_v8accessor *CV8accessorT
}

type CV8accessorTAccessor interface {
	GetCV8accessorT() *CV8accessorT
	SetCV8accessorT(*CV8accessorT)
}

func (r RefToCV8accessorT) GetCV8accessorT() *CV8accessorT {
	return r.p_v8accessor
}

func (r *RefToCV8accessorT) SetCV8accessorT(p *CV8accessorT) {
	r.p_v8accessor = p
}

// Go type CV8accessorT wraps cef type *C.cef_v8accessor_t
func newCV8accessorT(p *C.cef_v8accessor_t) *CV8accessorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T22744:")
	BaseAddRef(p)
	go_v8accessor := CV8accessorT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8accessor, func(g *CV8accessorT) {
		Tracef(unsafe.Pointer(g.p_v8accessor), "T22748:")
		BaseRelease(g.p_v8accessor)
	})
	return &go_v8accessor
}

// *C.cef_v8accessor_t has refCounted interface
func (v8accessor *CV8accessorT) HasOneRef() bool {
	return BaseHasOneRef(v8accessor.p_v8accessor)
}

func (p *C.cef_v8accessor_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Handle retrieval the accessor value identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the accessor. If retrieval succeeds set
// |retval| to the return value. If retrieval fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor retrieval was
// handled.
///
type GetHandler interface {
	Get(
		self *CV8accessorT,
		name string,
		object *CV8valueT,
	) (ret bool, retval *CV8valueT, exception string)
}

///
// Handle assignment of the accessor value identified by |name|. |object| is
// the receiver (&#39;this&#39; object) of the accessor. |value| is the new value
// being assigned to the accessor. If assignment fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor assignment was
// handled.
///
type SetHandler interface {
	Set(
		self *CV8accessorT,
		name string,
		object *CV8valueT,
		value *CV8valueT,
	) (ret bool, exception string)
}

var v8accessor_handlers = struct {
	get_handler map[*C.cef_v8accessor_t]GetHandler
	set_handler map[*C.cef_v8accessor_t]SetHandler
}{
	map[*C.cef_v8accessor_t]GetHandler{},
	map[*C.cef_v8accessor_t]SetHandler{},
}

// AllocCV8accessorT allocates CV8accessorT and construct it
func AllocCV8accessorT() *CV8accessorT {
	up := c_calloc(1, C.sizeof_cefingo_v8accessor_wrapper_t, "T22804:")
	cefp := C.cefingo_construct_v8accessor((*C.cefingo_v8accessor_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_v8accessor_t itself in DeassocFunc,
		// or cef_v8accessor_t is never GCed.
		Tracef(up, "T22810:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(v8accessor_handlers.get_handler, cefp)
		delete(v8accessor_handlers.set_handler, cefp)
	}))

	return newCV8accessorT(cefp)
}

func (v8accessor *CV8accessorT) Bind(a interface{}) *CV8accessorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := v8accessor.p_v8accessor

	if h, ok := a.(GetHandler); ok {
		v8accessor_handlers.get_handler[cp] = h
	}

	if h, ok := a.(SetHandler); ok {
		v8accessor_handlers.set_handler[cp] = h
	}

	if accessor, ok := a.(CV8accessorTAccessor); ok {
		accessor.SetCV8accessorT(v8accessor)
		Logf("T22849:")
	}

	return v8accessor
}

///
// Structure that should be implemented to handle V8 interceptor calls. The
// functions of this structure will be called on the thread associated with the
// V8 interceptor. Interceptor's named property handlers (with first argument of
// type CefString) are called when object is indexed by string. Indexed property
// handlers (with first argument of type int) are called when object is indexed
// by integer.
///

// Go type for cef_v8interceptor_t
type CV8interceptorT struct {
	noCopy          noCopy
	p_v8interceptor *C.cef_v8interceptor_t
}

type RefToCV8interceptorT struct {
	p_v8interceptor *CV8interceptorT
}

type CV8interceptorTAccessor interface {
	GetCV8interceptorT() *CV8interceptorT
	SetCV8interceptorT(*CV8interceptorT)
}

func (r RefToCV8interceptorT) GetCV8interceptorT() *CV8interceptorT {
	return r.p_v8interceptor
}

func (r *RefToCV8interceptorT) SetCV8interceptorT(p *CV8interceptorT) {
	r.p_v8interceptor = p
}

// Go type CV8interceptorT wraps cef type *C.cef_v8interceptor_t
func newCV8interceptorT(p *C.cef_v8interceptor_t) *CV8interceptorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T22879:")
	BaseAddRef(p)
	go_v8interceptor := CV8interceptorT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8interceptor, func(g *CV8interceptorT) {
		Tracef(unsafe.Pointer(g.p_v8interceptor), "T22883:")
		BaseRelease(g.p_v8interceptor)
	})
	return &go_v8interceptor
}

// *C.cef_v8interceptor_t has refCounted interface
func (v8interceptor *CV8interceptorT) HasOneRef() bool {
	return BaseHasOneRef(v8interceptor.p_v8interceptor)
}

func (p *C.cef_v8interceptor_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Handle retrieval of the interceptor value identified by |name|. |object| is
// the receiver (&#39;this&#39; object) of the interceptor. If retrieval succeeds, set
// |retval| to the return value. If the requested value does not exist, don&#39;t
// set either |retval| or |exception|. If retrieval fails, set |exception| to
// the exception that will be thrown. If the property has an associated
// accessor, it will be called only if you don&#39;t set |retval|. Return true (1)
// if interceptor retrieval was handled, false (0) otherwise.
///
func (self *CV8interceptorT) GetByname(
	name string,
	object *CV8valueT,
) (ret bool, retval *CV8valueT, exception string) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		goTmpobject = object.p_v8value
		BaseAddRef(goTmpobject)
	}
	var tmpretval *C.cef_v8value_t
	tmpc_exception := create_cef_string("")
	defer clear_cef_string(tmpc_exception)

	cRet := C.cefingo_v8interceptor_get_byname(self.p_v8interceptor, (*C.cef_string_t)(c_name), goTmpobject, &tmpretval, tmpc_exception)

	retval = newCV8valueT(tmpretval)
	exception = string_from_cef_string(tmpc_exception)

	ret = cRet == 1
	return ret, retval, exception
}

///
// Handle retrieval of the interceptor value identified by |index|. |object|
// is the receiver (&#39;this&#39; object) of the interceptor. If retrieval succeeds,
// set |retval| to the return value. If the requested value does not exist,
// don&#39;t set either |retval| or |exception|. If retrieval fails, set
// |exception| to the exception that will be thrown. Return true (1) if
// interceptor retrieval was handled, false (0) otherwise.
///
func (self *CV8interceptorT) GetByindex(
	index int,
	object *CV8valueT,
) (ret bool, retval *CV8valueT, exception string) {
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		goTmpobject = object.p_v8value
		BaseAddRef(goTmpobject)
	}
	var tmpretval *C.cef_v8value_t
	tmpc_exception := create_cef_string("")
	defer clear_cef_string(tmpc_exception)

	cRet := C.cefingo_v8interceptor_get_byindex(self.p_v8interceptor, (C.int)(index), goTmpobject, &tmpretval, tmpc_exception)

	retval = newCV8valueT(tmpretval)
	exception = string_from_cef_string(tmpc_exception)

	ret = cRet == 1
	return ret, retval, exception
}

///
// Handle assignment of the interceptor value identified by |name|. |object|
// is the receiver (&#39;this&#39; object) of the interceptor. |value| is the new
// value being assigned to the interceptor. If assignment fails, set
// |exception| to the exception that will be thrown. This setter will always
// be called, even when the property has an associated accessor. Return true
// (1) if interceptor assignment was handled, false (0) otherwise.
///
func (self *CV8interceptorT) SetByname(
	name string,
	object *CV8valueT,
	value *CV8valueT,
) (ret bool, exception string) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		goTmpobject = object.p_v8value
		BaseAddRef(goTmpobject)
	}
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		goTmpvalue = value.p_v8value
		BaseAddRef(goTmpvalue)
	}
	tmpc_exception := create_cef_string("")
	defer clear_cef_string(tmpc_exception)

	cRet := C.cefingo_v8interceptor_set_byname(self.p_v8interceptor, (*C.cef_string_t)(c_name), goTmpobject, goTmpvalue, tmpc_exception)

	exception = string_from_cef_string(tmpc_exception)

	ret = cRet == 1
	return ret, exception
}

///
// Handle assignment of the interceptor value identified by |index|. |object|
// is the receiver (&#39;this&#39; object) of the interceptor. |value| is the new
// value being assigned to the interceptor. If assignment fails, set
// |exception| to the exception that will be thrown. Return true (1) if
// interceptor assignment was handled, false (0) otherwise.
///
func (self *CV8interceptorT) SetByindex(
	index int,
	object *CV8valueT,
	value *CV8valueT,
) (ret bool, exception string) {
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		goTmpobject = object.p_v8value
		BaseAddRef(goTmpobject)
	}
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		goTmpvalue = value.p_v8value
		BaseAddRef(goTmpvalue)
	}
	tmpc_exception := create_cef_string("")
	defer clear_cef_string(tmpc_exception)

	cRet := C.cefingo_v8interceptor_set_byindex(self.p_v8interceptor, (C.int)(index), goTmpobject, goTmpvalue, tmpc_exception)

	exception = string_from_cef_string(tmpc_exception)

	ret = cRet == 1
	return ret, exception
}

///
// Structure representing a V8 exception. The functions of this structure may be
// called on any render process thread.
///

// Go type for cef_v8exception_t
type CV8exceptionT struct {
	noCopy        noCopy
	p_v8exception *C.cef_v8exception_t
}

type RefToCV8exceptionT struct {
	p_v8exception *CV8exceptionT
}

type CV8exceptionTAccessor interface {
	GetCV8exceptionT() *CV8exceptionT
	SetCV8exceptionT(*CV8exceptionT)
}

func (r RefToCV8exceptionT) GetCV8exceptionT() *CV8exceptionT {
	return r.p_v8exception
}

func (r *RefToCV8exceptionT) SetCV8exceptionT(p *CV8exceptionT) {
	r.p_v8exception = p
}

// Go type CV8exceptionT wraps cef type *C.cef_v8exception_t
func newCV8exceptionT(p *C.cef_v8exception_t) *CV8exceptionT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T23062:")
	BaseAddRef(p)
	go_v8exception := CV8exceptionT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8exception, func(g *CV8exceptionT) {
		Tracef(unsafe.Pointer(g.p_v8exception), "T23066:")
		BaseRelease(g.p_v8exception)
	})
	return &go_v8exception
}

// *C.cef_v8exception_t has refCounted interface
func (v8exception *CV8exceptionT) HasOneRef() bool {
	return BaseHasOneRef(v8exception.p_v8exception)
}

func (p *C.cef_v8exception_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the exception message.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8exceptionT) GetMessage() (ret string) {

	cRet := C.cefingo_v8exception_get_message(self.p_v8exception)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the line of source code that the exception occurred within.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8exceptionT) GetSourceLine() (ret string) {

	cRet := C.cefingo_v8exception_get_source_line(self.p_v8exception)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the resource name for the script from where the function causing
// the error originates.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8exceptionT) GetScriptResourceName() (ret string) {

	cRet := C.cefingo_v8exception_get_script_resource_name(self.p_v8exception)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the 1-based number of the line where the error occurred or 0 if the
// line number is unknown.
///
func (self *CV8exceptionT) GetLineNumber() (ret bool) {

	cRet := C.cefingo_v8exception_get_line_number(self.p_v8exception)

	ret = cRet == 1
	return ret
}

///
// Returns the index within the script of the first character where the error
// occurred.
///
func (self *CV8exceptionT) GetStartPosition() (ret bool) {

	cRet := C.cefingo_v8exception_get_start_position(self.p_v8exception)

	ret = cRet == 1
	return ret
}

///
// Returns the index within the script of the last character where the error
// occurred.
///
func (self *CV8exceptionT) GetEndPosition() (ret bool) {

	cRet := C.cefingo_v8exception_get_end_position(self.p_v8exception)

	ret = cRet == 1
	return ret
}

///
// Returns the index within the line of the first character where the error
// occurred.
///
func (self *CV8exceptionT) GetStartColumn() (ret bool) {

	cRet := C.cefingo_v8exception_get_start_column(self.p_v8exception)

	ret = cRet == 1
	return ret
}

///
// Returns the index within the line of the last character where the error
// occurred.
///
func (self *CV8exceptionT) GetEndColumn() (ret bool) {

	cRet := C.cefingo_v8exception_get_end_column(self.p_v8exception)

	ret = cRet == 1
	return ret
}

///
// Callback structure that is passed to cef_v8value_t::CreateArrayBuffer.
///

// Go type for cef_v8array_buffer_release_callback_t
type CV8arrayBufferReleaseCallbackT struct {
	noCopy                            noCopy
	p_v8array_buffer_release_callback *C.cef_v8array_buffer_release_callback_t
}

type RefToCV8arrayBufferReleaseCallbackT struct {
	p_v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT
}

type CV8arrayBufferReleaseCallbackTAccessor interface {
	GetCV8arrayBufferReleaseCallbackT() *CV8arrayBufferReleaseCallbackT
	SetCV8arrayBufferReleaseCallbackT(*CV8arrayBufferReleaseCallbackT)
}

func (r RefToCV8arrayBufferReleaseCallbackT) GetCV8arrayBufferReleaseCallbackT() *CV8arrayBufferReleaseCallbackT {
	return r.p_v8array_buffer_release_callback
}

func (r *RefToCV8arrayBufferReleaseCallbackT) SetCV8arrayBufferReleaseCallbackT(p *CV8arrayBufferReleaseCallbackT) {
	r.p_v8array_buffer_release_callback = p
}

// Go type CV8arrayBufferReleaseCallbackT wraps cef type *C.cef_v8array_buffer_release_callback_t
func newCV8arrayBufferReleaseCallbackT(p *C.cef_v8array_buffer_release_callback_t) *CV8arrayBufferReleaseCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T23237:")
	BaseAddRef(p)
	go_v8array_buffer_release_callback := CV8arrayBufferReleaseCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8array_buffer_release_callback, func(g *CV8arrayBufferReleaseCallbackT) {
		Tracef(unsafe.Pointer(g.p_v8array_buffer_release_callback), "T23241:")
		BaseRelease(g.p_v8array_buffer_release_callback)
	})
	return &go_v8array_buffer_release_callback
}

// *C.cef_v8array_buffer_release_callback_t has refCounted interface
func (v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT) HasOneRef() bool {
	return BaseHasOneRef(v8array_buffer_release_callback.p_v8array_buffer_release_callback)
}

func (p *C.cef_v8array_buffer_release_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Called to release |buffer| when the ArrayBuffer JS object is garbage
// collected. |buffer| is the value that was passed to CreateArrayBuffer along
// with this object.
///
type ReleaseBufferHandler interface {
	ReleaseBuffer(
		self *CV8arrayBufferReleaseCallbackT,
		buffer unsafe.Pointer,
	)
}

var v8array_buffer_release_callback_handlers = struct {
	release_buffer_handler map[*C.cef_v8array_buffer_release_callback_t]ReleaseBufferHandler
}{
	map[*C.cef_v8array_buffer_release_callback_t]ReleaseBufferHandler{},
}

// AllocCV8arrayBufferReleaseCallbackT allocates CV8arrayBufferReleaseCallbackT and construct it
func AllocCV8arrayBufferReleaseCallbackT() *CV8arrayBufferReleaseCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_v8array_buffer_release_callback_wrapper_t, "T23276:")
	cefp := C.cefingo_construct_v8array_buffer_release_callback((*C.cefingo_v8array_buffer_release_callback_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_v8array_buffer_release_callback_t itself in DeassocFunc,
		// or cef_v8array_buffer_release_callback_t is never GCed.
		Tracef(up, "T23282:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(v8array_buffer_release_callback_handlers.release_buffer_handler, cefp)
	}))

	return newCV8arrayBufferReleaseCallbackT(cefp)
}

func (v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT) Bind(a interface{}) *CV8arrayBufferReleaseCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := v8array_buffer_release_callback.p_v8array_buffer_release_callback

	if h, ok := a.(ReleaseBufferHandler); ok {
		v8array_buffer_release_callback_handlers.release_buffer_handler[cp] = h
	}

	if accessor, ok := a.(CV8arrayBufferReleaseCallbackTAccessor); ok {
		accessor.SetCV8arrayBufferReleaseCallbackT(v8array_buffer_release_callback)
		Logf("T23316:")
	}

	return v8array_buffer_release_callback
}

///
// Structure representing a V8 value handle. V8 handles can only be accessed
// from the thread on which they are created. Valid threads for creating a V8
// handle include the render process main thread (TID_RENDERER) and WebWorker
// threads. A task runner for posting tasks on the associated thread can be
// retrieved via the cef_v8context_t::get_task_runner() function.
///

// Go type for cef_v8value_t
type CV8valueT struct {
	noCopy    noCopy
	p_v8value *C.cef_v8value_t
}

type RefToCV8valueT struct {
	p_v8value *CV8valueT
}

type CV8valueTAccessor interface {
	GetCV8valueT() *CV8valueT
	SetCV8valueT(*CV8valueT)
}

func (r RefToCV8valueT) GetCV8valueT() *CV8valueT {
	return r.p_v8value
}

func (r *RefToCV8valueT) SetCV8valueT(p *CV8valueT) {
	r.p_v8value = p
}

// Go type CV8valueT wraps cef type *C.cef_v8value_t
func newCV8valueT(p *C.cef_v8value_t) *CV8valueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T23345:")
	BaseAddRef(p)
	go_v8value := CV8valueT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8value, func(g *CV8valueT) {
		Tracef(unsafe.Pointer(g.p_v8value), "T23349:")
		BaseRelease(g.p_v8value)
	})
	return &go_v8value
}

// *C.cef_v8value_t has refCounted interface
func (v8value *CV8valueT) HasOneRef() bool {
	return BaseHasOneRef(v8value.p_v8value)
}

func (p *C.cef_v8value_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8valueT) IsValid() (ret bool) {

	cRet := C.cefingo_v8value_is_valid(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is undefined.
///
func (self *CV8valueT) IsUndefined() (ret bool) {

	cRet := C.cefingo_v8value_is_undefined(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is null.
///
func (self *CV8valueT) IsNull() (ret bool) {

	cRet := C.cefingo_v8value_is_null(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is bool.
///
func (self *CV8valueT) IsBool() (ret bool) {

	cRet := C.cefingo_v8value_is_bool(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is int.
///
func (self *CV8valueT) IsInt() (ret bool) {

	cRet := C.cefingo_v8value_is_int(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is unsigned int.
///
func (self *CV8valueT) IsUint() (ret bool) {

	cRet := C.cefingo_v8value_is_uint(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is double.
///
func (self *CV8valueT) IsDouble() (ret bool) {

	cRet := C.cefingo_v8value_is_double(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is Date.
///
func (self *CV8valueT) IsDate() (ret bool) {

	cRet := C.cefingo_v8value_is_date(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is string.
///
func (self *CV8valueT) IsString() (ret bool) {

	cRet := C.cefingo_v8value_is_string(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is object.
///
func (self *CV8valueT) IsObject() (ret bool) {

	cRet := C.cefingo_v8value_is_object(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is array.
///
func (self *CV8valueT) IsArray() (ret bool) {

	cRet := C.cefingo_v8value_is_array(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is an ArrayBuffer.
///
func (self *CV8valueT) IsArrayBuffer() (ret bool) {

	cRet := C.cefingo_v8value_is_array_buffer(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// True if the value type is function.
///
func (self *CV8valueT) IsFunction() (ret bool) {

	cRet := C.cefingo_v8value_is_function(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CV8valueT) IsSame(
	that *CV8valueT,
) (ret bool) {
	var goTmpthat *C.cef_v8value_t
	if that != nil {
		goTmpthat = that.p_v8value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_v8value_is_same(self.p_v8value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Return a bool value.
///
func (self *CV8valueT) GetBoolValue() (ret bool) {

	cRet := C.cefingo_v8value_get_bool_value(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Return an int value.
///
func (self *CV8valueT) GetIntValue() (ret int32) {

	cRet := C.cefingo_v8value_get_int_value(self.p_v8value)

	ret = (int32)(cRet)
	return ret
}

///
// Return an unsigned int value.
///
func (self *CV8valueT) GetUintValue() (ret uint32) {

	cRet := C.cefingo_v8value_get_uint_value(self.p_v8value)

	ret = (uint32)(cRet)
	return ret
}

///
// Return a double value.
///
func (self *CV8valueT) GetDoubleValue() (ret float64) {

	cRet := C.cefingo_v8value_get_double_value(self.p_v8value)

	ret = (float64)(cRet)
	return ret
}

///
// Return a Date value.
///
func (self *CV8valueT) GetDateValue() (ret CTimeT) {

	cRet := C.cefingo_v8value_get_date_value(self.p_v8value)

	ret = (CTimeT)(cRet)
	return ret
}

///
// Return a string value.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8valueT) GetStringValue() (ret string) {

	cRet := C.cefingo_v8value_get_string_value(self.p_v8value)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this is a user created object.
///
func (self *CV8valueT) IsUserCreated() (ret bool) {

	cRet := C.cefingo_v8value_is_user_created(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the last function call resulted in an exception. This
// attribute exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) HasException() (ret bool) {

	cRet := C.cefingo_v8value_has_exception(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Returns the exception resulting from the last function call. This attribute
// exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) GetException() (ret *CV8exceptionT) {

	cRet := C.cefingo_v8value_get_exception(self.p_v8value)

	ret = newCV8exceptionT(cRet)
	return ret
}

///
// Clears the last exception and returns true (1) on success.
///
func (self *CV8valueT) ClearException() (ret bool) {

	cRet := C.cefingo_v8value_clear_exception(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object will re-throw future exceptions. This
// attribute exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) WillRethrowExceptions() (ret bool) {

	cRet := C.cefingo_v8value_will_rethrow_exceptions(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Set whether this object will re-throw future exceptions. By default
// exceptions are not re-thrown. If a exception is re-thrown the current
// context should not be accessed again until after the exception has been
// caught and not re-thrown. Returns true (1) on success. This attribute
// exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) SetRethrowExceptions(
	rethrow int,
) (ret bool) {

	cRet := C.cefingo_v8value_set_rethrow_exceptions(self.p_v8value, (C.int)(rethrow))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the object has a value with the specified identifier.
///
func (self *CV8valueT) HasValueBykey(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_v8value_has_value_bykey(self.p_v8value, (*C.cef_string_t)(c_key))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the object has a value with the specified identifier.
///
func (self *CV8valueT) HasValueByindex(
	index int,
) (ret bool) {

	cRet := C.cefingo_v8value_has_value_byindex(self.p_v8value, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Deletes the value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly or an
// exception is thrown. For read-only and don&#39;t-delete values this function
// will return true (1) even though deletion failed.
///
func (self *CV8valueT) DeleteValueBykey(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_v8value_delete_value_bykey(self.p_v8value, (*C.cef_string_t)(c_key))

	ret = cRet == 1
	return ret
}

///
// Deletes the value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly, deletion
// fails or an exception is thrown. For read-only and don&#39;t-delete values this
// function will return true (1) even though deletion failed.
///
func (self *CV8valueT) DeleteValueByindex(
	index int,
) (ret bool) {

	cRet := C.cefingo_v8value_delete_value_byindex(self.p_v8value, (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the value with the specified identifier on success. Returns NULL if
// this function is called incorrectly or an exception is thrown.
///
func (self *CV8valueT) GetValueBykey(
	key string,
) (ret *CV8valueT) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_v8value_get_value_bykey(self.p_v8value, (*C.cef_string_t)(c_key))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Returns the value with the specified identifier on success. Returns NULL if
// this function is called incorrectly or an exception is thrown.
///
func (self *CV8valueT) GetValueByindex(
	index int,
) (ret *CV8valueT) {

	cRet := C.cefingo_v8value_get_value_byindex(self.p_v8value, (C.int)(index))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Associates a value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly or an
// exception is thrown. For read-only values this function will return true
// (1) even though assignment failed.
///
func (self *CV8valueT) SetValueBykey(
	key string,
	value *CV8valueT,
	attribute CV8PropertyattributeT,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		goTmpvalue = value.p_v8value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_v8value_set_value_bykey(self.p_v8value, (*C.cef_string_t)(c_key), goTmpvalue, (C.cef_v8_propertyattribute_t)(attribute))

	ret = cRet == 1
	return ret
}

///
// Associates a value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly or an
// exception is thrown. For read-only values this function will return true
// (1) even though assignment failed.
///
func (self *CV8valueT) SetValueByindex(
	index int,
	value *CV8valueT,
) (ret bool) {
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		goTmpvalue = value.p_v8value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_v8value_set_value_byindex(self.p_v8value, (C.int)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Registers an identifier and returns true (1) on success. Access to the
// identifier will be forwarded to the cef_v8accessor_t instance passed to
// cef_v8value_t::cef_v8value_create_object(). Returns false (0) if this
// function is called incorrectly or an exception is thrown. For read-only
// values this function will return true (1) even though assignment failed.
///
func (self *CV8valueT) SetValueByaccessor(
	key string,
	settings CV8AccesscontrolT,
	attribute CV8PropertyattributeT,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_v8value_set_value_byaccessor(self.p_v8value, (*C.cef_string_t)(c_key), (C.cef_v8_accesscontrol_t)(settings), (C.cef_v8_propertyattribute_t)(attribute))

	ret = cRet == 1
	return ret
}

///
// Read the keys for the object&#39;s values into the specified vector. Integer-
// based keys will also be returned as strings.
///
func (self *CV8valueT) GetKeys(
	keys CStringListT,
) (ret bool) {

	cRet := C.cefingo_v8value_get_keys(self.p_v8value, (C.cef_string_list_t)(keys))

	ret = cRet == 1
	return ret
}

///
// Returns the amount of externally allocated memory registered for the
// object.
///
func (self *CV8valueT) GetExternallyAllocatedMemory() (ret bool) {

	cRet := C.cefingo_v8value_get_externally_allocated_memory(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Adjusts the amount of registered external memory for the object. Used to
// give V8 an indication of the amount of externally allocated memory that is
// kept alive by JavaScript objects. V8 uses this information to decide when
// to perform global garbage collection. Each cef_v8value_t tracks the amount
// of external memory associated with it and automatically decreases the
// global total by the appropriate amount on its destruction.
// |change_in_bytes| specifies the number of bytes to adjust by. This function
// returns the number of bytes associated with the object after the
// adjustment. This function can only be called on user created objects.
///
func (self *CV8valueT) AdjustExternallyAllocatedMemory(
	change_in_bytes int,
) (ret bool) {

	cRet := C.cefingo_v8value_adjust_externally_allocated_memory(self.p_v8value, (C.int)(change_in_bytes))

	ret = cRet == 1
	return ret
}

///
// Returns the number of elements in the array.
///
func (self *CV8valueT) GetArrayLength() (ret bool) {

	cRet := C.cefingo_v8value_get_array_length(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Returns the ReleaseCallback object associated with the ArrayBuffer or NULL
// if the ArrayBuffer was not created with CreateArrayBuffer.
///
func (self *CV8valueT) GetArrayBufferReleaseCallback() (ret *CV8arrayBufferReleaseCallbackT) {

	cRet := C.cefingo_v8value_get_array_buffer_release_callback(self.p_v8value)

	ret = newCV8arrayBufferReleaseCallbackT(cRet)
	return ret
}

///
// Prevent the ArrayBuffer from using it&#39;s memory block by setting the length
// to zero. This operation cannot be undone. If the ArrayBuffer was created
// with CreateArrayBuffer then
// cef_v8array_buffer_release_callback_t::ReleaseBuffer will be called to
// release the underlying buffer.
///
func (self *CV8valueT) NeuterArrayBuffer() (ret bool) {

	cRet := C.cefingo_v8value_neuter_array_buffer(self.p_v8value)

	ret = cRet == 1
	return ret
}

///
// Returns the function name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8valueT) GetFunctionName() (ret string) {

	cRet := C.cefingo_v8value_get_function_name(self.p_v8value)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the function handler or NULL if not a CEF-created function.
///
func (self *CV8valueT) GetFunctionHandler() (ret *CV8handlerT) {

	cRet := C.cefingo_v8value_get_function_handler(self.p_v8value)

	ret = newCV8handlerT(cRet)
	return ret
}

///
// Execute the function using the current V8 context. This function should
// only be called from within the scope of a cef_v8handler_t or
// cef_v8accessor_t callback, or in combination with calling enter() and
// exit() on a stored cef_v8context_t reference. |object| is the receiver
// (&#39;this&#39; object) of the function. If |object| is NULL the current context&#39;s
// global object will be used. |arguments| is the list of arguments that will
// be passed to the function. Returns the function return value on success.
// Returns NULL if this function is called incorrectly or an exception is
// thrown.
///
func (self *CV8valueT) ExecuteFunction(
	object *CV8valueT,
	arguments []*CV8valueT,
) (ret *CV8valueT) {
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		goTmpobject = object.p_v8value
		BaseAddRef(goTmpobject)
	}
	argumentsCount := len(arguments)
	tmparguments := c_calloc(C.size_t(argumentsCount), (C.size_t)(unsafe.Sizeof(arguments[0])), "T24017:cef_v8value_t::execute_function::arguments")
	slice := (*[1 << 30]*C.cef_v8value_t)(tmparguments)[:argumentsCount:argumentsCount]
	for i, v := range arguments {
		cefp := v.p_v8value
		if cefp != nil {
			BaseAddRef(cefp)
		}
		slice[i] = cefp
	}

	cRet := C.cefingo_v8value_execute_function(self.p_v8value, goTmpobject, (C.size_t)(argumentsCount), (**C.cef_v8value_t)(tmparguments))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Execute the function using the specified V8 context. |object| is the
// receiver (&#39;this&#39; object) of the function. If |object| is NULL the specified
// context&#39;s global object will be used. |arguments| is the list of arguments
// that will be passed to the function. Returns the function return value on
// success. Returns NULL if this function is called incorrectly or an
// exception is thrown.
///
func (self *CV8valueT) ExecuteFunctionWithContext(
	context *CV8contextT,
	object *CV8valueT,
	arguments []*CV8valueT,
) (ret *CV8valueT) {
	var goTmpcontext *C.cef_v8context_t
	if context != nil {
		goTmpcontext = context.p_v8context
		BaseAddRef(goTmpcontext)
	}
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		goTmpobject = object.p_v8value
		BaseAddRef(goTmpobject)
	}
	argumentsCount := len(arguments)
	tmparguments := c_calloc(C.size_t(argumentsCount), (C.size_t)(unsafe.Sizeof(arguments[0])), "T24055:cef_v8value_t::execute_function_with_context::arguments")
	slice := (*[1 << 30]*C.cef_v8value_t)(tmparguments)[:argumentsCount:argumentsCount]
	for i, v := range arguments {
		cefp := v.p_v8value
		if cefp != nil {
			BaseAddRef(cefp)
		}
		slice[i] = cefp
	}

	cRet := C.cefingo_v8value_execute_function_with_context(self.p_v8value, goTmpcontext, goTmpobject, (C.size_t)(argumentsCount), (**C.cef_v8value_t)(tmparguments))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type undefined.
///
func V8valueCreateUndefined() (ret *CV8valueT) {

	cRet := C.cef_v8value_create_undefined()

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type null.
///
func V8valueCreateNull() (ret *CV8valueT) {

	cRet := C.cef_v8value_create_null()

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type bool.
///
func V8valueCreateBool(
	value int,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_bool((C.int)(value))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type int.
///
func V8valueCreateInt(
	value int32,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_int((C.int32)(value))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type unsigned int.
///
func V8valueCreateUint(
	value uint32,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_uint((C.uint32)(value))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type double.
///
func V8valueCreateDouble(
	value float64,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_double((C.double)(value))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type Date. This function should only be
// called from within the scope of a cef_render_process_handler_t,
// cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
// enter() and exit() on a stored cef_v8context_t reference.
///
func V8valueCreateDate(
	date *CTimeT,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_date((*C.cef_time_t)(date))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type string.
///
func V8valueCreateString(
	value string,
) (ret *CV8valueT) {
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	cRet := C.cef_v8value_create_string((*C.cef_string_t)(c_value))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type object with optional accessor
// and/or interceptor. This function should only be called from within the scope
// of a cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t
// callback, or in combination with calling enter() and exit() on a stored
// cef_v8context_t reference.
///
func V8valueCreateObject(
	accessor *CV8accessorT,
	interceptor *CV8interceptorT,
) (ret *CV8valueT) {
	var goTmpaccessor *C.cef_v8accessor_t
	if accessor != nil {
		goTmpaccessor = accessor.p_v8accessor
		BaseAddRef(goTmpaccessor)
	}
	var goTmpinterceptor *C.cef_v8interceptor_t
	if interceptor != nil {
		goTmpinterceptor = interceptor.p_v8interceptor
		BaseAddRef(goTmpinterceptor)
	}

	cRet := C.cef_v8value_create_object(goTmpaccessor, goTmpinterceptor)

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type array with the specified |length|.
// If |length| is negative the returned array will have length 0. This function
// should only be called from within the scope of a
// cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,
// or in combination with calling enter() and exit() on a stored cef_v8context_t
// reference.
///
func V8valueCreateArray(
	length int,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_array((C.int)(length))

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type ArrayBuffer which wraps the
// provided |buffer| of size |length| bytes. The ArrayBuffer is externalized,
// meaning that it does not own |buffer|. The caller is responsible for freeing
// |buffer| when requested via a call to cef_v8array_buffer_release_callback_t::
// ReleaseBuffer. This function should only be called from within the scope of a
// cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,
// or in combination with calling enter() and exit() on a stored cef_v8context_t
// reference.
///
func V8valueCreateArrayBuffer(
	buffer unsafe.Pointer,
	length int64,
	release_callback *CV8arrayBufferReleaseCallbackT,
) (ret *CV8valueT) {
	var goTmprelease_callback *C.cef_v8array_buffer_release_callback_t
	if release_callback != nil {
		goTmprelease_callback = release_callback.p_v8array_buffer_release_callback
		BaseAddRef(goTmprelease_callback)
	}

	cRet := C.cef_v8value_create_array_buffer(buffer, (C.size_t)(length), goTmprelease_callback)

	ret = newCV8valueT(cRet)
	return ret
}

///
// Create a new cef_v8value_t object of type function. This function should only
// be called from within the scope of a cef_render_process_handler_t,
// cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
// enter() and exit() on a stored cef_v8context_t reference.
///
func V8valueCreateFunction(
	name string,
	handler *CV8handlerT,
) (ret *CV8valueT) {
	c_name := create_cef_string(name)
	defer clear_cef_string(c_name)
	var goTmphandler *C.cef_v8handler_t
	if handler != nil {
		goTmphandler = handler.p_v8handler
		BaseAddRef(goTmphandler)
	}

	cRet := C.cef_v8value_create_function((*C.cef_string_t)(c_name), goTmphandler)

	ret = newCV8valueT(cRet)
	return ret
}

///
// Structure representing a V8 stack trace handle. V8 handles can only be
// accessed from the thread on which they are created. Valid threads for
// creating a V8 handle include the render process main thread (TID_RENDERER)
// and WebWorker threads. A task runner for posting tasks on the associated
// thread can be retrieved via the cef_v8context_t::get_task_runner() function.
///

// Go type for cef_v8stack_trace_t
type CV8stackTraceT struct {
	noCopy          noCopy
	p_v8stack_trace *C.cef_v8stack_trace_t
}

type RefToCV8stackTraceT struct {
	p_v8stack_trace *CV8stackTraceT
}

type CV8stackTraceTAccessor interface {
	GetCV8stackTraceT() *CV8stackTraceT
	SetCV8stackTraceT(*CV8stackTraceT)
}

func (r RefToCV8stackTraceT) GetCV8stackTraceT() *CV8stackTraceT {
	return r.p_v8stack_trace
}

func (r *RefToCV8stackTraceT) SetCV8stackTraceT(p *CV8stackTraceT) {
	r.p_v8stack_trace = p
}

// Go type CV8stackTraceT wraps cef type *C.cef_v8stack_trace_t
func newCV8stackTraceT(p *C.cef_v8stack_trace_t) *CV8stackTraceT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T24349:")
	BaseAddRef(p)
	go_v8stack_trace := CV8stackTraceT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8stack_trace, func(g *CV8stackTraceT) {
		Tracef(unsafe.Pointer(g.p_v8stack_trace), "T24353:")
		BaseRelease(g.p_v8stack_trace)
	})
	return &go_v8stack_trace
}

// *C.cef_v8stack_trace_t has refCounted interface
func (v8stack_trace *CV8stackTraceT) HasOneRef() bool {
	return BaseHasOneRef(v8stack_trace.p_v8stack_trace)
}

func (p *C.cef_v8stack_trace_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8stackTraceT) IsValid() (ret bool) {

	cRet := C.cefingo_v8stack_trace_is_valid(self.p_v8stack_trace)

	ret = cRet == 1
	return ret
}

///
// Returns the number of stack frames.
///
func (self *CV8stackTraceT) GetFrameCount() (ret bool) {

	cRet := C.cefingo_v8stack_trace_get_frame_count(self.p_v8stack_trace)

	ret = cRet == 1
	return ret
}

///
// Returns the stack frame at the specified 0-based index.
///
func (self *CV8stackTraceT) GetFrame(
	index int,
) (ret *CV8stackFrameT) {

	cRet := C.cefingo_v8stack_trace_get_frame(self.p_v8stack_trace, (C.int)(index))

	ret = newCV8stackFrameT(cRet)
	return ret
}

///
// Returns the stack trace for the currently active context. |frame_limit| is
// the maximum number of frames that will be captured.
///
func V8stackTraceGetCurrent(
	frame_limit int,
) (ret *CV8stackTraceT) {

	cRet := C.cef_v8stack_trace_get_current((C.int)(frame_limit))

	ret = newCV8stackTraceT(cRet)
	return ret
}

///
// Structure representing a V8 stack frame handle. V8 handles can only be
// accessed from the thread on which they are created. Valid threads for
// creating a V8 handle include the render process main thread (TID_RENDERER)
// and WebWorker threads. A task runner for posting tasks on the associated
// thread can be retrieved via the cef_v8context_t::get_task_runner() function.
///

// Go type for cef_v8stack_frame_t
type CV8stackFrameT struct {
	noCopy          noCopy
	p_v8stack_frame *C.cef_v8stack_frame_t
}

type RefToCV8stackFrameT struct {
	p_v8stack_frame *CV8stackFrameT
}

type CV8stackFrameTAccessor interface {
	GetCV8stackFrameT() *CV8stackFrameT
	SetCV8stackFrameT(*CV8stackFrameT)
}

func (r RefToCV8stackFrameT) GetCV8stackFrameT() *CV8stackFrameT {
	return r.p_v8stack_frame
}

func (r *RefToCV8stackFrameT) SetCV8stackFrameT(p *CV8stackFrameT) {
	r.p_v8stack_frame = p
}

// Go type CV8stackFrameT wraps cef type *C.cef_v8stack_frame_t
func newCV8stackFrameT(p *C.cef_v8stack_frame_t) *CV8stackFrameT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T24460:")
	BaseAddRef(p)
	go_v8stack_frame := CV8stackFrameT{noCopy{}, p}
	runtime.SetFinalizer(&go_v8stack_frame, func(g *CV8stackFrameT) {
		Tracef(unsafe.Pointer(g.p_v8stack_frame), "T24464:")
		BaseRelease(g.p_v8stack_frame)
	})
	return &go_v8stack_frame
}

// *C.cef_v8stack_frame_t has refCounted interface
func (v8stack_frame *CV8stackFrameT) HasOneRef() bool {
	return BaseHasOneRef(v8stack_frame.p_v8stack_frame)
}

func (p *C.cef_v8stack_frame_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8stackFrameT) IsValid() (ret bool) {

	cRet := C.cefingo_v8stack_frame_is_valid(self.p_v8stack_frame)

	ret = cRet == 1
	return ret
}

///
// Returns the name of the resource script that contains the function.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8stackFrameT) GetScriptName() (ret string) {

	cRet := C.cefingo_v8stack_frame_get_script_name(self.p_v8stack_frame)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the name of the resource script that contains the function or the
// sourceURL value if the script name is undefined and its source ends with a
// &quot;//@ sourceURL=...&quot; string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8stackFrameT) GetScriptNameOrSourceUrl() (ret string) {

	cRet := C.cefingo_v8stack_frame_get_script_name_or_source_url(self.p_v8stack_frame)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the name of the function.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8stackFrameT) GetFunctionName() (ret string) {

	cRet := C.cefingo_v8stack_frame_get_function_name(self.p_v8stack_frame)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the 1-based line number for the function call or 0 if unknown.
///
func (self *CV8stackFrameT) GetLineNumber() (ret bool) {

	cRet := C.cefingo_v8stack_frame_get_line_number(self.p_v8stack_frame)

	ret = cRet == 1
	return ret
}

///
// Returns the 1-based column offset on the line for the function call or 0 if
// unknown.
///
func (self *CV8stackFrameT) GetColumn() (ret bool) {

	cRet := C.cefingo_v8stack_frame_get_column(self.p_v8stack_frame)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the function was compiled using eval().
///
func (self *CV8stackFrameT) IsEval() (ret bool) {

	cRet := C.cefingo_v8stack_frame_is_eval(self.p_v8stack_frame)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the function was called as a constructor via &quot;new&quot;.
///
func (self *CV8stackFrameT) IsConstructor() (ret bool) {

	cRet := C.cefingo_v8stack_frame_is_constructor(self.p_v8stack_frame)

	ret = cRet == 1
	return ret
}

///
// Register a new V8 extension with the specified JavaScript extension code and
// handler. Functions implemented by the handler are prototyped using the
// keyword 'native'. The calling of a native function is restricted to the scope
// in which the prototype of the native function is defined. This function may
// only be called on the render process main thread.
//
// Example JavaScript extension code: <pre>
//   // create the 'example' global object if it doesn't already exist.
//   if (!example)
//     example = {};
//   // create the 'example.test' global object if it doesn't already exist.
//   if (!example.test)
//     example.test = {};
//   (function() {
//     // Define the function 'example.test.myfunction'.
//     example.test.myfunction = function() {
//       // Call CefV8Handler::Execute() with the function name 'MyFunction'
//       // and no arguments.
//       native function MyFunction();
//       return MyFunction();
//     };
//     // Define the getter function for parameter 'example.test.myparam'.
//     example.test.__defineGetter__('myparam', function() {
//       // Call CefV8Handler::Execute() with the function name 'GetMyParam'
//       // and no arguments.
//       native function GetMyParam();
//       return GetMyParam();
//     });
//     // Define the setter function for parameter 'example.test.myparam'.
//     example.test.__defineSetter__('myparam', function(b) {
//       // Call CefV8Handler::Execute() with the function name 'SetMyParam'
//       // and a single argument.
//       native function SetMyParam();
//       if(b) SetMyParam(b);
//     });
//
//     // Extension definitions can also contain normal JavaScript variables
//     // and functions.
//     var myint = 0;
//     example.test.increment = function() {
//       myint += 1;
//       return myint;
//     };
//   })();
// </pre> Example usage in the page: <pre>
//   // Call the function.
//   example.test.myfunction();
//   // Set the parameter.
//   example.test.myparam = value;
//   // Get the parameter.
//   value = example.test.myparam;
//   // Call another function.
//   example.test.increment();
// </pre>
///
func RegisterExtension(
	extension_name string,
	javascript_code string,
	handler *CV8handlerT,
) (ret bool) {
	c_extension_name := create_cef_string(extension_name)
	defer clear_cef_string(c_extension_name)
	c_javascript_code := create_cef_string(javascript_code)
	defer clear_cef_string(c_javascript_code)
	var goTmphandler *C.cef_v8handler_t
	if handler != nil {
		goTmphandler = handler.p_v8handler
		BaseAddRef(goTmphandler)
	}

	cRet := C.cef_register_extension((*C.cef_string_t)(c_extension_name), (*C.cef_string_t)(c_javascript_code), goTmphandler)

	ret = cRet == 1
	return ret
}

// cef_values_capi.h, include/capi/cef_values_capi.h:217:3,

///
// Structure that wraps other data value types. Complex types (binary,
// dictionary and list) will be referenced but not owned by this object. Can be
// used on any process and thread.
///

// Go type for cef_value_t
type CValueT struct {
	noCopy  noCopy
	p_value *C.cef_value_t
}

type RefToCValueT struct {
	p_value *CValueT
}

type CValueTAccessor interface {
	GetCValueT() *CValueT
	SetCValueT(*CValueT)
}

func (r RefToCValueT) GetCValueT() *CValueT {
	return r.p_value
}

func (r *RefToCValueT) SetCValueT(p *CValueT) {
	r.p_value = p
}

// Go type CValueT wraps cef type *C.cef_value_t
func newCValueT(p *C.cef_value_t) *CValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T24716:")
	BaseAddRef(p)
	go_value := CValueT{noCopy{}, p}
	runtime.SetFinalizer(&go_value, func(g *CValueT) {
		Tracef(unsafe.Pointer(g.p_value), "T24720:")
		BaseRelease(g.p_value)
	})
	return &go_value
}

// *C.cef_value_t has refCounted interface
func (value *CValueT) HasOneRef() bool {
	return BaseHasOneRef(value.p_value)
}

func (p *C.cef_value_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if the underlying data is valid. This will always be true
// (1) for simple types. For complex types (binary, dictionary and list) the
// underlying data may become invalid if owned by another object (e.g. list or
// dictionary) and that other object is then modified or destroyed. This value
// object can be re-used by calling Set*() even if the underlying data is
// invalid.
///
func (self *CValueT) IsValid() (ret bool) {

	cRet := C.cefingo_value_is_valid(self.p_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the underlying data is owned by another object.
///
func (self *CValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_value_is_owned(self.p_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the underlying data is read-only. Some APIs may expose
// read-only objects.
///
func (self *CValueT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_value_is_read_only(self.p_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data. If true (1) modifications to this object will also affect |that|
// object and vice-versa.
///
func (self *CValueT) IsSame(
	that *CValueT,
) (ret bool) {
	var goTmpthat *C.cef_value_t
	if that != nil {
		goTmpthat = that.p_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_value_is_same(self.p_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CValueT) IsEqual(
	that *CValueT,
) (ret bool) {
	var goTmpthat *C.cef_value_t
	if that != nil {
		goTmpthat = that.p_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_value_is_equal(self.p_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a copy of this object. The underlying data will also be copied.
///
func (self *CValueT) Copy() (ret *CValueT) {

	cRet := C.cefingo_value_copy(self.p_value)

	ret = newCValueT(cRet)
	return ret
}

///
// Returns the underlying value type.
///
func (self *CValueT) GetType() (ret CValueTypeT) {

	cRet := C.cefingo_value_get_type(self.p_value)

	ret = CValueTypeT(cRet)
	return ret
}

///
// Returns the underlying value as type bool.
///
func (self *CValueT) GetBool() (ret bool) {

	cRet := C.cefingo_value_get_bool(self.p_value)

	ret = cRet == 1
	return ret
}

///
// Returns the underlying value as type int.
///
func (self *CValueT) GetInt() (ret bool) {

	cRet := C.cefingo_value_get_int(self.p_value)

	ret = cRet == 1
	return ret
}

///
// Returns the underlying value as type double.
///
func (self *CValueT) GetDouble() (ret float64) {

	cRet := C.cefingo_value_get_double(self.p_value)

	ret = (float64)(cRet)
	return ret
}

///
// Returns the underlying value as type string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CValueT) GetString() (ret string) {

	cRet := C.cefingo_value_get_string(self.p_value)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the underlying value as type binary. The returned reference may
// become invalid if the value is owned by another object or if ownership is
// transferred to another object in the future. To maintain a reference to the
// value after assigning ownership to a dictionary or list pass this object to
// the set_value() function instead of passing the returned reference to
// set_binary().
///
func (self *CValueT) GetBinary() (ret *CBinaryValueT) {

	cRet := C.cefingo_value_get_binary(self.p_value)

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Returns the underlying value as type dictionary. The returned reference may
// become invalid if the value is owned by another object or if ownership is
// transferred to another object in the future. To maintain a reference to the
// value after assigning ownership to a dictionary or list pass this object to
// the set_value() function instead of passing the returned reference to
// set_dictionary().
///
func (self *CValueT) GetDictionary() (ret *CDictionaryValueT) {

	cRet := C.cefingo_value_get_dictionary(self.p_value)

	ret = newCDictionaryValueT(cRet)
	return ret
}

///
// Returns the underlying value as type list. The returned reference may
// become invalid if the value is owned by another object or if ownership is
// transferred to another object in the future. To maintain a reference to the
// value after assigning ownership to a dictionary or list pass this object to
// the set_value() function instead of passing the returned reference to
// set_list().
///
func (self *CValueT) GetList() (ret *CListValueT) {

	cRet := C.cefingo_value_get_list(self.p_value)

	ret = newCListValueT(cRet)
	return ret
}

///
// Sets the underlying value as type null. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetNull() (ret bool) {

	cRet := C.cefingo_value_set_null(self.p_value)

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type bool. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetBool(
	value bool,
) (ret bool) {
	var tmpvalue int
	if value {
		tmpvalue = 1
	}

	cRet := C.cefingo_value_set_bool(self.p_value, C.int(tmpvalue))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type int. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetInt(
	value int,
) (ret bool) {

	cRet := C.cefingo_value_set_int(self.p_value, (C.int)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type double. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetDouble(
	value float64,
) (ret bool) {

	cRet := C.cefingo_value_set_double(self.p_value, (C.double)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type string. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetString(
	value string,
) (ret bool) {
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	cRet := C.cefingo_value_set_string(self.p_value, (*C.cef_string_t)(c_value))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type binary. Returns true (1) if the value was
// set successfully. This object keeps a reference to |value| and ownership of
// the underlying data remains unchanged.
///
func (self *CValueT) SetBinary(
	value *CBinaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_binary_value_t
	if value != nil {
		goTmpvalue = value.p_binary_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_value_set_binary(self.p_value, goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type dict. Returns true (1) if the value was
// set successfully. This object keeps a reference to |value| and ownership of
// the underlying data remains unchanged.
///
func (self *CValueT) SetDictionary(
	value *CDictionaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_dictionary_value_t
	if value != nil {
		goTmpvalue = value.p_dictionary_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_value_set_dictionary(self.p_value, goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type list. Returns true (1) if the value was
// set successfully. This object keeps a reference to |value| and ownership of
// the underlying data remains unchanged.
///
func (self *CValueT) SetList(
	value *CListValueT,
) (ret bool) {
	var goTmpvalue *C.cef_list_value_t
	if value != nil {
		goTmpvalue = value.p_list_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_value_set_list(self.p_value, goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Creates a new object.
///
func ValueCreate() (ret *CValueT) {

	cRet := C.cef_value_create()

	ret = newCValueT(cRet)
	return ret
}

///
// Structure representing a binary value. Can be used on any process and thread.
///

// Go type for cef_binary_value_t
type CBinaryValueT struct {
	noCopy         noCopy
	p_binary_value *C.cef_binary_value_t
}

type RefToCBinaryValueT struct {
	p_binary_value *CBinaryValueT
}

type CBinaryValueTAccessor interface {
	GetCBinaryValueT() *CBinaryValueT
	SetCBinaryValueT(*CBinaryValueT)
}

func (r RefToCBinaryValueT) GetCBinaryValueT() *CBinaryValueT {
	return r.p_binary_value
}

func (r *RefToCBinaryValueT) SetCBinaryValueT(p *CBinaryValueT) {
	r.p_binary_value = p
}

// Go type CBinaryValueT wraps cef type *C.cef_binary_value_t
func newCBinaryValueT(p *C.cef_binary_value_t) *CBinaryValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T25145:")
	BaseAddRef(p)
	go_binary_value := CBinaryValueT{noCopy{}, p}
	runtime.SetFinalizer(&go_binary_value, func(g *CBinaryValueT) {
		Tracef(unsafe.Pointer(g.p_binary_value), "T25149:")
		BaseRelease(g.p_binary_value)
	})
	return &go_binary_value
}

// *C.cef_binary_value_t has refCounted interface
func (binary_value *CBinaryValueT) HasOneRef() bool {
	return BaseHasOneRef(binary_value.p_binary_value)
}

func (p *C.cef_binary_value_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. This object may become invalid if
// the underlying data is owned by another object (e.g. list or dictionary)
// and that other object is then modified or destroyed. Do not call any other
// functions if this function returns false (0).
///
func (self *CBinaryValueT) IsValid() (ret bool) {

	cRet := C.cefingo_binary_value_is_valid(self.p_binary_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is currently owned by another object.
///
func (self *CBinaryValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_binary_value_is_owned(self.p_binary_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data.
///
func (self *CBinaryValueT) IsSame(
	that *CBinaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_binary_value_t
	if that != nil {
		goTmpthat = that.p_binary_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_binary_value_is_same(self.p_binary_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CBinaryValueT) IsEqual(
	that *CBinaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_binary_value_t
	if that != nil {
		goTmpthat = that.p_binary_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_binary_value_is_equal(self.p_binary_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a copy of this object. The data in this object will also be copied.
///
func (self *CBinaryValueT) Copy() (ret *CBinaryValueT) {

	cRet := C.cefingo_binary_value_copy(self.p_binary_value)

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Returns the data size.
///
func (self *CBinaryValueT) GetSize() (ret int64) {

	cRet := C.cefingo_binary_value_get_size(self.p_binary_value)

	ret = (int64)(cRet)
	return ret
}

///
// Read up to |buffer_size| number of bytes into |buffer|. Reading begins at
// the specified byte |data_offset|. Returns the number of bytes read.
///
func (self *CBinaryValueT) GetData(
	buffer unsafe.Pointer,
	buffer_size int64,
	data_offset int64,
) (ret int64) {

	cRet := C.cefingo_binary_value_get_data(self.p_binary_value, buffer, (C.size_t)(buffer_size), (C.size_t)(data_offset))

	ret = (int64)(cRet)
	return ret
}

///
// Creates a new object that is not owned by any other object. The specified
// |data| will be copied.
///
func BinaryValueCreate(
	data []byte,
) (ret *CBinaryValueT) {
	data_size := len(data)
	tmpdata := C.CBytes(data)

	cRet := C.cef_binary_value_create(tmpdata, (C.size_t)(data_size))

	C.free(tmpdata)

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Structure representing a dictionary value. Can be used on any process and
// thread.
///

// Go type for cef_dictionary_value_t
type CDictionaryValueT struct {
	noCopy             noCopy
	p_dictionary_value *C.cef_dictionary_value_t
}

type RefToCDictionaryValueT struct {
	p_dictionary_value *CDictionaryValueT
}

type CDictionaryValueTAccessor interface {
	GetCDictionaryValueT() *CDictionaryValueT
	SetCDictionaryValueT(*CDictionaryValueT)
}

func (r RefToCDictionaryValueT) GetCDictionaryValueT() *CDictionaryValueT {
	return r.p_dictionary_value
}

func (r *RefToCDictionaryValueT) SetCDictionaryValueT(p *CDictionaryValueT) {
	r.p_dictionary_value = p
}

// Go type CDictionaryValueT wraps cef type *C.cef_dictionary_value_t
func newCDictionaryValueT(p *C.cef_dictionary_value_t) *CDictionaryValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T25326:")
	BaseAddRef(p)
	go_dictionary_value := CDictionaryValueT{noCopy{}, p}
	runtime.SetFinalizer(&go_dictionary_value, func(g *CDictionaryValueT) {
		Tracef(unsafe.Pointer(g.p_dictionary_value), "T25330:")
		BaseRelease(g.p_dictionary_value)
	})
	return &go_dictionary_value
}

// *C.cef_dictionary_value_t has refCounted interface
func (dictionary_value *CDictionaryValueT) HasOneRef() bool {
	return BaseHasOneRef(dictionary_value.p_dictionary_value)
}

func (p *C.cef_dictionary_value_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. This object may become invalid if
// the underlying data is owned by another object (e.g. list or dictionary)
// and that other object is then modified or destroyed. Do not call any other
// functions if this function returns false (0).
///
func (self *CDictionaryValueT) IsValid() (ret bool) {

	cRet := C.cefingo_dictionary_value_is_valid(self.p_dictionary_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is currently owned by another object.
///
func (self *CDictionaryValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_dictionary_value_is_owned(self.p_dictionary_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CDictionaryValueT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_dictionary_value_is_read_only(self.p_dictionary_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data. If true (1) modifications to this object will also affect |that|
// object and vice-versa.
///
func (self *CDictionaryValueT) IsSame(
	that *CDictionaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_dictionary_value_t
	if that != nil {
		goTmpthat = that.p_dictionary_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_dictionary_value_is_same(self.p_dictionary_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CDictionaryValueT) IsEqual(
	that *CDictionaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_dictionary_value_t
	if that != nil {
		goTmpthat = that.p_dictionary_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_dictionary_value_is_equal(self.p_dictionary_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object. If |exclude_NULL_children| is true
// (1) any NULL dictionaries or lists will be excluded from the copy.
///
func (self *CDictionaryValueT) Copy(
	exclude_empty_children int,
) (ret *CDictionaryValueT) {

	cRet := C.cefingo_dictionary_value_copy(self.p_dictionary_value, (C.int)(exclude_empty_children))

	ret = newCDictionaryValueT(cRet)
	return ret
}

///
// Returns the number of values.
///
func (self *CDictionaryValueT) GetSize() (ret int64) {

	cRet := C.cefingo_dictionary_value_get_size(self.p_dictionary_value)

	ret = (int64)(cRet)
	return ret
}

///
// Removes all values. Returns true (1) on success.
///
func (self *CDictionaryValueT) Clear() (ret bool) {

	cRet := C.cefingo_dictionary_value_clear(self.p_dictionary_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the current dictionary has a value for the given key.
///
func (self *CDictionaryValueT) HasKey(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_has_key(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = cRet == 1
	return ret
}

///
// Reads all keys for this dictionary into the specified vector.
///
func (self *CDictionaryValueT) GetKeys(
	keys CStringListT,
) (ret bool) {

	cRet := C.cefingo_dictionary_value_get_keys(self.p_dictionary_value, (C.cef_string_list_t)(keys))

	ret = cRet == 1
	return ret
}

///
// Removes the value at the specified key. Returns true (1) is the value was
// removed successfully.
///
func (self *CDictionaryValueT) Remove(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_remove(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = cRet == 1
	return ret
}

///
// Returns the value type for the specified key.
///
func (self *CDictionaryValueT) GetType(
	key string,
) (ret CValueTypeT) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_type(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = CValueTypeT(cRet)
	return ret
}

///
// Returns the value at the specified key. For simple types the returned value
// will copy existing data and modifications to the value will not modify this
// object. For complex types (binary, dictionary and list) the returned value
// will reference existing data and modifications to the value will modify
// this object.
///
func (self *CDictionaryValueT) GetValue(
	key string,
) (ret *CValueT) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_value(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = newCValueT(cRet)
	return ret
}

///
// Returns the value at the specified key as type bool.
///
func (self *CDictionaryValueT) GetBool(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_bool(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = cRet == 1
	return ret
}

///
// Returns the value at the specified key as type int.
///
func (self *CDictionaryValueT) GetInt(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_int(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = cRet == 1
	return ret
}

///
// Returns the value at the specified key as type double.
///
func (self *CDictionaryValueT) GetDouble(
	key string,
) (ret float64) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_double(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = (float64)(cRet)
	return ret
}

///
// Returns the value at the specified key as type string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDictionaryValueT) GetString(
	key string,
) (ret string) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_string(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the value at the specified key as type binary. The returned value
// will reference existing data.
///
func (self *CDictionaryValueT) GetBinary(
	key string,
) (ret *CBinaryValueT) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_binary(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Returns the value at the specified key as type dictionary. The returned
// value will reference existing data and modifications to the value will
// modify this object.
///
func (self *CDictionaryValueT) GetDictionary(
	key string,
) (ret *CDictionaryValueT) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_dictionary(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = newCDictionaryValueT(cRet)
	return ret
}

///
// Returns the value at the specified key as type list. The returned value
// will reference existing data and modifications to the value will modify
// this object.
///
func (self *CDictionaryValueT) GetList(
	key string,
) (ret *CListValueT) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_get_list(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = newCListValueT(cRet)
	return ret
}

///
// Sets the value at the specified key. Returns true (1) if the value was set
// successfully. If |value| represents simple data then the underlying data
// will be copied and modifications to |value| will not modify this object. If
// |value| represents complex data (binary, dictionary or list) then the
// underlying data will be referenced and modifications to |value| will modify
// this object.
///
func (self *CDictionaryValueT) SetValue(
	key string,
	value *CValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)
	var goTmpvalue *C.cef_value_t
	if value != nil {
		goTmpvalue = value.p_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_dictionary_value_set_value(self.p_dictionary_value, (*C.cef_string_t)(c_key), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type null. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetNull(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_set_null(self.p_dictionary_value, (*C.cef_string_t)(c_key))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type bool. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetBool(
	key string,
	value bool,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)
	var tmpvalue int
	if value {
		tmpvalue = 1
	}

	cRet := C.cefingo_dictionary_value_set_bool(self.p_dictionary_value, (*C.cef_string_t)(c_key), C.int(tmpvalue))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type int. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetInt(
	key string,
	value int,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_set_int(self.p_dictionary_value, (*C.cef_string_t)(c_key), (C.int)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type double. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetDouble(
	key string,
	value float64,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)

	cRet := C.cefingo_dictionary_value_set_double(self.p_dictionary_value, (*C.cef_string_t)(c_key), (C.double)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type string. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetString(
	key string,
	value string,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	cRet := C.cefingo_dictionary_value_set_string(self.p_dictionary_value, (*C.cef_string_t)(c_key), (*C.cef_string_t)(c_value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type binary. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CDictionaryValueT) SetBinary(
	key string,
	value *CBinaryValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)
	var goTmpvalue *C.cef_binary_value_t
	if value != nil {
		goTmpvalue = value.p_binary_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_dictionary_value_set_binary(self.p_dictionary_value, (*C.cef_string_t)(c_key), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type dict. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CDictionaryValueT) SetDictionary(
	key string,
	value *CDictionaryValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)
	var goTmpvalue *C.cef_dictionary_value_t
	if value != nil {
		goTmpvalue = value.p_dictionary_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_dictionary_value_set_dictionary(self.p_dictionary_value, (*C.cef_string_t)(c_key), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type list. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CDictionaryValueT) SetList(
	key string,
	value *CListValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	defer clear_cef_string(c_key)
	var goTmpvalue *C.cef_list_value_t
	if value != nil {
		goTmpvalue = value.p_list_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_dictionary_value_set_list(self.p_dictionary_value, (*C.cef_string_t)(c_key), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Creates a new object that is not owned by any other object.
///
func DictionaryValueCreate() (ret *CDictionaryValueT) {

	cRet := C.cef_dictionary_value_create()

	ret = newCDictionaryValueT(cRet)
	return ret
}

///
// Structure representing a list value. Can be used on any process and thread.
///

// Go type for cef_list_value_t
type CListValueT struct {
	noCopy       noCopy
	p_list_value *C.cef_list_value_t
}

type RefToCListValueT struct {
	p_list_value *CListValueT
}

type CListValueTAccessor interface {
	GetCListValueT() *CListValueT
	SetCListValueT(*CListValueT)
}

func (r RefToCListValueT) GetCListValueT() *CListValueT {
	return r.p_list_value
}

func (r *RefToCListValueT) SetCListValueT(p *CListValueT) {
	r.p_list_value = p
}

// Go type CListValueT wraps cef type *C.cef_list_value_t
func newCListValueT(p *C.cef_list_value_t) *CListValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T25919:")
	BaseAddRef(p)
	go_list_value := CListValueT{noCopy{}, p}
	runtime.SetFinalizer(&go_list_value, func(g *CListValueT) {
		Tracef(unsafe.Pointer(g.p_list_value), "T25923:")
		BaseRelease(g.p_list_value)
	})
	return &go_list_value
}

// *C.cef_list_value_t has refCounted interface
func (list_value *CListValueT) HasOneRef() bool {
	return BaseHasOneRef(list_value.p_list_value)
}

func (p *C.cef_list_value_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns true (1) if this object is valid. This object may become invalid if
// the underlying data is owned by another object (e.g. list or dictionary)
// and that other object is then modified or destroyed. Do not call any other
// functions if this function returns false (0).
///
func (self *CListValueT) IsValid() (ret bool) {

	cRet := C.cefingo_list_value_is_valid(self.p_list_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is currently owned by another object.
///
func (self *CListValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_list_value_is_owned(self.p_list_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CListValueT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_list_value_is_read_only(self.p_list_value)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data. If true (1) modifications to this object will also affect |that|
// object and vice-versa.
///
func (self *CListValueT) IsSame(
	that *CListValueT,
) (ret bool) {
	var goTmpthat *C.cef_list_value_t
	if that != nil {
		goTmpthat = that.p_list_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_list_value_is_same(self.p_list_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CListValueT) IsEqual(
	that *CListValueT,
) (ret bool) {
	var goTmpthat *C.cef_list_value_t
	if that != nil {
		goTmpthat = that.p_list_value
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_list_value_is_equal(self.p_list_value, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object.
///
func (self *CListValueT) Copy() (ret *CListValueT) {

	cRet := C.cefingo_list_value_copy(self.p_list_value)

	ret = newCListValueT(cRet)
	return ret
}

///
// Sets the number of values. If the number of values is expanded all new
// value slots will default to type null. Returns true (1) on success.
///
func (self *CListValueT) SetSize(
	size int64,
) (ret bool) {

	cRet := C.cefingo_list_value_set_size(self.p_list_value, (C.size_t)(size))

	ret = cRet == 1
	return ret
}

///
// Returns the number of values.
///
func (self *CListValueT) GetSize() (ret int64) {

	cRet := C.cefingo_list_value_get_size(self.p_list_value)

	ret = (int64)(cRet)
	return ret
}

///
// Removes all values. Returns true (1) on success.
///
func (self *CListValueT) Clear() (ret bool) {

	cRet := C.cefingo_list_value_clear(self.p_list_value)

	ret = cRet == 1
	return ret
}

///
// Removes the value at the specified index.
///
func (self *CListValueT) Remove(
	index int64,
) (ret bool) {

	cRet := C.cefingo_list_value_remove(self.p_list_value, (C.size_t)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the value type at the specified index.
///
func (self *CListValueT) GetType(
	index int64,
) (ret CValueTypeT) {

	cRet := C.cefingo_list_value_get_type(self.p_list_value, (C.size_t)(index))

	ret = CValueTypeT(cRet)
	return ret
}

///
// Returns the value at the specified index. For simple types the returned
// value will copy existing data and modifications to the value will not
// modify this object. For complex types (binary, dictionary and list) the
// returned value will reference existing data and modifications to the value
// will modify this object.
///
func (self *CListValueT) GetValue(
	index int64,
) (ret *CValueT) {

	cRet := C.cefingo_list_value_get_value(self.p_list_value, (C.size_t)(index))

	ret = newCValueT(cRet)
	return ret
}

///
// Returns the value at the specified index as type bool.
///
func (self *CListValueT) GetBool(
	index int64,
) (ret bool) {

	cRet := C.cefingo_list_value_get_bool(self.p_list_value, (C.size_t)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the value at the specified index as type int.
///
func (self *CListValueT) GetInt(
	index int64,
) (ret int) {

	cRet := C.cefingo_list_value_get_int(self.p_list_value, (C.size_t)(index))

	ret = (int)(cRet)
	return ret
}

///
// Returns the value at the specified index as type double.
///
func (self *CListValueT) GetDouble(
	index int64,
) (ret float64) {

	cRet := C.cefingo_list_value_get_double(self.p_list_value, (C.size_t)(index))

	ret = (float64)(cRet)
	return ret
}

///
// Returns the value at the specified index as type string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CListValueT) GetString(
	index int64,
) (ret string) {

	cRet := C.cefingo_list_value_get_string(self.p_list_value, (C.size_t)(index))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the value at the specified index as type binary. The returned value
// will reference existing data.
///
func (self *CListValueT) GetBinary(
	index int64,
) (ret *CBinaryValueT) {

	cRet := C.cefingo_list_value_get_binary(self.p_list_value, (C.size_t)(index))

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Returns the value at the specified index as type dictionary. The returned
// value will reference existing data and modifications to the value will
// modify this object.
///
func (self *CListValueT) GetDictionary(
	index int64,
) (ret *CDictionaryValueT) {

	cRet := C.cefingo_list_value_get_dictionary(self.p_list_value, (C.size_t)(index))

	ret = newCDictionaryValueT(cRet)
	return ret
}

///
// Returns the value at the specified index as type list. The returned value
// will reference existing data and modifications to the value will modify
// this object.
///
func (self *CListValueT) GetList(
	index int64,
) (ret *CListValueT) {

	cRet := C.cefingo_list_value_get_list(self.p_list_value, (C.size_t)(index))

	ret = newCListValueT(cRet)
	return ret
}

///
// Sets the value at the specified index. Returns true (1) if the value was
// set successfully. If |value| represents simple data then the underlying
// data will be copied and modifications to |value| will not modify this
// object. If |value| represents complex data (binary, dictionary or list)
// then the underlying data will be referenced and modifications to |value|
// will modify this object.
///
func (self *CListValueT) SetValue(
	index int64,
	value *CValueT,
) (ret bool) {
	var goTmpvalue *C.cef_value_t
	if value != nil {
		goTmpvalue = value.p_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_list_value_set_value(self.p_list_value, (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type null. Returns true (1) if the
// value was set successfully.
///
func (self *CListValueT) SetNull(
	index int64,
) (ret bool) {

	cRet := C.cefingo_list_value_set_null(self.p_list_value, (C.size_t)(index))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type bool. Returns true (1) if the
// value was set successfully.
///
func (self *CListValueT) SetBool(
	index int64,
	value bool,
) (ret bool) {
	var tmpvalue int
	if value {
		tmpvalue = 1
	}

	cRet := C.cefingo_list_value_set_bool(self.p_list_value, (C.size_t)(index), C.int(tmpvalue))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type int. Returns true (1) if the
// value was set successfully.
///
func (self *CListValueT) SetInt(
	index int64,
	value int,
) (ret bool) {

	cRet := C.cefingo_list_value_set_int(self.p_list_value, (C.size_t)(index), (C.int)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type double. Returns true (1) if
// the value was set successfully.
///
func (self *CListValueT) SetDouble(
	index int64,
	value float64,
) (ret bool) {

	cRet := C.cefingo_list_value_set_double(self.p_list_value, (C.size_t)(index), (C.double)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type string. Returns true (1) if
// the value was set successfully.
///
func (self *CListValueT) SetString(
	index int64,
	value string,
) (ret bool) {
	c_value := create_cef_string(value)
	defer clear_cef_string(c_value)

	cRet := C.cefingo_list_value_set_string(self.p_list_value, (C.size_t)(index), (*C.cef_string_t)(c_value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type binary. Returns true (1) if
// the value was set successfully. If |value| is currently owned by another
// object then the value will be copied and the |value| reference will not
// change. Otherwise, ownership will be transferred to this object and the
// |value| reference will be invalidated.
///
func (self *CListValueT) SetBinary(
	index int64,
	value *CBinaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_binary_value_t
	if value != nil {
		goTmpvalue = value.p_binary_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_list_value_set_binary(self.p_list_value, (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type dict. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CListValueT) SetDictionary(
	index int64,
	value *CDictionaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_dictionary_value_t
	if value != nil {
		goTmpvalue = value.p_dictionary_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_list_value_set_dictionary(self.p_list_value, (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type list. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CListValueT) SetList(
	index int64,
	value *CListValueT,
) (ret bool) {
	var goTmpvalue *C.cef_list_value_t
	if value != nil {
		goTmpvalue = value.p_list_value
		BaseAddRef(goTmpvalue)
	}

	cRet := C.cefingo_list_value_set_list(self.p_list_value, (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Creates a new object that is not owned by any other object.
///
func ListValueCreate() (ret *CListValueT) {

	cRet := C.cef_list_value_create()

	ret = newCListValueT(cRet)
	return ret
}

// cef_view_capi.h, include/capi/views/cef_view_capi.h:383:3,

///
// A View is a rectangle within the views View hierarchy. It is the base
// structure for all Views. All size and position values are in density
// independent pixels (DIP) unless otherwise indicated. Methods must be called
// on the browser process UI thread unless otherwise indicated.
///

// Go type for cef_view_t
type CViewT struct {
	noCopy noCopy
	p_view *C.cef_view_t
}

type RefToCViewT struct {
	p_view *CViewT
}

type CViewTAccessor interface {
	GetCViewT() *CViewT
	SetCViewT(*CViewT)
}

func (r RefToCViewT) GetCViewT() *CViewT {
	return r.p_view
}

func (r *RefToCViewT) SetCViewT(p *CViewT) {
	r.p_view = p
}

// Go type CViewT wraps cef type *C.cef_view_t
func newCViewT(p *C.cef_view_t) *CViewT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T26461:")
	BaseAddRef(p)
	go_view := CViewT{noCopy{}, p}
	runtime.SetFinalizer(&go_view, func(g *CViewT) {
		Tracef(unsafe.Pointer(g.p_view), "T26465:")
		BaseRelease(g.p_view)
	})
	return &go_view
}

// *C.cef_view_t has refCounted interface
func (view *CViewT) HasOneRef() bool {
	return BaseHasOneRef(view.p_view)
}

func (p *C.cef_view_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns this View as a BrowserView or NULL if this is not a BrowserView.
///
func (self *CViewT) AsBrowserView() (ret *CBrowserViewT) {

	cRet := C.cefingo_view_as_browser_view(self.p_view)

	ret = newCBrowserViewT(cRet)
	return ret
}

///
// Returns this View as a Button or NULL if this is not a Button.
///
func (self *CViewT) AsButton() (ret *CButtonT) {

	cRet := C.cefingo_view_as_button(self.p_view)

	ret = newCButtonT(cRet)
	return ret
}

///
// Returns this View as a Panel or NULL if this is not a Panel.
///
func (self *CViewT) AsPanel() (ret *CPanelT) {

	cRet := C.cefingo_view_as_panel(self.p_view)

	ret = newCPanelT(cRet)
	return ret
}

///
// Returns this View as a ScrollView or NULL if this is not a ScrollView.
///
func (self *CViewT) AsScrollView() (ret *CScrollViewT) {

	cRet := C.cefingo_view_as_scroll_view(self.p_view)

	ret = newCScrollViewT(cRet)
	return ret
}

///
// Returns this View as a Textfield or NULL if this is not a Textfield.
///
func (self *CViewT) AsTextfield() (ret *CTextfieldT) {

	cRet := C.cefingo_view_as_textfield(self.p_view)

	ret = newCTextfieldT(cRet)
	return ret
}

///
// Returns the type of this View as a string. Used primarily for testing
// purposes.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CViewT) GetTypeString() (ret string) {

	cRet := C.cefingo_view_get_type_string(self.p_view)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a string representation of this View which includes the type and
// various type-specific identifying attributes. If |include_children| is true
// (1) any child Views will also be included. Used primarily for testing
// purposes.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CViewT) ToString(
	include_children int,
) (ret string) {

	cRet := C.cefingo_view_to_string(self.p_view, (C.int)(include_children))

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this View is valid.
///
func (self *CViewT) IsValid() (ret bool) {

	cRet := C.cefingo_view_is_valid(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this View is currently attached to another View. A View
// can only be attached to one View at a time.
///
func (self *CViewT) IsAttached() (ret bool) {

	cRet := C.cefingo_view_is_attached(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this View is the same as |that| View.
///
func (self *CViewT) IsSame(
	that *CViewT,
) (ret bool) {
	var goTmpthat *C.cef_view_t
	if that != nil {
		goTmpthat = that.p_view
		BaseAddRef(goTmpthat)
	}

	cRet := C.cefingo_view_is_same(self.p_view, goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns the delegate associated with this View, if any.
///
func (self *CViewT) GetDelegate() (ret *CViewDelegateT) {

	cRet := C.cefingo_view_get_delegate(self.p_view)

	ret = newCViewDelegateT(cRet)
	return ret
}

///
// Returns the top-level Window hosting this View, if any.
///
func (self *CViewT) GetWindow() (ret *CWindowT) {

	cRet := C.cefingo_view_get_window(self.p_view)

	ret = newCWindowT(cRet)
	return ret
}

///
// Returns the ID for this View.
///
func (self *CViewT) GetId() (ret bool) {

	cRet := C.cefingo_view_get_id(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Sets the ID for this View. ID should be unique within the subtree that you
// intend to search for it. 0 is the default ID for views.
///
func (self *CViewT) SetId(
	id int,
) {

	C.cefingo_view_set_id(self.p_view, (C.int)(id))

}

///
// Returns the group id of this View, or -1 if not set.
///
func (self *CViewT) GetGroupId() (ret bool) {

	cRet := C.cefingo_view_get_group_id(self.p_view)

	ret = cRet == 1
	return ret
}

///
// A group id is used to tag Views which are part of the same logical group.
// Focus can be moved between views with the same group using the arrow keys.
// The group id is immutable once it&#39;s set.
///
func (self *CViewT) SetGroupId(
	group_id int,
) {

	C.cefingo_view_set_group_id(self.p_view, (C.int)(group_id))

}

///
// Returns the View that contains this View, if any.
///
func (self *CViewT) GetParentView() (ret *CViewT) {

	cRet := C.cefingo_view_get_parent_view(self.p_view)

	ret = newCViewT(cRet)
	return ret
}

///
// Recursively descends the view tree starting at this View, and returns the
// first child that it encounters with the given ID. Returns NULL if no
// matching child view is found.
///
func (self *CViewT) GetViewForId(
	id int,
) (ret *CViewT) {

	cRet := C.cefingo_view_get_view_for_id(self.p_view, (C.int)(id))

	ret = newCViewT(cRet)
	return ret
}

///
// Sets the bounds (size and position) of this View. Position is in parent
// coordinates.
///
func (self *CViewT) SetBounds(
	bounds *CRectT,
) {

	C.cefingo_view_set_bounds(self.p_view, (*C.cef_rect_t)(bounds))

}

///
// Returns the bounds (size and position) of this View. Position is in parent
// coordinates.
///
func (self *CViewT) GetBounds() (ret CRectT) {

	cRet := C.cefingo_view_get_bounds(self.p_view)

	ret = (CRectT)(cRet)
	return ret
}

///
// Returns the bounds (size and position) of this View. Position is in screen
// coordinates.
///
func (self *CViewT) GetBoundsInScreen() (ret CRectT) {

	cRet := C.cefingo_view_get_bounds_in_screen(self.p_view)

	ret = (CRectT)(cRet)
	return ret
}

///
// Sets the size of this View without changing the position.
///
func (self *CViewT) SetSize(
	size *CSizeT,
) {

	C.cefingo_view_set_size(self.p_view, (*C.cef_size_t)(size))

}

///
// Returns the size of this View.
///
func (self *CViewT) GetSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_size(self.p_view)

	ret = (CSizeT)(cRet)
	return ret
}

///
// Sets the position of this View without changing the size. |position| is in
// parent coordinates.
///
func (self *CViewT) SetPosition(
	position *CPointT,
) {

	C.cefingo_view_set_position(self.p_view, (*C.cef_point_t)(position))

}

///
// Returns the position of this View. Position is in parent coordinates.
///
func (self *CViewT) GetPosition() (ret CPointT) {

	cRet := C.cefingo_view_get_position(self.p_view)

	ret = (CPointT)(cRet)
	return ret
}

///
// Returns the size this View would like to be if enough space is available.
///
func (self *CViewT) GetPreferredSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_preferred_size(self.p_view)

	ret = (CSizeT)(cRet)
	return ret
}

///
// Size this View to its preferred size.
///
func (self *CViewT) SizeToPreferredSize() {

	C.cefingo_view_size_to_preferred_size(self.p_view)

}

///
// Returns the minimum size for this View.
///
func (self *CViewT) GetMinimumSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_minimum_size(self.p_view)

	ret = (CSizeT)(cRet)
	return ret
}

///
// Returns the maximum size for this View.
///
func (self *CViewT) GetMaximumSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_maximum_size(self.p_view)

	ret = (CSizeT)(cRet)
	return ret
}

///
// Returns the height necessary to display this View with the provided width.
///
func (self *CViewT) GetHeightForWidth(
	width int,
) (ret bool) {

	cRet := C.cefingo_view_get_height_for_width(self.p_view, (C.int)(width))

	ret = cRet == 1
	return ret
}

///
// Indicate that this View and all parent Views require a re-layout. This
// ensures the next call to layout() will propagate to this View even if the
// bounds of parent Views do not change.
///
func (self *CViewT) InvalidateLayout() {

	C.cefingo_view_invalidate_layout(self.p_view)

}

///
// Sets whether this View is visible. Windows are hidden by default and other
// views are visible by default. This View and any parent views must be set as
// visible for this View to be drawn in a Window. If this View is set as
// hidden then it and any child views will not be drawn and, if any of those
// views currently have focus, then focus will also be cleared. Painting is
// scheduled as needed. If this View is a Window then calling this function is
// equivalent to calling the Window show() and hide() functions.
///
func (self *CViewT) SetVisible(
	visible int,
) {

	C.cefingo_view_set_visible(self.p_view, (C.int)(visible))

}

///
// Returns whether this View is visible. A view may be visible but still not
// drawn in a Window if any parent views are hidden. If this View is a Window
// then a return value of true (1) indicates that this Window is currently
// visible to the user on-screen. If this View is not a Window then call
// is_drawn() to determine whether this View and all parent views are visible
// and will be drawn.
///
func (self *CViewT) IsVisible() (ret bool) {

	cRet := C.cefingo_view_is_visible(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Returns whether this View is visible and drawn in a Window. A view is drawn
// if it and all parent views are visible. If this View is a Window then
// calling this function is equivalent to calling is_visible(). Otherwise, to
// determine if the containing Window is visible to the user on-screen call
// is_visible() on the Window.
///
func (self *CViewT) IsDrawn() (ret bool) {

	cRet := C.cefingo_view_is_drawn(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Set whether this View is enabled. A disabled View does not receive keyboard
// or mouse inputs. If |enabled| differs from the current value the View will
// be repainted. Also, clears focus if the focused View is disabled.
///
func (self *CViewT) SetEnabled(
	enabled int,
) {

	C.cefingo_view_set_enabled(self.p_view, (C.int)(enabled))

}

///
// Returns whether this View is enabled.
///
func (self *CViewT) IsEnabled() (ret bool) {

	cRet := C.cefingo_view_is_enabled(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Sets whether this View is capable of taking focus. It will clear focus if
// the focused View is set to be non-focusable. This is false (0) by default
// so that a View used as a container does not get the focus.
///
func (self *CViewT) SetFocusable(
	focusable bool,
) {
	var tmpfocusable int
	if focusable {
		tmpfocusable = 1
	}

	C.cefingo_view_set_focusable(self.p_view, C.int(tmpfocusable))

}

///
// Returns true (1) if this View is focusable, enabled and drawn.
///
func (self *CViewT) IsFocusable() (ret bool) {

	cRet := C.cefingo_view_is_focusable(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Return whether this View is focusable when the user requires full keyboard
// access, even though it may not be normally focusable.
///
func (self *CViewT) IsAccessibilityFocusable() (ret bool) {

	cRet := C.cefingo_view_is_accessibility_focusable(self.p_view)

	ret = cRet == 1
	return ret
}

///
// Request keyboard focus. If this View is focusable it will become the
// focused View.
///
func (self *CViewT) RequestFocus() {

	C.cefingo_view_request_focus(self.p_view)

}

///
// Sets the background color for this View.
///
func (self *CViewT) SetBackgroundColor(
	color CColorT,
) {

	C.cefingo_view_set_background_color(self.p_view, (C.cef_color_t)(color))

}

///
// Returns the background color for this View.
///
func (self *CViewT) GetBackgroundColor() (ret CColorT) {

	cRet := C.cefingo_view_get_background_color(self.p_view)

	ret = (CColorT)(cRet)
	return ret
}

///
// Convert |point| from this View&#39;s coordinate system to that of the screen.
// This View must belong to a Window when calling this function. Returns true
// (1) if the conversion is successful or false (0) otherwise. Use
// cef_display_t::convert_point_to_pixels() after calling this function if
// further conversion to display-specific pixel coordinates is desired.
///
func (self *CViewT) ConvertPointToScreen(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_to_screen(self.p_view, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| to this View&#39;s coordinate system from that of the screen.
// This View must belong to a Window when calling this function. Returns true
// (1) if the conversion is successful or false (0) otherwise. Use
// cef_display_t::convert_point_from_pixels() before calling this function if
// conversion from display-specific pixel coordinates is necessary.
///
func (self *CViewT) ConvertPointFromScreen(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_from_screen(self.p_view, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| from this View&#39;s coordinate system to that of the Window.
// This View must belong to a Window when calling this function. Returns true
// (1) if the conversion is successful or false (0) otherwise.
///
func (self *CViewT) ConvertPointToWindow(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_to_window(self.p_view, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| to this View&#39;s coordinate system from that of the Window.
// This View must belong to a Window when calling this function. Returns true
// (1) if the conversion is successful or false (0) otherwise.
///
func (self *CViewT) ConvertPointFromWindow(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_from_window(self.p_view, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| from this View&#39;s coordinate system to that of |view|.
// |view| needs to be in the same Window but not necessarily the same view
// hierarchy. Returns true (1) if the conversion is successful or false (0)
// otherwise.
///
func (self *CViewT) ConvertPointToView(
	view *CViewT,
	point *CPointT,
) (ret bool) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	cRet := C.cefingo_view_convert_point_to_view(self.p_view, goTmpview, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| to this View&#39;s coordinate system from that |view|. |view|
// needs to be in the same Window but not necessarily the same view hierarchy.
// Returns true (1) if the conversion is successful or false (0) otherwise.
///
func (self *CViewT) ConvertPointFromView(
	view *CViewT,
	point *CPointT,
) (ret bool) {
	var goTmpview *C.cef_view_t
	if view != nil {
		goTmpview = view.p_view
		BaseAddRef(goTmpview)
	}

	cRet := C.cefingo_view_convert_point_from_view(self.p_view, goTmpview, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

// cef_view_delegate_capi.h, include/capi/views/cef_view_delegate_capi.h:128:3,

///
// Implement this structure to handle view events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_view_delegate_t
type CViewDelegateT struct {
	noCopy          noCopy
	p_view_delegate *C.cef_view_delegate_t
}

type RefToCViewDelegateT struct {
	p_view_delegate *CViewDelegateT
}

type CViewDelegateTAccessor interface {
	GetCViewDelegateT() *CViewDelegateT
	SetCViewDelegateT(*CViewDelegateT)
}

func (r RefToCViewDelegateT) GetCViewDelegateT() *CViewDelegateT {
	return r.p_view_delegate
}

func (r *RefToCViewDelegateT) SetCViewDelegateT(p *CViewDelegateT) {
	r.p_view_delegate = p
}

// Go type CViewDelegateT wraps cef type *C.cef_view_delegate_t
func newCViewDelegateT(p *C.cef_view_delegate_t) *CViewDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T27219:")
	BaseAddRef(p)
	go_view_delegate := CViewDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_view_delegate, func(g *CViewDelegateT) {
		Tracef(unsafe.Pointer(g.p_view_delegate), "T27223:")
		BaseRelease(g.p_view_delegate)
	})
	return &go_view_delegate
}

// *C.cef_view_delegate_t has refCounted interface
func (view_delegate *CViewDelegateT) HasOneRef() bool {
	return BaseHasOneRef(view_delegate.p_view_delegate)
}

func (p *C.cef_view_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
type GetPreferredSizeHandler interface {
	GetPreferredSize(
		self *CViewDelegateT,
		view *CViewT,
	) (ret CSizeT)
}

///
// Return the minimum size for |view|.
///
type GetMinimumSizeHandler interface {
	GetMinimumSize(
		self *CViewDelegateT,
		view *CViewT,
	) (ret CSizeT)
}

///
// Return the maximum size for |view|.
///
type GetMaximumSizeHandler interface {
	GetMaximumSize(
		self *CViewDelegateT,
		view *CViewT,
	) (ret CSizeT)
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
type GetHeightForWidthHandler interface {
	GetHeightForWidth(
		self *CViewDelegateT,
		view *CViewT,
		width int,
	) (ret bool)
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
type OnParentViewChangedHandler interface {
	OnParentViewChanged(
		self *CViewDelegateT,
		view *CViewT,
		added int,
		parent *CViewT,
	)
}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
type OnChildViewChangedHandler interface {
	OnChildViewChanged(
		self *CViewDelegateT,
		view *CViewT,
		added int,
		child *CViewT,
	)
}

///
// Called when |view| gains focus.
///
type OnFocusHandler interface {
	OnFocus(
		self *CViewDelegateT,
		view *CViewT,
	)
}

///
// Called when |view| loses focus.
///
type OnBlurHandler interface {
	OnBlur(
		self *CViewDelegateT,
		view *CViewT,
	)
}

var view_delegate_handlers = struct {
	get_preferred_size_handler     map[*C.cef_view_delegate_t]GetPreferredSizeHandler
	get_minimum_size_handler       map[*C.cef_view_delegate_t]GetMinimumSizeHandler
	get_maximum_size_handler       map[*C.cef_view_delegate_t]GetMaximumSizeHandler
	get_height_for_width_handler   map[*C.cef_view_delegate_t]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*C.cef_view_delegate_t]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*C.cef_view_delegate_t]OnChildViewChangedHandler
	on_focus_handler               map[*C.cef_view_delegate_t]OnFocusHandler
	on_blur_handler                map[*C.cef_view_delegate_t]OnBlurHandler
}{
	map[*C.cef_view_delegate_t]GetPreferredSizeHandler{},
	map[*C.cef_view_delegate_t]GetMinimumSizeHandler{},
	map[*C.cef_view_delegate_t]GetMaximumSizeHandler{},
	map[*C.cef_view_delegate_t]GetHeightForWidthHandler{},
	map[*C.cef_view_delegate_t]OnParentViewChangedHandler{},
	map[*C.cef_view_delegate_t]OnChildViewChangedHandler{},
	map[*C.cef_view_delegate_t]OnFocusHandler{},
	map[*C.cef_view_delegate_t]OnBlurHandler{},
}

// AllocCViewDelegateT allocates CViewDelegateT and construct it
func AllocCViewDelegateT() *CViewDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_view_delegate_wrapper_t, "T27358:")
	cefp := C.cefingo_construct_view_delegate((*C.cefingo_view_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_view_delegate_t itself in DeassocFunc,
		// or cef_view_delegate_t is never GCed.
		Tracef(up, "T27364:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(view_delegate_handlers.get_preferred_size_handler, cefp)
		delete(view_delegate_handlers.get_minimum_size_handler, cefp)
		delete(view_delegate_handlers.get_maximum_size_handler, cefp)
		delete(view_delegate_handlers.get_height_for_width_handler, cefp)
		delete(view_delegate_handlers.on_parent_view_changed_handler, cefp)
		delete(view_delegate_handlers.on_child_view_changed_handler, cefp)
		delete(view_delegate_handlers.on_focus_handler, cefp)
		delete(view_delegate_handlers.on_blur_handler, cefp)
	}))

	return newCViewDelegateT(cefp)
}

func (view_delegate *CViewDelegateT) Bind(a interface{}) *CViewDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := view_delegate.p_view_delegate

	if h, ok := a.(GetPreferredSizeHandler); ok {
		view_delegate_handlers.get_preferred_size_handler[cp] = h
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		view_delegate_handlers.get_minimum_size_handler[cp] = h
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		view_delegate_handlers.get_maximum_size_handler[cp] = h
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		view_delegate_handlers.get_height_for_width_handler[cp] = h
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		view_delegate_handlers.on_parent_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		view_delegate_handlers.on_child_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnFocusHandler); ok {
		view_delegate_handlers.on_focus_handler[cp] = h
	}

	if h, ok := a.(OnBlurHandler); ok {
		view_delegate_handlers.on_blur_handler[cp] = h
	}

	if accessor, ok := a.(CViewDelegateTAccessor); ok {
		accessor.SetCViewDelegateT(view_delegate)
		Logf("T27433:")
	}

	return view_delegate
}

// cef_web_plugin_capi.h, include/capi/cef_web_plugin_capi.h:87:3,

///
// Information about a specific web plugin.
///

// Go type for cef_web_plugin_info_t
type CWebPluginInfoT struct {
	noCopy            noCopy
	p_web_plugin_info *C.cef_web_plugin_info_t
}

type RefToCWebPluginInfoT struct {
	p_web_plugin_info *CWebPluginInfoT
}

type CWebPluginInfoTAccessor interface {
	GetCWebPluginInfoT() *CWebPluginInfoT
	SetCWebPluginInfoT(*CWebPluginInfoT)
}

func (r RefToCWebPluginInfoT) GetCWebPluginInfoT() *CWebPluginInfoT {
	return r.p_web_plugin_info
}

func (r *RefToCWebPluginInfoT) SetCWebPluginInfoT(p *CWebPluginInfoT) {
	r.p_web_plugin_info = p
}

// Go type CWebPluginInfoT wraps cef type *C.cef_web_plugin_info_t
func newCWebPluginInfoT(p *C.cef_web_plugin_info_t) *CWebPluginInfoT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T27460:")
	BaseAddRef(p)
	go_web_plugin_info := CWebPluginInfoT{noCopy{}, p}
	runtime.SetFinalizer(&go_web_plugin_info, func(g *CWebPluginInfoT) {
		Tracef(unsafe.Pointer(g.p_web_plugin_info), "T27464:")
		BaseRelease(g.p_web_plugin_info)
	})
	return &go_web_plugin_info
}

// *C.cef_web_plugin_info_t has refCounted interface
func (web_plugin_info *CWebPluginInfoT) HasOneRef() bool {
	return BaseHasOneRef(web_plugin_info.p_web_plugin_info)
}

func (p *C.cef_web_plugin_info_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the plugin name (i.e. Flash).
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CWebPluginInfoT) GetName() (ret string) {

	cRet := C.cefingo_web_plugin_info_get_name(self.p_web_plugin_info)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the plugin file path (DLL/bundle/library).
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CWebPluginInfoT) GetPath() (ret string) {

	cRet := C.cefingo_web_plugin_info_get_path(self.p_web_plugin_info)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the version of the plugin (may be OS-specific).
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CWebPluginInfoT) GetVersion() (ret string) {

	cRet := C.cefingo_web_plugin_info_get_version(self.p_web_plugin_info)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a description of the plugin from the version information.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CWebPluginInfoT) GetDescription() (ret string) {

	cRet := C.cefingo_web_plugin_info_get_description(self.p_web_plugin_info)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Structure to implement for visiting web plugin information. The functions of
// this structure will be called on the browser process UI thread.
///

// Go type for cef_web_plugin_info_visitor_t
type CWebPluginInfoVisitorT struct {
	noCopy                    noCopy
	p_web_plugin_info_visitor *C.cef_web_plugin_info_visitor_t
}

type RefToCWebPluginInfoVisitorT struct {
	p_web_plugin_info_visitor *CWebPluginInfoVisitorT
}

type CWebPluginInfoVisitorTAccessor interface {
	GetCWebPluginInfoVisitorT() *CWebPluginInfoVisitorT
	SetCWebPluginInfoVisitorT(*CWebPluginInfoVisitorT)
}

func (r RefToCWebPluginInfoVisitorT) GetCWebPluginInfoVisitorT() *CWebPluginInfoVisitorT {
	return r.p_web_plugin_info_visitor
}

func (r *RefToCWebPluginInfoVisitorT) SetCWebPluginInfoVisitorT(p *CWebPluginInfoVisitorT) {
	r.p_web_plugin_info_visitor = p
}

// Go type CWebPluginInfoVisitorT wraps cef type *C.cef_web_plugin_info_visitor_t
func newCWebPluginInfoVisitorT(p *C.cef_web_plugin_info_visitor_t) *CWebPluginInfoVisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T27583:")
	BaseAddRef(p)
	go_web_plugin_info_visitor := CWebPluginInfoVisitorT{noCopy{}, p}
	runtime.SetFinalizer(&go_web_plugin_info_visitor, func(g *CWebPluginInfoVisitorT) {
		Tracef(unsafe.Pointer(g.p_web_plugin_info_visitor), "T27587:")
		BaseRelease(g.p_web_plugin_info_visitor)
	})
	return &go_web_plugin_info_visitor
}

// *C.cef_web_plugin_info_visitor_t has refCounted interface
func (web_plugin_info_visitor *CWebPluginInfoVisitorT) HasOneRef() bool {
	return BaseHasOneRef(web_plugin_info_visitor.p_web_plugin_info_visitor)
}

func (p *C.cef_web_plugin_info_visitor_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called once for each plugin. |count| is the 0-based
// index for the current plugin. |total| is the total number of plugins.
// Return false (0) to stop visiting plugins. This function may never be
// called if no plugins are found.
///
type CWebPluginInfoVisitorTVisitHandler interface {
	Visit(
		self *CWebPluginInfoVisitorT,
		info *CWebPluginInfoT,
		count int,
		total int,
	) (ret bool)
}

var web_plugin_info_visitor_handlers = struct {
	visit_handler map[*C.cef_web_plugin_info_visitor_t]CWebPluginInfoVisitorTVisitHandler
}{
	map[*C.cef_web_plugin_info_visitor_t]CWebPluginInfoVisitorTVisitHandler{},
}

// AllocCWebPluginInfoVisitorT allocates CWebPluginInfoVisitorT and construct it
func AllocCWebPluginInfoVisitorT() *CWebPluginInfoVisitorT {
	up := c_calloc(1, C.sizeof_cefingo_web_plugin_info_visitor_wrapper_t, "T27625:")
	cefp := C.cefingo_construct_web_plugin_info_visitor((*C.cefingo_web_plugin_info_visitor_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_web_plugin_info_visitor_t itself in DeassocFunc,
		// or cef_web_plugin_info_visitor_t is never GCed.
		Tracef(up, "T27631:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(web_plugin_info_visitor_handlers.visit_handler, cefp)
	}))

	return newCWebPluginInfoVisitorT(cefp)
}

func (web_plugin_info_visitor *CWebPluginInfoVisitorT) Bind(a interface{}) *CWebPluginInfoVisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := web_plugin_info_visitor.p_web_plugin_info_visitor

	if h, ok := a.(CWebPluginInfoVisitorTVisitHandler); ok {
		web_plugin_info_visitor_handlers.visit_handler[cp] = h
	}

	if accessor, ok := a.(CWebPluginInfoVisitorTAccessor); ok {
		accessor.SetCWebPluginInfoVisitorT(web_plugin_info_visitor)
		Logf("T27665:")
	}

	return web_plugin_info_visitor
}

///
// Structure to implement for receiving unstable plugin information. The
// functions of this structure will be called on the browser process IO thread.
///

// Go type for cef_web_plugin_unstable_callback_t
type CWebPluginUnstableCallbackT struct {
	noCopy                         noCopy
	p_web_plugin_unstable_callback *C.cef_web_plugin_unstable_callback_t
}

type RefToCWebPluginUnstableCallbackT struct {
	p_web_plugin_unstable_callback *CWebPluginUnstableCallbackT
}

type CWebPluginUnstableCallbackTAccessor interface {
	GetCWebPluginUnstableCallbackT() *CWebPluginUnstableCallbackT
	SetCWebPluginUnstableCallbackT(*CWebPluginUnstableCallbackT)
}

func (r RefToCWebPluginUnstableCallbackT) GetCWebPluginUnstableCallbackT() *CWebPluginUnstableCallbackT {
	return r.p_web_plugin_unstable_callback
}

func (r *RefToCWebPluginUnstableCallbackT) SetCWebPluginUnstableCallbackT(p *CWebPluginUnstableCallbackT) {
	r.p_web_plugin_unstable_callback = p
}

// Go type CWebPluginUnstableCallbackT wraps cef type *C.cef_web_plugin_unstable_callback_t
func newCWebPluginUnstableCallbackT(p *C.cef_web_plugin_unstable_callback_t) *CWebPluginUnstableCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T27691:")
	BaseAddRef(p)
	go_web_plugin_unstable_callback := CWebPluginUnstableCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_web_plugin_unstable_callback, func(g *CWebPluginUnstableCallbackT) {
		Tracef(unsafe.Pointer(g.p_web_plugin_unstable_callback), "T27695:")
		BaseRelease(g.p_web_plugin_unstable_callback)
	})
	return &go_web_plugin_unstable_callback
}

// *C.cef_web_plugin_unstable_callback_t has refCounted interface
func (web_plugin_unstable_callback *CWebPluginUnstableCallbackT) HasOneRef() bool {
	return BaseHasOneRef(web_plugin_unstable_callback.p_web_plugin_unstable_callback)
}

func (p *C.cef_web_plugin_unstable_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called for the requested plugin. |unstable| will be
// true (1) if the plugin has reached the crash count threshold of 3 times in
// 120 seconds.
///
type IsUnstableHandler interface {
	IsUnstable(
		self *CWebPluginUnstableCallbackT,
		path string,
		unstable int,
	)
}

var web_plugin_unstable_callback_handlers = struct {
	is_unstable_handler map[*C.cef_web_plugin_unstable_callback_t]IsUnstableHandler
}{
	map[*C.cef_web_plugin_unstable_callback_t]IsUnstableHandler{},
}

// AllocCWebPluginUnstableCallbackT allocates CWebPluginUnstableCallbackT and construct it
func AllocCWebPluginUnstableCallbackT() *CWebPluginUnstableCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_web_plugin_unstable_callback_wrapper_t, "T27731:")
	cefp := C.cefingo_construct_web_plugin_unstable_callback((*C.cefingo_web_plugin_unstable_callback_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_web_plugin_unstable_callback_t itself in DeassocFunc,
		// or cef_web_plugin_unstable_callback_t is never GCed.
		Tracef(up, "T27737:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(web_plugin_unstable_callback_handlers.is_unstable_handler, cefp)
	}))

	return newCWebPluginUnstableCallbackT(cefp)
}

func (web_plugin_unstable_callback *CWebPluginUnstableCallbackT) Bind(a interface{}) *CWebPluginUnstableCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := web_plugin_unstable_callback.p_web_plugin_unstable_callback

	if h, ok := a.(IsUnstableHandler); ok {
		web_plugin_unstable_callback_handlers.is_unstable_handler[cp] = h
	}

	if accessor, ok := a.(CWebPluginUnstableCallbackTAccessor); ok {
		accessor.SetCWebPluginUnstableCallbackT(web_plugin_unstable_callback)
		Logf("T27771:")
	}

	return web_plugin_unstable_callback
}

///
// Implement this structure to receive notification when CDM registration is
// complete. The functions of this structure will be called on the browser
// process UI thread.
///

// Go type for cef_register_cdm_callback_t
type CRegisterCdmCallbackT struct {
	noCopy                  noCopy
	p_register_cdm_callback *C.cef_register_cdm_callback_t
}

type RefToCRegisterCdmCallbackT struct {
	p_register_cdm_callback *CRegisterCdmCallbackT
}

type CRegisterCdmCallbackTAccessor interface {
	GetCRegisterCdmCallbackT() *CRegisterCdmCallbackT
	SetCRegisterCdmCallbackT(*CRegisterCdmCallbackT)
}

func (r RefToCRegisterCdmCallbackT) GetCRegisterCdmCallbackT() *CRegisterCdmCallbackT {
	return r.p_register_cdm_callback
}

func (r *RefToCRegisterCdmCallbackT) SetCRegisterCdmCallbackT(p *CRegisterCdmCallbackT) {
	r.p_register_cdm_callback = p
}

// Go type CRegisterCdmCallbackT wraps cef type *C.cef_register_cdm_callback_t
func newCRegisterCdmCallbackT(p *C.cef_register_cdm_callback_t) *CRegisterCdmCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T27798:")
	BaseAddRef(p)
	go_register_cdm_callback := CRegisterCdmCallbackT{noCopy{}, p}
	runtime.SetFinalizer(&go_register_cdm_callback, func(g *CRegisterCdmCallbackT) {
		Tracef(unsafe.Pointer(g.p_register_cdm_callback), "T27802:")
		BaseRelease(g.p_register_cdm_callback)
	})
	return &go_register_cdm_callback
}

// *C.cef_register_cdm_callback_t has refCounted interface
func (register_cdm_callback *CRegisterCdmCallbackT) HasOneRef() bool {
	return BaseHasOneRef(register_cdm_callback.p_register_cdm_callback)
}

func (p *C.cef_register_cdm_callback_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Method that will be called when CDM registration is complete. |result| will
// be CEF_CDM_REGISTRATION_ERROR_NONE if registration completed successfully.
// Otherwise, |result| and |error_message| will contain additional information
// about why registration failed.
///
type OnCdmRegistrationCompleteHandler interface {
	OnCdmRegistrationComplete(
		self *CRegisterCdmCallbackT,
		result CCdmRegistrationErrorT,
		error_message string,
	)
}

var register_cdm_callback_handlers = struct {
	on_cdm_registration_complete_handler map[*C.cef_register_cdm_callback_t]OnCdmRegistrationCompleteHandler
}{
	map[*C.cef_register_cdm_callback_t]OnCdmRegistrationCompleteHandler{},
}

// AllocCRegisterCdmCallbackT allocates CRegisterCdmCallbackT and construct it
func AllocCRegisterCdmCallbackT() *CRegisterCdmCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_register_cdm_callback_wrapper_t, "T27839:")
	cefp := C.cefingo_construct_register_cdm_callback((*C.cefingo_register_cdm_callback_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_register_cdm_callback_t itself in DeassocFunc,
		// or cef_register_cdm_callback_t is never GCed.
		Tracef(up, "T27845:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(register_cdm_callback_handlers.on_cdm_registration_complete_handler, cefp)
	}))

	return newCRegisterCdmCallbackT(cefp)
}

func (register_cdm_callback *CRegisterCdmCallbackT) Bind(a interface{}) *CRegisterCdmCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := register_cdm_callback.p_register_cdm_callback

	if h, ok := a.(OnCdmRegistrationCompleteHandler); ok {
		register_cdm_callback_handlers.on_cdm_registration_complete_handler[cp] = h
	}

	if accessor, ok := a.(CRegisterCdmCallbackTAccessor); ok {
		accessor.SetCRegisterCdmCallbackT(register_cdm_callback)
		Logf("T27879:")
	}

	return register_cdm_callback
}

///
// Visit web plugin information. Can be called on any thread in the browser
// process.
///
func VisitWebPluginInfo(
	visitor *CWebPluginInfoVisitorT,
) {
	var goTmpvisitor *C.cef_web_plugin_info_visitor_t
	if visitor != nil {
		goTmpvisitor = visitor.p_web_plugin_info_visitor
		BaseAddRef(goTmpvisitor)
	}

	C.cef_visit_web_plugin_info(goTmpvisitor)

}

///
// Cause the plugin list to refresh the next time it is accessed regardless of
// whether it has already been loaded. Can be called on any thread in the
// browser process.
///
func RefreshWebPlugins() {

	C.cef_refresh_web_plugins()

}

///
// Unregister an internal plugin. This may be undone the next time
// cef_refresh_web_plugins() is called. Can be called on any thread in the
// browser process.
///
func UnregisterInternalWebPlugin(
	path string,
) {
	c_path := create_cef_string(path)
	defer clear_cef_string(c_path)

	C.cef_unregister_internal_web_plugin((*C.cef_string_t)(c_path))

}

///
// Register a plugin crash. Can be called on any thread in the browser process
// but will be executed on the IO thread.
///
func RegisterWebPluginCrash(
	path string,
) {
	c_path := create_cef_string(path)
	defer clear_cef_string(c_path)

	C.cef_register_web_plugin_crash((*C.cef_string_t)(c_path))

}

///
// Query if a plugin is unstable. Can be called on any thread in the browser
// process.
///
func IsWebPluginUnstable(
	path string,
	callback *CWebPluginUnstableCallbackT,
) {
	c_path := create_cef_string(path)
	defer clear_cef_string(c_path)
	var goTmpcallback *C.cef_web_plugin_unstable_callback_t
	if callback != nil {
		goTmpcallback = callback.p_web_plugin_unstable_callback
		BaseAddRef(goTmpcallback)
	}

	C.cef_is_web_plugin_unstable((*C.cef_string_t)(c_path), goTmpcallback)

}

///
// Register the Widevine CDM plugin.
//
// The client application is responsible for downloading an appropriate
// platform-specific CDM binary distribution from Google, extracting the
// contents, and building the required directory structure on the local machine.
// The cef_browser_host_t::StartDownload function and CefZipArchive structure
// can be used to implement this functionality in CEF. Contact Google via
// https://www.widevine.com/contact.html for details on CDM download.
//
// |path| is a directory that must contain the following files:
//   1. manifest.json file from the CDM binary distribution (see below).
//   2. widevinecdm file from the CDM binary distribution (e.g.
//      widevinecdm.dll on on Windows, libwidevinecdm.dylib on OS X,
//      libwidevinecdm.so on Linux).
//
// If any of these files are missing or if the manifest file has incorrect
// contents the registration will fail and |callback| will receive a |result|
// value of CEF_CDM_REGISTRATION_ERROR_INCORRECT_CONTENTS.
//
// The manifest.json file must contain the following keys:
//   A. "os": Supported OS (e.g. "mac", "win" or "linux").
//   B. "arch": Supported architecture (e.g. "ia32" or "x64").
//   C. "x-cdm-module-versions": Module API version (e.g. "4").
//   D. "x-cdm-interface-versions": Interface API version (e.g. "8").
//   E. "x-cdm-host-versions": Host API version (e.g. "8").
//   F. "version": CDM version (e.g. "1.4.8.903").
//   G. "x-cdm-codecs": List of supported codecs (e.g. "vp8,vp9.0,avc1").
//
// A through E are used to verify compatibility with the current Chromium
// version. If the CDM is not compatible the registration will fail and
// |callback| will receive a |result| value of
// CEF_CDM_REGISTRATION_ERROR_INCOMPATIBLE.
//
// |callback| will be executed asynchronously once registration is complete.
//
// On Linux this function must be called before cef_initialize() and the
// registration cannot be changed during runtime. If registration is not
// supported at the time that cef_register_widevine_cdm() is called then
// |callback| will receive a |result| value of
// CEF_CDM_REGISTRATION_ERROR_NOT_SUPPORTED.
///
func RegisterWidevineCdm(
	path string,
	callback *CRegisterCdmCallbackT,
) {
	c_path := create_cef_string(path)
	defer clear_cef_string(c_path)
	var goTmpcallback *C.cef_register_cdm_callback_t
	if callback != nil {
		goTmpcallback = callback.p_register_cdm_callback
		BaseAddRef(goTmpcallback)
	}

	C.cef_register_widevine_cdm((*C.cef_string_t)(c_path), goTmpcallback)

}

// cef_window_capi.h, include/capi/views/cef_window_capi.h:302:3,

///
// A Window is a top-level Window/widget in the Views hierarchy. By default it
// will have a non-client area with title bar, icon and buttons that supports
// moving and resizing. All size and position values are in density independent
// pixels (DIP) unless otherwise indicated. Methods must be called on the
// browser process UI thread unless otherwise indicated.
///

// Go type for cef_window_t
type CWindowT struct {
	noCopy   noCopy
	p_window *C.cef_window_t
}

type RefToCWindowT struct {
	p_window *CWindowT
}

type CWindowTAccessor interface {
	GetCWindowT() *CWindowT
	SetCWindowT(*CWindowT)
}

func (r RefToCWindowT) GetCWindowT() *CWindowT {
	return r.p_window
}

func (r *RefToCWindowT) SetCWindowT(p *CWindowT) {
	r.p_window = p
}

// Go type CWindowT wraps cef type *C.cef_window_t
func newCWindowT(p *C.cef_window_t) *CWindowT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T28052:")
	BaseAddRef(p)
	go_window := CWindowT{noCopy{}, p}
	runtime.SetFinalizer(&go_window, func(g *CWindowT) {
		Tracef(unsafe.Pointer(g.p_window), "T28056:")
		BaseRelease(g.p_window)
	})
	return &go_window
}

// *C.cef_window_t has refCounted interface
func (window *CWindowT) HasOneRef() bool {
	return BaseHasOneRef(window.p_window)
}

func (p *C.cef_window_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (window *CWindowT) ToCPanelT() *CPanelT {
	p := (*C.cef_panel_t)(unsafe.Pointer(window.p_window))
	return newCPanelT(p)
}

///
// Show the Window.
///
func (self *CWindowT) Show() {

	C.cefingo_window_show(self.p_window)

}

///
// Hide the Window.
///
func (self *CWindowT) Hide() {

	C.cefingo_window_hide(self.p_window)

}

///
// Sizes the Window to |size| and centers it in the current display.
///
func (self *CWindowT) CenterWindow(
	size *CSizeT,
) {

	C.cefingo_window_center_window(self.p_window, (*C.cef_size_t)(size))

}

///
// Close the Window.
///
func (self *CWindowT) Close() {

	C.cefingo_window_close(self.p_window)

}

///
// Returns true (1) if the Window has been closed.
///
func (self *CWindowT) IsClosed() (ret bool) {

	cRet := C.cefingo_window_is_closed(self.p_window)

	ret = cRet == 1
	return ret
}

///
// Activate the Window, assuming it already exists and is visible.
///
func (self *CWindowT) Activate() {

	C.cefingo_window_activate(self.p_window)

}

///
// Deactivate the Window, making the next Window in the Z order the active
// Window.
///
func (self *CWindowT) Deactivate() {

	C.cefingo_window_deactivate(self.p_window)

}

///
// Returns whether the Window is the currently active Window.
///
func (self *CWindowT) IsActive() (ret bool) {

	cRet := C.cefingo_window_is_active(self.p_window)

	ret = cRet == 1
	return ret
}

///
// Bring this Window to the top of other Windows in the Windowing system.
///
func (self *CWindowT) BringToTop() {

	C.cefingo_window_bring_to_top(self.p_window)

}

///
// Set the Window to be on top of other Windows in the Windowing system.
///
func (self *CWindowT) SetAlwaysOnTop(
	on_top int,
) {

	C.cefingo_window_set_always_on_top(self.p_window, (C.int)(on_top))

}

///
// Returns whether the Window has been set to be on top of other Windows in
// the Windowing system.
///
func (self *CWindowT) IsAlwaysOnTop() (ret bool) {

	cRet := C.cefingo_window_is_always_on_top(self.p_window)

	ret = cRet == 1
	return ret
}

///
// Maximize the Window.
///
func (self *CWindowT) Maximize() {

	C.cefingo_window_maximize(self.p_window)

}

///
// Minimize the Window.
///
func (self *CWindowT) Minimize() {

	C.cefingo_window_minimize(self.p_window)

}

///
// Restore the Window.
///
func (self *CWindowT) Restore() {

	C.cefingo_window_restore(self.p_window)

}

///
// Set fullscreen Window state.
///
func (self *CWindowT) SetFullscreen(
	fullscreen int,
) {

	C.cefingo_window_set_fullscreen(self.p_window, (C.int)(fullscreen))

}

///
// Returns true (1) if the Window is maximized.
///
func (self *CWindowT) IsMaximized() (ret bool) {

	cRet := C.cefingo_window_is_maximized(self.p_window)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the Window is minimized.
///
func (self *CWindowT) IsMinimized() (ret bool) {

	cRet := C.cefingo_window_is_minimized(self.p_window)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the Window is fullscreen.
///
func (self *CWindowT) IsFullscreen() (ret bool) {

	cRet := C.cefingo_window_is_fullscreen(self.p_window)

	ret = cRet == 1
	return ret
}

///
// Set the Window title.
///
func (self *CWindowT) SetTitle(
	title string,
) {
	c_title := create_cef_string(title)
	defer clear_cef_string(c_title)

	C.cefingo_window_set_title(self.p_window, (*C.cef_string_t)(c_title))

}

///
// Get the Window title.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CWindowT) GetTitle() (ret string) {

	cRet := C.cefingo_window_get_title(self.p_window)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the Window icon. This should be a 16x16 icon suitable for use in the
// Windows&#39;s title bar.
///
func (self *CWindowT) SetWindowIcon(
	image *CImageT,
) {
	var goTmpimage *C.cef_image_t
	if image != nil {
		goTmpimage = image.p_image
		BaseAddRef(goTmpimage)
	}

	C.cefingo_window_set_window_icon(self.p_window, goTmpimage)

}

///
// Get the Window icon.
///
func (self *CWindowT) GetWindowIcon() (ret *CImageT) {

	cRet := C.cefingo_window_get_window_icon(self.p_window)

	ret = newCImageT(cRet)
	return ret
}

///
// Set the Window App icon. This should be a larger icon for use in the host
// environment app switching UI. On Windows, this is the ICON_BIG used in Alt-
// Tab list and Windows taskbar. The Window icon will be used by default if no
// Window App icon is specified.
///
func (self *CWindowT) SetWindowAppIcon(
	image *CImageT,
) {
	var goTmpimage *C.cef_image_t
	if image != nil {
		goTmpimage = image.p_image
		BaseAddRef(goTmpimage)
	}

	C.cefingo_window_set_window_app_icon(self.p_window, goTmpimage)

}

///
// Get the Window App icon.
///
func (self *CWindowT) GetWindowAppIcon() (ret *CImageT) {

	cRet := C.cefingo_window_get_window_app_icon(self.p_window)

	ret = newCImageT(cRet)
	return ret
}

///
// Show a menu with contents |menu_model|. |screen_point| specifies the menu
// position in screen coordinates. |anchor_position| specifies how the menu
// will be anchored relative to |screen_point|.
///
func (self *CWindowT) ShowMenu(
	menu_model *CMenuModelT,
	screen_point *CPointT,
	anchor_position CMenuAnchorPositionT,
) {
	var goTmpmenu_model *C.cef_menu_model_t
	if menu_model != nil {
		goTmpmenu_model = menu_model.p_menu_model
		BaseAddRef(goTmpmenu_model)
	}

	C.cefingo_window_show_menu(self.p_window, goTmpmenu_model, (*C.cef_point_t)(screen_point), (C.cef_menu_anchor_position_t)(anchor_position))

}

///
// Cancel the menu that is currently showing, if any.
///
func (self *CWindowT) CancelMenu() {

	C.cefingo_window_cancel_menu(self.p_window)

}

///
// Returns the Display that most closely intersects the bounds of this Window.
// May return NULL if this Window is not currently displayed.
///
func (self *CWindowT) GetDisplay() (ret *CDisplayT) {

	cRet := C.cefingo_window_get_display(self.p_window)

	ret = newCDisplayT(cRet)
	return ret
}

///
// Returns the bounds (size and position) of this Window&#39;s client area.
// Position is in screen coordinates.
///
func (self *CWindowT) GetClientAreaBoundsInScreen() (ret CRectT) {

	cRet := C.cefingo_window_get_client_area_bounds_in_screen(self.p_window)

	ret = (CRectT)(cRet)
	return ret
}

///
// Set the regions where mouse events will be intercepted by this Window to
// support drag operations. Call this function with an NULL vector to clear
// the draggable regions. The draggable region bounds should be in window
// coordinates.
///
func (self *CWindowT) SetDraggableRegions(
	regionsCount int64,
	regions *CDraggableRegionT,
) {

	C.cefingo_window_set_draggable_regions(self.p_window, (C.size_t)(regionsCount), (*C.cef_draggable_region_t)(regions))

}

///
// Retrieve the platform window handle for this Window.
///
func (self *CWindowT) GetWindowHandle() (ret CWindowHandleT) {

	cRet := C.cefingo_window_get_window_handle(self.p_window)

	ret = (CWindowHandleT)(cRet)
	return ret
}

///
// Simulate a key press. |key_code| is the VKEY_* value from Chromium&#39;s
// ui/events/keycodes/keyboard_codes.h header (VK_* values on Windows).
// |event_flags| is some combination of EVENTFLAG_SHIFT_DOWN,
// EVENTFLAG_CONTROL_DOWN and/or EVENTFLAG_ALT_DOWN. This function is exposed
// primarily for testing purposes.
///
func (self *CWindowT) SendKeyPress(
	key_code int,
	event_flags uint32,
) {

	C.cefingo_window_send_key_press(self.p_window, (C.int)(key_code), (C.uint32)(event_flags))

}

///
// Simulate a mouse move. The mouse cursor will be moved to the specified
// (screen_x, screen_y) position. This function is exposed primarily for
// testing purposes.
///
func (self *CWindowT) SendMouseMove(
	screen_x int,
	screen_y int,
) {

	C.cefingo_window_send_mouse_move(self.p_window, (C.int)(screen_x), (C.int)(screen_y))

}

///
// Simulate mouse down and/or mouse up events. |button| is the mouse button
// type. If |mouse_down| is true (1) a mouse down event will be sent. If
// |mouse_up| is true (1) a mouse up event will be sent. If both are true (1)
// a mouse down event will be sent followed by a mouse up event (equivalent to
// clicking the mouse button). The events will be sent using the current
// cursor position so make sure to call send_mouse_move() first to position
// the mouse. This function is exposed primarily for testing purposes.
///
func (self *CWindowT) SendMouseEvents(
	button CMouseButtonTypeT,
	mouse_down int,
	mouse_up int,
) {

	C.cefingo_window_send_mouse_events(self.p_window, (C.cef_mouse_button_type_t)(button), (C.int)(mouse_down), (C.int)(mouse_up))

}

///
// Set the keyboard accelerator for the specified |command_id|. |key_code| can
// be any virtual key or character value. cef_window_delegate_t::OnAccelerator
// will be called if the keyboard combination is triggered while this window
// has focus.
///
func (self *CWindowT) SetAccelerator(
	command_id int,
	key_code int,
	shift_pressed int,
	ctrl_pressed int,
	alt_pressed int,
) {

	C.cefingo_window_set_accelerator(self.p_window, (C.int)(command_id), (C.int)(key_code), (C.int)(shift_pressed), (C.int)(ctrl_pressed), (C.int)(alt_pressed))

}

///
// Remove the keyboard accelerator for the specified |command_id|.
///
func (self *CWindowT) RemoveAccelerator(
	command_id int,
) {

	C.cefingo_window_remove_accelerator(self.p_window, (C.int)(command_id))

}

///
// Remove all keyboard accelerators.
///
func (self *CWindowT) RemoveAllAccelerators() {

	C.cefingo_window_remove_all_accelerators(self.p_window)

}

///
// Create a new Window.
///
func WindowCreateTopLevel(
	delegate *CWindowDelegateT,
) (ret *CWindowT) {
	var goTmpdelegate *C.cef_window_delegate_t
	if delegate != nil {
		goTmpdelegate = delegate.p_window_delegate
		BaseAddRef(goTmpdelegate)
	}

	cRet := C.cef_window_create_top_level(goTmpdelegate)

	ret = newCWindowT(cRet)
	return ret
}

// cef_window_delegate_capi.h, include/capi/views/cef_window_delegate_capi.h:140:3,

///
// Implement this structure to handle window events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

// Go type for cef_window_delegate_t
type CWindowDelegateT struct {
	noCopy            noCopy
	p_window_delegate *C.cef_window_delegate_t
}

type RefToCWindowDelegateT struct {
	p_window_delegate *CWindowDelegateT
}

type CWindowDelegateTAccessor interface {
	GetCWindowDelegateT() *CWindowDelegateT
	SetCWindowDelegateT(*CWindowDelegateT)
}

func (r RefToCWindowDelegateT) GetCWindowDelegateT() *CWindowDelegateT {
	return r.p_window_delegate
}

func (r *RefToCWindowDelegateT) SetCWindowDelegateT(p *CWindowDelegateT) {
	r.p_window_delegate = p
}

// Go type CWindowDelegateT wraps cef type *C.cef_window_delegate_t
func newCWindowDelegateT(p *C.cef_window_delegate_t) *CWindowDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T28624:")
	BaseAddRef(p)
	go_window_delegate := CWindowDelegateT{noCopy{}, p}
	runtime.SetFinalizer(&go_window_delegate, func(g *CWindowDelegateT) {
		Tracef(unsafe.Pointer(g.p_window_delegate), "T28628:")
		BaseRelease(g.p_window_delegate)
	})
	return &go_window_delegate
}

// *C.cef_window_delegate_t has refCounted interface
func (window_delegate *CWindowDelegateT) HasOneRef() bool {
	return BaseHasOneRef(window_delegate.p_window_delegate)
}

func (p *C.cef_window_delegate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (window_delegate *CWindowDelegateT) ToCPanelDelegateT() *CPanelDelegateT {
	p := (*C.cef_panel_delegate_t)(unsafe.Pointer(window_delegate.p_window_delegate))
	return newCPanelDelegateT(p)
}

///
// Called when |window| is created.
///
type OnWindowCreatedHandler interface {
	OnWindowCreated(
		self *CWindowDelegateT,
		window *CWindowT,
	)
}

///
// Called when |window| is destroyed. Release all references to |window| and
// do not attempt to execute any functions on |window| after this callback
// returns.
///
type OnWindowDestroyedHandler interface {
	OnWindowDestroyed(
		self *CWindowDelegateT,
		window *CWindowT,
	)
}

///
// Return the parent for |window| or NULL if the |window| does not have a
// parent. Windows with parents will not get a taskbar button. Set |is_menu|
// to true (1) if |window| will be displayed as a menu, in which case it will
// not be clipped to the parent window bounds. Set |can_activate_menu| to
// false (0) if |is_menu| is true (1) and |window| should not be activated
// (given keyboard focus) when displayed.
///
type GetParentWindowHandler interface {
	GetParentWindow(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret *CWindowT, is_menu bool, can_activate_menu bool)
}

///
// Return true (1) if |window| should be created without a frame or title bar.
// The window will be resizable if can_resize() returns true (1). Use
// cef_window_t::set_draggable_regions() to specify draggable regions.
///
type IsFramelessHandler interface {
	IsFrameless(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be resized.
///
type CanResizeHandler interface {
	CanResize(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be maximized.
///
type CanMaximizeHandler interface {
	CanMaximize(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be minimized.
///
type CanMinimizeHandler interface {
	CanMinimize(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be closed. This will be called for user-
// initiated window close actions and when cef_window_t::close() is called.
///
type CanCloseHandler interface {
	CanClose(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Called when a keyboard accelerator registered with
// cef_window_t::SetAccelerator is triggered. Return true (1) if the
// accelerator was handled or false (0) otherwise.
///
type OnAcceleratorHandler interface {
	OnAccelerator(
		self *CWindowDelegateT,
		window *CWindowT,
		command_id int,
	) (ret bool)
}

///
// Called after all other controls in the window have had a chance to handle
// the event. |event| contains information about the keyboard event. Return
// true (1) if the keyboard event was handled or false (0) otherwise.
///
type CWindowDelegateTOnKeyEventHandler interface {
	OnKeyEvent(
		self *CWindowDelegateT,
		window *CWindowT,
		event *CKeyEventT,
	) (ret bool)
}

var window_delegate_handlers = struct {
	on_window_created_handler      map[*C.cef_window_delegate_t]OnWindowCreatedHandler
	on_window_destroyed_handler    map[*C.cef_window_delegate_t]OnWindowDestroyedHandler
	get_parent_window_handler      map[*C.cef_window_delegate_t]GetParentWindowHandler
	is_frameless_handler           map[*C.cef_window_delegate_t]IsFramelessHandler
	can_resize_handler             map[*C.cef_window_delegate_t]CanResizeHandler
	can_maximize_handler           map[*C.cef_window_delegate_t]CanMaximizeHandler
	can_minimize_handler           map[*C.cef_window_delegate_t]CanMinimizeHandler
	can_close_handler              map[*C.cef_window_delegate_t]CanCloseHandler
	on_accelerator_handler         map[*C.cef_window_delegate_t]OnAcceleratorHandler
	on_key_event_handler           map[*C.cef_window_delegate_t]CWindowDelegateTOnKeyEventHandler
	get_preferred_size_handler     map[*C.cef_window_delegate_t]GetPreferredSizeHandler
	get_minimum_size_handler       map[*C.cef_window_delegate_t]GetMinimumSizeHandler
	get_maximum_size_handler       map[*C.cef_window_delegate_t]GetMaximumSizeHandler
	get_height_for_width_handler   map[*C.cef_window_delegate_t]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*C.cef_window_delegate_t]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*C.cef_window_delegate_t]OnChildViewChangedHandler
	on_focus_handler               map[*C.cef_window_delegate_t]OnFocusHandler
	on_blur_handler                map[*C.cef_window_delegate_t]OnBlurHandler
}{
	map[*C.cef_window_delegate_t]OnWindowCreatedHandler{},
	map[*C.cef_window_delegate_t]OnWindowDestroyedHandler{},
	map[*C.cef_window_delegate_t]GetParentWindowHandler{},
	map[*C.cef_window_delegate_t]IsFramelessHandler{},
	map[*C.cef_window_delegate_t]CanResizeHandler{},
	map[*C.cef_window_delegate_t]CanMaximizeHandler{},
	map[*C.cef_window_delegate_t]CanMinimizeHandler{},
	map[*C.cef_window_delegate_t]CanCloseHandler{},
	map[*C.cef_window_delegate_t]OnAcceleratorHandler{},
	map[*C.cef_window_delegate_t]CWindowDelegateTOnKeyEventHandler{},
	map[*C.cef_window_delegate_t]GetPreferredSizeHandler{},
	map[*C.cef_window_delegate_t]GetMinimumSizeHandler{},
	map[*C.cef_window_delegate_t]GetMaximumSizeHandler{},
	map[*C.cef_window_delegate_t]GetHeightForWidthHandler{},
	map[*C.cef_window_delegate_t]OnParentViewChangedHandler{},
	map[*C.cef_window_delegate_t]OnChildViewChangedHandler{},
	map[*C.cef_window_delegate_t]OnFocusHandler{},
	map[*C.cef_window_delegate_t]OnBlurHandler{},
}

// AllocCWindowDelegateT allocates CWindowDelegateT and construct it
func AllocCWindowDelegateT() *CWindowDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_window_delegate_wrapper_t, "T28806:")
	cefp := C.cefingo_construct_window_delegate((*C.cefingo_window_delegate_wrapper_t)(up))

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_window_delegate_t itself in DeassocFunc,
		// or cef_window_delegate_t is never GCed.
		Tracef(up, "T28812:")

		cefingoIfaceAccess.Lock()
		defer cefingoIfaceAccess.Unlock()
		delete(window_delegate_handlers.on_window_created_handler, cefp)
		delete(window_delegate_handlers.on_window_destroyed_handler, cefp)
		delete(window_delegate_handlers.get_parent_window_handler, cefp)
		delete(window_delegate_handlers.is_frameless_handler, cefp)
		delete(window_delegate_handlers.can_resize_handler, cefp)
		delete(window_delegate_handlers.can_maximize_handler, cefp)
		delete(window_delegate_handlers.can_minimize_handler, cefp)
		delete(window_delegate_handlers.can_close_handler, cefp)
		delete(window_delegate_handlers.on_accelerator_handler, cefp)
		delete(window_delegate_handlers.on_key_event_handler, cefp)
		delete(window_delegate_handlers.get_preferred_size_handler, cefp)
		delete(window_delegate_handlers.get_minimum_size_handler, cefp)
		delete(window_delegate_handlers.get_maximum_size_handler, cefp)
		delete(window_delegate_handlers.get_height_for_width_handler, cefp)
		delete(window_delegate_handlers.on_parent_view_changed_handler, cefp)
		delete(window_delegate_handlers.on_child_view_changed_handler, cefp)
		delete(window_delegate_handlers.on_focus_handler, cefp)
		delete(window_delegate_handlers.on_blur_handler, cefp)
	}))

	return newCWindowDelegateT(cefp)
}

func (window_delegate *CWindowDelegateT) Bind(a interface{}) *CWindowDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := window_delegate.p_window_delegate

	if h, ok := a.(OnWindowCreatedHandler); ok {
		window_delegate_handlers.on_window_created_handler[cp] = h
	}

	if h, ok := a.(OnWindowDestroyedHandler); ok {
		window_delegate_handlers.on_window_destroyed_handler[cp] = h
	}

	if h, ok := a.(GetParentWindowHandler); ok {
		window_delegate_handlers.get_parent_window_handler[cp] = h
	}

	if h, ok := a.(IsFramelessHandler); ok {
		window_delegate_handlers.is_frameless_handler[cp] = h
	}

	if h, ok := a.(CanResizeHandler); ok {
		window_delegate_handlers.can_resize_handler[cp] = h
	}

	if h, ok := a.(CanMaximizeHandler); ok {
		window_delegate_handlers.can_maximize_handler[cp] = h
	}

	if h, ok := a.(CanMinimizeHandler); ok {
		window_delegate_handlers.can_minimize_handler[cp] = h
	}

	if h, ok := a.(CanCloseHandler); ok {
		window_delegate_handlers.can_close_handler[cp] = h
	}

	if h, ok := a.(OnAcceleratorHandler); ok {
		window_delegate_handlers.on_accelerator_handler[cp] = h
	}

	if h, ok := a.(CWindowDelegateTOnKeyEventHandler); ok {
		window_delegate_handlers.on_key_event_handler[cp] = h
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		window_delegate_handlers.get_preferred_size_handler[cp] = h
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		window_delegate_handlers.get_minimum_size_handler[cp] = h
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		window_delegate_handlers.get_maximum_size_handler[cp] = h
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		window_delegate_handlers.get_height_for_width_handler[cp] = h
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		window_delegate_handlers.on_parent_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		window_delegate_handlers.on_child_view_changed_handler[cp] = h
	}

	if h, ok := a.(OnFocusHandler); ok {
		window_delegate_handlers.on_focus_handler[cp] = h
	}

	if h, ok := a.(OnBlurHandler); ok {
		window_delegate_handlers.on_blur_handler[cp] = h
	}

	if accessor, ok := a.(CWindowDelegateTAccessor); ok {
		accessor.SetCWindowDelegateT(window_delegate)
		Logf("T28931:")
	}

	return window_delegate
}

// cef_x509_certificate_capi.h, include/capi/cef_x509_certificate_capi.h:123:3,

///
// Structure representing the issuer or subject field of an X.509 certificate.
///

// Go type for cef_x509cert_principal_t
type CX509certPrincipalT struct {
	noCopy               noCopy
	p_x509cert_principal *C.cef_x509cert_principal_t
}

type RefToCX509certPrincipalT struct {
	p_x509cert_principal *CX509certPrincipalT
}

type CX509certPrincipalTAccessor interface {
	GetCX509certPrincipalT() *CX509certPrincipalT
	SetCX509certPrincipalT(*CX509certPrincipalT)
}

func (r RefToCX509certPrincipalT) GetCX509certPrincipalT() *CX509certPrincipalT {
	return r.p_x509cert_principal
}

func (r *RefToCX509certPrincipalT) SetCX509certPrincipalT(p *CX509certPrincipalT) {
	r.p_x509cert_principal = p
}

// Go type CX509certPrincipalT wraps cef type *C.cef_x509cert_principal_t
func newCX509certPrincipalT(p *C.cef_x509cert_principal_t) *CX509certPrincipalT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T28958:")
	BaseAddRef(p)
	go_x509cert_principal := CX509certPrincipalT{noCopy{}, p}
	runtime.SetFinalizer(&go_x509cert_principal, func(g *CX509certPrincipalT) {
		Tracef(unsafe.Pointer(g.p_x509cert_principal), "T28962:")
		BaseRelease(g.p_x509cert_principal)
	})
	return &go_x509cert_principal
}

// *C.cef_x509cert_principal_t has refCounted interface
func (x509cert_principal *CX509certPrincipalT) HasOneRef() bool {
	return BaseHasOneRef(x509cert_principal.p_x509cert_principal)
}

func (p *C.cef_x509cert_principal_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns a name that can be used to represent the issuer. It tries in this
// order: Common Name (CN), Organization Name (O) and Organizational Unit Name
// (OU) and returns the first non-NULL one found.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetDisplayName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_display_name(self.p_x509cert_principal)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the common name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetCommonName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_common_name(self.p_x509cert_principal)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the locality name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetLocalityName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_locality_name(self.p_x509cert_principal)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the state or province name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetStateOrProvinceName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_state_or_province_name(self.p_x509cert_principal)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the country name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetCountryName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_country_name(self.p_x509cert_principal)

	s := string_from_cef_string((*C.cef_string_t)(cRet))
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Retrieve the list of street addresses.
///
func (self *CX509certPrincipalT) GetStreetAddresses(
	addresses CStringListT,
) {

	C.cefingo_x509cert_principal_get_street_addresses(self.p_x509cert_principal, (C.cef_string_list_t)(addresses))

}

///
// Retrieve the list of organization names.
///
func (self *CX509certPrincipalT) GetOrganizationNames(
	names CStringListT,
) {

	C.cefingo_x509cert_principal_get_organization_names(self.p_x509cert_principal, (C.cef_string_list_t)(names))

}

///
// Retrieve the list of organization unit names.
///
func (self *CX509certPrincipalT) GetOrganizationUnitNames(
	names CStringListT,
) {

	C.cefingo_x509cert_principal_get_organization_unit_names(self.p_x509cert_principal, (C.cef_string_list_t)(names))

}

///
// Retrieve the list of domain components.
///
func (self *CX509certPrincipalT) GetDomainComponents(
	components CStringListT,
) {

	C.cefingo_x509cert_principal_get_domain_components(self.p_x509cert_principal, (C.cef_string_list_t)(components))

}

///
// Structure representing a X.509 certificate.
///

// Go type for cef_x509certificate_t
type CX509certificateT struct {
	noCopy            noCopy
	p_x509certificate *C.cef_x509certificate_t
}

type RefToCX509certificateT struct {
	p_x509certificate *CX509certificateT
}

type CX509certificateTAccessor interface {
	GetCX509certificateT() *CX509certificateT
	SetCX509certificateT(*CX509certificateT)
}

func (r RefToCX509certificateT) GetCX509certificateT() *CX509certificateT {
	return r.p_x509certificate
}

func (r *RefToCX509certificateT) SetCX509certificateT(p *CX509certificateT) {
	r.p_x509certificate = p
}

// Go type CX509certificateT wraps cef type *C.cef_x509certificate_t
func newCX509certificateT(p *C.cef_x509certificate_t) *CX509certificateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T29148:")
	BaseAddRef(p)
	go_x509certificate := CX509certificateT{noCopy{}, p}
	runtime.SetFinalizer(&go_x509certificate, func(g *CX509certificateT) {
		Tracef(unsafe.Pointer(g.p_x509certificate), "T29152:")
		BaseRelease(g.p_x509certificate)
	})
	return &go_x509certificate
}

// *C.cef_x509certificate_t has refCounted interface
func (x509certificate *CX509certificateT) HasOneRef() bool {
	return BaseHasOneRef(x509certificate.p_x509certificate)
}

func (p *C.cef_x509certificate_t) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

///
// Returns the subject of the X.509 certificate. For HTTPS server certificates
// this represents the web server.  The common name of the subject should
// match the host name of the web server.
///
func (self *CX509certificateT) GetSubject() (ret *CX509certPrincipalT) {

	cRet := C.cefingo_x509certificate_get_subject(self.p_x509certificate)

	ret = newCX509certPrincipalT(cRet)
	return ret
}

///
// Returns the issuer of the X.509 certificate.
///
func (self *CX509certificateT) GetIssuer() (ret *CX509certPrincipalT) {

	cRet := C.cefingo_x509certificate_get_issuer(self.p_x509certificate)

	ret = newCX509certPrincipalT(cRet)
	return ret
}

///
// Returns the DER encoded serial number for the X.509 certificate. The value
// possibly includes a leading 00 byte.
///
func (self *CX509certificateT) GetSerialNumber() (ret *CBinaryValueT) {

	cRet := C.cefingo_x509certificate_get_serial_number(self.p_x509certificate)

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Returns the date before which the X.509 certificate is invalid.
// CefTime.GetTimeT() will return 0 if no date was specified.
///
func (self *CX509certificateT) GetValidStart() (ret CTimeT) {

	cRet := C.cefingo_x509certificate_get_valid_start(self.p_x509certificate)

	ret = (CTimeT)(cRet)
	return ret
}

///
// Returns the date after which the X.509 certificate is invalid.
// CefTime.GetTimeT() will return 0 if no date was specified.
///
func (self *CX509certificateT) GetValidExpiry() (ret CTimeT) {

	cRet := C.cefingo_x509certificate_get_valid_expiry(self.p_x509certificate)

	ret = (CTimeT)(cRet)
	return ret
}

///
// Returns the DER encoded data for the X.509 certificate.
///
func (self *CX509certificateT) GetDerencoded() (ret *CBinaryValueT) {

	cRet := C.cefingo_x509certificate_get_derencoded(self.p_x509certificate)

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Returns the PEM encoded data for the X.509 certificate.
///
func (self *CX509certificateT) GetPemencoded() (ret *CBinaryValueT) {

	cRet := C.cefingo_x509certificate_get_pemencoded(self.p_x509certificate)

	ret = newCBinaryValueT(cRet)
	return ret
}

///
// Returns the number of certificates in the issuer chain. If 0, the
// certificate is self-signed.
///
func (self *CX509certificateT) GetIssuerChainSize() (ret int64) {

	cRet := C.cefingo_x509certificate_get_issuer_chain_size(self.p_x509certificate)

	ret = (int64)(cRet)
	return ret
}

///
// Returns the DER encoded data for the certificate issuer chain. If we failed
// to encode a certificate in the chain it is still present in the array but
// is an NULL string.
///
func (self *CX509certificateT) GetDerencodedIssuerChain() (chain []*CBinaryValueT) {
	var _chainCount C.size_t
	chainCount := &_chainCount
	var tmpchain *C.cef_binary_value_t

	C.cefingo_x509certificate_get_derencoded_issuer_chain(self.p_x509certificate, (*C.size_t)(chainCount), &tmpchain)

	chain = make([]*CBinaryValueT, *chainCount)
	_tmpchain := (*[1 << 30](*C.cef_binary_value_t))(unsafe.Pointer(tmpchain))[:*chainCount:*chainCount]
	for i := C.size_t(0); i < *chainCount; i++ {
		chain[i] = newCBinaryValueT(_tmpchain[i])
	}
	return chain
}

///
// Returns the PEM encoded data for the certificate issuer chain. If we failed
// to encode a certificate in the chain it is still present in the array but
// is an NULL string.
///
func (self *CX509certificateT) GetPemencodedIssuerChain() (chain []*CBinaryValueT) {
	var _chainCount C.size_t
	chainCount := &_chainCount
	var tmpchain *C.cef_binary_value_t

	C.cefingo_x509certificate_get_pemencoded_issuer_chain(self.p_x509certificate, (*C.size_t)(chainCount), &tmpchain)

	chain = make([]*CBinaryValueT, *chainCount)
	_tmpchain := (*[1 << 30](*C.cef_binary_value_t))(unsafe.Pointer(tmpchain))[:*chainCount:*chainCount]
	for i := C.size_t(0); i < *chainCount; i++ {
		chain[i] = newCBinaryValueT(_tmpchain[i])
	}
	return chain
}
