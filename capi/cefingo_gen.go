// Code generated by "gen-cefingo.go" DO NOT EDIT.

package capi

import (
	"runtime"
	"unsafe"
)

// #include "cefingo.h"
import "C"

// cef_accessibility_handler_capi.h, include/capi/cef_accessibility_handler_capi.h:75:3,

///
// Implement this structure to receive accessibility notification when
// accessibility events have been registered. The functions of this structure
// will be called on the UI thread.
///

type cCAccessibilityHandlerT C.cef_accessibility_handler_t

// Go type for cef_accessibility_handler_t
type CAccessibilityHandlerT struct {
	noCopy                   noCopy
	pc_accessibility_handler *cCAccessibilityHandlerT
	beUnrefed                unrefedBy
}

func (p *CAccessibilityHandlerT) Pass() (ret *CAccessibilityHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCAccessibilityHandlerT((*C.cef_accessibility_handler_t)(p.pc_accessibility_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CAccessibilityHandlerT) NewRef() (newP *CAccessibilityHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_accessibility_handler
	BaseAddRef(gop)
	newP = newCAccessibilityHandlerT((*C.cef_accessibility_handler_t)(gop), byApp)
	return newP
}

// Go type CAccessibilityHandlerT wraps cef type *C.cef_accessibility_handler_t
func newCAccessibilityHandlerT(p *C.cef_accessibility_handler_t, unrefedBy unrefedBy) *CAccessibilityHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T101.1:")
	pc := (*cCAccessibilityHandlerT)(p)
	go_accessibility_handler := &CAccessibilityHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_accessibility_handler, func(g *CAccessibilityHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_accessibility_handler != nil {
			Tracef(unsafe.Pointer(g.pc_accessibility_handler), "T101.2:")
			BaseRelease(g.pc_accessibility_handler)
		}
	})

	return go_accessibility_handler
}

// *C.cef_accessibility_handler_t has refCounted interface
func (accessibility_handler *CAccessibilityHandlerT) HasOneRef() bool {
	return BaseHasOneRef(accessibility_handler.pc_accessibility_handler)
}

func (p *cCAccessibilityHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (accessibility_handler *CAccessibilityHandlerT) Unref() (ret bool) {
	if accessibility_handler == nil {
		return
	}
	if accessibility_handler.beUnrefed == byApp {
		ret = BaseRelease(accessibility_handler.pc_accessibility_handler)
		accessibility_handler.beUnrefed = unrefed
	}
	accessibility_handler.pc_accessibility_handler = nil
	return ret
}

///
// Called after renderer process sends accessibility tree changes to the
// browser process.
///
type OnAccessibilityTreeChangeHandler interface {
	OnAccessibilityTreeChange(
		self *CAccessibilityHandlerT,
		value *CValueT,
	)
}

///
// Called after renderer process sends accessibility location changes to the
// browser process.
///
type OnAccessibilityLocationChangeHandler interface {
	OnAccessibilityLocationChange(
		self *CAccessibilityHandlerT,
		value *CValueT,
	)
}

var accessibility_handler_handlers = struct {
	handler                                  map[*cCAccessibilityHandlerT]interface{}
	on_accessibility_tree_change_handler     map[*cCAccessibilityHandlerT]OnAccessibilityTreeChangeHandler
	on_accessibility_location_change_handler map[*cCAccessibilityHandlerT]OnAccessibilityLocationChangeHandler
}{
	map[*cCAccessibilityHandlerT]interface{}{},
	map[*cCAccessibilityHandlerT]OnAccessibilityTreeChangeHandler{},
	map[*cCAccessibilityHandlerT]OnAccessibilityLocationChangeHandler{},
}

// allocCAccessibilityHandlerT allocates CAccessibilityHandlerT and construct it
func allocCAccessibilityHandlerT() *CAccessibilityHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_accessibility_handler_wrapper_t, "T101.3:")
	cefp := C.cefingo_construct_accessibility_handler((*C.cefingo_accessibility_handler_wrapper_t)(up))
	cgop := (*cCAccessibilityHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_accessibility_handler_t itself in DeassocFunc,
		// or cef_accessibility_handler_t is never GCed.
		Tracef(up, "T101.4:")
		unbindAllCAccessibilityHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCAccessibilityHandlerT(cefp, byApp)
}

// NewCAccessibilityHandlerT allocates CAccessibilityHandlerT, construct and bind it
func NewCAccessibilityHandlerT(a interface{}) *CAccessibilityHandlerT {
	return allocCAccessibilityHandlerT().bind(a)
}

func (accessibility_handler *CAccessibilityHandlerT) bind(a interface{}) *CAccessibilityHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := accessibility_handler.pc_accessibility_handler
	accessibility_handler_handlers.handler[cp] = a

	if h, ok := a.(OnAccessibilityTreeChangeHandler); ok {
		accessibility_handler_handlers.on_accessibility_tree_change_handler[cp] = h
		noBind = false
	} else {
		delete(accessibility_handler_handlers.on_accessibility_tree_change_handler, cp)
	}

	if h, ok := a.(OnAccessibilityLocationChangeHandler); ok {
		accessibility_handler_handlers.on_accessibility_location_change_handler[cp] = h
		noBind = false
	} else {
		delete(accessibility_handler_handlers.on_accessibility_location_change_handler, cp)
	}

	if noBind {
		Panicln("F229: *CAccessibilityHandlerT No bind")
	}
	return accessibility_handler
}

func unbindAllCAccessibilityHandlerT(cp *cCAccessibilityHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := accessibility_handler.pc_accessibility_handler
	delete(accessibility_handler_handlers.handler, cp)

	delete(accessibility_handler_handlers.on_accessibility_tree_change_handler, cp)
	delete(accessibility_handler_handlers.on_accessibility_location_change_handler, cp)
}

func (accessibility_handler *CAccessibilityHandlerT) UnbindAll() {
	unbindAllCAccessibilityHandlerT(accessibility_handler.pc_accessibility_handler)
	accessibility_handler.Unref()
}

func (accessibility_handler *CAccessibilityHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := accessibility_handler.pc_accessibility_handler
	return accessibility_handler_handlers.handler[cp]
}

// cef_app_capi.h, include/capi/cef_app_capi.h:114:3,

///
// Implement this structure to provide handler implementations. Methods will be
// called by the process and/or thread indicated.
///

type cCAppT C.cef_app_t

// Go type for cef_app_t
type CAppT struct {
	noCopy    noCopy
	pc_app    *cCAppT
	beUnrefed unrefedBy
}

func (p *CAppT) Pass() (ret *CAppT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCAppT((*C.cef_app_t)(p.pc_app), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CAppT) NewRef() (newP *CAppT) {
	if self == nil {
		return newP
	}
	gop := self.pc_app
	BaseAddRef(gop)
	newP = newCAppT((*C.cef_app_t)(gop), byApp)
	return newP
}

// Go type CAppT wraps cef type *C.cef_app_t
func newCAppT(p *C.cef_app_t, unrefedBy unrefedBy) *CAppT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T102.1:")
	pc := (*cCAppT)(p)
	go_app := &CAppT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_app, func(g *CAppT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_app != nil {
			Tracef(unsafe.Pointer(g.pc_app), "T102.2:")
			BaseRelease(g.pc_app)
		}
	})

	return go_app
}

// *C.cef_app_t has refCounted interface
func (app *CAppT) HasOneRef() bool {
	return BaseHasOneRef(app.pc_app)
}

func (p *cCAppT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (app *CAppT) Unref() (ret bool) {
	if app == nil {
		return
	}
	if app.beUnrefed == byApp {
		ret = BaseRelease(app.pc_app)
		app.beUnrefed = unrefed
	}
	app.pc_app = nil
	return ret
}

///
// Provides an opportunity to view and/or modify command-line arguments before
// processing by CEF and Chromium. The |process_type| value will be NULL for
// the browser process. Do not keep a reference to the cef_command_line_t
// object passed to this function. The CefSettings.command_line_args_disabled
// value can be used to start with an NULL command-line object. Any values
// specified in CefSettings that equate to command-line arguments will be set
// before this function is called. Be cautious when using this function to
// modify command-line arguments for non-browser processes as this may result
// in undefined behavior including crashes.
///
type OnBeforeCommandLineProcessingHandler interface {
	OnBeforeCommandLineProcessing(
		self *CAppT,
		process_type string,
		command_line *CCommandLineT,
	)
}

///
// Provides an opportunity to register custom schemes. Do not keep a reference
// to the |registrar| object. This function is called on the main thread for
// each process and the registered schemes should be the same across all
// processes.
///
type OnRegisterCustomSchemesHandler interface {
	OnRegisterCustomSchemes(
		self *CAppT,
		registrar *CSchemeRegistrarT,
	)
}

///
// Return the handler for resource bundle events. If
// CefSettings.pack_loading_disabled is true (1) a handler must be returned.
// If no handler is returned resources will be loaded from pack files. This
// function is called by the browser and render processes on multiple threads.
///
type GetResourceBundleHandlerHandler interface {
	GetResourceBundleHandler(
		self *CAppT,
	) (ret *CResourceBundleHandlerT)
}

///
// Return the handler for functionality specific to the browser process. This
// function is called on multiple threads in the browser process.
///
type GetBrowserProcessHandlerHandler interface {
	GetBrowserProcessHandler(
		self *CAppT,
	) (ret *CBrowserProcessHandlerT)
}

///
// Return the handler for functionality specific to the render process. This
// function is called on the render process main thread.
///
type GetRenderProcessHandlerHandler interface {
	GetRenderProcessHandler(
		self *CAppT,
	) (ret *CRenderProcessHandlerT)
}

var app_handlers = struct {
	handler                                   map[*cCAppT]interface{}
	on_before_command_line_processing_handler map[*cCAppT]OnBeforeCommandLineProcessingHandler
	on_register_custom_schemes_handler        map[*cCAppT]OnRegisterCustomSchemesHandler
	get_resource_bundle_handler_handler       map[*cCAppT]GetResourceBundleHandlerHandler
	get_browser_process_handler_handler       map[*cCAppT]GetBrowserProcessHandlerHandler
	get_render_process_handler_handler        map[*cCAppT]GetRenderProcessHandlerHandler
}{
	map[*cCAppT]interface{}{},
	map[*cCAppT]OnBeforeCommandLineProcessingHandler{},
	map[*cCAppT]OnRegisterCustomSchemesHandler{},
	map[*cCAppT]GetResourceBundleHandlerHandler{},
	map[*cCAppT]GetBrowserProcessHandlerHandler{},
	map[*cCAppT]GetRenderProcessHandlerHandler{},
}

// allocCAppT allocates CAppT and construct it
func allocCAppT() *CAppT {
	up := c_calloc(1, C.sizeof_cefingo_app_wrapper_t, "T102.3:")
	cefp := C.cefingo_construct_app((*C.cefingo_app_wrapper_t)(up))
	cgop := (*cCAppT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_app_t itself in DeassocFunc,
		// or cef_app_t is never GCed.
		Tracef(up, "T102.4:")
		unbindAllCAppT(cgop)
	}))

	BaseAddRef(cgop)
	return newCAppT(cefp, byApp)
}

// NewCAppT allocates CAppT, construct and bind it
func NewCAppT(a interface{}) *CAppT {
	return allocCAppT().bind(a)
}

func (app *CAppT) bind(a interface{}) *CAppT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := app.pc_app
	app_handlers.handler[cp] = a

	if h, ok := a.(OnBeforeCommandLineProcessingHandler); ok {
		app_handlers.on_before_command_line_processing_handler[cp] = h
		noBind = false
	} else {
		delete(app_handlers.on_before_command_line_processing_handler, cp)
	}

	if h, ok := a.(OnRegisterCustomSchemesHandler); ok {
		app_handlers.on_register_custom_schemes_handler[cp] = h
		noBind = false
	} else {
		delete(app_handlers.on_register_custom_schemes_handler, cp)
	}

	if h, ok := a.(GetResourceBundleHandlerHandler); ok {
		app_handlers.get_resource_bundle_handler_handler[cp] = h
		noBind = false
	} else {
		delete(app_handlers.get_resource_bundle_handler_handler, cp)
	}

	if h, ok := a.(GetBrowserProcessHandlerHandler); ok {
		app_handlers.get_browser_process_handler_handler[cp] = h
		noBind = false
	} else {
		delete(app_handlers.get_browser_process_handler_handler, cp)
	}

	if h, ok := a.(GetRenderProcessHandlerHandler); ok {
		app_handlers.get_render_process_handler_handler[cp] = h
		noBind = false
	} else {
		delete(app_handlers.get_render_process_handler_handler, cp)
	}

	if noBind {
		Panicln("F229: *CAppT No bind")
	}
	return app
}

func unbindAllCAppT(cp *cCAppT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := app.pc_app
	delete(app_handlers.handler, cp)

	delete(app_handlers.on_before_command_line_processing_handler, cp)
	delete(app_handlers.on_register_custom_schemes_handler, cp)
	delete(app_handlers.get_resource_bundle_handler_handler, cp)
	delete(app_handlers.get_browser_process_handler_handler, cp)
	delete(app_handlers.get_render_process_handler_handler, cp)
}

func (app *CAppT) UnbindAll() {
	unbindAllCAppT(app.pc_app)
	app.Unref()
}

func (app *CAppT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := app.pc_app
	return app_handlers.handler[cp]
}

///
// This function should be called from the application entry point function to
// execute a secondary process. It can be used to run secondary processes from
// the browser client executable (default behavior) or from a separate
// executable specified by the CefSettings.browser_subprocess_path value. If
// called for the browser process (identified by no "type" command-line value)
// it will return immediately with a value of -1. If called for a recognized
// secondary process it will block until the process should exit and then return
// the process exit code. The |application| parameter may be NULL. The
// |windows_sandbox_info| parameter is only used on Windows and may be NULL (see
// cef_sandbox_win.h for details).
///
func ExecuteProcess(
	args *CMainArgsT,
	application *CAppT,
	windows_sandbox_info unsafe.Pointer,
) (ret int) {
	var goTmpapplication *C.cef_app_t
	if application != nil {
		BaseAddRef(application.pc_app)
		goTmpapplication = (*C.cef_app_t)(application.pc_app)
	}

	cRet := C.cef_execute_process((*C.cef_main_args_t)(args), goTmpapplication, windows_sandbox_info)

	ret = (int)(cRet) // return GoObj
	return ret
}

///
// This function should be called on the main application thread to initialize
// the CEF browser process. The |application| parameter may be NULL. A return
// value of true (1) indicates that it succeeded and false (0) indicates that it
// failed. The |windows_sandbox_info| parameter is only used on Windows and may
// be NULL (see cef_sandbox_win.h for details).
///
func Initialize(
	args *CMainArgsT,
	settings *CSettingsT,
	application *CAppT,
	windows_sandbox_info unsafe.Pointer,
) (ret bool) {
	var goTmpapplication *C.cef_app_t
	if application != nil {
		BaseAddRef(application.pc_app)
		goTmpapplication = (*C.cef_app_t)(application.pc_app)
	}

	cRet := C.cef_initialize((*C.cef_main_args_t)(args), (*C.cef_settings_t)(settings), goTmpapplication, windows_sandbox_info)

	ret = cRet == 1
	return ret
}

///
// This function should be called on the main application thread to shut down
// the CEF browser process before the application exits.
///
func Shutdown() {

	C.cef_shutdown()

}

///
// Perform a single iteration of CEF message loop processing. This function is
// provided for cases where the CEF message loop must be integrated into an
// existing application message loop. Use of this function is not recommended
// for most users; use either the cef_run_message_loop() function or
// CefSettings.multi_threaded_message_loop if possible. When using this function
// care must be taken to balance performance against excessive CPU usage. It is
// recommended to enable the CefSettings.external_message_pump option when using
// this function so that
// cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can
// facilitate the scheduling process. This function should only be called on the
// main application thread and only if cef_initialize() is called with a
// CefSettings.multi_threaded_message_loop value of false (0). This function
// will not block.
///
func DoMessageLoopWork() {

	C.cef_do_message_loop_work()

}

///
// Run the CEF message loop. Use this function instead of an application-
// provided message loop to get the best balance between performance and CPU
// usage. This function should only be called on the main application thread and
// only if cef_initialize() is called with a
// CefSettings.multi_threaded_message_loop value of false (0). This function
// will block until a quit message is received by the system.
///
func RunMessageLoop() {

	C.cef_run_message_loop()

}

///
// Quit the CEF message loop that was started by calling cef_run_message_loop().
// This function should only be called on the main application thread and only
// if cef_run_message_loop() was used.
///
func QuitMessageLoop() {

	C.cef_quit_message_loop()

}

///
// Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a
// modal message loop. Set to false (0) after exiting the modal message loop.
///
func SetOsmodalLoop(
	osModalLoop bool,
) {
	var tmposModalLoop int
	if osModalLoop {
		tmposModalLoop = 1
	}

	C.cef_set_osmodal_loop(C.int(tmposModalLoop))

}

///
// Call during process startup to enable High-DPI support on Windows 7 or newer.
// Older versions of Windows should be left DPI-unaware because they do not
// support DirectWrite and GDI fonts are kerned very badly.
///
func EnableHighdpiSupport() {

	C.cef_enable_highdpi_support()

}

// cef_audio_handler_capi.h, include/capi/cef_audio_handler_capi.h:115:3,

///
// Implement this structure to handle audio events.
///

type cCAudioHandlerT C.cef_audio_handler_t

// Go type for cef_audio_handler_t
type CAudioHandlerT struct {
	noCopy           noCopy
	pc_audio_handler *cCAudioHandlerT
	beUnrefed        unrefedBy
}

func (p *CAudioHandlerT) Pass() (ret *CAudioHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCAudioHandlerT((*C.cef_audio_handler_t)(p.pc_audio_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CAudioHandlerT) NewRef() (newP *CAudioHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_audio_handler
	BaseAddRef(gop)
	newP = newCAudioHandlerT((*C.cef_audio_handler_t)(gop), byApp)
	return newP
}

// Go type CAudioHandlerT wraps cef type *C.cef_audio_handler_t
func newCAudioHandlerT(p *C.cef_audio_handler_t, unrefedBy unrefedBy) *CAudioHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T103.1:")
	pc := (*cCAudioHandlerT)(p)
	go_audio_handler := &CAudioHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_audio_handler, func(g *CAudioHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_audio_handler != nil {
			Tracef(unsafe.Pointer(g.pc_audio_handler), "T103.2:")
			BaseRelease(g.pc_audio_handler)
		}
	})

	return go_audio_handler
}

// *C.cef_audio_handler_t has refCounted interface
func (audio_handler *CAudioHandlerT) HasOneRef() bool {
	return BaseHasOneRef(audio_handler.pc_audio_handler)
}

func (p *cCAudioHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (audio_handler *CAudioHandlerT) Unref() (ret bool) {
	if audio_handler == nil {
		return
	}
	if audio_handler.beUnrefed == byApp {
		ret = BaseRelease(audio_handler.pc_audio_handler)
		audio_handler.beUnrefed = unrefed
	}
	audio_handler.pc_audio_handler = nil
	return ret
}

///
// Called on the UI thread to allow configuration of audio stream parameters.
// Return true (1) to proceed with audio stream capture, or false (0) to
// cancel it. All members of |params| can optionally be configured here, but
// they are also pre-filled with some sensible defaults.
///
type GetAudioParametersHandler interface {
	GetAudioParameters(
		self *CAudioHandlerT,
		browser *CBrowserT,
		params *CAudioParametersT,
	) (ret bool)
}

///
// Called on a browser audio capture thread when the browser starts streaming
// audio. OnAudioStreamStopped will always be called after
// OnAudioStreamStarted; both functions may be called multiple times for the
// same browser. |params| contains the audio parameters like sample rate and
// channel layout. |channels| is the number of channels.
///
type OnAudioStreamStartedHandler interface {
	OnAudioStreamStarted(
		self *CAudioHandlerT,
		browser *CBrowserT,
		params *CAudioParametersT,
		channels int,
	)
}

///
// Called on the UI thread when the stream has stopped. OnAudioSteamStopped
// will always be called after OnAudioStreamStarted; both functions may be
// called multiple times for the same stream.
///
type OnAudioStreamStoppedHandler interface {
	OnAudioStreamStopped(
		self *CAudioHandlerT,
		browser *CBrowserT,
	)
}

///
// Called on the UI or audio stream thread when an error occurred. During the
// stream creation phase this callback will be called on the UI thread while
// in the capturing phase it will be called on the audio stream thread. The
// stream will be stopped immediately.
///
type OnAudioStreamErrorHandler interface {
	OnAudioStreamError(
		self *CAudioHandlerT,
		browser *CBrowserT,
		message string,
	)
}

var audio_handler_handlers = struct {
	handler                         map[*cCAudioHandlerT]interface{}
	get_audio_parameters_handler    map[*cCAudioHandlerT]GetAudioParametersHandler
	on_audio_stream_started_handler map[*cCAudioHandlerT]OnAudioStreamStartedHandler
	on_audio_stream_stopped_handler map[*cCAudioHandlerT]OnAudioStreamStoppedHandler
	on_audio_stream_error_handler   map[*cCAudioHandlerT]OnAudioStreamErrorHandler
}{
	map[*cCAudioHandlerT]interface{}{},
	map[*cCAudioHandlerT]GetAudioParametersHandler{},
	map[*cCAudioHandlerT]OnAudioStreamStartedHandler{},
	map[*cCAudioHandlerT]OnAudioStreamStoppedHandler{},
	map[*cCAudioHandlerT]OnAudioStreamErrorHandler{},
}

// allocCAudioHandlerT allocates CAudioHandlerT and construct it
func allocCAudioHandlerT() *CAudioHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_audio_handler_wrapper_t, "T103.3:")
	cefp := C.cefingo_construct_audio_handler((*C.cefingo_audio_handler_wrapper_t)(up))
	cgop := (*cCAudioHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_audio_handler_t itself in DeassocFunc,
		// or cef_audio_handler_t is never GCed.
		Tracef(up, "T103.4:")
		unbindAllCAudioHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCAudioHandlerT(cefp, byApp)
}

// NewCAudioHandlerT allocates CAudioHandlerT, construct and bind it
func NewCAudioHandlerT(a interface{}) *CAudioHandlerT {
	return allocCAudioHandlerT().bind(a)
}

func (audio_handler *CAudioHandlerT) bind(a interface{}) *CAudioHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := audio_handler.pc_audio_handler
	audio_handler_handlers.handler[cp] = a

	if h, ok := a.(GetAudioParametersHandler); ok {
		audio_handler_handlers.get_audio_parameters_handler[cp] = h
		noBind = false
	} else {
		delete(audio_handler_handlers.get_audio_parameters_handler, cp)
	}

	if h, ok := a.(OnAudioStreamStartedHandler); ok {
		audio_handler_handlers.on_audio_stream_started_handler[cp] = h
		noBind = false
	} else {
		delete(audio_handler_handlers.on_audio_stream_started_handler, cp)
	}

	if h, ok := a.(OnAudioStreamStoppedHandler); ok {
		audio_handler_handlers.on_audio_stream_stopped_handler[cp] = h
		noBind = false
	} else {
		delete(audio_handler_handlers.on_audio_stream_stopped_handler, cp)
	}

	if h, ok := a.(OnAudioStreamErrorHandler); ok {
		audio_handler_handlers.on_audio_stream_error_handler[cp] = h
		noBind = false
	} else {
		delete(audio_handler_handlers.on_audio_stream_error_handler, cp)
	}

	if noBind {
		Panicln("F229: *CAudioHandlerT No bind")
	}
	return audio_handler
}

func unbindAllCAudioHandlerT(cp *cCAudioHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := audio_handler.pc_audio_handler
	delete(audio_handler_handlers.handler, cp)

	delete(audio_handler_handlers.get_audio_parameters_handler, cp)
	delete(audio_handler_handlers.on_audio_stream_started_handler, cp)
	delete(audio_handler_handlers.on_audio_stream_stopped_handler, cp)
	delete(audio_handler_handlers.on_audio_stream_error_handler, cp)
}

func (audio_handler *CAudioHandlerT) UnbindAll() {
	unbindAllCAudioHandlerT(audio_handler.pc_audio_handler)
	audio_handler.Unref()
}

func (audio_handler *CAudioHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := audio_handler.pc_audio_handler
	return audio_handler_handlers.handler[cp]
}

// cef_auth_callback_capi.h, include/capi/cef_auth_callback_capi.h:70:3,

///
// Callback structure used for asynchronous continuation of authentication
// requests.
///

type cCAuthCallbackT C.cef_auth_callback_t

// Go type for cef_auth_callback_t
type CAuthCallbackT struct {
	noCopy           noCopy
	pc_auth_callback *cCAuthCallbackT
	beUnrefed        unrefedBy
}

func (p *CAuthCallbackT) Pass() (ret *CAuthCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCAuthCallbackT((*C.cef_auth_callback_t)(p.pc_auth_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CAuthCallbackT) NewRef() (newP *CAuthCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_auth_callback
	BaseAddRef(gop)
	newP = newCAuthCallbackT((*C.cef_auth_callback_t)(gop), byApp)
	return newP
}

// Go type CAuthCallbackT wraps cef type *C.cef_auth_callback_t
func newCAuthCallbackT(p *C.cef_auth_callback_t, unrefedBy unrefedBy) *CAuthCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T104.1:")
	pc := (*cCAuthCallbackT)(p)
	go_auth_callback := &CAuthCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_auth_callback, func(g *CAuthCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_auth_callback != nil {
			Tracef(unsafe.Pointer(g.pc_auth_callback), "T104.2:")
			BaseRelease(g.pc_auth_callback)
		}
	})

	return go_auth_callback
}

// *C.cef_auth_callback_t has refCounted interface
func (auth_callback *CAuthCallbackT) HasOneRef() bool {
	return BaseHasOneRef(auth_callback.pc_auth_callback)
}

func (p *cCAuthCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (auth_callback *CAuthCallbackT) Unref() (ret bool) {
	if auth_callback == nil {
		return
	}
	if auth_callback.beUnrefed == byApp {
		ret = BaseRelease(auth_callback.pc_auth_callback)
		auth_callback.beUnrefed = unrefed
	}
	auth_callback.pc_auth_callback = nil
	return ret
}

///
// Continue the authentication request.
///
func (self *CAuthCallbackT) Cont(
	username string,
	password string,
) {
	c_username := create_cef_string(username)
	c_password := create_cef_string(password)

	C.cefingo_auth_callback_cont((*C.cef_auth_callback_t)(self.pc_auth_callback), c_username.p_cef_string_t, c_password.p_cef_string_t)

}

///
// Cancel the authentication request.
///
func (self *CAuthCallbackT) Cancel() {

	C.cefingo_auth_callback_cancel((*C.cef_auth_callback_t)(self.pc_auth_callback))

}

// cef_box_layout_capi.h, include/capi/views/cef_box_layout_capi.h:82:3,

///
// A Layout manager that arranges child views vertically or horizontally in a
// side-by-side fashion with spacing around and between the child views. The
// child views are always sized according to their preferred size. If the host's
// bounds provide insufficient space, child views will be clamped. Excess space
// will not be distributed. Methods must be called on the browser process UI
// thread unless otherwise indicated.
///

type cCBoxLayoutT C.cef_box_layout_t

// Go type for cef_box_layout_t
type CBoxLayoutT struct {
	noCopy        noCopy
	pc_box_layout *cCBoxLayoutT
	beUnrefed     unrefedBy
}

func (p *CBoxLayoutT) Pass() (ret *CBoxLayoutT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBoxLayoutT((*C.cef_box_layout_t)(p.pc_box_layout), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBoxLayoutT) NewRef() (newP *CBoxLayoutT) {
	if self == nil {
		return newP
	}
	gop := self.pc_box_layout
	BaseAddRef(gop)
	newP = newCBoxLayoutT((*C.cef_box_layout_t)(gop), byApp)
	return newP
}

// Go type CBoxLayoutT wraps cef type *C.cef_box_layout_t
func newCBoxLayoutT(p *C.cef_box_layout_t, unrefedBy unrefedBy) *CBoxLayoutT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T105.1:")
	pc := (*cCBoxLayoutT)(p)
	go_box_layout := &CBoxLayoutT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_box_layout, func(g *CBoxLayoutT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_box_layout != nil {
			Tracef(unsafe.Pointer(g.pc_box_layout), "T105.2:")
			BaseRelease(g.pc_box_layout)
		}
	})

	return go_box_layout
}

// *C.cef_box_layout_t has refCounted interface
func (box_layout *CBoxLayoutT) HasOneRef() bool {
	return BaseHasOneRef(box_layout.pc_box_layout)
}

func (p *cCBoxLayoutT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (box_layout *CBoxLayoutT) Unref() (ret bool) {
	if box_layout == nil {
		return
	}
	if box_layout.beUnrefed == byApp {
		ret = BaseRelease(box_layout.pc_box_layout)
		box_layout.beUnrefed = unrefed
	}
	box_layout.pc_box_layout = nil
	return ret
}

// Convert to Base Class Pointer *CLayoutT
func (box_layout *CBoxLayoutT) ToCLayoutT() *CLayoutT {
	p := (*C.cef_layout_t)(unsafe.Pointer(box_layout.pc_box_layout))
	BaseAddRef(box_layout.pc_box_layout)
	return newCLayoutT(p, byApp)
}

///
// Set the flex weight for the given |view|. Using the preferred size as the
// basis, free space along the main axis is distributed to views in the ratio
// of their flex weights. Similarly, if the views will overflow the parent,
// space is subtracted in these ratios. A flex of 0 means this view is not
// resized. Flex values must not be negative.
///
func (self *CBoxLayoutT) SetFlexForView(
	view *CViewT,
	flex int,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	C.cefingo_box_layout_set_flex_for_view((*C.cef_box_layout_t)(self.pc_box_layout), goTmpview, (C.int)(flex))

}

///
// Clears the flex for the given |view|, causing it to use the default flex
// specified via cef_box_layout_tSettings.default_flex.
///
func (self *CBoxLayoutT) ClearFlexForView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	C.cefingo_box_layout_clear_flex_for_view((*C.cef_box_layout_t)(self.pc_box_layout), goTmpview)

}

// cef_browser_capi.h, include/capi/cef_browser_capi.h:195:3,

///
// Structure used to represent a browser. When used in the browser process the
// functions of this structure may be called on any thread unless otherwise
// indicated in the comments. When used in the render process the functions of
// this structure may only be called on the main thread.
///

type cCBrowserT C.cef_browser_t

// Go type for cef_browser_t
type CBrowserT struct {
	noCopy     noCopy
	pc_browser *cCBrowserT
	beUnrefed  unrefedBy
}

func (p *CBrowserT) Pass() (ret *CBrowserT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBrowserT((*C.cef_browser_t)(p.pc_browser), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBrowserT) NewRef() (newP *CBrowserT) {
	if self == nil {
		return newP
	}
	gop := self.pc_browser
	BaseAddRef(gop)
	newP = newCBrowserT((*C.cef_browser_t)(gop), byApp)
	return newP
}

// Go type CBrowserT wraps cef type *C.cef_browser_t
func newCBrowserT(p *C.cef_browser_t, unrefedBy unrefedBy) *CBrowserT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T106.1:")
	pc := (*cCBrowserT)(p)
	go_browser := &CBrowserT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_browser, func(g *CBrowserT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_browser != nil {
			Tracef(unsafe.Pointer(g.pc_browser), "T106.2:")
			BaseRelease(g.pc_browser)
		}
	})

	return go_browser
}

// *C.cef_browser_t has refCounted interface
func (browser *CBrowserT) HasOneRef() bool {
	return BaseHasOneRef(browser.pc_browser)
}

func (p *cCBrowserT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (browser *CBrowserT) Unref() (ret bool) {
	if browser == nil {
		return
	}
	if browser.beUnrefed == byApp {
		ret = BaseRelease(browser.pc_browser)
		browser.beUnrefed = unrefed
	}
	browser.pc_browser = nil
	return ret
}

///
// True if this object is currently valid. This will return false (0) after
// cef_life_span_handler_t::OnBeforeClose is called.
///
func (self *CBrowserT) IsValid() (ret bool) {

	cRet := C.cefingo_browser_is_valid((*C.cef_browser_t)(self.pc_browser))

	ret = cRet == 1
	return ret
}

///
// Returns the browser host object. This function can only be called in the
// browser process.
///
func (self *CBrowserT) GetHost() (ret *CBrowserHostT) {

	cRet := C.cefingo_browser_get_host((*C.cef_browser_t)(self.pc_browser))

	ret = newCBrowserHostT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if the browser can navigate backwards.
///
func (self *CBrowserT) CanGoBack() (ret bool) {

	cRet := C.cefingo_browser_can_go_back((*C.cef_browser_t)(self.pc_browser))

	ret = cRet == 1
	return ret
}

///
// Navigate backwards.
///
func (self *CBrowserT) GoBack() {

	C.cefingo_browser_go_back((*C.cef_browser_t)(self.pc_browser))

}

///
// Returns true (1) if the browser can navigate forwards.
///
func (self *CBrowserT) CanGoForward() (ret bool) {

	cRet := C.cefingo_browser_can_go_forward((*C.cef_browser_t)(self.pc_browser))

	ret = cRet == 1
	return ret
}

///
// Navigate forwards.
///
func (self *CBrowserT) GoForward() {

	C.cefingo_browser_go_forward((*C.cef_browser_t)(self.pc_browser))

}

///
// Returns true (1) if the browser is currently loading.
///
func (self *CBrowserT) IsLoading() (ret bool) {

	cRet := C.cefingo_browser_is_loading((*C.cef_browser_t)(self.pc_browser))

	ret = cRet == 1
	return ret
}

///
// Reload the current page.
///
func (self *CBrowserT) Reload() {

	C.cefingo_browser_reload((*C.cef_browser_t)(self.pc_browser))

}

///
// Reload the current page ignoring any cached data.
///
func (self *CBrowserT) ReloadIgnoreCache() {

	C.cefingo_browser_reload_ignore_cache((*C.cef_browser_t)(self.pc_browser))

}

///
// Stop loading the page.
///
func (self *CBrowserT) StopLoad() {

	C.cefingo_browser_stop_load((*C.cef_browser_t)(self.pc_browser))

}

///
// Returns the globally unique identifier for this browser. This value is also
// used as the tabId for extension APIs.
///
func (self *CBrowserT) GetIdentifier() (ret int) {

	cRet := C.cefingo_browser_get_identifier((*C.cef_browser_t)(self.pc_browser))

	ret = (int)(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CBrowserT) IsSame(
	that *CBrowserT,
) (ret bool) {
	var goTmpthat *C.cef_browser_t
	if that != nil {
		BaseAddRef(that.pc_browser)
		goTmpthat = (*C.cef_browser_t)(that.pc_browser)
	}

	cRet := C.cefingo_browser_is_same((*C.cef_browser_t)(self.pc_browser), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the browser is a popup.
///
func (self *CBrowserT) IsPopup() (ret bool) {

	cRet := C.cefingo_browser_is_popup((*C.cef_browser_t)(self.pc_browser))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if a document has been loaded in the browser.
///
func (self *CBrowserT) HasDocument() (ret bool) {

	cRet := C.cefingo_browser_has_document((*C.cef_browser_t)(self.pc_browser))

	ret = cRet == 1
	return ret
}

///
// Returns the main (top-level) frame for the browser. In the browser process
// this will return a valid object until after
// cef_life_span_handler_t::OnBeforeClose is called. In the renderer process
// this will return NULL if the main frame is hosted in a different renderer
// process (e.g. for cross-origin sub-frames). The main frame object will
// change during cross-origin navigation or re-navigation after renderer
// process termination (due to crashes, etc).
///
func (self *CBrowserT) GetMainFrame() (ret *CFrameT) {

	cRet := C.cefingo_browser_get_main_frame((*C.cef_browser_t)(self.pc_browser))

	ret = newCFrameT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the focused frame for the browser.
///
func (self *CBrowserT) GetFocusedFrame() (ret *CFrameT) {

	cRet := C.cefingo_browser_get_focused_frame((*C.cef_browser_t)(self.pc_browser))

	ret = newCFrameT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the frame with the specified identifier, or NULL if not found.
///
func (self *CBrowserT) GetFrameByident(
	identifier int64,
) (ret *CFrameT) {

	cRet := C.cefingo_browser_get_frame_byident((*C.cef_browser_t)(self.pc_browser), (C.int64)(identifier))

	ret = newCFrameT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the frame with the specified name, or NULL if not found.
///
func (self *CBrowserT) GetFrame(
	name string,
) (ret *CFrameT) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_browser_get_frame((*C.cef_browser_t)(self.pc_browser), c_name.p_cef_string_t)

	ret = newCFrameT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the number of frames that currently exist.
///
func (self *CBrowserT) GetFrameCount() (ret int64) {

	cRet := C.cefingo_browser_get_frame_count((*C.cef_browser_t)(self.pc_browser))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the names of all existing frames.
///
func (self *CBrowserT) GetFrameNames(
	names CStringListT,
) {

	C.cefingo_browser_get_frame_names((*C.cef_browser_t)(self.pc_browser), (C.cef_string_list_t)(names))

}

///
// Callback structure for cef_browser_host_t::RunFileDialog. The functions of
// this structure will be called on the browser process UI thread.
///

type cCRunFileDialogCallbackT C.cef_run_file_dialog_callback_t

// Go type for cef_run_file_dialog_callback_t
type CRunFileDialogCallbackT struct {
	noCopy                      noCopy
	pc_run_file_dialog_callback *cCRunFileDialogCallbackT
	beUnrefed                   unrefedBy
}

func (p *CRunFileDialogCallbackT) Pass() (ret *CRunFileDialogCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRunFileDialogCallbackT((*C.cef_run_file_dialog_callback_t)(p.pc_run_file_dialog_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRunFileDialogCallbackT) NewRef() (newP *CRunFileDialogCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_run_file_dialog_callback
	BaseAddRef(gop)
	newP = newCRunFileDialogCallbackT((*C.cef_run_file_dialog_callback_t)(gop), byApp)
	return newP
}

// Go type CRunFileDialogCallbackT wraps cef type *C.cef_run_file_dialog_callback_t
func newCRunFileDialogCallbackT(p *C.cef_run_file_dialog_callback_t, unrefedBy unrefedBy) *CRunFileDialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T107.1:")
	pc := (*cCRunFileDialogCallbackT)(p)
	go_run_file_dialog_callback := &CRunFileDialogCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_run_file_dialog_callback, func(g *CRunFileDialogCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_run_file_dialog_callback != nil {
			Tracef(unsafe.Pointer(g.pc_run_file_dialog_callback), "T107.2:")
			BaseRelease(g.pc_run_file_dialog_callback)
		}
	})

	return go_run_file_dialog_callback
}

// *C.cef_run_file_dialog_callback_t has refCounted interface
func (run_file_dialog_callback *CRunFileDialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(run_file_dialog_callback.pc_run_file_dialog_callback)
}

func (p *cCRunFileDialogCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (run_file_dialog_callback *CRunFileDialogCallbackT) Unref() (ret bool) {
	if run_file_dialog_callback == nil {
		return
	}
	if run_file_dialog_callback.beUnrefed == byApp {
		ret = BaseRelease(run_file_dialog_callback.pc_run_file_dialog_callback)
		run_file_dialog_callback.beUnrefed = unrefed
	}
	run_file_dialog_callback.pc_run_file_dialog_callback = nil
	return ret
}

///
// Called asynchronously after the file dialog is dismissed.
// |selected_accept_filter| is the 0-based index of the value selected from
// the accept filters array passed to cef_browser_host_t::RunFileDialog.
// |file_paths| will be a single value or a list of values depending on the
// dialog mode. If the selection was cancelled |file_paths| will be NULL.
///
type OnFileDialogDismissedHandler interface {
	OnFileDialogDismissed(
		self *CRunFileDialogCallbackT,
		selected_accept_filter int,
		file_paths CStringListT,
	)
}

var run_file_dialog_callback_handlers = struct {
	handler                          map[*cCRunFileDialogCallbackT]interface{}
	on_file_dialog_dismissed_handler map[*cCRunFileDialogCallbackT]OnFileDialogDismissedHandler
}{
	map[*cCRunFileDialogCallbackT]interface{}{},
	map[*cCRunFileDialogCallbackT]OnFileDialogDismissedHandler{},
}

// allocCRunFileDialogCallbackT allocates CRunFileDialogCallbackT and construct it
func allocCRunFileDialogCallbackT() *CRunFileDialogCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_run_file_dialog_callback_wrapper_t, "T107.3:")
	cefp := C.cefingo_construct_run_file_dialog_callback((*C.cefingo_run_file_dialog_callback_wrapper_t)(up))
	cgop := (*cCRunFileDialogCallbackT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_run_file_dialog_callback_t itself in DeassocFunc,
		// or cef_run_file_dialog_callback_t is never GCed.
		Tracef(up, "T107.4:")
		unbindAllCRunFileDialogCallbackT(cgop)
	}))

	BaseAddRef(cgop)
	return newCRunFileDialogCallbackT(cefp, byApp)
}

// NewCRunFileDialogCallbackT allocates CRunFileDialogCallbackT, construct and bind it
func NewCRunFileDialogCallbackT(a interface{}) *CRunFileDialogCallbackT {
	return allocCRunFileDialogCallbackT().bind(a)
}

func (run_file_dialog_callback *CRunFileDialogCallbackT) bind(a interface{}) *CRunFileDialogCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := run_file_dialog_callback.pc_run_file_dialog_callback
	run_file_dialog_callback_handlers.handler[cp] = a

	if h, ok := a.(OnFileDialogDismissedHandler); ok {
		run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler[cp] = h
		noBind = false
	} else {
		delete(run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler, cp)
	}

	if noBind {
		Panicln("F229: *CRunFileDialogCallbackT No bind")
	}
	return run_file_dialog_callback
}

func unbindAllCRunFileDialogCallbackT(cp *cCRunFileDialogCallbackT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := run_file_dialog_callback.pc_run_file_dialog_callback
	delete(run_file_dialog_callback_handlers.handler, cp)

	delete(run_file_dialog_callback_handlers.on_file_dialog_dismissed_handler, cp)
}

func (run_file_dialog_callback *CRunFileDialogCallbackT) UnbindAll() {
	unbindAllCRunFileDialogCallbackT(run_file_dialog_callback.pc_run_file_dialog_callback)
	run_file_dialog_callback.Unref()
}

func (run_file_dialog_callback *CRunFileDialogCallbackT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := run_file_dialog_callback.pc_run_file_dialog_callback
	return run_file_dialog_callback_handlers.handler[cp]
}

///
// Callback structure for cef_browser_host_t::GetNavigationEntries. The
// functions of this structure will be called on the browser process UI thread.
///

type cCNavigationEntryVisitorT C.cef_navigation_entry_visitor_t

// Go type for cef_navigation_entry_visitor_t
type CNavigationEntryVisitorT struct {
	noCopy                      noCopy
	pc_navigation_entry_visitor *cCNavigationEntryVisitorT
	beUnrefed                   unrefedBy
}

func (p *CNavigationEntryVisitorT) Pass() (ret *CNavigationEntryVisitorT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCNavigationEntryVisitorT((*C.cef_navigation_entry_visitor_t)(p.pc_navigation_entry_visitor), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CNavigationEntryVisitorT) NewRef() (newP *CNavigationEntryVisitorT) {
	if self == nil {
		return newP
	}
	gop := self.pc_navigation_entry_visitor
	BaseAddRef(gop)
	newP = newCNavigationEntryVisitorT((*C.cef_navigation_entry_visitor_t)(gop), byApp)
	return newP
}

// Go type CNavigationEntryVisitorT wraps cef type *C.cef_navigation_entry_visitor_t
func newCNavigationEntryVisitorT(p *C.cef_navigation_entry_visitor_t, unrefedBy unrefedBy) *CNavigationEntryVisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T108.1:")
	pc := (*cCNavigationEntryVisitorT)(p)
	go_navigation_entry_visitor := &CNavigationEntryVisitorT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_navigation_entry_visitor, func(g *CNavigationEntryVisitorT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_navigation_entry_visitor != nil {
			Tracef(unsafe.Pointer(g.pc_navigation_entry_visitor), "T108.2:")
			BaseRelease(g.pc_navigation_entry_visitor)
		}
	})

	return go_navigation_entry_visitor
}

// *C.cef_navigation_entry_visitor_t has refCounted interface
func (navigation_entry_visitor *CNavigationEntryVisitorT) HasOneRef() bool {
	return BaseHasOneRef(navigation_entry_visitor.pc_navigation_entry_visitor)
}

func (p *cCNavigationEntryVisitorT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (navigation_entry_visitor *CNavigationEntryVisitorT) Unref() (ret bool) {
	if navigation_entry_visitor == nil {
		return
	}
	if navigation_entry_visitor.beUnrefed == byApp {
		ret = BaseRelease(navigation_entry_visitor.pc_navigation_entry_visitor)
		navigation_entry_visitor.beUnrefed = unrefed
	}
	navigation_entry_visitor.pc_navigation_entry_visitor = nil
	return ret
}

///
// Method that will be executed. Do not keep a reference to |entry| outside of
// this callback. Return true (1) to continue visiting entries or false (0) to
// stop. |current| is true (1) if this entry is the currently loaded
// navigation entry. |index| is the 0-based index of this entry and |total| is
// the total number of entries.
///
type CNavigationEntryVisitorTVisitHandler interface {
	Visit(
		self *CNavigationEntryVisitorT,
		entry *CNavigationEntryT,
		current bool,
		index int,
		total int,
	) (ret bool)
}

var navigation_entry_visitor_handlers = struct {
	handler       map[*cCNavigationEntryVisitorT]interface{}
	visit_handler map[*cCNavigationEntryVisitorT]CNavigationEntryVisitorTVisitHandler
}{
	map[*cCNavigationEntryVisitorT]interface{}{},
	map[*cCNavigationEntryVisitorT]CNavigationEntryVisitorTVisitHandler{},
}

// allocCNavigationEntryVisitorT allocates CNavigationEntryVisitorT and construct it
func allocCNavigationEntryVisitorT() *CNavigationEntryVisitorT {
	up := c_calloc(1, C.sizeof_cefingo_navigation_entry_visitor_wrapper_t, "T108.3:")
	cefp := C.cefingo_construct_navigation_entry_visitor((*C.cefingo_navigation_entry_visitor_wrapper_t)(up))
	cgop := (*cCNavigationEntryVisitorT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_navigation_entry_visitor_t itself in DeassocFunc,
		// or cef_navigation_entry_visitor_t is never GCed.
		Tracef(up, "T108.4:")
		unbindAllCNavigationEntryVisitorT(cgop)
	}))

	BaseAddRef(cgop)
	return newCNavigationEntryVisitorT(cefp, byApp)
}

// NewCNavigationEntryVisitorT allocates CNavigationEntryVisitorT, construct and bind it
func NewCNavigationEntryVisitorT(a interface{}) *CNavigationEntryVisitorT {
	return allocCNavigationEntryVisitorT().bind(a)
}

func (navigation_entry_visitor *CNavigationEntryVisitorT) bind(a interface{}) *CNavigationEntryVisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := navigation_entry_visitor.pc_navigation_entry_visitor
	navigation_entry_visitor_handlers.handler[cp] = a

	if h, ok := a.(CNavigationEntryVisitorTVisitHandler); ok {
		navigation_entry_visitor_handlers.visit_handler[cp] = h
		noBind = false
	} else {
		delete(navigation_entry_visitor_handlers.visit_handler, cp)
	}

	if noBind {
		Panicln("F229: *CNavigationEntryVisitorT No bind")
	}
	return navigation_entry_visitor
}

func unbindAllCNavigationEntryVisitorT(cp *cCNavigationEntryVisitorT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := navigation_entry_visitor.pc_navigation_entry_visitor
	delete(navigation_entry_visitor_handlers.handler, cp)

	delete(navigation_entry_visitor_handlers.visit_handler, cp)
}

func (navigation_entry_visitor *CNavigationEntryVisitorT) UnbindAll() {
	unbindAllCNavigationEntryVisitorT(navigation_entry_visitor.pc_navigation_entry_visitor)
	navigation_entry_visitor.Unref()
}

func (navigation_entry_visitor *CNavigationEntryVisitorT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := navigation_entry_visitor.pc_navigation_entry_visitor
	return navigation_entry_visitor_handlers.handler[cp]
}

///
// Callback structure for cef_browser_host_t::PrintToPDF. The functions of this
// structure will be called on the browser process UI thread.
///

type cCPdfPrintCallbackT C.cef_pdf_print_callback_t

// Go type for cef_pdf_print_callback_t
type CPdfPrintCallbackT struct {
	noCopy                noCopy
	pc_pdf_print_callback *cCPdfPrintCallbackT
	beUnrefed             unrefedBy
}

func (p *CPdfPrintCallbackT) Pass() (ret *CPdfPrintCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPdfPrintCallbackT((*C.cef_pdf_print_callback_t)(p.pc_pdf_print_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPdfPrintCallbackT) NewRef() (newP *CPdfPrintCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_pdf_print_callback
	BaseAddRef(gop)
	newP = newCPdfPrintCallbackT((*C.cef_pdf_print_callback_t)(gop), byApp)
	return newP
}

// Go type CPdfPrintCallbackT wraps cef type *C.cef_pdf_print_callback_t
func newCPdfPrintCallbackT(p *C.cef_pdf_print_callback_t, unrefedBy unrefedBy) *CPdfPrintCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T109.1:")
	pc := (*cCPdfPrintCallbackT)(p)
	go_pdf_print_callback := &CPdfPrintCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_pdf_print_callback, func(g *CPdfPrintCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_pdf_print_callback != nil {
			Tracef(unsafe.Pointer(g.pc_pdf_print_callback), "T109.2:")
			BaseRelease(g.pc_pdf_print_callback)
		}
	})

	return go_pdf_print_callback
}

// *C.cef_pdf_print_callback_t has refCounted interface
func (pdf_print_callback *CPdfPrintCallbackT) HasOneRef() bool {
	return BaseHasOneRef(pdf_print_callback.pc_pdf_print_callback)
}

func (p *cCPdfPrintCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (pdf_print_callback *CPdfPrintCallbackT) Unref() (ret bool) {
	if pdf_print_callback == nil {
		return
	}
	if pdf_print_callback.beUnrefed == byApp {
		ret = BaseRelease(pdf_print_callback.pc_pdf_print_callback)
		pdf_print_callback.beUnrefed = unrefed
	}
	pdf_print_callback.pc_pdf_print_callback = nil
	return ret
}

///
// Method that will be executed when the PDF printing has completed. |path| is
// the output path. |ok| will be true (1) if the printing completed
// successfully or false (0) otherwise.
///
type OnPdfPrintFinishedHandler interface {
	OnPdfPrintFinished(
		self *CPdfPrintCallbackT,
		path string,
		ok bool,
	)
}

var pdf_print_callback_handlers = struct {
	handler                       map[*cCPdfPrintCallbackT]interface{}
	on_pdf_print_finished_handler map[*cCPdfPrintCallbackT]OnPdfPrintFinishedHandler
}{
	map[*cCPdfPrintCallbackT]interface{}{},
	map[*cCPdfPrintCallbackT]OnPdfPrintFinishedHandler{},
}

// allocCPdfPrintCallbackT allocates CPdfPrintCallbackT and construct it
func allocCPdfPrintCallbackT() *CPdfPrintCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_pdf_print_callback_wrapper_t, "T109.3:")
	cefp := C.cefingo_construct_pdf_print_callback((*C.cefingo_pdf_print_callback_wrapper_t)(up))
	cgop := (*cCPdfPrintCallbackT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_pdf_print_callback_t itself in DeassocFunc,
		// or cef_pdf_print_callback_t is never GCed.
		Tracef(up, "T109.4:")
		unbindAllCPdfPrintCallbackT(cgop)
	}))

	BaseAddRef(cgop)
	return newCPdfPrintCallbackT(cefp, byApp)
}

// NewCPdfPrintCallbackT allocates CPdfPrintCallbackT, construct and bind it
func NewCPdfPrintCallbackT(a interface{}) *CPdfPrintCallbackT {
	return allocCPdfPrintCallbackT().bind(a)
}

func (pdf_print_callback *CPdfPrintCallbackT) bind(a interface{}) *CPdfPrintCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := pdf_print_callback.pc_pdf_print_callback
	pdf_print_callback_handlers.handler[cp] = a

	if h, ok := a.(OnPdfPrintFinishedHandler); ok {
		pdf_print_callback_handlers.on_pdf_print_finished_handler[cp] = h
		noBind = false
	} else {
		delete(pdf_print_callback_handlers.on_pdf_print_finished_handler, cp)
	}

	if noBind {
		Panicln("F229: *CPdfPrintCallbackT No bind")
	}
	return pdf_print_callback
}

func unbindAllCPdfPrintCallbackT(cp *cCPdfPrintCallbackT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := pdf_print_callback.pc_pdf_print_callback
	delete(pdf_print_callback_handlers.handler, cp)

	delete(pdf_print_callback_handlers.on_pdf_print_finished_handler, cp)
}

func (pdf_print_callback *CPdfPrintCallbackT) UnbindAll() {
	unbindAllCPdfPrintCallbackT(pdf_print_callback.pc_pdf_print_callback)
	pdf_print_callback.Unref()
}

func (pdf_print_callback *CPdfPrintCallbackT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := pdf_print_callback.pc_pdf_print_callback
	return pdf_print_callback_handlers.handler[cp]
}

///
// Callback structure for cef_browser_host_t::DownloadImage. The functions of
// this structure will be called on the browser process UI thread.
///

type cCDownloadImageCallbackT C.cef_download_image_callback_t

// Go type for cef_download_image_callback_t
type CDownloadImageCallbackT struct {
	noCopy                     noCopy
	pc_download_image_callback *cCDownloadImageCallbackT
	beUnrefed                  unrefedBy
}

func (p *CDownloadImageCallbackT) Pass() (ret *CDownloadImageCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDownloadImageCallbackT((*C.cef_download_image_callback_t)(p.pc_download_image_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDownloadImageCallbackT) NewRef() (newP *CDownloadImageCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_download_image_callback
	BaseAddRef(gop)
	newP = newCDownloadImageCallbackT((*C.cef_download_image_callback_t)(gop), byApp)
	return newP
}

// Go type CDownloadImageCallbackT wraps cef type *C.cef_download_image_callback_t
func newCDownloadImageCallbackT(p *C.cef_download_image_callback_t, unrefedBy unrefedBy) *CDownloadImageCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T110.1:")
	pc := (*cCDownloadImageCallbackT)(p)
	go_download_image_callback := &CDownloadImageCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_download_image_callback, func(g *CDownloadImageCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_download_image_callback != nil {
			Tracef(unsafe.Pointer(g.pc_download_image_callback), "T110.2:")
			BaseRelease(g.pc_download_image_callback)
		}
	})

	return go_download_image_callback
}

// *C.cef_download_image_callback_t has refCounted interface
func (download_image_callback *CDownloadImageCallbackT) HasOneRef() bool {
	return BaseHasOneRef(download_image_callback.pc_download_image_callback)
}

func (p *cCDownloadImageCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (download_image_callback *CDownloadImageCallbackT) Unref() (ret bool) {
	if download_image_callback == nil {
		return
	}
	if download_image_callback.beUnrefed == byApp {
		ret = BaseRelease(download_image_callback.pc_download_image_callback)
		download_image_callback.beUnrefed = unrefed
	}
	download_image_callback.pc_download_image_callback = nil
	return ret
}

///
// Method that will be executed when the image download has completed.
// |image_url| is the URL that was downloaded and |http_status_code| is the
// resulting HTTP status code. |image| is the resulting image, possibly at
// multiple scale factors, or NULL if the download failed.
///
func (self *CDownloadImageCallbackT) OnDownloadImageFinished(
	image_url string,
	http_status_code int,
	image *CImageT,
) {
	c_image_url := create_cef_string(image_url)
	var goTmpimage *C.cef_image_t
	if image != nil {
		BaseAddRef(image.pc_image)
		goTmpimage = (*C.cef_image_t)(image.pc_image)
	}

	C.cefingo_download_image_callback_on_download_image_finished((*C.cef_download_image_callback_t)(self.pc_download_image_callback), c_image_url.p_cef_string_t, (C.int)(http_status_code), goTmpimage)

}

///
// Structure used to represent the browser process aspects of a browser. The
// functions of this structure can only be called in the browser process. They
// may be called on any thread in that process unless otherwise indicated in the
// comments.
///

type cCBrowserHostT C.cef_browser_host_t

// Go type for cef_browser_host_t
type CBrowserHostT struct {
	noCopy          noCopy
	pc_browser_host *cCBrowserHostT
	beUnrefed       unrefedBy
}

func (p *CBrowserHostT) Pass() (ret *CBrowserHostT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBrowserHostT((*C.cef_browser_host_t)(p.pc_browser_host), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBrowserHostT) NewRef() (newP *CBrowserHostT) {
	if self == nil {
		return newP
	}
	gop := self.pc_browser_host
	BaseAddRef(gop)
	newP = newCBrowserHostT((*C.cef_browser_host_t)(gop), byApp)
	return newP
}

// Go type CBrowserHostT wraps cef type *C.cef_browser_host_t
func newCBrowserHostT(p *C.cef_browser_host_t, unrefedBy unrefedBy) *CBrowserHostT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T111.1:")
	pc := (*cCBrowserHostT)(p)
	go_browser_host := &CBrowserHostT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_browser_host, func(g *CBrowserHostT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_browser_host != nil {
			Tracef(unsafe.Pointer(g.pc_browser_host), "T111.2:")
			BaseRelease(g.pc_browser_host)
		}
	})

	return go_browser_host
}

// *C.cef_browser_host_t has refCounted interface
func (browser_host *CBrowserHostT) HasOneRef() bool {
	return BaseHasOneRef(browser_host.pc_browser_host)
}

func (p *cCBrowserHostT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (browser_host *CBrowserHostT) Unref() (ret bool) {
	if browser_host == nil {
		return
	}
	if browser_host.beUnrefed == byApp {
		ret = BaseRelease(browser_host.pc_browser_host)
		browser_host.beUnrefed = unrefed
	}
	browser_host.pc_browser_host = nil
	return ret
}

///
// Returns the hosted browser object.
///
func (self *CBrowserHostT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_browser_host_get_browser((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = newCBrowserT(cRet, byApp) // return GoObj
	return ret
}

///
// Request that the browser close. The JavaScript &#39;onbeforeunload&#39; event will
// be fired. If |force_close| is false (0) the event handler, if any, will be
// allowed to prompt the user and the user can optionally cancel the close. If
// |force_close| is true (1) the prompt will not be displayed and the close
// will proceed. Results in a call to cef_life_span_handler_t::do_close() if
// the event handler allows the close or if |force_close| is true (1). See
// cef_life_span_handler_t::do_close() documentation for additional usage
// information.
///
func (self *CBrowserHostT) CloseBrowser(
	force_close bool,
) {
	var tmpforce_close int
	if force_close {
		tmpforce_close = 1
	}

	C.cefingo_browser_host_close_browser((*C.cef_browser_host_t)(self.pc_browser_host), C.int(tmpforce_close))

}

///
// Helper for closing a browser. Call this function from the top-level window
// close handler (if any). Internally this calls CloseBrowser(false (0)) if
// the close has not yet been initiated. This function returns false (0) while
// the close is pending and true (1) after the close has completed. See
// close_browser() and cef_life_span_handler_t::do_close() documentation for
// additional usage information. This function must be called on the browser
// process UI thread.
///
func (self *CBrowserHostT) TryCloseBrowser() (ret bool) {

	cRet := C.cefingo_browser_host_try_close_browser((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = cRet == 1
	return ret
}

///
// Set whether the browser is focused.
///
func (self *CBrowserHostT) SetFocus(
	focus bool,
) {
	var tmpfocus int
	if focus {
		tmpfocus = 1
	}

	C.cefingo_browser_host_set_focus((*C.cef_browser_host_t)(self.pc_browser_host), C.int(tmpfocus))

}

///
// Retrieve the window handle (if any) for this browser. If this browser is
// wrapped in a cef_browser_view_t this function should be called on the
// browser process UI thread and it will return the handle for the top-level
// native window.
///
func (self *CBrowserHostT) GetWindowHandle() (ret CWindowHandleT) {

	cRet := C.cefingo_browser_host_get_window_handle((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = (CWindowHandleT)(cRet) // return GoObj
	return ret
}

///
// Retrieve the window handle (if any) of the browser that opened this
// browser. Will return NULL for non-popup browsers or if this browser is
// wrapped in a cef_browser_view_t. This function can be used in combination
// with custom handling of modal windows.
///
func (self *CBrowserHostT) GetOpenerWindowHandle() (ret CWindowHandleT) {

	cRet := C.cefingo_browser_host_get_opener_window_handle((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = (CWindowHandleT)(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if this browser is wrapped in a cef_browser_view_t.
///
func (self *CBrowserHostT) HasView() (ret bool) {

	cRet := C.cefingo_browser_host_has_view((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = cRet == 1
	return ret
}

///
// Returns the client for this browser.
///
func (self *CBrowserHostT) GetClient() (ret *CClientT) {

	cRet := C.cefingo_browser_host_get_client((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = newCClientT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the request context for this browser.
///
func (self *CBrowserHostT) GetRequestContext() (ret *CRequestContextT) {

	cRet := C.cefingo_browser_host_get_request_context((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = newCRequestContextT(cRet, byApp) // return GoObj
	return ret
}

///
// Get the current zoom level. The default zoom level is 0.0. This function
// can only be called on the UI thread.
///
func (self *CBrowserHostT) GetZoomLevel() (ret float64) {

	cRet := C.cefingo_browser_host_get_zoom_level((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = (float64)(cRet) // return GoObj
	return ret
}

///
// Change the zoom level to the specified value. Specify 0.0 to reset the zoom
// level. If called on the UI thread the change will be applied immediately.
// Otherwise, the change will be applied asynchronously on the UI thread.
///
func (self *CBrowserHostT) SetZoomLevel(
	zoomLevel float64,
) {

	C.cefingo_browser_host_set_zoom_level((*C.cef_browser_host_t)(self.pc_browser_host), (C.double)(zoomLevel))

}

///
// Call to run a file chooser dialog. Only a single file chooser dialog may be
// pending at any given time. |mode| represents the type of dialog to display.
// |title| to the title to be used for the dialog and may be NULL to show the
// default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode). |default_file_path|
// is the path with optional directory and/or file name component that will be
// initially selected in the dialog. |accept_filters| are used to restrict the
// selectable file types and may any combination of (a) valid lower-cased MIME
// types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b) individual file extensions (e.g.
// &quot;.txt&quot; or &quot;.png&quot;), or (c) combined description and file extension delimited
// using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image Types|.png;.gif;.jpg&quot;).
// |selected_accept_filter| is the 0-based index of the filter that will be
// selected by default. |callback| will be executed after the dialog is
// dismissed or immediately if another dialog is already pending. The dialog
// will be initiated asynchronously on the UI thread.
///
func (self *CBrowserHostT) RunFileDialog(
	mode CFileDialogModeT,
	title string,
	default_file_path string,
	accept_filters CStringListT,
	selected_accept_filter int,
	callback *CRunFileDialogCallbackT,
) {
	c_title := create_cef_string(title)
	c_default_file_path := create_cef_string(default_file_path)
	var goTmpcallback *C.cef_run_file_dialog_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_run_file_dialog_callback)
		goTmpcallback = (*C.cef_run_file_dialog_callback_t)(callback.pc_run_file_dialog_callback)
	}

	C.cefingo_browser_host_run_file_dialog((*C.cef_browser_host_t)(self.pc_browser_host), (C.cef_file_dialog_mode_t)(mode), c_title.p_cef_string_t, c_default_file_path.p_cef_string_t, (C.cef_string_list_t)(accept_filters), (C.int)(selected_accept_filter), goTmpcallback)

}

///
// Download the file at |url| using cef_download_handler_t.
///
func (self *CBrowserHostT) StartDownload(
	url string,
) {
	c_url := create_cef_string(url)

	C.cefingo_browser_host_start_download((*C.cef_browser_host_t)(self.pc_browser_host), c_url.p_cef_string_t)

}

///
// Download |image_url| and execute |callback| on completion with the images
// received from the renderer. If |is_favicon| is true (1) then cookies are
// not sent and not accepted during download. Images with density independent
// pixel (DIP) sizes larger than |max_image_size| are filtered out from the
// image results. Versions of the image at different scale factors may be
// downloaded up to the maximum scale factor supported by the system. If there
// are no image results &lt;= |max_image_size| then the smallest image is resized
// to |max_image_size| and is the only result. A |max_image_size| of 0 means
// unlimited. If |bypass_cache| is true (1) then |image_url| is requested from
// the server even if it is present in the browser cache.
///
func (self *CBrowserHostT) DownloadImage(
	image_url string,
	is_favicon bool,
	max_image_size uint32,
	bypass_cache bool,
	callback *CDownloadImageCallbackT,
) {
	c_image_url := create_cef_string(image_url)
	var tmpis_favicon int
	if is_favicon {
		tmpis_favicon = 1
	}
	var tmpbypass_cache int
	if bypass_cache {
		tmpbypass_cache = 1
	}
	var goTmpcallback *C.cef_download_image_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_download_image_callback)
		goTmpcallback = (*C.cef_download_image_callback_t)(callback.pc_download_image_callback)
	}

	C.cefingo_browser_host_download_image((*C.cef_browser_host_t)(self.pc_browser_host), c_image_url.p_cef_string_t, C.int(tmpis_favicon), (C.uint32)(max_image_size), C.int(tmpbypass_cache), goTmpcallback)

}

///
// Print the current browser contents.
///
func (self *CBrowserHostT) Print() {

	C.cefingo_browser_host_print((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Print the current browser contents to the PDF file specified by |path| and
// execute |callback| on completion. The caller is responsible for deleting
// |path| when done. For PDF printing to work on Linux you must implement the
// cef_print_handler_t::GetPdfPaperSize function.
///
func (self *CBrowserHostT) PrintToPdf(
	path string,
	settings *CPdfPrintSettingsT,
	callback *CPdfPrintCallbackT,
) {
	c_path := create_cef_string(path)
	var goTmpcallback *C.cef_pdf_print_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_pdf_print_callback)
		goTmpcallback = (*C.cef_pdf_print_callback_t)(callback.pc_pdf_print_callback)
	}

	C.cefingo_browser_host_print_to_pdf((*C.cef_browser_host_t)(self.pc_browser_host), c_path.p_cef_string_t, (*C.cef_pdf_print_settings_t)(settings), goTmpcallback)

}

///
// Search for |searchText|. |forward| indicates whether to search forward or
// backward within the page. |matchCase| indicates whether the search should
// be case-sensitive. |findNext| indicates whether this is the first request
// or a follow-up. The search will be restarted if |searchText| or |matchCase|
// change. The search will be stopped if |searchText| is NULL. The
// cef_find_handler_t instance, if any, returned via
// cef_client_t::GetFindHandler will be called to report find results.
///
func (self *CBrowserHostT) Find(
	searchText string,
	forward bool,
	matchCase bool,
	findNext bool,
) {
	c_searchText := create_cef_string(searchText)
	var tmpforward int
	if forward {
		tmpforward = 1
	}
	var tmpmatchCase int
	if matchCase {
		tmpmatchCase = 1
	}
	var tmpfindNext int
	if findNext {
		tmpfindNext = 1
	}

	C.cefingo_browser_host_find((*C.cef_browser_host_t)(self.pc_browser_host), c_searchText.p_cef_string_t, C.int(tmpforward), C.int(tmpmatchCase), C.int(tmpfindNext))

}

///
// Cancel all searches that are currently going on.
///
func (self *CBrowserHostT) StopFinding(
	clearSelection bool,
) {
	var tmpclearSelection int
	if clearSelection {
		tmpclearSelection = 1
	}

	C.cefingo_browser_host_stop_finding((*C.cef_browser_host_t)(self.pc_browser_host), C.int(tmpclearSelection))

}

///
// Open developer tools (DevTools) in its own browser. The DevTools browser
// will remain associated with this browser. If the DevTools browser is
// already open then it will be focused, in which case the |windowInfo|,
// |client| and |settings| parameters will be ignored. If |inspect_element_at|
// is non-NULL then the element at the specified (x,y) location will be
// inspected. The |windowInfo| parameter will be ignored if this browser is
// wrapped in a cef_browser_view_t.
///
func (self *CBrowserHostT) ShowDevTools(
	windowInfo *CWindowInfoT,
	client *CClientT,
	settings *CBrowserSettingsT,
	inspect_element_at *CPointT,
) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		BaseAddRef(client.pc_client)
		goTmpclient = (*C.cef_client_t)(client.pc_client)
	}

	C.cefingo_browser_host_show_dev_tools((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_window_info_t)(windowInfo), goTmpclient, (*C.cef_browser_settings_t)(settings), (*C.cef_point_t)(inspect_element_at))

}

///
// Explicitly close the associated DevTools browser, if any.
///
func (self *CBrowserHostT) CloseDevTools() {

	C.cefingo_browser_host_close_dev_tools((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Returns true (1) if this browser currently has an associated DevTools
// browser. Must be called on the browser process UI thread.
///
func (self *CBrowserHostT) HasDevTools() (ret bool) {

	cRet := C.cefingo_browser_host_has_dev_tools((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = cRet == 1
	return ret
}

///
// Send a function call message over the DevTools protocol. |message| must be
// a UTF8-encoded JSON dictionary that contains &quot;id&quot; (int), &quot;function&quot;
// (string) and &quot;params&quot; (dictionary, optional) values. See the DevTools
// protocol documentation at https://chromedevtools.github.io/devtools-
// protocol/ for details of supported functions and the expected &quot;params&quot;
// dictionary contents. |message| will be copied if necessary. This function
// will return true (1) if called on the UI thread and the message was
// successfully submitted for validation, otherwise false (0). Validation will
// be applied asynchronously and any messages that fail due to formatting
// errors or missing parameters may be discarded without notification. Prefer
// ExecuteDevToolsMethod if a more structured approach to message formatting
// is desired.
//
// Every valid function call will result in an asynchronous function result or
// error message that references the sent message &quot;id&quot;. Event messages are
// received while notifications are enabled (for example, between function
// calls for &quot;Page.enable&quot; and &quot;Page.disable&quot;). All received messages will be
// delivered to the observer(s) registered with AddDevToolsMessageObserver.
// See cef_dev_tools_message_observer_t::OnDevToolsMessage documentation for
// details of received message contents.
//
// Usage of the SendDevToolsMessage, ExecuteDevToolsMethod and
// AddDevToolsMessageObserver functions does not require an active DevTools
// front-end or remote-debugging session. Other active DevTools sessions will
// continue to function independently. However, any modification of global
// browser state by one session may not be reflected in the UI of other
// sessions.
//
// Communication with the DevTools front-end (when displayed) can be logged
// for development purposes by passing the `--devtools-protocol-log-
// file=&lt;path&gt;` command-line flag.
///
func (self *CBrowserHostT) SendDevToolsMessage(
	message []byte,
) (ret bool) {
	message_size := len(message)
	tmpmessage := C.CBytes(message)
	defer C.free(tmpmessage)

	cRet := C.cefingo_browser_host_send_dev_tools_message((*C.cef_browser_host_t)(self.pc_browser_host), tmpmessage, (C.size_t)(message_size))

	ret = cRet == 1
	return ret
}

///
// Execute a function call over the DevTools protocol. This is a more
// structured version of SendDevToolsMessage. |message_id| is an incremental
// number that uniquely identifies the message (pass 0 to have the next number
// assigned automatically based on previous values). |function| is the
// function name. |params| are the function parameters, which may be NULL. See
// the DevTools protocol documentation (linked above) for details of supported
// functions and the expected |params| dictionary contents. This function will
// return the assigned message ID if called on the UI thread and the message
// was successfully submitted for validation, otherwise 0. See the
// SendDevToolsMessage documentation for additional usage information.
///
func (self *CBrowserHostT) ExecuteDevToolsMethod(
	message_id int,
	method string,
	params *CDictionaryValueT,
) (ret bool) {
	c_method := create_cef_string(method)
	var goTmpparams *C.cef_dictionary_value_t
	if params != nil {
		BaseAddRef(params.pc_dictionary_value)
		goTmpparams = (*C.cef_dictionary_value_t)(params.pc_dictionary_value)
	}

	cRet := C.cefingo_browser_host_execute_dev_tools_method((*C.cef_browser_host_t)(self.pc_browser_host), (C.int)(message_id), c_method.p_cef_string_t, goTmpparams)

	ret = cRet == 1
	return ret
}

///
// Add an observer for DevTools protocol messages (function results and
// events). The observer will remain registered until the returned
// Registration object is destroyed. See the SendDevToolsMessage documentation
// for additional usage information.
///
func (self *CBrowserHostT) AddDevToolsMessageObserver(
	observer *CDevToolsMessageObserverT,
) (ret *CRegistrationT) {
	var goTmpobserver *C.cef_dev_tools_message_observer_t
	if observer != nil {
		BaseAddRef(observer.pc_dev_tools_message_observer)
		goTmpobserver = (*C.cef_dev_tools_message_observer_t)(observer.pc_dev_tools_message_observer)
	}

	cRet := C.cefingo_browser_host_add_dev_tools_message_observer((*C.cef_browser_host_t)(self.pc_browser_host), goTmpobserver)

	ret = newCRegistrationT(cRet, byApp) // return GoObj
	return ret
}

///
// Retrieve a snapshot of current navigation entries as values sent to the
// specified visitor. If |current_only| is true (1) only the current
// navigation entry will be sent, otherwise all navigation entries will be
// sent.
///
func (self *CBrowserHostT) GetNavigationEntries(
	visitor *CNavigationEntryVisitorT,
	current_only bool,
) {
	var goTmpvisitor *C.cef_navigation_entry_visitor_t
	if visitor != nil {
		BaseAddRef(visitor.pc_navigation_entry_visitor)
		goTmpvisitor = (*C.cef_navigation_entry_visitor_t)(visitor.pc_navigation_entry_visitor)
	}
	var tmpcurrent_only int
	if current_only {
		tmpcurrent_only = 1
	}

	C.cefingo_browser_host_get_navigation_entries((*C.cef_browser_host_t)(self.pc_browser_host), goTmpvisitor, C.int(tmpcurrent_only))

}

///
// If a misspelled word is currently selected in an editable node calling this
// function will replace it with the specified |word|.
///
func (self *CBrowserHostT) ReplaceMisspelling(
	word string,
) {
	c_word := create_cef_string(word)

	C.cefingo_browser_host_replace_misspelling((*C.cef_browser_host_t)(self.pc_browser_host), c_word.p_cef_string_t)

}

///
// Add the specified |word| to the spelling dictionary.
///
func (self *CBrowserHostT) AddWordToDictionary(
	word string,
) {
	c_word := create_cef_string(word)

	C.cefingo_browser_host_add_word_to_dictionary((*C.cef_browser_host_t)(self.pc_browser_host), c_word.p_cef_string_t)

}

///
// Returns true (1) if window rendering is disabled.
///
func (self *CBrowserHostT) IsWindowRenderingDisabled() (ret bool) {

	cRet := C.cefingo_browser_host_is_window_rendering_disabled((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = cRet == 1
	return ret
}

///
// Notify the browser that the widget has been resized. The browser will first
// call cef_render_handler_t::GetViewRect to get the new size and then call
// cef_render_handler_t::OnPaint asynchronously with the updated regions. This
// function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) WasResized() {

	C.cefingo_browser_host_was_resized((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Notify the browser that it has been hidden or shown. Layouting and
// cef_render_handler_t::OnPaint notification will stop when the browser is
// hidden. This function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) WasHidden(
	hidden bool,
) {
	var tmphidden int
	if hidden {
		tmphidden = 1
	}

	C.cefingo_browser_host_was_hidden((*C.cef_browser_host_t)(self.pc_browser_host), C.int(tmphidden))

}

///
// Send a notification to the browser that the screen info has changed. The
// browser will then call cef_render_handler_t::GetScreenInfo to update the
// screen information with the new values. This simulates moving the webview
// window from one display to another, or changing the properties of the
// current display. This function is only used when window rendering is
// disabled.
///
func (self *CBrowserHostT) NotifyScreenInfoChanged() {

	C.cefingo_browser_host_notify_screen_info_changed((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Invalidate the view. The browser will call cef_render_handler_t::OnPaint
// asynchronously. This function is only used when window rendering is
// disabled.
///
func (self *CBrowserHostT) Invalidate(
	ctype CPaintElementTypeT,
) {

	C.cefingo_browser_host_invalidate((*C.cef_browser_host_t)(self.pc_browser_host), (C.cef_paint_element_type_t)(ctype))

}

///
// Issue a BeginFrame request to Chromium.  Only valid when
// cef_window_tInfo::external_begin_frame_enabled is set to true (1).
///
func (self *CBrowserHostT) SendExternalBeginFrame() {

	C.cefingo_browser_host_send_external_begin_frame((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Send a key event to the browser.
///
func (self *CBrowserHostT) SendKeyEvent(
	event *CKeyEventT,
) {

	C.cefingo_browser_host_send_key_event((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_key_event_t)(event))

}

///
// Send a mouse click event to the browser. The |x| and |y| coordinates are
// relative to the upper-left corner of the view.
///
func (self *CBrowserHostT) SendMouseClickEvent(
	event *CMouseEventT,
	ctype CMouseButtonTypeT,
	mouseUp bool,
	clickCount int,
) {
	var tmpmouseUp int
	if mouseUp {
		tmpmouseUp = 1
	}

	C.cefingo_browser_host_send_mouse_click_event((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_mouse_event_t)(event), (C.cef_mouse_button_type_t)(ctype), C.int(tmpmouseUp), (C.int)(clickCount))

}

///
// Send a mouse move event to the browser. The |x| and |y| coordinates are
// relative to the upper-left corner of the view.
///
func (self *CBrowserHostT) SendMouseMoveEvent(
	event *CMouseEventT,
	mouseLeave bool,
) {
	var tmpmouseLeave int
	if mouseLeave {
		tmpmouseLeave = 1
	}

	C.cefingo_browser_host_send_mouse_move_event((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_mouse_event_t)(event), C.int(tmpmouseLeave))

}

///
// Send a mouse wheel event to the browser. The |x| and |y| coordinates are
// relative to the upper-left corner of the view. The |deltaX| and |deltaY|
// values represent the movement delta in the X and Y directions respectively.
// In order to scroll inside select popups with window rendering disabled
// cef_render_handler_t::GetScreenPoint should be implemented properly.
///
func (self *CBrowserHostT) SendMouseWheelEvent(
	event *CMouseEventT,
	deltaX int,
	deltaY int,
) {

	C.cefingo_browser_host_send_mouse_wheel_event((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_mouse_event_t)(event), (C.int)(deltaX), (C.int)(deltaY))

}

///
// Send a touch event to the browser for a windowless browser.
///
func (self *CBrowserHostT) SendTouchEvent(
	event *CTouchEventT,
) {

	C.cefingo_browser_host_send_touch_event((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_touch_event_t)(event))

}

///
// Send a capture lost event to the browser.
///
func (self *CBrowserHostT) SendCaptureLostEvent() {

	C.cefingo_browser_host_send_capture_lost_event((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Notify the browser that the window hosting it is about to be moved or
// resized. This function is only used on Windows and Linux.
///
func (self *CBrowserHostT) NotifyMoveOrResizeStarted() {

	C.cefingo_browser_host_notify_move_or_resize_started((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Returns the maximum rate in frames per second (fps) that
// cef_render_handler_t:: OnPaint will be called for a windowless browser. The
// actual fps may be lower if the browser cannot generate frames at the
// requested rate. The minimum value is 1 and the maximum value is 60 (default
// 30). This function can only be called on the UI thread.
///
func (self *CBrowserHostT) GetWindowlessFrameRate() (ret int) {

	cRet := C.cefingo_browser_host_get_windowless_frame_rate((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = (int)(cRet) // return GoObj
	return ret
}

///
// Set the maximum rate in frames per second (fps) that cef_render_handler_t::
// OnPaint will be called for a windowless browser. The actual fps may be
// lower if the browser cannot generate frames at the requested rate. The
// minimum value is 1 and the maximum value is 60 (default 30). Can also be
// set at browser creation via cef_browser_tSettings.windowless_frame_rate.
///
func (self *CBrowserHostT) SetWindowlessFrameRate(
	frame_rate int,
) {

	C.cefingo_browser_host_set_windowless_frame_rate((*C.cef_browser_host_t)(self.pc_browser_host), (C.int)(frame_rate))

}

///
// Begins a new composition or updates the existing composition. Blink has a
// special node (a composition node) that allows the input function to change
// text without affecting other DOM nodes. |text| is the optional text that
// will be inserted into the composition node. |underlines| is an optional set
// of ranges that will be underlined in the resulting text.
// |replacement_range| is an optional range of the existing text that will be
// replaced. |selection_range| is an optional range of the resulting text that
// will be selected after insertion or replacement. The |replacement_range|
// value is only used on OS X.
//
// This function may be called multiple times as the composition changes. When
// the client is done making changes the composition should either be canceled
// or completed. To cancel the composition call ImeCancelComposition. To
// complete the composition call either ImeCommitText or
// ImeFinishComposingText. Completion is usually signaled when:
//   A. The client receives a WM_IME_COMPOSITION message with a GCS_RESULTSTR
//      flag (on Windows), or;
//   B. The client receives a &quot;commit&quot; signal of GtkIMContext (on Linux), or;
//   C. insertText of NSTextInput is called (on Mac).
//
// This function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeSetComposition(
	text string,
	underlinesCount int64,
	underlines *CCompositionUnderlineT,
	replacement_range *CRangeT,
	selection_range *CRangeT,
) {
	c_text := create_cef_string(text)

	C.cefingo_browser_host_ime_set_composition((*C.cef_browser_host_t)(self.pc_browser_host), c_text.p_cef_string_t, (C.size_t)(underlinesCount), (*C.cef_composition_underline_t)(underlines), (*C.cef_range_t)(replacement_range), (*C.cef_range_t)(selection_range))

}

///
// Completes the existing composition by optionally inserting the specified
// |text| into the composition node. |replacement_range| is an optional range
// of the existing text that will be replaced. |relative_cursor_pos| is where
// the cursor will be positioned relative to the current cursor position. See
// comments on ImeSetComposition for usage. The |replacement_range| and
// |relative_cursor_pos| values are only used on OS X. This function is only
// used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeCommitText(
	text string,
	replacement_range *CRangeT,
	relative_cursor_pos int,
) {
	c_text := create_cef_string(text)

	C.cefingo_browser_host_ime_commit_text((*C.cef_browser_host_t)(self.pc_browser_host), c_text.p_cef_string_t, (*C.cef_range_t)(replacement_range), (C.int)(relative_cursor_pos))

}

///
// Completes the existing composition by applying the current composition node
// contents. If |keep_selection| is false (0) the current selection, if any,
// will be discarded. See comments on ImeSetComposition for usage. This
// function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeFinishComposingText(
	keep_selection bool,
) {
	var tmpkeep_selection int
	if keep_selection {
		tmpkeep_selection = 1
	}

	C.cefingo_browser_host_ime_finish_composing_text((*C.cef_browser_host_t)(self.pc_browser_host), C.int(tmpkeep_selection))

}

///
// Cancels the existing composition and discards the composition node contents
// without applying them. See comments on ImeSetComposition for usage. This
// function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) ImeCancelComposition() {

	C.cefingo_browser_host_ime_cancel_composition((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Call this function when the user drags the mouse into the web view (before
// calling DragTargetDragOver/DragTargetLeave/DragTargetDrop). |drag_data|
// should not contain file contents as this type of data is not allowed to be
// dragged into the web view. File contents can be removed using
// cef_drag_data_t::ResetFileContents (for example, if |drag_data| comes from
// cef_render_handler_t::StartDragging). This function is only used when
// window rendering is disabled.
///
func (self *CBrowserHostT) DragTargetDragEnter(
	drag_data *CDragDataT,
	event *CMouseEventT,
	allowed_ops CDragOperationsMaskT,
) {
	var goTmpdrag_data *C.cef_drag_data_t
	if drag_data != nil {
		BaseAddRef(drag_data.pc_drag_data)
		goTmpdrag_data = (*C.cef_drag_data_t)(drag_data.pc_drag_data)
	}

	C.cefingo_browser_host_drag_target_drag_enter((*C.cef_browser_host_t)(self.pc_browser_host), goTmpdrag_data, (*C.cef_mouse_event_t)(event), (C.cef_drag_operations_mask_t)(allowed_ops))

}

///
// Call this function each time the mouse is moved across the web view during
// a drag operation (after calling DragTargetDragEnter and before calling
// DragTargetDragLeave/DragTargetDrop). This function is only used when window
// rendering is disabled.
///
func (self *CBrowserHostT) DragTargetDragOver(
	event *CMouseEventT,
	allowed_ops CDragOperationsMaskT,
) {

	C.cefingo_browser_host_drag_target_drag_over((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_mouse_event_t)(event), (C.cef_drag_operations_mask_t)(allowed_ops))

}

///
// Call this function when the user drags the mouse out of the web view (after
// calling DragTargetDragEnter). This function is only used when window
// rendering is disabled.
///
func (self *CBrowserHostT) DragTargetDragLeave() {

	C.cefingo_browser_host_drag_target_drag_leave((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Call this function when the user completes the drag operation by dropping
// the object onto the web view (after calling DragTargetDragEnter). The
// object being dropped is |drag_data|, given as an argument to the previous
// DragTargetDragEnter call. This function is only used when window rendering
// is disabled.
///
func (self *CBrowserHostT) DragTargetDrop(
	event *CMouseEventT,
) {

	C.cefingo_browser_host_drag_target_drop((*C.cef_browser_host_t)(self.pc_browser_host), (*C.cef_mouse_event_t)(event))

}

///
// Call this function when the drag operation started by a
// cef_render_handler_t::StartDragging call has ended either in a drop or by
// being cancelled. |x| and |y| are mouse coordinates relative to the upper-
// left corner of the view. If the web view is both the drag source and the
// drag target then all DragTarget* functions should be called before
// DragSource* mthods. This function is only used when window rendering is
// disabled.
///
func (self *CBrowserHostT) DragSourceEndedAt(
	x int,
	y int,
	op CDragOperationsMaskT,
) {

	C.cefingo_browser_host_drag_source_ended_at((*C.cef_browser_host_t)(self.pc_browser_host), (C.int)(x), (C.int)(y), (C.cef_drag_operations_mask_t)(op))

}

///
// Call this function when the drag operation started by a
// cef_render_handler_t::StartDragging call has completed. This function may
// be called immediately without first calling DragSourceEndedAt to cancel a
// drag operation. If the web view is both the drag source and the drag target
// then all DragTarget* functions should be called before DragSource* mthods.
// This function is only used when window rendering is disabled.
///
func (self *CBrowserHostT) DragSourceSystemDragEnded() {

	C.cefingo_browser_host_drag_source_system_drag_ended((*C.cef_browser_host_t)(self.pc_browser_host))

}

///
// Returns the current visible navigation entry for this browser. This
// function can only be called on the UI thread.
///
func (self *CBrowserHostT) GetVisibleNavigationEntry() (ret *CNavigationEntryT) {

	cRet := C.cefingo_browser_host_get_visible_navigation_entry((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = newCNavigationEntryT(cRet, byApp) // return GoObj
	return ret
}

///
// Set accessibility state for all frames. |accessibility_state| may be
// default, enabled or disabled. If |accessibility_state| is STATE_DEFAULT
// then accessibility will be disabled by default and the state may be further
// controlled with the &quot;force-renderer-accessibility&quot; and &quot;disable-renderer-
// accessibility&quot; command-line switches. If |accessibility_state| is
// STATE_ENABLED then accessibility will be enabled. If |accessibility_state|
// is STATE_DISABLED then accessibility will be completely disabled.
//
// For windowed browsers accessibility will be enabled in Complete mode (which
// corresponds to kAccessibilityModeComplete in Chromium). In this mode all
// platform accessibility objects will be created and managed by Chromium&#39;s
// internal implementation. The client needs only to detect the screen reader
// and call this function appropriately. For example, on macOS the client can
// handle the @&quot;AXEnhancedUserStructure&quot; accessibility attribute to detect
// VoiceOver state changes and on Windows the client can handle WM_GETOBJECT
// with OBJID_CLIENT to detect accessibility readers.
//
// For windowless browsers accessibility will be enabled in TreeOnly mode
// (which corresponds to kAccessibilityModeWebContentsOnly in Chromium). In
// this mode renderer accessibility is enabled, the full tree is computed, and
// events are passed to CefAccessibiltyHandler, but platform accessibility
// objects are not created. The client may implement platform accessibility
// objects using CefAccessibiltyHandler callbacks if desired.
///
func (self *CBrowserHostT) SetAccessibilityState(
	accessibility_state CStateT,
) {

	C.cefingo_browser_host_set_accessibility_state((*C.cef_browser_host_t)(self.pc_browser_host), (C.cef_state_t)(accessibility_state))

}

///
// Enable notifications of auto resize via
// cef_display_handler_t::OnAutoResize. Notifications are disabled by default.
// |min_size| and |max_size| define the range of allowed sizes.
///
func (self *CBrowserHostT) SetAutoResizeEnabled(
	enabled bool,
	min_size *CSizeT,
	max_size *CSizeT,
) {
	var tmpenabled int
	if enabled {
		tmpenabled = 1
	}

	C.cefingo_browser_host_set_auto_resize_enabled((*C.cef_browser_host_t)(self.pc_browser_host), C.int(tmpenabled), (*C.cef_size_t)(min_size), (*C.cef_size_t)(max_size))

}

///
// Returns the extension hosted in this browser or NULL if no extension is
// hosted. See cef_request_context_t::LoadExtension for details.
///
func (self *CBrowserHostT) GetExtension() (ret *CExtensionT) {

	cRet := C.cefingo_browser_host_get_extension((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = newCExtensionT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if this browser is hosting an extension background script.
// Background hosts do not have a window and are not displayable. See
// cef_request_context_t::LoadExtension for details.
///
func (self *CBrowserHostT) IsBackgroundHost() (ret bool) {

	cRet := C.cefingo_browser_host_is_background_host((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = cRet == 1
	return ret
}

///
//  Set whether the browser&#39;s audio is muted.
///
func (self *CBrowserHostT) SetAudioMuted(
	mute bool,
) {
	var tmpmute int
	if mute {
		tmpmute = 1
	}

	C.cefingo_browser_host_set_audio_muted((*C.cef_browser_host_t)(self.pc_browser_host), C.int(tmpmute))

}

///
// Returns true (1) if the browser&#39;s audio is muted.  This function can only
// be called on the UI thread.
///
func (self *CBrowserHostT) IsAudioMuted() (ret bool) {

	cRet := C.cefingo_browser_host_is_audio_muted((*C.cef_browser_host_t)(self.pc_browser_host))

	ret = cRet == 1
	return ret
}

///
// Create a new browser using the window parameters specified by |windowInfo|.
// All values will be copied internally and the actual window (if any) will be
// created on the UI thread. If |request_context| is NULL the global request
// context will be used. This function can be called on any browser process
// thread and will not block. The optional |extra_info| parameter provides an
// opportunity to specify extra information specific to the created browser that
// will be passed to cef_render_process_handler_t::on_browser_created() in the
// render process.
///
func BrowserHostCreateBrowser(
	windowInfo *CWindowInfoT,
	client *CClientT,
	url string,
	settings *CBrowserSettingsT,
	extra_info *CDictionaryValueT,
	request_context *CRequestContextT,
) (ret bool) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		BaseAddRef(client.pc_client)
		goTmpclient = (*C.cef_client_t)(client.pc_client)
	}
	c_url := create_cef_string(url)
	var goTmpextra_info *C.cef_dictionary_value_t
	if extra_info != nil {
		BaseAddRef(extra_info.pc_dictionary_value)
		goTmpextra_info = (*C.cef_dictionary_value_t)(extra_info.pc_dictionary_value)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		BaseAddRef(request_context.pc_request_context)
		goTmprequest_context = (*C.cef_request_context_t)(request_context.pc_request_context)
	}

	cRet := C.cef_browser_host_create_browser((*C.cef_window_info_t)(windowInfo), goTmpclient, c_url.p_cef_string_t, (*C.cef_browser_settings_t)(settings), goTmpextra_info, goTmprequest_context)

	ret = cRet == 1
	return ret
}

///
// Create a new browser using the window parameters specified by |windowInfo|.
// If |request_context| is NULL the global request context will be used. This
// function can only be called on the browser process UI thread. The optional
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
func BrowserHostCreateBrowserSync(
	windowInfo *CWindowInfoT,
	client *CClientT,
	url string,
	settings *CBrowserSettingsT,
	extra_info *CDictionaryValueT,
	request_context *CRequestContextT,
) (ret *CBrowserT) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		BaseAddRef(client.pc_client)
		goTmpclient = (*C.cef_client_t)(client.pc_client)
	}
	c_url := create_cef_string(url)
	var goTmpextra_info *C.cef_dictionary_value_t
	if extra_info != nil {
		BaseAddRef(extra_info.pc_dictionary_value)
		goTmpextra_info = (*C.cef_dictionary_value_t)(extra_info.pc_dictionary_value)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		BaseAddRef(request_context.pc_request_context)
		goTmprequest_context = (*C.cef_request_context_t)(request_context.pc_request_context)
	}

	cRet := C.cef_browser_host_create_browser_sync((*C.cef_window_info_t)(windowInfo), goTmpclient, c_url.p_cef_string_t, (*C.cef_browser_settings_t)(settings), goTmpextra_info, goTmprequest_context)

	ret = newCBrowserT(cRet, byApp) // return GoObj
	return ret
}

// cef_browser_process_handler_capi.h, include/capi/cef_browser_process_handler_capi.h:107:3,

///
// Structure used to implement browser process callbacks. The functions of this
// structure will be called on the browser process main thread unless otherwise
// indicated.
///

type cCBrowserProcessHandlerT C.cef_browser_process_handler_t

// Go type for cef_browser_process_handler_t
type CBrowserProcessHandlerT struct {
	noCopy                     noCopy
	pc_browser_process_handler *cCBrowserProcessHandlerT
	beUnrefed                  unrefedBy
}

func (p *CBrowserProcessHandlerT) Pass() (ret *CBrowserProcessHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBrowserProcessHandlerT((*C.cef_browser_process_handler_t)(p.pc_browser_process_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBrowserProcessHandlerT) NewRef() (newP *CBrowserProcessHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_browser_process_handler
	BaseAddRef(gop)
	newP = newCBrowserProcessHandlerT((*C.cef_browser_process_handler_t)(gop), byApp)
	return newP
}

// Go type CBrowserProcessHandlerT wraps cef type *C.cef_browser_process_handler_t
func newCBrowserProcessHandlerT(p *C.cef_browser_process_handler_t, unrefedBy unrefedBy) *CBrowserProcessHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T112.1:")
	pc := (*cCBrowserProcessHandlerT)(p)
	go_browser_process_handler := &CBrowserProcessHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_browser_process_handler, func(g *CBrowserProcessHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_browser_process_handler != nil {
			Tracef(unsafe.Pointer(g.pc_browser_process_handler), "T112.2:")
			BaseRelease(g.pc_browser_process_handler)
		}
	})

	return go_browser_process_handler
}

// *C.cef_browser_process_handler_t has refCounted interface
func (browser_process_handler *CBrowserProcessHandlerT) HasOneRef() bool {
	return BaseHasOneRef(browser_process_handler.pc_browser_process_handler)
}

func (p *cCBrowserProcessHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (browser_process_handler *CBrowserProcessHandlerT) Unref() (ret bool) {
	if browser_process_handler == nil {
		return
	}
	if browser_process_handler.beUnrefed == byApp {
		ret = BaseRelease(browser_process_handler.pc_browser_process_handler)
		browser_process_handler.beUnrefed = unrefed
	}
	browser_process_handler.pc_browser_process_handler = nil
	return ret
}

///
// Called on the browser process UI thread immediately after the CEF context
// has been initialized.
///
type OnContextInitializedHandler interface {
	OnContextInitialized(
		self *CBrowserProcessHandlerT,
	)
}

///
// Called before a child process is launched. Will be called on the browser
// process UI thread when launching a render process and on the browser
// process IO thread when launching a GPU process. Provides an opportunity to
// modify the child process command line. Do not keep a reference to
// |command_line| outside of this function.
///
type OnBeforeChildProcessLaunchHandler interface {
	OnBeforeChildProcessLaunch(
		self *CBrowserProcessHandlerT,
		command_line *CCommandLineT,
	)
}

///
// Called from any thread when work has been scheduled for the browser process
// main (UI) thread. This callback is used in combination with CefSettings.
// external_message_pump and cef_do_message_loop_work() in cases where the CEF
// message loop must be integrated into an existing application message loop
// (see additional comments and warnings on CefDoMessageLoopWork). This
// callback should schedule a cef_do_message_loop_work() call to happen on the
// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
// |delay_ms| is &lt;= 0 then the call should happen reasonably soon. If
// |delay_ms| is &gt; 0 then the call should be scheduled to happen after the
// specified delay and any currently pending scheduled call should be
// cancelled.
///
type OnScheduleMessagePumpWorkHandler interface {
	OnScheduleMessagePumpWork(
		self *CBrowserProcessHandlerT,
		delay_ms int64,
	)
}

///
// Return the default client for use with a newly created browser window. If
// null is returned the browser will be unmanaged (no callbacks will be
// executed for that browser) and application shutdown will be blocked until
// the browser window is closed manually. This function is currently only used
// with the chrome runtime.
///
type GetDefaultClientHandler interface {
	GetDefaultClient(
		self *CBrowserProcessHandlerT,
	) (ret *CClientT)
}

var browser_process_handler_handlers = struct {
	handler                                map[*cCBrowserProcessHandlerT]interface{}
	on_context_initialized_handler         map[*cCBrowserProcessHandlerT]OnContextInitializedHandler
	on_before_child_process_launch_handler map[*cCBrowserProcessHandlerT]OnBeforeChildProcessLaunchHandler
	on_schedule_message_pump_work_handler  map[*cCBrowserProcessHandlerT]OnScheduleMessagePumpWorkHandler
	get_default_client_handler             map[*cCBrowserProcessHandlerT]GetDefaultClientHandler
}{
	map[*cCBrowserProcessHandlerT]interface{}{},
	map[*cCBrowserProcessHandlerT]OnContextInitializedHandler{},
	map[*cCBrowserProcessHandlerT]OnBeforeChildProcessLaunchHandler{},
	map[*cCBrowserProcessHandlerT]OnScheduleMessagePumpWorkHandler{},
	map[*cCBrowserProcessHandlerT]GetDefaultClientHandler{},
}

// allocCBrowserProcessHandlerT allocates CBrowserProcessHandlerT and construct it
func allocCBrowserProcessHandlerT() *CBrowserProcessHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_browser_process_handler_wrapper_t, "T112.3:")
	cefp := C.cefingo_construct_browser_process_handler((*C.cefingo_browser_process_handler_wrapper_t)(up))
	cgop := (*cCBrowserProcessHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_browser_process_handler_t itself in DeassocFunc,
		// or cef_browser_process_handler_t is never GCed.
		Tracef(up, "T112.4:")
		unbindAllCBrowserProcessHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCBrowserProcessHandlerT(cefp, byApp)
}

// NewCBrowserProcessHandlerT allocates CBrowserProcessHandlerT, construct and bind it
func NewCBrowserProcessHandlerT(a interface{}) *CBrowserProcessHandlerT {
	return allocCBrowserProcessHandlerT().bind(a)
}

func (browser_process_handler *CBrowserProcessHandlerT) bind(a interface{}) *CBrowserProcessHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := browser_process_handler.pc_browser_process_handler
	browser_process_handler_handlers.handler[cp] = a

	if h, ok := a.(OnContextInitializedHandler); ok {
		browser_process_handler_handlers.on_context_initialized_handler[cp] = h
		noBind = false
	} else {
		delete(browser_process_handler_handlers.on_context_initialized_handler, cp)
	}

	if h, ok := a.(OnBeforeChildProcessLaunchHandler); ok {
		browser_process_handler_handlers.on_before_child_process_launch_handler[cp] = h
		noBind = false
	} else {
		delete(browser_process_handler_handlers.on_before_child_process_launch_handler, cp)
	}

	if h, ok := a.(OnScheduleMessagePumpWorkHandler); ok {
		browser_process_handler_handlers.on_schedule_message_pump_work_handler[cp] = h
		noBind = false
	} else {
		delete(browser_process_handler_handlers.on_schedule_message_pump_work_handler, cp)
	}

	if h, ok := a.(GetDefaultClientHandler); ok {
		browser_process_handler_handlers.get_default_client_handler[cp] = h
		noBind = false
	} else {
		delete(browser_process_handler_handlers.get_default_client_handler, cp)
	}

	if noBind {
		Panicln("F229: *CBrowserProcessHandlerT No bind")
	}
	return browser_process_handler
}

func unbindAllCBrowserProcessHandlerT(cp *cCBrowserProcessHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := browser_process_handler.pc_browser_process_handler
	delete(browser_process_handler_handlers.handler, cp)

	delete(browser_process_handler_handlers.on_context_initialized_handler, cp)
	delete(browser_process_handler_handlers.on_before_child_process_launch_handler, cp)
	delete(browser_process_handler_handlers.on_schedule_message_pump_work_handler, cp)
	delete(browser_process_handler_handlers.get_default_client_handler, cp)
}

func (browser_process_handler *CBrowserProcessHandlerT) UnbindAll() {
	unbindAllCBrowserProcessHandlerT(browser_process_handler.pc_browser_process_handler)
	browser_process_handler.Unref()
}

func (browser_process_handler *CBrowserProcessHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := browser_process_handler.pc_browser_process_handler
	return browser_process_handler_handlers.handler[cp]
}

// cef_browser_view_capi.h, include/capi/views/cef_browser_view_capi.h:90:3,

///
// A View hosting a cef_browser_t instance. Methods must be called on the
// browser process UI thread unless otherwise indicated.
///

type cCBrowserViewT C.cef_browser_view_t

// Go type for cef_browser_view_t
type CBrowserViewT struct {
	noCopy          noCopy
	pc_browser_view *cCBrowserViewT
	beUnrefed       unrefedBy
}

func (p *CBrowserViewT) Pass() (ret *CBrowserViewT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBrowserViewT((*C.cef_browser_view_t)(p.pc_browser_view), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBrowserViewT) NewRef() (newP *CBrowserViewT) {
	if self == nil {
		return newP
	}
	gop := self.pc_browser_view
	BaseAddRef(gop)
	newP = newCBrowserViewT((*C.cef_browser_view_t)(gop), byApp)
	return newP
}

// Go type CBrowserViewT wraps cef type *C.cef_browser_view_t
func newCBrowserViewT(p *C.cef_browser_view_t, unrefedBy unrefedBy) *CBrowserViewT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T113.1:")
	pc := (*cCBrowserViewT)(p)
	go_browser_view := &CBrowserViewT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_browser_view, func(g *CBrowserViewT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_browser_view != nil {
			Tracef(unsafe.Pointer(g.pc_browser_view), "T113.2:")
			BaseRelease(g.pc_browser_view)
		}
	})

	return go_browser_view
}

// *C.cef_browser_view_t has refCounted interface
func (browser_view *CBrowserViewT) HasOneRef() bool {
	return BaseHasOneRef(browser_view.pc_browser_view)
}

func (p *cCBrowserViewT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (browser_view *CBrowserViewT) Unref() (ret bool) {
	if browser_view == nil {
		return
	}
	if browser_view.beUnrefed == byApp {
		ret = BaseRelease(browser_view.pc_browser_view)
		browser_view.beUnrefed = unrefed
	}
	browser_view.pc_browser_view = nil
	return ret
}

// Convert to Base Class Pointer *CViewT
func (browser_view *CBrowserViewT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(browser_view.pc_browser_view))
	BaseAddRef(browser_view.pc_browser_view)
	return newCViewT(p, byApp)
}

///
// Returns the cef_browser_t hosted by this BrowserView. Will return NULL if
// the browser has not yet been created or has already been destroyed.
///
func (self *CBrowserViewT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_browser_view_get_browser((*C.cef_browser_view_t)(self.pc_browser_view))

	ret = newCBrowserT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the Chrome toolbar associated with this BrowserView. Only supported
// when using the Chrome runtime. The cef_browser_view_delegate_t::
// get_chrome_toolbar_type() function must return a value other than
// CEF_CTT_NONE and the toolbar will not be available until after this
// BrowserView is added to a cef_window_t and
// cef_view_delegate_t::on_window_changed() has been called.
///
func (self *CBrowserViewT) GetChromeToolbar() (ret *CViewT) {

	cRet := C.cefingo_browser_view_get_chrome_toolbar((*C.cef_browser_view_t)(self.pc_browser_view))

	ret = newCViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets whether accelerators registered with cef_window_t::SetAccelerator are
// triggered before or after the event is sent to the cef_browser_t. If
// |prefer_accelerators| is true (1) then the matching accelerator will be
// triggered immediately and the event will not be sent to the cef_browser_t.
// If |prefer_accelerators| is false (0) then the matching accelerator will
// only be triggered if the event is not handled by web content or by
// cef_keyboard_handler_t. The default value is false (0).
///
func (self *CBrowserViewT) SetPreferAccelerators(
	prefer_accelerators bool,
) {
	var tmpprefer_accelerators int
	if prefer_accelerators {
		tmpprefer_accelerators = 1
	}

	C.cefingo_browser_view_set_prefer_accelerators((*C.cef_browser_view_t)(self.pc_browser_view), C.int(tmpprefer_accelerators))

}

///
// Create a new BrowserView. The underlying cef_browser_t will not be created
// until this view is added to the views hierarchy. The optional |extra_info|
// parameter provides an opportunity to specify extra information specific to
// the created browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
func BrowserViewCreate(
	client *CClientT,
	url string,
	settings *CBrowserSettingsT,
	extra_info *CDictionaryValueT,
	request_context *CRequestContextT,
	delegate *CBrowserViewDelegateT,
) (ret *CBrowserViewT) {
	var goTmpclient *C.cef_client_t
	if client != nil {
		BaseAddRef(client.pc_client)
		goTmpclient = (*C.cef_client_t)(client.pc_client)
	}
	c_url := create_cef_string(url)
	var goTmpextra_info *C.cef_dictionary_value_t
	if extra_info != nil {
		BaseAddRef(extra_info.pc_dictionary_value)
		goTmpextra_info = (*C.cef_dictionary_value_t)(extra_info.pc_dictionary_value)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		BaseAddRef(request_context.pc_request_context)
		goTmprequest_context = (*C.cef_request_context_t)(request_context.pc_request_context)
	}
	var goTmpdelegate *C.cef_browser_view_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_browser_view_delegate)
		goTmpdelegate = (*C.cef_browser_view_delegate_t)(delegate.pc_browser_view_delegate)
	}

	cRet := C.cef_browser_view_create(goTmpclient, c_url.p_cef_string_t, (*C.cef_browser_settings_t)(settings), goTmpextra_info, goTmprequest_context, goTmpdelegate)

	ret = newCBrowserViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the BrowserView associated with |browser|.
///
func BrowserViewGetForBrowser(
	browser *CBrowserT,
) (ret *CBrowserViewT) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		BaseAddRef(browser.pc_browser)
		goTmpbrowser = (*C.cef_browser_t)(browser.pc_browser)
	}

	cRet := C.cef_browser_view_get_for_browser(goTmpbrowser)

	ret = newCBrowserViewT(cRet, byApp) // return GoObj
	return ret
}

// cef_browser_view_delegate_capi.h, include/capi/views/cef_browser_view_delegate_capi.h:123:3,

///
// Implement this structure to handle BrowserView events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCBrowserViewDelegateT C.cef_browser_view_delegate_t

// Go type for cef_browser_view_delegate_t
type CBrowserViewDelegateT struct {
	noCopy                   noCopy
	pc_browser_view_delegate *cCBrowserViewDelegateT
	beUnrefed                unrefedBy
}

func (p *CBrowserViewDelegateT) Pass() (ret *CBrowserViewDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBrowserViewDelegateT((*C.cef_browser_view_delegate_t)(p.pc_browser_view_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBrowserViewDelegateT) NewRef() (newP *CBrowserViewDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_browser_view_delegate
	BaseAddRef(gop)
	newP = newCBrowserViewDelegateT((*C.cef_browser_view_delegate_t)(gop), byApp)
	return newP
}

// Go type CBrowserViewDelegateT wraps cef type *C.cef_browser_view_delegate_t
func newCBrowserViewDelegateT(p *C.cef_browser_view_delegate_t, unrefedBy unrefedBy) *CBrowserViewDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T114.1:")
	pc := (*cCBrowserViewDelegateT)(p)
	go_browser_view_delegate := &CBrowserViewDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_browser_view_delegate, func(g *CBrowserViewDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_browser_view_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_browser_view_delegate), "T114.2:")
			BaseRelease(g.pc_browser_view_delegate)
		}
	})

	return go_browser_view_delegate
}

// *C.cef_browser_view_delegate_t has refCounted interface
func (browser_view_delegate *CBrowserViewDelegateT) HasOneRef() bool {
	return BaseHasOneRef(browser_view_delegate.pc_browser_view_delegate)
}

func (p *cCBrowserViewDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (browser_view_delegate *CBrowserViewDelegateT) Unref() (ret bool) {
	if browser_view_delegate == nil {
		return
	}
	if browser_view_delegate.beUnrefed == byApp {
		ret = BaseRelease(browser_view_delegate.pc_browser_view_delegate)
		browser_view_delegate.beUnrefed = unrefed
	}
	browser_view_delegate.pc_browser_view_delegate = nil
	return ret
}

// Convert to Base Class Pointer *CViewDelegateT
func (browser_view_delegate *CBrowserViewDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(browser_view_delegate.pc_browser_view_delegate))
	BaseAddRef(browser_view_delegate.pc_browser_view_delegate)
	return newCViewDelegateT(p, byApp)
}

///
// Called when |browser| associated with |browser_view| is created. This
// function will be called after cef_life_span_handler_t::on_after_created()
// is called for |browser| and before on_popup_browser_view_created() is
// called for |browser|&#39;s parent delegate if |browser| is a popup.
///
type CBrowserViewDelegateTOnBrowserCreatedHandler interface {
	OnBrowserCreated(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		browser *CBrowserT,
	)
}

///
// Called when |browser| associated with |browser_view| is destroyed. Release
// all references to |browser| and do not attempt to execute any functions on
// |browser| after this callback returns. This function will be called before
// cef_life_span_handler_t::on_before_close() is called for |browser|.
///
type CBrowserViewDelegateTOnBrowserDestroyedHandler interface {
	OnBrowserDestroyed(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		browser *CBrowserT,
	)
}

///
// Called before a new popup BrowserView is created. The popup originated from
// |browser_view|. |settings| and |client| are the values returned from
// cef_life_span_handler_t::on_before_popup(). |is_devtools| will be true (1)
// if the popup will be a DevTools browser. Return the delegate that will be
// used for the new popup BrowserView.
///
type GetDelegateForPopupBrowserViewHandler interface {
	GetDelegateForPopupBrowserView(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		settings *CBrowserSettingsT,
		client *CClientT,
		is_devtools bool,
	) (ret *CBrowserViewDelegateT)
}

///
// Called after |popup_browser_view| is created. This function will be called
// after cef_life_span_handler_t::on_after_created() and on_browser_created()
// are called for the new popup browser. The popup originated from
// |browser_view|. |is_devtools| will be true (1) if the popup is a DevTools
// browser. Optionally add |popup_browser_view| to the views hierarchy
// yourself and return true (1). Otherwise return false (0) and a default
// cef_window_t will be created for the popup.
///
type OnPopupBrowserViewCreatedHandler interface {
	OnPopupBrowserViewCreated(
		self *CBrowserViewDelegateT,
		browser_view *CBrowserViewT,
		popup_browser_view *CBrowserViewT,
		is_devtools bool,
	) (ret bool)
}

///
// Returns the Chrome toolbar type that will be available via
// cef_browser_view_t::get_chrome_toolbar(). See that function for related
// documentation.
///
type GetChromeToolbarTypeHandler interface {
	GetChromeToolbarType(
		self *CBrowserViewDelegateT,
	) (ret CChromeToolbarTypeT)
}

var browser_view_delegate_handlers = struct {
	handler                                     map[*cCBrowserViewDelegateT]interface{}
	on_browser_created_handler                  map[*cCBrowserViewDelegateT]CBrowserViewDelegateTOnBrowserCreatedHandler
	on_browser_destroyed_handler                map[*cCBrowserViewDelegateT]CBrowserViewDelegateTOnBrowserDestroyedHandler
	get_delegate_for_popup_browser_view_handler map[*cCBrowserViewDelegateT]GetDelegateForPopupBrowserViewHandler
	on_popup_browser_view_created_handler       map[*cCBrowserViewDelegateT]OnPopupBrowserViewCreatedHandler
	get_chrome_toolbar_type_handler             map[*cCBrowserViewDelegateT]GetChromeToolbarTypeHandler
	get_preferred_size_handler                  map[*cCBrowserViewDelegateT]GetPreferredSizeHandler
	get_minimum_size_handler                    map[*cCBrowserViewDelegateT]GetMinimumSizeHandler
	get_maximum_size_handler                    map[*cCBrowserViewDelegateT]GetMaximumSizeHandler
	get_height_for_width_handler                map[*cCBrowserViewDelegateT]GetHeightForWidthHandler
	on_parent_view_changed_handler              map[*cCBrowserViewDelegateT]OnParentViewChangedHandler
	on_child_view_changed_handler               map[*cCBrowserViewDelegateT]OnChildViewChangedHandler
	on_window_changed_handler                   map[*cCBrowserViewDelegateT]OnWindowChangedHandler
	on_layout_changed_handler                   map[*cCBrowserViewDelegateT]OnLayoutChangedHandler
	on_focus_handler                            map[*cCBrowserViewDelegateT]OnFocusHandler
	on_blur_handler                             map[*cCBrowserViewDelegateT]OnBlurHandler
}{
	map[*cCBrowserViewDelegateT]interface{}{},
	map[*cCBrowserViewDelegateT]CBrowserViewDelegateTOnBrowserCreatedHandler{},
	map[*cCBrowserViewDelegateT]CBrowserViewDelegateTOnBrowserDestroyedHandler{},
	map[*cCBrowserViewDelegateT]GetDelegateForPopupBrowserViewHandler{},
	map[*cCBrowserViewDelegateT]OnPopupBrowserViewCreatedHandler{},
	map[*cCBrowserViewDelegateT]GetChromeToolbarTypeHandler{},
	map[*cCBrowserViewDelegateT]GetPreferredSizeHandler{},
	map[*cCBrowserViewDelegateT]GetMinimumSizeHandler{},
	map[*cCBrowserViewDelegateT]GetMaximumSizeHandler{},
	map[*cCBrowserViewDelegateT]GetHeightForWidthHandler{},
	map[*cCBrowserViewDelegateT]OnParentViewChangedHandler{},
	map[*cCBrowserViewDelegateT]OnChildViewChangedHandler{},
	map[*cCBrowserViewDelegateT]OnWindowChangedHandler{},
	map[*cCBrowserViewDelegateT]OnLayoutChangedHandler{},
	map[*cCBrowserViewDelegateT]OnFocusHandler{},
	map[*cCBrowserViewDelegateT]OnBlurHandler{},
}

// allocCBrowserViewDelegateT allocates CBrowserViewDelegateT and construct it
func allocCBrowserViewDelegateT() *CBrowserViewDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_browser_view_delegate_wrapper_t, "T114.3:")
	cefp := C.cefingo_construct_browser_view_delegate((*C.cefingo_browser_view_delegate_wrapper_t)(up))
	cgop := (*cCBrowserViewDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_browser_view_delegate_t itself in DeassocFunc,
		// or cef_browser_view_delegate_t is never GCed.
		Tracef(up, "T114.4:")
		unbindAllCBrowserViewDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCBrowserViewDelegateT(cefp, byApp)
}

// NewCBrowserViewDelegateT allocates CBrowserViewDelegateT, construct and bind it
func NewCBrowserViewDelegateT(a interface{}) *CBrowserViewDelegateT {
	return allocCBrowserViewDelegateT().bind(a)
}

func (browser_view_delegate *CBrowserViewDelegateT) bind(a interface{}) *CBrowserViewDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := browser_view_delegate.pc_browser_view_delegate
	browser_view_delegate_handlers.handler[cp] = a

	if h, ok := a.(CBrowserViewDelegateTOnBrowserCreatedHandler); ok {
		browser_view_delegate_handlers.on_browser_created_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_browser_created_handler, cp)
	}

	if h, ok := a.(CBrowserViewDelegateTOnBrowserDestroyedHandler); ok {
		browser_view_delegate_handlers.on_browser_destroyed_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_browser_destroyed_handler, cp)
	}

	if h, ok := a.(GetDelegateForPopupBrowserViewHandler); ok {
		browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler, cp)
	}

	if h, ok := a.(OnPopupBrowserViewCreatedHandler); ok {
		browser_view_delegate_handlers.on_popup_browser_view_created_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_popup_browser_view_created_handler, cp)
	}

	if h, ok := a.(GetChromeToolbarTypeHandler); ok {
		browser_view_delegate_handlers.get_chrome_toolbar_type_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.get_chrome_toolbar_type_handler, cp)
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		browser_view_delegate_handlers.get_preferred_size_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.get_preferred_size_handler, cp)
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		browser_view_delegate_handlers.get_minimum_size_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.get_minimum_size_handler, cp)
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		browser_view_delegate_handlers.get_maximum_size_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.get_maximum_size_handler, cp)
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		browser_view_delegate_handlers.get_height_for_width_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.get_height_for_width_handler, cp)
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		browser_view_delegate_handlers.on_parent_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_parent_view_changed_handler, cp)
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		browser_view_delegate_handlers.on_child_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_child_view_changed_handler, cp)
	}

	if h, ok := a.(OnWindowChangedHandler); ok {
		browser_view_delegate_handlers.on_window_changed_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_window_changed_handler, cp)
	}

	if h, ok := a.(OnLayoutChangedHandler); ok {
		browser_view_delegate_handlers.on_layout_changed_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_layout_changed_handler, cp)
	}

	if h, ok := a.(OnFocusHandler); ok {
		browser_view_delegate_handlers.on_focus_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_focus_handler, cp)
	}

	if h, ok := a.(OnBlurHandler); ok {
		browser_view_delegate_handlers.on_blur_handler[cp] = h
		noBind = false
	} else {
		delete(browser_view_delegate_handlers.on_blur_handler, cp)
	}

	if noBind {
		Panicln("F229: *CBrowserViewDelegateT No bind")
	}
	return browser_view_delegate
}

func unbindAllCBrowserViewDelegateT(cp *cCBrowserViewDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := browser_view_delegate.pc_browser_view_delegate
	delete(browser_view_delegate_handlers.handler, cp)

	delete(browser_view_delegate_handlers.on_browser_created_handler, cp)
	delete(browser_view_delegate_handlers.on_browser_destroyed_handler, cp)
	delete(browser_view_delegate_handlers.get_delegate_for_popup_browser_view_handler, cp)
	delete(browser_view_delegate_handlers.on_popup_browser_view_created_handler, cp)
	delete(browser_view_delegate_handlers.get_chrome_toolbar_type_handler, cp)
	delete(browser_view_delegate_handlers.get_preferred_size_handler, cp)
	delete(browser_view_delegate_handlers.get_minimum_size_handler, cp)
	delete(browser_view_delegate_handlers.get_maximum_size_handler, cp)
	delete(browser_view_delegate_handlers.get_height_for_width_handler, cp)
	delete(browser_view_delegate_handlers.on_parent_view_changed_handler, cp)
	delete(browser_view_delegate_handlers.on_child_view_changed_handler, cp)
	delete(browser_view_delegate_handlers.on_window_changed_handler, cp)
	delete(browser_view_delegate_handlers.on_layout_changed_handler, cp)
	delete(browser_view_delegate_handlers.on_focus_handler, cp)
	delete(browser_view_delegate_handlers.on_blur_handler, cp)
}

func (browser_view_delegate *CBrowserViewDelegateT) UnbindAll() {
	unbindAllCBrowserViewDelegateT(browser_view_delegate.pc_browser_view_delegate)
	browser_view_delegate.Unref()
}

func (browser_view_delegate *CBrowserViewDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := browser_view_delegate.pc_browser_view_delegate
	return browser_view_delegate_handlers.handler[cp]
}

// cef_button_capi.h, include/capi/views/cef_button_capi.h:97:3,

///
// A View representing a button. Depending on the specific type, the button
// could be implemented by a native control or custom rendered. Methods must be
// called on the browser process UI thread unless otherwise indicated.
///

type cCButtonT C.cef_button_t

// Go type for cef_button_t
type CButtonT struct {
	noCopy    noCopy
	pc_button *cCButtonT
	beUnrefed unrefedBy
}

func (p *CButtonT) Pass() (ret *CButtonT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCButtonT((*C.cef_button_t)(p.pc_button), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CButtonT) NewRef() (newP *CButtonT) {
	if self == nil {
		return newP
	}
	gop := self.pc_button
	BaseAddRef(gop)
	newP = newCButtonT((*C.cef_button_t)(gop), byApp)
	return newP
}

// Go type CButtonT wraps cef type *C.cef_button_t
func newCButtonT(p *C.cef_button_t, unrefedBy unrefedBy) *CButtonT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T115.1:")
	pc := (*cCButtonT)(p)
	go_button := &CButtonT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_button, func(g *CButtonT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_button != nil {
			Tracef(unsafe.Pointer(g.pc_button), "T115.2:")
			BaseRelease(g.pc_button)
		}
	})

	return go_button
}

// *C.cef_button_t has refCounted interface
func (button *CButtonT) HasOneRef() bool {
	return BaseHasOneRef(button.pc_button)
}

func (p *cCButtonT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (button *CButtonT) Unref() (ret bool) {
	if button == nil {
		return
	}
	if button.beUnrefed == byApp {
		ret = BaseRelease(button.pc_button)
		button.beUnrefed = unrefed
	}
	button.pc_button = nil
	return ret
}

// Convert to Base Class Pointer *CViewT
func (button *CButtonT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(button.pc_button))
	BaseAddRef(button.pc_button)
	return newCViewT(p, byApp)
}

///
// Returns this Button as a LabelButton or NULL if this is not a LabelButton.
///
func (self *CButtonT) AsLabelButton() (ret *CLabelButtonT) {

	cRet := C.cefingo_button_as_label_button((*C.cef_button_t)(self.pc_button))

	ret = newCLabelButtonT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the current display state of the Button.
///
func (self *CButtonT) SetState(
	state CButtonStateT,
) {

	C.cefingo_button_set_state((*C.cef_button_t)(self.pc_button), (C.cef_button_state_t)(state))

}

///
// Returns the current display state of the Button.
///
func (self *CButtonT) GetState() (ret CButtonStateT) {

	cRet := C.cefingo_button_get_state((*C.cef_button_t)(self.pc_button))

	ret = CButtonStateT(cRet) // return GoObj
	return ret
}

///
// Sets the Button will use an ink drop effect for displaying state changes.
///
func (self *CButtonT) SetInkDropEnabled(
	enabled int,
) {

	C.cefingo_button_set_ink_drop_enabled((*C.cef_button_t)(self.pc_button), (C.int)(enabled))

}

///
// Sets the tooltip text that will be displayed when the user hovers the mouse
// cursor over the Button.
///
func (self *CButtonT) SetTooltipText(
	tooltip_text string,
) {
	c_tooltip_text := create_cef_string(tooltip_text)

	C.cefingo_button_set_tooltip_text((*C.cef_button_t)(self.pc_button), c_tooltip_text.p_cef_string_t)

}

///
// Sets the accessible name that will be exposed to assistive technology (AT).
///
func (self *CButtonT) SetAccessibleName(
	name string,
) {
	c_name := create_cef_string(name)

	C.cefingo_button_set_accessible_name((*C.cef_button_t)(self.pc_button), c_name.p_cef_string_t)

}

// cef_button_delegate_capi.h, include/capi/views/cef_button_delegate_capi.h:74:3,

///
// Implement this structure to handle Button events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCButtonDelegateT C.cef_button_delegate_t

// Go type for cef_button_delegate_t
type CButtonDelegateT struct {
	noCopy             noCopy
	pc_button_delegate *cCButtonDelegateT
	beUnrefed          unrefedBy
}

func (p *CButtonDelegateT) Pass() (ret *CButtonDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCButtonDelegateT((*C.cef_button_delegate_t)(p.pc_button_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CButtonDelegateT) NewRef() (newP *CButtonDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_button_delegate
	BaseAddRef(gop)
	newP = newCButtonDelegateT((*C.cef_button_delegate_t)(gop), byApp)
	return newP
}

// Go type CButtonDelegateT wraps cef type *C.cef_button_delegate_t
func newCButtonDelegateT(p *C.cef_button_delegate_t, unrefedBy unrefedBy) *CButtonDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T116.1:")
	pc := (*cCButtonDelegateT)(p)
	go_button_delegate := &CButtonDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_button_delegate, func(g *CButtonDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_button_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_button_delegate), "T116.2:")
			BaseRelease(g.pc_button_delegate)
		}
	})

	return go_button_delegate
}

// *C.cef_button_delegate_t has refCounted interface
func (button_delegate *CButtonDelegateT) HasOneRef() bool {
	return BaseHasOneRef(button_delegate.pc_button_delegate)
}

func (p *cCButtonDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (button_delegate *CButtonDelegateT) Unref() (ret bool) {
	if button_delegate == nil {
		return
	}
	if button_delegate.beUnrefed == byApp {
		ret = BaseRelease(button_delegate.pc_button_delegate)
		button_delegate.beUnrefed = unrefed
	}
	button_delegate.pc_button_delegate = nil
	return ret
}

// Convert to Base Class Pointer *CViewDelegateT
func (button_delegate *CButtonDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(button_delegate.pc_button_delegate))
	BaseAddRef(button_delegate.pc_button_delegate)
	return newCViewDelegateT(p, byApp)
}

///
// Called when |button| is pressed.
///
type OnButtonPressedHandler interface {
	OnButtonPressed(
		self *CButtonDelegateT,
		button *CButtonT,
	)
}

///
// Called when the state of |button| changes.
///
type OnButtonStateChangedHandler interface {
	OnButtonStateChanged(
		self *CButtonDelegateT,
		button *CButtonT,
	)
}

var button_delegate_handlers = struct {
	handler                         map[*cCButtonDelegateT]interface{}
	on_button_pressed_handler       map[*cCButtonDelegateT]OnButtonPressedHandler
	on_button_state_changed_handler map[*cCButtonDelegateT]OnButtonStateChangedHandler
	get_preferred_size_handler      map[*cCButtonDelegateT]GetPreferredSizeHandler
	get_minimum_size_handler        map[*cCButtonDelegateT]GetMinimumSizeHandler
	get_maximum_size_handler        map[*cCButtonDelegateT]GetMaximumSizeHandler
	get_height_for_width_handler    map[*cCButtonDelegateT]GetHeightForWidthHandler
	on_parent_view_changed_handler  map[*cCButtonDelegateT]OnParentViewChangedHandler
	on_child_view_changed_handler   map[*cCButtonDelegateT]OnChildViewChangedHandler
	on_window_changed_handler       map[*cCButtonDelegateT]OnWindowChangedHandler
	on_layout_changed_handler       map[*cCButtonDelegateT]OnLayoutChangedHandler
	on_focus_handler                map[*cCButtonDelegateT]OnFocusHandler
	on_blur_handler                 map[*cCButtonDelegateT]OnBlurHandler
}{
	map[*cCButtonDelegateT]interface{}{},
	map[*cCButtonDelegateT]OnButtonPressedHandler{},
	map[*cCButtonDelegateT]OnButtonStateChangedHandler{},
	map[*cCButtonDelegateT]GetPreferredSizeHandler{},
	map[*cCButtonDelegateT]GetMinimumSizeHandler{},
	map[*cCButtonDelegateT]GetMaximumSizeHandler{},
	map[*cCButtonDelegateT]GetHeightForWidthHandler{},
	map[*cCButtonDelegateT]OnParentViewChangedHandler{},
	map[*cCButtonDelegateT]OnChildViewChangedHandler{},
	map[*cCButtonDelegateT]OnWindowChangedHandler{},
	map[*cCButtonDelegateT]OnLayoutChangedHandler{},
	map[*cCButtonDelegateT]OnFocusHandler{},
	map[*cCButtonDelegateT]OnBlurHandler{},
}

// allocCButtonDelegateT allocates CButtonDelegateT and construct it
func allocCButtonDelegateT() *CButtonDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_button_delegate_wrapper_t, "T116.3:")
	cefp := C.cefingo_construct_button_delegate((*C.cefingo_button_delegate_wrapper_t)(up))
	cgop := (*cCButtonDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_button_delegate_t itself in DeassocFunc,
		// or cef_button_delegate_t is never GCed.
		Tracef(up, "T116.4:")
		unbindAllCButtonDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCButtonDelegateT(cefp, byApp)
}

// NewCButtonDelegateT allocates CButtonDelegateT, construct and bind it
func NewCButtonDelegateT(a interface{}) *CButtonDelegateT {
	return allocCButtonDelegateT().bind(a)
}

func (button_delegate *CButtonDelegateT) bind(a interface{}) *CButtonDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := button_delegate.pc_button_delegate
	button_delegate_handlers.handler[cp] = a

	if h, ok := a.(OnButtonPressedHandler); ok {
		button_delegate_handlers.on_button_pressed_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_button_pressed_handler, cp)
	}

	if h, ok := a.(OnButtonStateChangedHandler); ok {
		button_delegate_handlers.on_button_state_changed_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_button_state_changed_handler, cp)
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		button_delegate_handlers.get_preferred_size_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.get_preferred_size_handler, cp)
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		button_delegate_handlers.get_minimum_size_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.get_minimum_size_handler, cp)
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		button_delegate_handlers.get_maximum_size_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.get_maximum_size_handler, cp)
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		button_delegate_handlers.get_height_for_width_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.get_height_for_width_handler, cp)
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		button_delegate_handlers.on_parent_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_parent_view_changed_handler, cp)
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		button_delegate_handlers.on_child_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_child_view_changed_handler, cp)
	}

	if h, ok := a.(OnWindowChangedHandler); ok {
		button_delegate_handlers.on_window_changed_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_window_changed_handler, cp)
	}

	if h, ok := a.(OnLayoutChangedHandler); ok {
		button_delegate_handlers.on_layout_changed_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_layout_changed_handler, cp)
	}

	if h, ok := a.(OnFocusHandler); ok {
		button_delegate_handlers.on_focus_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_focus_handler, cp)
	}

	if h, ok := a.(OnBlurHandler); ok {
		button_delegate_handlers.on_blur_handler[cp] = h
		noBind = false
	} else {
		delete(button_delegate_handlers.on_blur_handler, cp)
	}

	if noBind {
		Panicln("F229: *CButtonDelegateT No bind")
	}
	return button_delegate
}

func unbindAllCButtonDelegateT(cp *cCButtonDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := button_delegate.pc_button_delegate
	delete(button_delegate_handlers.handler, cp)

	delete(button_delegate_handlers.on_button_pressed_handler, cp)
	delete(button_delegate_handlers.on_button_state_changed_handler, cp)
	delete(button_delegate_handlers.get_preferred_size_handler, cp)
	delete(button_delegate_handlers.get_minimum_size_handler, cp)
	delete(button_delegate_handlers.get_maximum_size_handler, cp)
	delete(button_delegate_handlers.get_height_for_width_handler, cp)
	delete(button_delegate_handlers.on_parent_view_changed_handler, cp)
	delete(button_delegate_handlers.on_child_view_changed_handler, cp)
	delete(button_delegate_handlers.on_window_changed_handler, cp)
	delete(button_delegate_handlers.on_layout_changed_handler, cp)
	delete(button_delegate_handlers.on_focus_handler, cp)
	delete(button_delegate_handlers.on_blur_handler, cp)
}

func (button_delegate *CButtonDelegateT) UnbindAll() {
	unbindAllCButtonDelegateT(button_delegate.pc_button_delegate)
	button_delegate.Unref()
}

func (button_delegate *CButtonDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := button_delegate.pc_button_delegate
	return button_delegate_handlers.handler[cp]
}

// cef_callback_capi.h, include/capi/cef_callback_capi.h:67:3,

///
// Generic callback structure used for asynchronous continuation.
///

type cCCallbackT C.cef_callback_t

// Go type for cef_callback_t
type CCallbackT struct {
	noCopy      noCopy
	pc_callback *cCCallbackT
	beUnrefed   unrefedBy
}

func (p *CCallbackT) Pass() (ret *CCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCCallbackT((*C.cef_callback_t)(p.pc_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CCallbackT) NewRef() (newP *CCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_callback
	BaseAddRef(gop)
	newP = newCCallbackT((*C.cef_callback_t)(gop), byApp)
	return newP
}

// Go type CCallbackT wraps cef type *C.cef_callback_t
func newCCallbackT(p *C.cef_callback_t, unrefedBy unrefedBy) *CCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T117.1:")
	pc := (*cCCallbackT)(p)
	go_callback := &CCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_callback, func(g *CCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_callback != nil {
			Tracef(unsafe.Pointer(g.pc_callback), "T117.2:")
			BaseRelease(g.pc_callback)
		}
	})

	return go_callback
}

// *C.cef_callback_t has refCounted interface
func (callback *CCallbackT) HasOneRef() bool {
	return BaseHasOneRef(callback.pc_callback)
}

func (p *cCCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (callback *CCallbackT) Unref() (ret bool) {
	if callback == nil {
		return
	}
	if callback.beUnrefed == byApp {
		ret = BaseRelease(callback.pc_callback)
		callback.beUnrefed = unrefed
	}
	callback.pc_callback = nil
	return ret
}

///
// Continue processing.
///
func (self *CCallbackT) Cont() {

	C.cefingo_callback_cont((*C.cef_callback_t)(self.pc_callback))

}

///
// Cancel processing.
///
func (self *CCallbackT) Cancel() {

	C.cefingo_callback_cancel((*C.cef_callback_t)(self.pc_callback))

}

///
// Generic callback structure used for asynchronous completion.
///

type cCCompletionCallbackT C.cef_completion_callback_t

// Go type for cef_completion_callback_t
type CCompletionCallbackT struct {
	noCopy                 noCopy
	pc_completion_callback *cCCompletionCallbackT
	beUnrefed              unrefedBy
}

func (p *CCompletionCallbackT) Pass() (ret *CCompletionCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCCompletionCallbackT((*C.cef_completion_callback_t)(p.pc_completion_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CCompletionCallbackT) NewRef() (newP *CCompletionCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_completion_callback
	BaseAddRef(gop)
	newP = newCCompletionCallbackT((*C.cef_completion_callback_t)(gop), byApp)
	return newP
}

// Go type CCompletionCallbackT wraps cef type *C.cef_completion_callback_t
func newCCompletionCallbackT(p *C.cef_completion_callback_t, unrefedBy unrefedBy) *CCompletionCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T118.1:")
	pc := (*cCCompletionCallbackT)(p)
	go_completion_callback := &CCompletionCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_completion_callback, func(g *CCompletionCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_completion_callback != nil {
			Tracef(unsafe.Pointer(g.pc_completion_callback), "T118.2:")
			BaseRelease(g.pc_completion_callback)
		}
	})

	return go_completion_callback
}

// *C.cef_completion_callback_t has refCounted interface
func (completion_callback *CCompletionCallbackT) HasOneRef() bool {
	return BaseHasOneRef(completion_callback.pc_completion_callback)
}

func (p *cCCompletionCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (completion_callback *CCompletionCallbackT) Unref() (ret bool) {
	if completion_callback == nil {
		return
	}
	if completion_callback.beUnrefed == byApp {
		ret = BaseRelease(completion_callback.pc_completion_callback)
		completion_callback.beUnrefed = unrefed
	}
	completion_callback.pc_completion_callback = nil
	return ret
}

///
// Method that will be called once the task is complete.
///
func (self *CCompletionCallbackT) OnComplete() {

	C.cefingo_completion_callback_on_complete((*C.cef_completion_callback_t)(self.pc_completion_callback))

}

// cef_client_capi.h, include/capi/cef_client_capi.h:197:3,

///
// Implement this structure to provide handler implementations.
///

type cCClientT C.cef_client_t

// Go type for cef_client_t
type CClientT struct {
	noCopy    noCopy
	pc_client *cCClientT
	beUnrefed unrefedBy
}

func (p *CClientT) Pass() (ret *CClientT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCClientT((*C.cef_client_t)(p.pc_client), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CClientT) NewRef() (newP *CClientT) {
	if self == nil {
		return newP
	}
	gop := self.pc_client
	BaseAddRef(gop)
	newP = newCClientT((*C.cef_client_t)(gop), byApp)
	return newP
}

// Go type CClientT wraps cef type *C.cef_client_t
func newCClientT(p *C.cef_client_t, unrefedBy unrefedBy) *CClientT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T119.1:")
	pc := (*cCClientT)(p)
	go_client := &CClientT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_client, func(g *CClientT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_client != nil {
			Tracef(unsafe.Pointer(g.pc_client), "T119.2:")
			BaseRelease(g.pc_client)
		}
	})

	return go_client
}

// *C.cef_client_t has refCounted interface
func (client *CClientT) HasOneRef() bool {
	return BaseHasOneRef(client.pc_client)
}

func (p *cCClientT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (client *CClientT) Unref() (ret bool) {
	if client == nil {
		return
	}
	if client.beUnrefed == byApp {
		ret = BaseRelease(client.pc_client)
		client.beUnrefed = unrefed
	}
	client.pc_client = nil
	return ret
}

///
// Return the handler for audio rendering events.
///
type GetAudioHandlerHandler interface {
	GetAudioHandler(
		self *CClientT,
	) (ret *CAudioHandlerT)
}

///
// Return the handler for commands. If no handler is provided the default
// implementation will be used.
///
type GetCommandHandlerHandler interface {
	GetCommandHandler(
		self *CClientT,
	) (ret *CCommandHandlerT)
}

///
// Return the handler for context menus. If no handler is provided the default
// implementation will be used.
///
type GetContextMenuHandlerHandler interface {
	GetContextMenuHandler(
		self *CClientT,
	) (ret *CContextMenuHandlerT)
}

///
// Return the handler for dialogs. If no handler is provided the default
// implementation will be used.
///
type GetDialogHandlerHandler interface {
	GetDialogHandler(
		self *CClientT,
	) (ret *CDialogHandlerT)
}

///
// Return the handler for browser display state events.
///
type GetDisplayHandlerHandler interface {
	GetDisplayHandler(
		self *CClientT,
	) (ret *CDisplayHandlerT)
}

///
// Return the handler for download events. If no handler is returned downloads
// will not be allowed.
///
type GetDownloadHandlerHandler interface {
	GetDownloadHandler(
		self *CClientT,
	) (ret *CDownloadHandlerT)
}

///
// Return the handler for drag events.
///
type GetDragHandlerHandler interface {
	GetDragHandler(
		self *CClientT,
	) (ret *CDragHandlerT)
}

///
// Return the handler for find result events.
///
type GetFindHandlerHandler interface {
	GetFindHandler(
		self *CClientT,
	) (ret *CFindHandlerT)
}

///
// Return the handler for focus events.
///
type GetFocusHandlerHandler interface {
	GetFocusHandler(
		self *CClientT,
	) (ret *CFocusHandlerT)
}

///
// Return the handler for events related to cef_frame_t lifespan. This
// function will be called once during cef_browser_t creation and the result
// will be cached for performance reasons.
///
type GetFrameHandlerHandler interface {
	GetFrameHandler(
		self *CClientT,
	) (ret *CFrameHandlerT)
}

///
// Return the handler for JavaScript dialogs. If no handler is provided the
// default implementation will be used.
///
type GetJsdialogHandlerHandler interface {
	GetJsdialogHandler(
		self *CClientT,
	) (ret *CJsdialogHandlerT)
}

///
// Return the handler for keyboard events.
///
type GetKeyboardHandlerHandler interface {
	GetKeyboardHandler(
		self *CClientT,
	) (ret *CKeyboardHandlerT)
}

///
// Return the handler for browser life span events.
///
type GetLifeSpanHandlerHandler interface {
	GetLifeSpanHandler(
		self *CClientT,
	) (ret *CLifeSpanHandlerT)
}

///
// Return the handler for browser load status events.
///
type CClientTGetLoadHandlerHandler interface {
	GetLoadHandler(
		self *CClientT,
	) (ret *CLoadHandlerT)
}

///
// Return the handler for printing on Linux. If a print handler is not
// provided then printing will not be supported on the Linux platform.
///
type GetPrintHandlerHandler interface {
	GetPrintHandler(
		self *CClientT,
	) (ret *CPrintHandlerT)
}

///
// Return the handler for off-screen rendering events.
///
type GetRenderHandlerHandler interface {
	GetRenderHandler(
		self *CClientT,
	) (ret *CRenderHandlerT)
}

///
// Return the handler for browser request events.
///
type GetRequestHandlerHandler interface {
	GetRequestHandler(
		self *CClientT,
	) (ret *CRequestHandlerT)
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise.  It is safe to keep
// a reference to |message| outside of this callback.
///
type CClientTOnProcessMessageReceivedHandler interface {
	OnProcessMessageReceived(
		self *CClientT,
		browser *CBrowserT,
		frame *CFrameT,
		source_process CProcessIdT,
		message *CProcessMessageT,
	) (ret bool)
}

var client_handlers = struct {
	handler                             map[*cCClientT]interface{}
	get_audio_handler_handler           map[*cCClientT]GetAudioHandlerHandler
	get_command_handler_handler         map[*cCClientT]GetCommandHandlerHandler
	get_context_menu_handler_handler    map[*cCClientT]GetContextMenuHandlerHandler
	get_dialog_handler_handler          map[*cCClientT]GetDialogHandlerHandler
	get_display_handler_handler         map[*cCClientT]GetDisplayHandlerHandler
	get_download_handler_handler        map[*cCClientT]GetDownloadHandlerHandler
	get_drag_handler_handler            map[*cCClientT]GetDragHandlerHandler
	get_find_handler_handler            map[*cCClientT]GetFindHandlerHandler
	get_focus_handler_handler           map[*cCClientT]GetFocusHandlerHandler
	get_frame_handler_handler           map[*cCClientT]GetFrameHandlerHandler
	get_jsdialog_handler_handler        map[*cCClientT]GetJsdialogHandlerHandler
	get_keyboard_handler_handler        map[*cCClientT]GetKeyboardHandlerHandler
	get_life_span_handler_handler       map[*cCClientT]GetLifeSpanHandlerHandler
	get_load_handler_handler            map[*cCClientT]CClientTGetLoadHandlerHandler
	get_print_handler_handler           map[*cCClientT]GetPrintHandlerHandler
	get_render_handler_handler          map[*cCClientT]GetRenderHandlerHandler
	get_request_handler_handler         map[*cCClientT]GetRequestHandlerHandler
	on_process_message_received_handler map[*cCClientT]CClientTOnProcessMessageReceivedHandler
}{
	map[*cCClientT]interface{}{},
	map[*cCClientT]GetAudioHandlerHandler{},
	map[*cCClientT]GetCommandHandlerHandler{},
	map[*cCClientT]GetContextMenuHandlerHandler{},
	map[*cCClientT]GetDialogHandlerHandler{},
	map[*cCClientT]GetDisplayHandlerHandler{},
	map[*cCClientT]GetDownloadHandlerHandler{},
	map[*cCClientT]GetDragHandlerHandler{},
	map[*cCClientT]GetFindHandlerHandler{},
	map[*cCClientT]GetFocusHandlerHandler{},
	map[*cCClientT]GetFrameHandlerHandler{},
	map[*cCClientT]GetJsdialogHandlerHandler{},
	map[*cCClientT]GetKeyboardHandlerHandler{},
	map[*cCClientT]GetLifeSpanHandlerHandler{},
	map[*cCClientT]CClientTGetLoadHandlerHandler{},
	map[*cCClientT]GetPrintHandlerHandler{},
	map[*cCClientT]GetRenderHandlerHandler{},
	map[*cCClientT]GetRequestHandlerHandler{},
	map[*cCClientT]CClientTOnProcessMessageReceivedHandler{},
}

// allocCClientT allocates CClientT and construct it
func allocCClientT() *CClientT {
	up := c_calloc(1, C.sizeof_cefingo_client_wrapper_t, "T119.3:")
	cefp := C.cefingo_construct_client((*C.cefingo_client_wrapper_t)(up))
	cgop := (*cCClientT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_client_t itself in DeassocFunc,
		// or cef_client_t is never GCed.
		Tracef(up, "T119.4:")
		unbindAllCClientT(cgop)
	}))

	BaseAddRef(cgop)
	return newCClientT(cefp, byApp)
}

// NewCClientT allocates CClientT, construct and bind it
func NewCClientT(a interface{}) *CClientT {
	return allocCClientT().bind(a)
}

func (client *CClientT) bind(a interface{}) *CClientT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := client.pc_client
	client_handlers.handler[cp] = a

	if h, ok := a.(GetAudioHandlerHandler); ok {
		client_handlers.get_audio_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_audio_handler_handler, cp)
	}

	if h, ok := a.(GetCommandHandlerHandler); ok {
		client_handlers.get_command_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_command_handler_handler, cp)
	}

	if h, ok := a.(GetContextMenuHandlerHandler); ok {
		client_handlers.get_context_menu_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_context_menu_handler_handler, cp)
	}

	if h, ok := a.(GetDialogHandlerHandler); ok {
		client_handlers.get_dialog_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_dialog_handler_handler, cp)
	}

	if h, ok := a.(GetDisplayHandlerHandler); ok {
		client_handlers.get_display_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_display_handler_handler, cp)
	}

	if h, ok := a.(GetDownloadHandlerHandler); ok {
		client_handlers.get_download_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_download_handler_handler, cp)
	}

	if h, ok := a.(GetDragHandlerHandler); ok {
		client_handlers.get_drag_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_drag_handler_handler, cp)
	}

	if h, ok := a.(GetFindHandlerHandler); ok {
		client_handlers.get_find_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_find_handler_handler, cp)
	}

	if h, ok := a.(GetFocusHandlerHandler); ok {
		client_handlers.get_focus_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_focus_handler_handler, cp)
	}

	if h, ok := a.(GetFrameHandlerHandler); ok {
		client_handlers.get_frame_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_frame_handler_handler, cp)
	}

	if h, ok := a.(GetJsdialogHandlerHandler); ok {
		client_handlers.get_jsdialog_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_jsdialog_handler_handler, cp)
	}

	if h, ok := a.(GetKeyboardHandlerHandler); ok {
		client_handlers.get_keyboard_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_keyboard_handler_handler, cp)
	}

	if h, ok := a.(GetLifeSpanHandlerHandler); ok {
		client_handlers.get_life_span_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_life_span_handler_handler, cp)
	}

	if h, ok := a.(CClientTGetLoadHandlerHandler); ok {
		client_handlers.get_load_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_load_handler_handler, cp)
	}

	if h, ok := a.(GetPrintHandlerHandler); ok {
		client_handlers.get_print_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_print_handler_handler, cp)
	}

	if h, ok := a.(GetRenderHandlerHandler); ok {
		client_handlers.get_render_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_render_handler_handler, cp)
	}

	if h, ok := a.(GetRequestHandlerHandler); ok {
		client_handlers.get_request_handler_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.get_request_handler_handler, cp)
	}

	if h, ok := a.(CClientTOnProcessMessageReceivedHandler); ok {
		client_handlers.on_process_message_received_handler[cp] = h
		noBind = false
	} else {
		delete(client_handlers.on_process_message_received_handler, cp)
	}

	if noBind {
		Panicln("F229: *CClientT No bind")
	}
	return client
}

func unbindAllCClientT(cp *cCClientT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := client.pc_client
	delete(client_handlers.handler, cp)

	delete(client_handlers.get_audio_handler_handler, cp)
	delete(client_handlers.get_command_handler_handler, cp)
	delete(client_handlers.get_context_menu_handler_handler, cp)
	delete(client_handlers.get_dialog_handler_handler, cp)
	delete(client_handlers.get_display_handler_handler, cp)
	delete(client_handlers.get_download_handler_handler, cp)
	delete(client_handlers.get_drag_handler_handler, cp)
	delete(client_handlers.get_find_handler_handler, cp)
	delete(client_handlers.get_focus_handler_handler, cp)
	delete(client_handlers.get_frame_handler_handler, cp)
	delete(client_handlers.get_jsdialog_handler_handler, cp)
	delete(client_handlers.get_keyboard_handler_handler, cp)
	delete(client_handlers.get_life_span_handler_handler, cp)
	delete(client_handlers.get_load_handler_handler, cp)
	delete(client_handlers.get_print_handler_handler, cp)
	delete(client_handlers.get_render_handler_handler, cp)
	delete(client_handlers.get_request_handler_handler, cp)
	delete(client_handlers.on_process_message_received_handler, cp)
}

func (client *CClientT) UnbindAll() {
	unbindAllCClientT(client.pc_client)
	client.Unref()
}

func (client *CClientT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := client.pc_client
	return client_handlers.handler[cp]
}

// cef_command_handler_capi.h, include/capi/cef_command_handler_capi.h:74:3,

///
// Implement this structure to handle events related to commands. The functions
// of this structure will be called on the UI thread.
///

type cCCommandHandlerT C.cef_command_handler_t

// Go type for cef_command_handler_t
type CCommandHandlerT struct {
	noCopy             noCopy
	pc_command_handler *cCCommandHandlerT
	beUnrefed          unrefedBy
}

func (p *CCommandHandlerT) Pass() (ret *CCommandHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCCommandHandlerT((*C.cef_command_handler_t)(p.pc_command_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CCommandHandlerT) NewRef() (newP *CCommandHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_command_handler
	BaseAddRef(gop)
	newP = newCCommandHandlerT((*C.cef_command_handler_t)(gop), byApp)
	return newP
}

// Go type CCommandHandlerT wraps cef type *C.cef_command_handler_t
func newCCommandHandlerT(p *C.cef_command_handler_t, unrefedBy unrefedBy) *CCommandHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T393.1:")
	pc := (*cCCommandHandlerT)(p)
	go_command_handler := &CCommandHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_command_handler, func(g *CCommandHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_command_handler != nil {
			Tracef(unsafe.Pointer(g.pc_command_handler), "T393.2:")
			BaseRelease(g.pc_command_handler)
		}
	})

	return go_command_handler
}

// *C.cef_command_handler_t has refCounted interface
func (command_handler *CCommandHandlerT) HasOneRef() bool {
	return BaseHasOneRef(command_handler.pc_command_handler)
}

func (p *cCCommandHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (command_handler *CCommandHandlerT) Unref() (ret bool) {
	if command_handler == nil {
		return
	}
	if command_handler.beUnrefed == byApp {
		ret = BaseRelease(command_handler.pc_command_handler)
		command_handler.beUnrefed = unrefed
	}
	command_handler.pc_command_handler = nil
	return ret
}

///
// Called to execute a Chrome command triggered via menu selection or keyboard
// shortcut. Values for |command_id| can be found in the cef_command_ids.h
// file. |disposition| provides information about the intended command target.
// Return true (1) if the command was handled or false (0) for the default
// implementation. For context menu commands this will be called after
// cef_context_menu_handler_t::OnContextMenuCommand. Only used with the Chrome
// runtime.
///
func (self *CCommandHandlerT) OnChromeCommand(
	browser *CBrowserT,
	command_id int,
	disposition CWindowOpenDispositionT,
) (ret bool) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		BaseAddRef(browser.pc_browser)
		goTmpbrowser = (*C.cef_browser_t)(browser.pc_browser)
	}

	cRet := C.cefingo_command_handler_on_chrome_command((*C.cef_command_handler_t)(self.pc_command_handler), goTmpbrowser, (C.int)(command_id), (C.cef_window_open_disposition_t)(disposition))

	ret = cRet == 1
	return ret
}

// cef_command_line_capi.h, include/capi/cef_command_line_capi.h:198:3,

///
// Structure used to create and/or parse command line arguments. Arguments with
// '--', '-' and, on Windows, '/' prefixes are considered switches. Switches
// will always precede any arguments without switch prefixes. Switches can
// optionally have a value specified using the '=' delimiter (e.g.
// "-switch=value"). An argument of "--" will terminate switch parsing with all
// subsequent tokens, regardless of prefix, being interpreted as non-switch
// arguments. Switch names should be lowercase ASCII and will be converted to
// such if necessary. Switch values will retain the original case and UTF8
// encoding. This structure can be used before cef_initialize() is called.
///

type cCCommandLineT C.cef_command_line_t

// Go type for cef_command_line_t
type CCommandLineT struct {
	noCopy          noCopy
	pc_command_line *cCCommandLineT
	beUnrefed       unrefedBy
}

func (p *CCommandLineT) Pass() (ret *CCommandLineT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCCommandLineT((*C.cef_command_line_t)(p.pc_command_line), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CCommandLineT) NewRef() (newP *CCommandLineT) {
	if self == nil {
		return newP
	}
	gop := self.pc_command_line
	BaseAddRef(gop)
	newP = newCCommandLineT((*C.cef_command_line_t)(gop), byApp)
	return newP
}

// Go type CCommandLineT wraps cef type *C.cef_command_line_t
func newCCommandLineT(p *C.cef_command_line_t, unrefedBy unrefedBy) *CCommandLineT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T120.1:")
	pc := (*cCCommandLineT)(p)
	go_command_line := &CCommandLineT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_command_line, func(g *CCommandLineT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_command_line != nil {
			Tracef(unsafe.Pointer(g.pc_command_line), "T120.2:")
			BaseRelease(g.pc_command_line)
		}
	})

	return go_command_line
}

// *C.cef_command_line_t has refCounted interface
func (command_line *CCommandLineT) HasOneRef() bool {
	return BaseHasOneRef(command_line.pc_command_line)
}

func (p *cCCommandLineT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (command_line *CCommandLineT) Unref() (ret bool) {
	if command_line == nil {
		return
	}
	if command_line.beUnrefed == byApp {
		ret = BaseRelease(command_line.pc_command_line)
		command_line.beUnrefed = unrefed
	}
	command_line.pc_command_line = nil
	return ret
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CCommandLineT) IsValid() (ret bool) {

	cRet := C.cefingo_command_line_is_valid((*C.cef_command_line_t)(self.pc_command_line))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CCommandLineT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_command_line_is_read_only((*C.cef_command_line_t)(self.pc_command_line))

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object.
///
func (self *CCommandLineT) Copy() (ret *CCommandLineT) {

	cRet := C.cefingo_command_line_copy((*C.cef_command_line_t)(self.pc_command_line))

	ret = newCCommandLineT(cRet, byApp) // return GoObj
	return ret
}

///
// Initialize the command line with the string returned by calling
// GetCommandLineW(). This function is only supported on Windows.
///
func (self *CCommandLineT) InitFromString(
	command_line string,
) {
	c_command_line := create_cef_string(command_line)

	C.cefingo_command_line_init_from_string((*C.cef_command_line_t)(self.pc_command_line), c_command_line.p_cef_string_t)

}

///
// Reset the command-line switches and arguments but leave the program
// component unchanged.
///
func (self *CCommandLineT) Reset() {

	C.cefingo_command_line_reset((*C.cef_command_line_t)(self.pc_command_line))

}

///
// Retrieve the original command line string as a vector of strings. The argv
// array: { program, [(--|-|/)switch[=value]]*, [--], [argument]* }
///
func (self *CCommandLineT) GetArgv(
	argv CStringListT,
) {

	C.cefingo_command_line_get_argv((*C.cef_command_line_t)(self.pc_command_line), (C.cef_string_list_t)(argv))

}

///
// Constructs and returns the represented command line string. Use this
// function cautiously because quoting behavior is unclear.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CCommandLineT) GetCommandLineString() (ret string) {

	cRet := C.cefingo_command_line_get_command_line_string((*C.cef_command_line_t)(self.pc_command_line))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Get the program part of the command line string (the first item).
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CCommandLineT) GetProgram() (ret string) {

	cRet := C.cefingo_command_line_get_program((*C.cef_command_line_t)(self.pc_command_line))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the program part of the command line string (the first item).
///
func (self *CCommandLineT) SetProgram(
	program string,
) {
	c_program := create_cef_string(program)

	C.cefingo_command_line_set_program((*C.cef_command_line_t)(self.pc_command_line), c_program.p_cef_string_t)

}

///
// Returns true (1) if the command line has switches.
///
func (self *CCommandLineT) HasSwitches() (ret bool) {

	cRet := C.cefingo_command_line_has_switches((*C.cef_command_line_t)(self.pc_command_line))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the command line contains the given switch.
///
func (self *CCommandLineT) HasSwitch(
	name string,
) (ret bool) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_command_line_has_switch((*C.cef_command_line_t)(self.pc_command_line), c_name.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the value associated with the given switch. If the switch has no
// value or isn&#39;t present this function returns the NULL string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CCommandLineT) GetSwitchValue(
	name string,
) (ret string) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_command_line_get_switch_value((*C.cef_command_line_t)(self.pc_command_line), c_name.p_cef_string_t)

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the map of switch names and values. If a switch has no value an
// NULL string is returned.
///
func (self *CCommandLineT) GetSwitches(
	switches CStringMapT,
) {

	C.cefingo_command_line_get_switches((*C.cef_command_line_t)(self.pc_command_line), (C.cef_string_map_t)(switches))

}

///
// Add a switch to the end of the command line. If the switch has no value
// pass an NULL value string.
///
func (self *CCommandLineT) AppendSwitch(
	name string,
) {
	c_name := create_cef_string(name)

	C.cefingo_command_line_append_switch((*C.cef_command_line_t)(self.pc_command_line), c_name.p_cef_string_t)

}

///
// Add a switch with the specified value to the end of the command line.
///
func (self *CCommandLineT) AppendSwitchWithValue(
	name string,
	value string,
) {
	c_name := create_cef_string(name)
	c_value := create_cef_string(value)

	C.cefingo_command_line_append_switch_with_value((*C.cef_command_line_t)(self.pc_command_line), c_name.p_cef_string_t, c_value.p_cef_string_t)

}

///
// True if there are remaining command line arguments.
///
func (self *CCommandLineT) HasArguments() (ret bool) {

	cRet := C.cefingo_command_line_has_arguments((*C.cef_command_line_t)(self.pc_command_line))

	ret = cRet == 1
	return ret
}

///
// Get the remaining command line arguments.
///
func (self *CCommandLineT) GetArguments(
	arguments CStringListT,
) {

	C.cefingo_command_line_get_arguments((*C.cef_command_line_t)(self.pc_command_line), (C.cef_string_list_t)(arguments))

}

///
// Add an argument to the end of the command line.
///
func (self *CCommandLineT) AppendArgument(
	argument string,
) {
	c_argument := create_cef_string(argument)

	C.cefingo_command_line_append_argument((*C.cef_command_line_t)(self.pc_command_line), c_argument.p_cef_string_t)

}

///
// Insert a command before the current command. Common for debuggers, like
// &quot;valgrind&quot; or &quot;gdb --args&quot;.
///
func (self *CCommandLineT) PrependWrapper(
	wrapper string,
) {
	c_wrapper := create_cef_string(wrapper)

	C.cefingo_command_line_prepend_wrapper((*C.cef_command_line_t)(self.pc_command_line), c_wrapper.p_cef_string_t)

}

///
// Create a new cef_command_line_t instance.
///
func CommandLineCreate() (ret *CCommandLineT) {

	cRet := C.cef_command_line_create()

	ret = newCCommandLineT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the singleton global cef_command_line_t object. The returned object
// will be read-only.
///
func CommandLineGetGlobal() (ret *CCommandLineT) {

	cRet := C.cef_command_line_get_global()

	ret = newCCommandLineT(cRet, byApp) // return GoObj
	return ret
}

// cef_context_menu_handler_capi.h, include/capi/cef_context_menu_handler_capi.h:75:3,

///
// Callback structure used for continuation of custom context menu display.
///

type cCRunContextMenuCallbackT C.cef_run_context_menu_callback_t

// Go type for cef_run_context_menu_callback_t
type CRunContextMenuCallbackT struct {
	noCopy                       noCopy
	pc_run_context_menu_callback *cCRunContextMenuCallbackT
	beUnrefed                    unrefedBy
}

func (p *CRunContextMenuCallbackT) Pass() (ret *CRunContextMenuCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRunContextMenuCallbackT((*C.cef_run_context_menu_callback_t)(p.pc_run_context_menu_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRunContextMenuCallbackT) NewRef() (newP *CRunContextMenuCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_run_context_menu_callback
	BaseAddRef(gop)
	newP = newCRunContextMenuCallbackT((*C.cef_run_context_menu_callback_t)(gop), byApp)
	return newP
}

// Go type CRunContextMenuCallbackT wraps cef type *C.cef_run_context_menu_callback_t
func newCRunContextMenuCallbackT(p *C.cef_run_context_menu_callback_t, unrefedBy unrefedBy) *CRunContextMenuCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T121.1:")
	pc := (*cCRunContextMenuCallbackT)(p)
	go_run_context_menu_callback := &CRunContextMenuCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_run_context_menu_callback, func(g *CRunContextMenuCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_run_context_menu_callback != nil {
			Tracef(unsafe.Pointer(g.pc_run_context_menu_callback), "T121.2:")
			BaseRelease(g.pc_run_context_menu_callback)
		}
	})

	return go_run_context_menu_callback
}

// *C.cef_run_context_menu_callback_t has refCounted interface
func (run_context_menu_callback *CRunContextMenuCallbackT) HasOneRef() bool {
	return BaseHasOneRef(run_context_menu_callback.pc_run_context_menu_callback)
}

func (p *cCRunContextMenuCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (run_context_menu_callback *CRunContextMenuCallbackT) Unref() (ret bool) {
	if run_context_menu_callback == nil {
		return
	}
	if run_context_menu_callback.beUnrefed == byApp {
		ret = BaseRelease(run_context_menu_callback.pc_run_context_menu_callback)
		run_context_menu_callback.beUnrefed = unrefed
	}
	run_context_menu_callback.pc_run_context_menu_callback = nil
	return ret
}

///
// Complete context menu display by selecting the specified |command_id| and
// |event_flags|.
///
func (self *CRunContextMenuCallbackT) Cont(
	command_id int,
	event_flags CEventFlagsT,
) {

	C.cefingo_run_context_menu_callback_cont((*C.cef_run_context_menu_callback_t)(self.pc_run_context_menu_callback), (C.int)(command_id), (C.cef_event_flags_t)(event_flags))

}

///
// Cancel context menu display.
///
func (self *CRunContextMenuCallbackT) Cancel() {

	C.cefingo_run_context_menu_callback_cancel((*C.cef_run_context_menu_callback_t)(self.pc_run_context_menu_callback))

}

///
// Implement this structure to handle context menu events. The functions of this
// structure will be called on the UI thread.
///

type cCContextMenuHandlerT C.cef_context_menu_handler_t

// Go type for cef_context_menu_handler_t
type CContextMenuHandlerT struct {
	noCopy                  noCopy
	pc_context_menu_handler *cCContextMenuHandlerT
	beUnrefed               unrefedBy
}

func (p *CContextMenuHandlerT) Pass() (ret *CContextMenuHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCContextMenuHandlerT((*C.cef_context_menu_handler_t)(p.pc_context_menu_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CContextMenuHandlerT) NewRef() (newP *CContextMenuHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_context_menu_handler
	BaseAddRef(gop)
	newP = newCContextMenuHandlerT((*C.cef_context_menu_handler_t)(gop), byApp)
	return newP
}

// Go type CContextMenuHandlerT wraps cef type *C.cef_context_menu_handler_t
func newCContextMenuHandlerT(p *C.cef_context_menu_handler_t, unrefedBy unrefedBy) *CContextMenuHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T122.1:")
	pc := (*cCContextMenuHandlerT)(p)
	go_context_menu_handler := &CContextMenuHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_context_menu_handler, func(g *CContextMenuHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_context_menu_handler != nil {
			Tracef(unsafe.Pointer(g.pc_context_menu_handler), "T122.2:")
			BaseRelease(g.pc_context_menu_handler)
		}
	})

	return go_context_menu_handler
}

// *C.cef_context_menu_handler_t has refCounted interface
func (context_menu_handler *CContextMenuHandlerT) HasOneRef() bool {
	return BaseHasOneRef(context_menu_handler.pc_context_menu_handler)
}

func (p *cCContextMenuHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (context_menu_handler *CContextMenuHandlerT) Unref() (ret bool) {
	if context_menu_handler == nil {
		return
	}
	if context_menu_handler.beUnrefed == byApp {
		ret = BaseRelease(context_menu_handler.pc_context_menu_handler)
		context_menu_handler.beUnrefed = unrefed
	}
	context_menu_handler.pc_context_menu_handler = nil
	return ret
}

///
// Called before a context menu is displayed. |params| provides information
// about the context menu state. |model| initially contains the default
// context menu. The |model| can be cleared to show no context menu or
// modified to show a custom menu. Do not keep references to |params| or
// |model| outside of this callback.
///
type OnBeforeContextMenuHandler interface {
	OnBeforeContextMenu(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		params *CContextMenuParamsT,
		model *CMenuModelT,
	)
}

///
// Called to allow custom display of the context menu. |params| provides
// information about the context menu state. |model| contains the context menu
// model resulting from OnBeforeContextMenu. For custom display return true
// (1) and execute |callback| either synchronously or asynchronously with the
// selected command ID. For default display return false (0). Do not keep
// references to |params| or |model| outside of this callback.
///
type RunContextMenuHandler interface {
	RunContextMenu(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		params *CContextMenuParamsT,
		model *CMenuModelT,
		callback *CRunContextMenuCallbackT,
	) (ret bool)
}

///
// Called to execute a command selected from the context menu. Return true (1)
// if the command was handled or false (0) for the default implementation. See
// cef_menu_id_t for the command ids that have default implementations. All
// user-defined command ids should be between MENU_ID_USER_FIRST and
// MENU_ID_USER_LAST. |params| will have the same values as what was passed to
// on_before_context_menu(). Do not keep a reference to |params| outside of
// this callback.
///
type OnContextMenuCommandHandler interface {
	OnContextMenuCommand(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		params *CContextMenuParamsT,
		command_id int,
		event_flags CEventFlagsT,
	) (ret bool)
}

///
// Called when the context menu is dismissed irregardless of whether the menu
// was NULL or a command was selected.
///
type OnContextMenuDismissedHandler interface {
	OnContextMenuDismissed(
		self *CContextMenuHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
	)
}

var context_menu_handler_handlers = struct {
	handler                           map[*cCContextMenuHandlerT]interface{}
	on_before_context_menu_handler    map[*cCContextMenuHandlerT]OnBeforeContextMenuHandler
	run_context_menu_handler          map[*cCContextMenuHandlerT]RunContextMenuHandler
	on_context_menu_command_handler   map[*cCContextMenuHandlerT]OnContextMenuCommandHandler
	on_context_menu_dismissed_handler map[*cCContextMenuHandlerT]OnContextMenuDismissedHandler
}{
	map[*cCContextMenuHandlerT]interface{}{},
	map[*cCContextMenuHandlerT]OnBeforeContextMenuHandler{},
	map[*cCContextMenuHandlerT]RunContextMenuHandler{},
	map[*cCContextMenuHandlerT]OnContextMenuCommandHandler{},
	map[*cCContextMenuHandlerT]OnContextMenuDismissedHandler{},
}

// allocCContextMenuHandlerT allocates CContextMenuHandlerT and construct it
func allocCContextMenuHandlerT() *CContextMenuHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_context_menu_handler_wrapper_t, "T122.3:")
	cefp := C.cefingo_construct_context_menu_handler((*C.cefingo_context_menu_handler_wrapper_t)(up))
	cgop := (*cCContextMenuHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_context_menu_handler_t itself in DeassocFunc,
		// or cef_context_menu_handler_t is never GCed.
		Tracef(up, "T122.4:")
		unbindAllCContextMenuHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCContextMenuHandlerT(cefp, byApp)
}

// NewCContextMenuHandlerT allocates CContextMenuHandlerT, construct and bind it
func NewCContextMenuHandlerT(a interface{}) *CContextMenuHandlerT {
	return allocCContextMenuHandlerT().bind(a)
}

func (context_menu_handler *CContextMenuHandlerT) bind(a interface{}) *CContextMenuHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := context_menu_handler.pc_context_menu_handler
	context_menu_handler_handlers.handler[cp] = a

	if h, ok := a.(OnBeforeContextMenuHandler); ok {
		context_menu_handler_handlers.on_before_context_menu_handler[cp] = h
		noBind = false
	} else {
		delete(context_menu_handler_handlers.on_before_context_menu_handler, cp)
	}

	if h, ok := a.(RunContextMenuHandler); ok {
		context_menu_handler_handlers.run_context_menu_handler[cp] = h
		noBind = false
	} else {
		delete(context_menu_handler_handlers.run_context_menu_handler, cp)
	}

	if h, ok := a.(OnContextMenuCommandHandler); ok {
		context_menu_handler_handlers.on_context_menu_command_handler[cp] = h
		noBind = false
	} else {
		delete(context_menu_handler_handlers.on_context_menu_command_handler, cp)
	}

	if h, ok := a.(OnContextMenuDismissedHandler); ok {
		context_menu_handler_handlers.on_context_menu_dismissed_handler[cp] = h
		noBind = false
	} else {
		delete(context_menu_handler_handlers.on_context_menu_dismissed_handler, cp)
	}

	if noBind {
		Panicln("F229: *CContextMenuHandlerT No bind")
	}
	return context_menu_handler
}

func unbindAllCContextMenuHandlerT(cp *cCContextMenuHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := context_menu_handler.pc_context_menu_handler
	delete(context_menu_handler_handlers.handler, cp)

	delete(context_menu_handler_handlers.on_before_context_menu_handler, cp)
	delete(context_menu_handler_handlers.run_context_menu_handler, cp)
	delete(context_menu_handler_handlers.on_context_menu_command_handler, cp)
	delete(context_menu_handler_handlers.on_context_menu_dismissed_handler, cp)
}

func (context_menu_handler *CContextMenuHandlerT) UnbindAll() {
	unbindAllCContextMenuHandlerT(context_menu_handler.pc_context_menu_handler)
	context_menu_handler.Unref()
}

func (context_menu_handler *CContextMenuHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := context_menu_handler.pc_context_menu_handler
	return context_menu_handler_handlers.handler[cp]
}

///
// Provides information about the context menu state. The ethods of this
// structure can only be accessed on browser process the UI thread.
///

type cCContextMenuParamsT C.cef_context_menu_params_t

// Go type for cef_context_menu_params_t
type CContextMenuParamsT struct {
	noCopy                 noCopy
	pc_context_menu_params *cCContextMenuParamsT
	beUnrefed              unrefedBy
}

func (p *CContextMenuParamsT) Pass() (ret *CContextMenuParamsT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCContextMenuParamsT((*C.cef_context_menu_params_t)(p.pc_context_menu_params), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CContextMenuParamsT) NewRef() (newP *CContextMenuParamsT) {
	if self == nil {
		return newP
	}
	gop := self.pc_context_menu_params
	BaseAddRef(gop)
	newP = newCContextMenuParamsT((*C.cef_context_menu_params_t)(gop), byApp)
	return newP
}

// Go type CContextMenuParamsT wraps cef type *C.cef_context_menu_params_t
func newCContextMenuParamsT(p *C.cef_context_menu_params_t, unrefedBy unrefedBy) *CContextMenuParamsT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T123.1:")
	pc := (*cCContextMenuParamsT)(p)
	go_context_menu_params := &CContextMenuParamsT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_context_menu_params, func(g *CContextMenuParamsT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_context_menu_params != nil {
			Tracef(unsafe.Pointer(g.pc_context_menu_params), "T123.2:")
			BaseRelease(g.pc_context_menu_params)
		}
	})

	return go_context_menu_params
}

// *C.cef_context_menu_params_t has refCounted interface
func (context_menu_params *CContextMenuParamsT) HasOneRef() bool {
	return BaseHasOneRef(context_menu_params.pc_context_menu_params)
}

func (p *cCContextMenuParamsT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (context_menu_params *CContextMenuParamsT) Unref() (ret bool) {
	if context_menu_params == nil {
		return
	}
	if context_menu_params.beUnrefed == byApp {
		ret = BaseRelease(context_menu_params.pc_context_menu_params)
		context_menu_params.beUnrefed = unrefed
	}
	context_menu_params.pc_context_menu_params = nil
	return ret
}

///
// Returns the X coordinate of the mouse where the context menu was invoked.
// Coords are relative to the associated RenderView&#39;s origin.
///
func (self *CContextMenuParamsT) GetXcoord() (ret bool) {

	cRet := C.cefingo_context_menu_params_get_xcoord((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = cRet == 1
	return ret
}

///
// Returns the Y coordinate of the mouse where the context menu was invoked.
// Coords are relative to the associated RenderView&#39;s origin.
///
func (self *CContextMenuParamsT) GetYcoord() (ret bool) {

	cRet := C.cefingo_context_menu_params_get_ycoord((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = cRet == 1
	return ret
}

///
// Returns flags representing the type of node that the context menu was
// invoked on.
///
func (self *CContextMenuParamsT) GetTypeFlags() (ret CContextMenuTypeFlagsT) {

	cRet := C.cefingo_context_menu_params_get_type_flags((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = CContextMenuTypeFlagsT(cRet) // return GoObj
	return ret
}

///
// Returns the URL of the link, if any, that encloses the node that the
// context menu was invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetLinkUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_link_url((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the link URL, if any, to be used ONLY for &quot;copy link address&quot;. We
// don&#39;t validate this field in the frontend process.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetUnfilteredLinkUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_unfiltered_link_url((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the source URL, if any, for the element that the context menu was
// invoked on. Example of elements with source URLs are img, audio, and video.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetSourceUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_source_url((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if the context menu was invoked on an image which has non-
// NULL contents.
///
func (self *CContextMenuParamsT) HasImageContents() (ret bool) {

	cRet := C.cefingo_context_menu_params_has_image_contents((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = cRet == 1
	return ret
}

///
// Returns the title text or the alt text if the context menu was invoked on
// an image.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetTitleText() (ret string) {

	cRet := C.cefingo_context_menu_params_get_title_text((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the URL of the top level page that the context menu was invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetPageUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_page_url((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the URL of the subframe that the context menu was invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetFrameUrl() (ret string) {

	cRet := C.cefingo_context_menu_params_get_frame_url((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the character encoding of the subframe that the context menu was
// invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetFrameCharset() (ret string) {

	cRet := C.cefingo_context_menu_params_get_frame_charset((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the type of context node that the context menu was invoked on.
///
func (self *CContextMenuParamsT) GetMediaType() (ret CContextMenuMediaTypeT) {

	cRet := C.cefingo_context_menu_params_get_media_type((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = CContextMenuMediaTypeT(cRet) // return GoObj
	return ret
}

///
// Returns flags representing the actions supported by the media element, if
// any, that the context menu was invoked on.
///
func (self *CContextMenuParamsT) GetMediaStateFlags() (ret CContextMenuMediaStateFlagsT) {

	cRet := C.cefingo_context_menu_params_get_media_state_flags((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = CContextMenuMediaStateFlagsT(cRet) // return GoObj
	return ret
}

///
// Returns the text of the selection, if any, that the context menu was
// invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetSelectionText() (ret string) {

	cRet := C.cefingo_context_menu_params_get_selection_text((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the text of the misspelled word, if any, that the context menu was
// invoked on.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CContextMenuParamsT) GetMisspelledWord() (ret string) {

	cRet := C.cefingo_context_menu_params_get_misspelled_word((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if suggestions exist, false (0) otherwise. Fills in
// |suggestions| from the spell check service for the misspelled word if there
// is one.
///
func (self *CContextMenuParamsT) GetDictionarySuggestions(
	suggestions CStringListT,
) (ret bool) {

	cRet := C.cefingo_context_menu_params_get_dictionary_suggestions((*C.cef_context_menu_params_t)(self.pc_context_menu_params), (C.cef_string_list_t)(suggestions))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the context menu was invoked on an editable node.
///
func (self *CContextMenuParamsT) IsEditable() (ret bool) {

	cRet := C.cefingo_context_menu_params_is_editable((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the context menu was invoked on an editable node where
// spell-check is enabled.
///
func (self *CContextMenuParamsT) IsSpellCheckEnabled() (ret bool) {

	cRet := C.cefingo_context_menu_params_is_spell_check_enabled((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = cRet == 1
	return ret
}

///
// Returns flags representing the actions supported by the editable node, if
// any, that the context menu was invoked on.
///
func (self *CContextMenuParamsT) GetEditStateFlags() (ret CContextMenuEditStateFlagsT) {

	cRet := C.cefingo_context_menu_params_get_edit_state_flags((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = CContextMenuEditStateFlagsT(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if the context menu contains items specified by the
// renderer process.
///
func (self *CContextMenuParamsT) IsCustomMenu() (ret bool) {

	cRet := C.cefingo_context_menu_params_is_custom_menu((*C.cef_context_menu_params_t)(self.pc_context_menu_params))

	ret = cRet == 1
	return ret
}

// cef_cookie_capi.h, include/capi/cef_cookie_capi.h:122:3,

///
// Structure used for managing cookies. The functions of this structure may be
// called on any thread unless otherwise indicated.
///

type cCCookieManagerT C.cef_cookie_manager_t

// Go type for cef_cookie_manager_t
type CCookieManagerT struct {
	noCopy            noCopy
	pc_cookie_manager *cCCookieManagerT
	beUnrefed         unrefedBy
}

func (p *CCookieManagerT) Pass() (ret *CCookieManagerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCCookieManagerT((*C.cef_cookie_manager_t)(p.pc_cookie_manager), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CCookieManagerT) NewRef() (newP *CCookieManagerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_cookie_manager
	BaseAddRef(gop)
	newP = newCCookieManagerT((*C.cef_cookie_manager_t)(gop), byApp)
	return newP
}

// Go type CCookieManagerT wraps cef type *C.cef_cookie_manager_t
func newCCookieManagerT(p *C.cef_cookie_manager_t, unrefedBy unrefedBy) *CCookieManagerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T124.1:")
	pc := (*cCCookieManagerT)(p)
	go_cookie_manager := &CCookieManagerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_cookie_manager, func(g *CCookieManagerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_cookie_manager != nil {
			Tracef(unsafe.Pointer(g.pc_cookie_manager), "T124.2:")
			BaseRelease(g.pc_cookie_manager)
		}
	})

	return go_cookie_manager
}

// *C.cef_cookie_manager_t has refCounted interface
func (cookie_manager *CCookieManagerT) HasOneRef() bool {
	return BaseHasOneRef(cookie_manager.pc_cookie_manager)
}

func (p *cCCookieManagerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (cookie_manager *CCookieManagerT) Unref() (ret bool) {
	if cookie_manager == nil {
		return
	}
	if cookie_manager.beUnrefed == byApp {
		ret = BaseRelease(cookie_manager.pc_cookie_manager)
		cookie_manager.beUnrefed = unrefed
	}
	cookie_manager.pc_cookie_manager = nil
	return ret
}

///
// Visit all cookies on the UI thread. The returned cookies are ordered by
// longest path, then by earliest creation date. Returns false (0) if cookies
// cannot be accessed.
///
func (self *CCookieManagerT) VisitAllCookies(
	visitor *CCookieVisitorT,
) (ret bool) {
	var goTmpvisitor *C.cef_cookie_visitor_t
	if visitor != nil {
		BaseAddRef(visitor.pc_cookie_visitor)
		goTmpvisitor = (*C.cef_cookie_visitor_t)(visitor.pc_cookie_visitor)
	}

	cRet := C.cefingo_cookie_manager_visit_all_cookies((*C.cef_cookie_manager_t)(self.pc_cookie_manager), goTmpvisitor)

	ret = cRet == 1
	return ret
}

///
// Visit a subset of cookies on the UI thread. The results are filtered by the
// given url scheme, host, domain and path. If |includeHttpOnly| is true (1)
// HTTP-only cookies will also be included in the results. The returned
// cookies are ordered by longest path, then by earliest creation date.
// Returns false (0) if cookies cannot be accessed.
///
func (self *CCookieManagerT) VisitUrlCookies(
	url string,
	includeHttpOnly int,
	visitor *CCookieVisitorT,
) (ret bool) {
	c_url := create_cef_string(url)
	var goTmpvisitor *C.cef_cookie_visitor_t
	if visitor != nil {
		BaseAddRef(visitor.pc_cookie_visitor)
		goTmpvisitor = (*C.cef_cookie_visitor_t)(visitor.pc_cookie_visitor)
	}

	cRet := C.cefingo_cookie_manager_visit_url_cookies((*C.cef_cookie_manager_t)(self.pc_cookie_manager), c_url.p_cef_string_t, (C.int)(includeHttpOnly), goTmpvisitor)

	ret = cRet == 1
	return ret
}

///
// Sets a cookie given a valid URL and explicit user-provided cookie
// attributes. This function expects each attribute to be well-formed. It will
// check for disallowed characters (e.g. the &#39;;&#39; character is disallowed
// within the cookie value attribute) and fail without setting the cookie if
// such characters are found. If |callback| is non-NULL it will be executed
// asnychronously on the UI thread after the cookie has been set. Returns
// false (0) if an invalid URL is specified or if cookies cannot be accessed.
///
func (self *CCookieManagerT) SetCookie(
	url string,
	cookie *CCookieT,
	callback *CSetCookieCallbackT,
) (ret bool) {
	c_url := create_cef_string(url)
	var goTmpcallback *C.cef_set_cookie_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_set_cookie_callback)
		goTmpcallback = (*C.cef_set_cookie_callback_t)(callback.pc_set_cookie_callback)
	}

	cRet := C.cefingo_cookie_manager_set_cookie((*C.cef_cookie_manager_t)(self.pc_cookie_manager), c_url.p_cef_string_t, (*C.cef_cookie_t)(cookie), goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Delete all cookies that match the specified parameters. If both |url| and
// |cookie_name| values are specified all host and domain cookies matching
// both will be deleted. If only |url| is specified all host cookies (but not
// domain cookies) irrespective of path will be deleted. If |url| is NULL all
// cookies for all hosts and domains will be deleted. If |callback| is non-
// NULL it will be executed asnychronously on the UI thread after the cookies
// have been deleted. Returns false (0) if a non-NULL invalid URL is specified
// or if cookies cannot be accessed. Cookies can alternately be deleted using
// the Visit*Cookies() functions.
///
func (self *CCookieManagerT) DeleteCookies(
	url string,
	cookie_name string,
	callback *CDeleteCookiesCallbackT,
) (ret bool) {
	c_url := create_cef_string(url)
	c_cookie_name := create_cef_string(cookie_name)
	var goTmpcallback *C.cef_delete_cookies_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_delete_cookies_callback)
		goTmpcallback = (*C.cef_delete_cookies_callback_t)(callback.pc_delete_cookies_callback)
	}

	cRet := C.cefingo_cookie_manager_delete_cookies((*C.cef_cookie_manager_t)(self.pc_cookie_manager), c_url.p_cef_string_t, c_cookie_name.p_cef_string_t, goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Flush the backing store (if any) to disk. If |callback| is non-NULL it will
// be executed asnychronously on the UI thread after the flush is complete.
// Returns false (0) if cookies cannot be accessed.
///
func (self *CCookieManagerT) FlushStore(
	callback *CCompletionCallbackT,
) (ret bool) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	cRet := C.cefingo_cookie_manager_flush_store((*C.cef_cookie_manager_t)(self.pc_cookie_manager), goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Returns the global cookie manager. By default data will be stored at
// CefSettings.cache_path if specified or in memory otherwise. If |callback| is
// non-NULL it will be executed asnychronously on the UI thread after the
// manager's storage has been initialized. Using this function is equivalent to
// calling cef_request_context_t::cef_request_context_get_global_context()->GetD
// efaultCookieManager().
///
func CookieManagerGetGlobalManager(
	callback *CCompletionCallbackT,
) (ret *CCookieManagerT) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	cRet := C.cef_cookie_manager_get_global_manager(goTmpcallback)

	ret = newCCookieManagerT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure to implement for visiting cookie values. The functions of this
// structure will always be called on the UI thread.
///

type cCCookieVisitorT C.cef_cookie_visitor_t

// Go type for cef_cookie_visitor_t
type CCookieVisitorT struct {
	noCopy            noCopy
	pc_cookie_visitor *cCCookieVisitorT
	beUnrefed         unrefedBy
}

func (p *CCookieVisitorT) Pass() (ret *CCookieVisitorT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCCookieVisitorT((*C.cef_cookie_visitor_t)(p.pc_cookie_visitor), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CCookieVisitorT) NewRef() (newP *CCookieVisitorT) {
	if self == nil {
		return newP
	}
	gop := self.pc_cookie_visitor
	BaseAddRef(gop)
	newP = newCCookieVisitorT((*C.cef_cookie_visitor_t)(gop), byApp)
	return newP
}

// Go type CCookieVisitorT wraps cef type *C.cef_cookie_visitor_t
func newCCookieVisitorT(p *C.cef_cookie_visitor_t, unrefedBy unrefedBy) *CCookieVisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T125.1:")
	pc := (*cCCookieVisitorT)(p)
	go_cookie_visitor := &CCookieVisitorT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_cookie_visitor, func(g *CCookieVisitorT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_cookie_visitor != nil {
			Tracef(unsafe.Pointer(g.pc_cookie_visitor), "T125.2:")
			BaseRelease(g.pc_cookie_visitor)
		}
	})

	return go_cookie_visitor
}

// *C.cef_cookie_visitor_t has refCounted interface
func (cookie_visitor *CCookieVisitorT) HasOneRef() bool {
	return BaseHasOneRef(cookie_visitor.pc_cookie_visitor)
}

func (p *cCCookieVisitorT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (cookie_visitor *CCookieVisitorT) Unref() (ret bool) {
	if cookie_visitor == nil {
		return
	}
	if cookie_visitor.beUnrefed == byApp {
		ret = BaseRelease(cookie_visitor.pc_cookie_visitor)
		cookie_visitor.beUnrefed = unrefed
	}
	cookie_visitor.pc_cookie_visitor = nil
	return ret
}

///
// Method that will be called once for each cookie. |count| is the 0-based
// index for the current cookie. |total| is the total number of cookies. Set
// |deleteCookie| to true (1) to delete the cookie currently being visited.
// Return false (0) to stop visiting cookies. This function may never be
// called if no cookies are found.
///
type CCookieVisitorTVisitHandler interface {
	Visit(
		self *CCookieVisitorT,
		cookie *CCookieT,
		count int,
		total int,
	) (ret bool, deleteCookie int)
}

var cookie_visitor_handlers = struct {
	handler       map[*cCCookieVisitorT]interface{}
	visit_handler map[*cCCookieVisitorT]CCookieVisitorTVisitHandler
}{
	map[*cCCookieVisitorT]interface{}{},
	map[*cCCookieVisitorT]CCookieVisitorTVisitHandler{},
}

// allocCCookieVisitorT allocates CCookieVisitorT and construct it
func allocCCookieVisitorT() *CCookieVisitorT {
	up := c_calloc(1, C.sizeof_cefingo_cookie_visitor_wrapper_t, "T125.3:")
	cefp := C.cefingo_construct_cookie_visitor((*C.cefingo_cookie_visitor_wrapper_t)(up))
	cgop := (*cCCookieVisitorT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_cookie_visitor_t itself in DeassocFunc,
		// or cef_cookie_visitor_t is never GCed.
		Tracef(up, "T125.4:")
		unbindAllCCookieVisitorT(cgop)
	}))

	BaseAddRef(cgop)
	return newCCookieVisitorT(cefp, byApp)
}

// NewCCookieVisitorT allocates CCookieVisitorT, construct and bind it
func NewCCookieVisitorT(a interface{}) *CCookieVisitorT {
	return allocCCookieVisitorT().bind(a)
}

func (cookie_visitor *CCookieVisitorT) bind(a interface{}) *CCookieVisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := cookie_visitor.pc_cookie_visitor
	cookie_visitor_handlers.handler[cp] = a

	if h, ok := a.(CCookieVisitorTVisitHandler); ok {
		cookie_visitor_handlers.visit_handler[cp] = h
		noBind = false
	} else {
		delete(cookie_visitor_handlers.visit_handler, cp)
	}

	if noBind {
		Panicln("F229: *CCookieVisitorT No bind")
	}
	return cookie_visitor
}

func unbindAllCCookieVisitorT(cp *cCCookieVisitorT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := cookie_visitor.pc_cookie_visitor
	delete(cookie_visitor_handlers.handler, cp)

	delete(cookie_visitor_handlers.visit_handler, cp)
}

func (cookie_visitor *CCookieVisitorT) UnbindAll() {
	unbindAllCCookieVisitorT(cookie_visitor.pc_cookie_visitor)
	cookie_visitor.Unref()
}

func (cookie_visitor *CCookieVisitorT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := cookie_visitor.pc_cookie_visitor
	return cookie_visitor_handlers.handler[cp]
}

///
// Structure to implement to be notified of asynchronous completion via
// cef_cookie_manager_t::set_cookie().
///

type cCSetCookieCallbackT C.cef_set_cookie_callback_t

// Go type for cef_set_cookie_callback_t
type CSetCookieCallbackT struct {
	noCopy                 noCopy
	pc_set_cookie_callback *cCSetCookieCallbackT
	beUnrefed              unrefedBy
}

func (p *CSetCookieCallbackT) Pass() (ret *CSetCookieCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCSetCookieCallbackT((*C.cef_set_cookie_callback_t)(p.pc_set_cookie_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CSetCookieCallbackT) NewRef() (newP *CSetCookieCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_set_cookie_callback
	BaseAddRef(gop)
	newP = newCSetCookieCallbackT((*C.cef_set_cookie_callback_t)(gop), byApp)
	return newP
}

// Go type CSetCookieCallbackT wraps cef type *C.cef_set_cookie_callback_t
func newCSetCookieCallbackT(p *C.cef_set_cookie_callback_t, unrefedBy unrefedBy) *CSetCookieCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T126.1:")
	pc := (*cCSetCookieCallbackT)(p)
	go_set_cookie_callback := &CSetCookieCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_set_cookie_callback, func(g *CSetCookieCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_set_cookie_callback != nil {
			Tracef(unsafe.Pointer(g.pc_set_cookie_callback), "T126.2:")
			BaseRelease(g.pc_set_cookie_callback)
		}
	})

	return go_set_cookie_callback
}

// *C.cef_set_cookie_callback_t has refCounted interface
func (set_cookie_callback *CSetCookieCallbackT) HasOneRef() bool {
	return BaseHasOneRef(set_cookie_callback.pc_set_cookie_callback)
}

func (p *cCSetCookieCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (set_cookie_callback *CSetCookieCallbackT) Unref() (ret bool) {
	if set_cookie_callback == nil {
		return
	}
	if set_cookie_callback.beUnrefed == byApp {
		ret = BaseRelease(set_cookie_callback.pc_set_cookie_callback)
		set_cookie_callback.beUnrefed = unrefed
	}
	set_cookie_callback.pc_set_cookie_callback = nil
	return ret
}

///
// Method that will be called upon completion. |success| will be true (1) if
// the cookie was set successfully.
///
type CSetCookieCallbackTOnCompleteHandler interface {
	OnComplete(
		self *CSetCookieCallbackT,
		success int,
	)
}

var set_cookie_callback_handlers = struct {
	handler             map[*cCSetCookieCallbackT]interface{}
	on_complete_handler map[*cCSetCookieCallbackT]CSetCookieCallbackTOnCompleteHandler
}{
	map[*cCSetCookieCallbackT]interface{}{},
	map[*cCSetCookieCallbackT]CSetCookieCallbackTOnCompleteHandler{},
}

// allocCSetCookieCallbackT allocates CSetCookieCallbackT and construct it
func allocCSetCookieCallbackT() *CSetCookieCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_set_cookie_callback_wrapper_t, "T126.3:")
	cefp := C.cefingo_construct_set_cookie_callback((*C.cefingo_set_cookie_callback_wrapper_t)(up))
	cgop := (*cCSetCookieCallbackT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_set_cookie_callback_t itself in DeassocFunc,
		// or cef_set_cookie_callback_t is never GCed.
		Tracef(up, "T126.4:")
		unbindAllCSetCookieCallbackT(cgop)
	}))

	BaseAddRef(cgop)
	return newCSetCookieCallbackT(cefp, byApp)
}

// NewCSetCookieCallbackT allocates CSetCookieCallbackT, construct and bind it
func NewCSetCookieCallbackT(a interface{}) *CSetCookieCallbackT {
	return allocCSetCookieCallbackT().bind(a)
}

func (set_cookie_callback *CSetCookieCallbackT) bind(a interface{}) *CSetCookieCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := set_cookie_callback.pc_set_cookie_callback
	set_cookie_callback_handlers.handler[cp] = a

	if h, ok := a.(CSetCookieCallbackTOnCompleteHandler); ok {
		set_cookie_callback_handlers.on_complete_handler[cp] = h
		noBind = false
	} else {
		delete(set_cookie_callback_handlers.on_complete_handler, cp)
	}

	if noBind {
		Panicln("F229: *CSetCookieCallbackT No bind")
	}
	return set_cookie_callback
}

func unbindAllCSetCookieCallbackT(cp *cCSetCookieCallbackT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := set_cookie_callback.pc_set_cookie_callback
	delete(set_cookie_callback_handlers.handler, cp)

	delete(set_cookie_callback_handlers.on_complete_handler, cp)
}

func (set_cookie_callback *CSetCookieCallbackT) UnbindAll() {
	unbindAllCSetCookieCallbackT(set_cookie_callback.pc_set_cookie_callback)
	set_cookie_callback.Unref()
}

func (set_cookie_callback *CSetCookieCallbackT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := set_cookie_callback.pc_set_cookie_callback
	return set_cookie_callback_handlers.handler[cp]
}

///
// Structure to implement to be notified of asynchronous completion via
// cef_cookie_manager_t::delete_cookies().
///

type cCDeleteCookiesCallbackT C.cef_delete_cookies_callback_t

// Go type for cef_delete_cookies_callback_t
type CDeleteCookiesCallbackT struct {
	noCopy                     noCopy
	pc_delete_cookies_callback *cCDeleteCookiesCallbackT
	beUnrefed                  unrefedBy
}

func (p *CDeleteCookiesCallbackT) Pass() (ret *CDeleteCookiesCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDeleteCookiesCallbackT((*C.cef_delete_cookies_callback_t)(p.pc_delete_cookies_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDeleteCookiesCallbackT) NewRef() (newP *CDeleteCookiesCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_delete_cookies_callback
	BaseAddRef(gop)
	newP = newCDeleteCookiesCallbackT((*C.cef_delete_cookies_callback_t)(gop), byApp)
	return newP
}

// Go type CDeleteCookiesCallbackT wraps cef type *C.cef_delete_cookies_callback_t
func newCDeleteCookiesCallbackT(p *C.cef_delete_cookies_callback_t, unrefedBy unrefedBy) *CDeleteCookiesCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T127.1:")
	pc := (*cCDeleteCookiesCallbackT)(p)
	go_delete_cookies_callback := &CDeleteCookiesCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_delete_cookies_callback, func(g *CDeleteCookiesCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_delete_cookies_callback != nil {
			Tracef(unsafe.Pointer(g.pc_delete_cookies_callback), "T127.2:")
			BaseRelease(g.pc_delete_cookies_callback)
		}
	})

	return go_delete_cookies_callback
}

// *C.cef_delete_cookies_callback_t has refCounted interface
func (delete_cookies_callback *CDeleteCookiesCallbackT) HasOneRef() bool {
	return BaseHasOneRef(delete_cookies_callback.pc_delete_cookies_callback)
}

func (p *cCDeleteCookiesCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (delete_cookies_callback *CDeleteCookiesCallbackT) Unref() (ret bool) {
	if delete_cookies_callback == nil {
		return
	}
	if delete_cookies_callback.beUnrefed == byApp {
		ret = BaseRelease(delete_cookies_callback.pc_delete_cookies_callback)
		delete_cookies_callback.beUnrefed = unrefed
	}
	delete_cookies_callback.pc_delete_cookies_callback = nil
	return ret
}

///
// Method that will be called upon completion. |num_deleted| will be the
// number of cookies that were deleted.
///
type CDeleteCookiesCallbackTOnCompleteHandler interface {
	OnComplete(
		self *CDeleteCookiesCallbackT,
		num_deleted int,
	)
}

var delete_cookies_callback_handlers = struct {
	handler             map[*cCDeleteCookiesCallbackT]interface{}
	on_complete_handler map[*cCDeleteCookiesCallbackT]CDeleteCookiesCallbackTOnCompleteHandler
}{
	map[*cCDeleteCookiesCallbackT]interface{}{},
	map[*cCDeleteCookiesCallbackT]CDeleteCookiesCallbackTOnCompleteHandler{},
}

// allocCDeleteCookiesCallbackT allocates CDeleteCookiesCallbackT and construct it
func allocCDeleteCookiesCallbackT() *CDeleteCookiesCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_delete_cookies_callback_wrapper_t, "T127.3:")
	cefp := C.cefingo_construct_delete_cookies_callback((*C.cefingo_delete_cookies_callback_wrapper_t)(up))
	cgop := (*cCDeleteCookiesCallbackT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_delete_cookies_callback_t itself in DeassocFunc,
		// or cef_delete_cookies_callback_t is never GCed.
		Tracef(up, "T127.4:")
		unbindAllCDeleteCookiesCallbackT(cgop)
	}))

	BaseAddRef(cgop)
	return newCDeleteCookiesCallbackT(cefp, byApp)
}

// NewCDeleteCookiesCallbackT allocates CDeleteCookiesCallbackT, construct and bind it
func NewCDeleteCookiesCallbackT(a interface{}) *CDeleteCookiesCallbackT {
	return allocCDeleteCookiesCallbackT().bind(a)
}

func (delete_cookies_callback *CDeleteCookiesCallbackT) bind(a interface{}) *CDeleteCookiesCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := delete_cookies_callback.pc_delete_cookies_callback
	delete_cookies_callback_handlers.handler[cp] = a

	if h, ok := a.(CDeleteCookiesCallbackTOnCompleteHandler); ok {
		delete_cookies_callback_handlers.on_complete_handler[cp] = h
		noBind = false
	} else {
		delete(delete_cookies_callback_handlers.on_complete_handler, cp)
	}

	if noBind {
		Panicln("F229: *CDeleteCookiesCallbackT No bind")
	}
	return delete_cookies_callback
}

func unbindAllCDeleteCookiesCallbackT(cp *cCDeleteCookiesCallbackT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := delete_cookies_callback.pc_delete_cookies_callback
	delete(delete_cookies_callback_handlers.handler, cp)

	delete(delete_cookies_callback_handlers.on_complete_handler, cp)
}

func (delete_cookies_callback *CDeleteCookiesCallbackT) UnbindAll() {
	unbindAllCDeleteCookiesCallbackT(delete_cookies_callback.pc_delete_cookies_callback)
	delete_cookies_callback.Unref()
}

func (delete_cookies_callback *CDeleteCookiesCallbackT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := delete_cookies_callback.pc_delete_cookies_callback
	return delete_cookies_callback_handlers.handler[cp]
}

// cef_crash_util_capi.h, include/capi/cef_crash_util_capi.h:139:16,

///
// Crash reporting is configured using an INI-style config file named
// "crash_reporter.cfg". On Windows and Linux this file must be placed next to
// the main application executable. On macOS this file must be placed in the
// top-level app bundle Resources directory (e.g.
// "<appname>.app/Contents/Resources"). File contents are as follows:
//
//  # Comments start with a hash character and must be on their own line.
//
//  [Config]
//  ProductName=<Value of the "prod" crash key; defaults to "cef">
//  ProductVersion=<Value of the "ver" crash key; defaults to the CEF version>
//  AppName=<Windows only; App-specific folder name component for storing crash
//           information; default to "CEF">
//  ExternalHandler=<Windows only; Name of the external handler exe to use
//                   instead of re-launching the main exe; default to empty>
//  BrowserCrashForwardingEnabled=<macOS only; True if browser process crashes
//                                 should be forwarded to the system crash
//                                 reporter; default to false>
//  ServerURL=<crash server URL; default to empty>
//  RateLimitEnabled=<True if uploads should be rate limited; default to true>
//  MaxUploadsPerDay=<Max uploads per 24 hours, used if rate limit is enabled;
//                    default to 5>
//  MaxDatabaseSizeInMb=<Total crash report disk usage greater than this value
//                       will cause older reports to be deleted; default to 20>
//  MaxDatabaseAgeInDays=<Crash reports older than this value will be deleted;
//                        default to 5>
//
//  [CrashKeys]
//  my_key1=<small|medium|large>
//  my_key2=<small|medium|large>
//
// Config section:
//
// If "ProductName" and/or "ProductVersion" are set then the specified values
// will be included in the crash dump metadata. On macOS if these values are set
// to NULL then they will be retrieved from the Info.plist file using the
// "CFBundleName" and "CFBundleShortVersionString" keys respectively.
//
// If "AppName" is set on Windows then crash report information (metrics,
// database and dumps) will be stored locally on disk under the
// "C:\Users\[CurrentUser]\AppData\Local\[AppName]\User Data" folder. On other
// platforms the CefSettings.user_data_path value will be used.
//
// If "ExternalHandler" is set on Windows then the specified exe will be
// launched as the crashpad-handler instead of re-launching the main process
// exe. The value can be an absolute path or a path relative to the main exe
// directory. On Linux the CefSettings.browser_subprocess_path value will be
// used. On macOS the existing subprocess app bundle will be used.
//
// If "BrowserCrashForwardingEnabled" is set to true (1) on macOS then browser
// process crashes will be forwarded to the system crash reporter. This results
// in the crash UI dialog being displayed to the user and crash reports being
// logged under "~/Library/Logs/DiagnosticReports". Forwarding of crash reports
// from non-browser processes and Debug builds is always disabled.
//
// If "ServerURL" is set then crashes will be uploaded as a multi-part POST
// request to the specified URL. Otherwise, reports will only be stored locally
// on disk.
//
// If "RateLimitEnabled" is set to true (1) then crash report uploads will be
// rate limited as follows:
//  1. If "MaxUploadsPerDay" is set to a positive value then at most the
//     specified number of crashes will be uploaded in each 24 hour period.
//  2. If crash upload fails due to a network or server error then an
//     incremental backoff delay up to a maximum of 24 hours will be applied for
//     retries.
//  3. If a backoff delay is applied and "MaxUploadsPerDay" is > 1 then the
//     "MaxUploadsPerDay" value will be reduced to 1 until the client is
//     restarted. This helps to avoid an upload flood when the network or
//     server error is resolved.
// Rate limiting is not supported on Linux.
//
// If "MaxDatabaseSizeInMb" is set to a positive value then crash report storage
// on disk will be limited to that size in megabytes. For example, on Windows
// each dump is about 600KB so a "MaxDatabaseSizeInMb" value of 20 equates to
// about 34 crash reports stored on disk. Not supported on Linux.
//
// If "MaxDatabaseAgeInDays" is set to a positive value then crash reports older
// than the specified age in days will be deleted. Not supported on Linux.
//
// CrashKeys section:
//
// A maximum of 26 crash keys of each size can be specified for use by the
// application. Crash key values will be truncated based on the specified size
// (small = 64 bytes, medium = 256 bytes, large = 1024 bytes). The value of
// crash keys can be set from any thread or process using the
// CefSetCrashKeyValue function. These key/value pairs will be sent to the crash
// server along with the crash dump file.
///
func CrashReportingEnabled() (ret bool) {

	cRet := C.cef_crash_reporting_enabled()

	ret = cRet == 1
	return ret
}

///
// Sets or clears a specific key-value pair from the crash metadata.
///
func SetCrashKeyValue(
	key string,
	value string,
) {
	c_key := create_cef_string(key)
	c_value := create_cef_string(value)

	C.cef_set_crash_key_value(c_key.p_cef_string_t, c_value.p_cef_string_t)

}

// cef_devtools_message_observer_capi.h, include/capi/cef_devtools_message_observer_capi.h:141:3,

///
// Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The
// functions of this structure will be called on the browser process UI thread.
///

type cCDevToolsMessageObserverT C.cef_dev_tools_message_observer_t

// Go type for cef_dev_tools_message_observer_t
type CDevToolsMessageObserverT struct {
	noCopy                        noCopy
	pc_dev_tools_message_observer *cCDevToolsMessageObserverT
	beUnrefed                     unrefedBy
}

func (p *CDevToolsMessageObserverT) Pass() (ret *CDevToolsMessageObserverT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDevToolsMessageObserverT((*C.cef_dev_tools_message_observer_t)(p.pc_dev_tools_message_observer), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDevToolsMessageObserverT) NewRef() (newP *CDevToolsMessageObserverT) {
	if self == nil {
		return newP
	}
	gop := self.pc_dev_tools_message_observer
	BaseAddRef(gop)
	newP = newCDevToolsMessageObserverT((*C.cef_dev_tools_message_observer_t)(gop), byApp)
	return newP
}

// Go type CDevToolsMessageObserverT wraps cef type *C.cef_dev_tools_message_observer_t
func newCDevToolsMessageObserverT(p *C.cef_dev_tools_message_observer_t, unrefedBy unrefedBy) *CDevToolsMessageObserverT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T128.1:")
	pc := (*cCDevToolsMessageObserverT)(p)
	go_dev_tools_message_observer := &CDevToolsMessageObserverT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_dev_tools_message_observer, func(g *CDevToolsMessageObserverT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_dev_tools_message_observer != nil {
			Tracef(unsafe.Pointer(g.pc_dev_tools_message_observer), "T128.2:")
			BaseRelease(g.pc_dev_tools_message_observer)
		}
	})

	return go_dev_tools_message_observer
}

// *C.cef_dev_tools_message_observer_t has refCounted interface
func (dev_tools_message_observer *CDevToolsMessageObserverT) HasOneRef() bool {
	return BaseHasOneRef(dev_tools_message_observer.pc_dev_tools_message_observer)
}

func (p *cCDevToolsMessageObserverT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (dev_tools_message_observer *CDevToolsMessageObserverT) Unref() (ret bool) {
	if dev_tools_message_observer == nil {
		return
	}
	if dev_tools_message_observer.beUnrefed == byApp {
		ret = BaseRelease(dev_tools_message_observer.pc_dev_tools_message_observer)
		dev_tools_message_observer.beUnrefed = unrefed
	}
	dev_tools_message_observer.pc_dev_tools_message_observer = nil
	return ret
}

///
// Method that will be called on receipt of a DevTools protocol message.
// |browser| is the originating browser instance. |message| is a UTF8-encoded
// JSON dictionary representing either a function result or an event.
// |message| is only valid for the scope of this callback and should be copied
// if necessary. Return true (1) if the message was handled or false (0) if
// the message should be further processed and passed to the
// OnDevToolsMethodResult or OnDevToolsEvent functions as appropriate.
//
// Method result dictionaries include an &quot;id&quot; (int) value that identifies the
// orginating function call sent from cef_browser_host_t::SendDevToolsMessage,
// and optionally either a &quot;result&quot; (dictionary) or &quot;error&quot; (dictionary)
// value. The &quot;error&quot; dictionary will contain &quot;code&quot; (int) and &quot;message&quot;
// (string) values. Event dictionaries include a &quot;function&quot; (string) value and
// optionally a &quot;params&quot; (dictionary) value. See the DevTools protocol
// documentation at https://chromedevtools.github.io/devtools-protocol/ for
// details of supported function calls and the expected &quot;result&quot; or &quot;params&quot;
// dictionary contents. JSON dictionaries can be parsed using the CefParseJSON
// function if desired, however be aware of performance considerations when
// parsing large messages (some of which may exceed 1MB in size).
///
type OnDevToolsMessageHandler interface {
	OnDevToolsMessage(
		self *CDevToolsMessageObserverT,
		browser *CBrowserT,
		message []byte,
	) (ret bool)
}

///
// Method that will be called after attempted execution of a DevTools protocol
// function. |browser| is the originating browser instance. |message_id| is
// the &quot;id&quot; value that identifies the originating function call message. If
// the function succeeded |success| will be true (1) and |result| will be the
// UTF8-encoded JSON &quot;result&quot; dictionary value (which may be NULL). If the
// function failed |success| will be false (0) and |result| will be the
// UTF8-encoded JSON &quot;error&quot; dictionary value. |result| is only valid for the
// scope of this callback and should be copied if necessary. See the
// OnDevToolsMessage documentation for additional details on |result|
// contents.
///
type OnDevToolsMethodResultHandler interface {
	OnDevToolsMethodResult(
		self *CDevToolsMessageObserverT,
		browser *CBrowserT,
		message_id int,
		success int,
		result []byte,
	)
}

///
// Method that will be called on receipt of a DevTools protocol event.
// |browser| is the originating browser instance. |function| is the &quot;function&quot;
// value. |params| is the UTF8-encoded JSON &quot;params&quot; dictionary value (which
// may be NULL). |params| is only valid for the scope of this callback and
// should be copied if necessary. See the OnDevToolsMessage documentation for
// additional details on |params| contents.
///
type OnDevToolsEventHandler interface {
	OnDevToolsEvent(
		self *CDevToolsMessageObserverT,
		browser *CBrowserT,
		method string,
		params []byte,
	)
}

///
// Method that will be called when the DevTools agent has attached. |browser|
// is the originating browser instance. This will generally occur in response
// to the first message sent while the agent is detached.
///
type OnDevToolsAgentAttachedHandler interface {
	OnDevToolsAgentAttached(
		self *CDevToolsMessageObserverT,
		browser *CBrowserT,
	)
}

///
// Method that will be called when the DevTools agent has detached. |browser|
// is the originating browser instance. Any function results that were pending
// before the agent became detached will not be delivered, and any active
// event subscriptions will be canceled.
///
type OnDevToolsAgentDetachedHandler interface {
	OnDevToolsAgentDetached(
		self *CDevToolsMessageObserverT,
		browser *CBrowserT,
	)
}

var dev_tools_message_observer_handlers = struct {
	handler                             map[*cCDevToolsMessageObserverT]interface{}
	on_dev_tools_message_handler        map[*cCDevToolsMessageObserverT]OnDevToolsMessageHandler
	on_dev_tools_method_result_handler  map[*cCDevToolsMessageObserverT]OnDevToolsMethodResultHandler
	on_dev_tools_event_handler          map[*cCDevToolsMessageObserverT]OnDevToolsEventHandler
	on_dev_tools_agent_attached_handler map[*cCDevToolsMessageObserverT]OnDevToolsAgentAttachedHandler
	on_dev_tools_agent_detached_handler map[*cCDevToolsMessageObserverT]OnDevToolsAgentDetachedHandler
}{
	map[*cCDevToolsMessageObserverT]interface{}{},
	map[*cCDevToolsMessageObserverT]OnDevToolsMessageHandler{},
	map[*cCDevToolsMessageObserverT]OnDevToolsMethodResultHandler{},
	map[*cCDevToolsMessageObserverT]OnDevToolsEventHandler{},
	map[*cCDevToolsMessageObserverT]OnDevToolsAgentAttachedHandler{},
	map[*cCDevToolsMessageObserverT]OnDevToolsAgentDetachedHandler{},
}

// allocCDevToolsMessageObserverT allocates CDevToolsMessageObserverT and construct it
func allocCDevToolsMessageObserverT() *CDevToolsMessageObserverT {
	up := c_calloc(1, C.sizeof_cefingo_dev_tools_message_observer_wrapper_t, "T128.3:")
	cefp := C.cefingo_construct_dev_tools_message_observer((*C.cefingo_dev_tools_message_observer_wrapper_t)(up))
	cgop := (*cCDevToolsMessageObserverT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_dev_tools_message_observer_t itself in DeassocFunc,
		// or cef_dev_tools_message_observer_t is never GCed.
		Tracef(up, "T128.4:")
		unbindAllCDevToolsMessageObserverT(cgop)
	}))

	BaseAddRef(cgop)
	return newCDevToolsMessageObserverT(cefp, byApp)
}

// NewCDevToolsMessageObserverT allocates CDevToolsMessageObserverT, construct and bind it
func NewCDevToolsMessageObserverT(a interface{}) *CDevToolsMessageObserverT {
	return allocCDevToolsMessageObserverT().bind(a)
}

func (dev_tools_message_observer *CDevToolsMessageObserverT) bind(a interface{}) *CDevToolsMessageObserverT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := dev_tools_message_observer.pc_dev_tools_message_observer
	dev_tools_message_observer_handlers.handler[cp] = a

	if h, ok := a.(OnDevToolsMessageHandler); ok {
		dev_tools_message_observer_handlers.on_dev_tools_message_handler[cp] = h
		noBind = false
	} else {
		delete(dev_tools_message_observer_handlers.on_dev_tools_message_handler, cp)
	}

	if h, ok := a.(OnDevToolsMethodResultHandler); ok {
		dev_tools_message_observer_handlers.on_dev_tools_method_result_handler[cp] = h
		noBind = false
	} else {
		delete(dev_tools_message_observer_handlers.on_dev_tools_method_result_handler, cp)
	}

	if h, ok := a.(OnDevToolsEventHandler); ok {
		dev_tools_message_observer_handlers.on_dev_tools_event_handler[cp] = h
		noBind = false
	} else {
		delete(dev_tools_message_observer_handlers.on_dev_tools_event_handler, cp)
	}

	if h, ok := a.(OnDevToolsAgentAttachedHandler); ok {
		dev_tools_message_observer_handlers.on_dev_tools_agent_attached_handler[cp] = h
		noBind = false
	} else {
		delete(dev_tools_message_observer_handlers.on_dev_tools_agent_attached_handler, cp)
	}

	if h, ok := a.(OnDevToolsAgentDetachedHandler); ok {
		dev_tools_message_observer_handlers.on_dev_tools_agent_detached_handler[cp] = h
		noBind = false
	} else {
		delete(dev_tools_message_observer_handlers.on_dev_tools_agent_detached_handler, cp)
	}

	if noBind {
		Panicln("F229: *CDevToolsMessageObserverT No bind")
	}
	return dev_tools_message_observer
}

func unbindAllCDevToolsMessageObserverT(cp *cCDevToolsMessageObserverT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := dev_tools_message_observer.pc_dev_tools_message_observer
	delete(dev_tools_message_observer_handlers.handler, cp)

	delete(dev_tools_message_observer_handlers.on_dev_tools_message_handler, cp)
	delete(dev_tools_message_observer_handlers.on_dev_tools_method_result_handler, cp)
	delete(dev_tools_message_observer_handlers.on_dev_tools_event_handler, cp)
	delete(dev_tools_message_observer_handlers.on_dev_tools_agent_attached_handler, cp)
	delete(dev_tools_message_observer_handlers.on_dev_tools_agent_detached_handler, cp)
}

func (dev_tools_message_observer *CDevToolsMessageObserverT) UnbindAll() {
	unbindAllCDevToolsMessageObserverT(dev_tools_message_observer.pc_dev_tools_message_observer)
	dev_tools_message_observer.Unref()
}

func (dev_tools_message_observer *CDevToolsMessageObserverT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := dev_tools_message_observer.pc_dev_tools_message_observer
	return dev_tools_message_observer_handlers.handler[cp]
}

// cef_dialog_handler_capi.h, include/capi/cef_dialog_handler_capi.h:74:3,

///
// Callback structure for asynchronous continuation of file dialog requests.
///

type cCFileDialogCallbackT C.cef_file_dialog_callback_t

// Go type for cef_file_dialog_callback_t
type CFileDialogCallbackT struct {
	noCopy                  noCopy
	pc_file_dialog_callback *cCFileDialogCallbackT
	beUnrefed               unrefedBy
}

func (p *CFileDialogCallbackT) Pass() (ret *CFileDialogCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCFileDialogCallbackT((*C.cef_file_dialog_callback_t)(p.pc_file_dialog_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CFileDialogCallbackT) NewRef() (newP *CFileDialogCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_file_dialog_callback
	BaseAddRef(gop)
	newP = newCFileDialogCallbackT((*C.cef_file_dialog_callback_t)(gop), byApp)
	return newP
}

// Go type CFileDialogCallbackT wraps cef type *C.cef_file_dialog_callback_t
func newCFileDialogCallbackT(p *C.cef_file_dialog_callback_t, unrefedBy unrefedBy) *CFileDialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T129.1:")
	pc := (*cCFileDialogCallbackT)(p)
	go_file_dialog_callback := &CFileDialogCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_file_dialog_callback, func(g *CFileDialogCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_file_dialog_callback != nil {
			Tracef(unsafe.Pointer(g.pc_file_dialog_callback), "T129.2:")
			BaseRelease(g.pc_file_dialog_callback)
		}
	})

	return go_file_dialog_callback
}

// *C.cef_file_dialog_callback_t has refCounted interface
func (file_dialog_callback *CFileDialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(file_dialog_callback.pc_file_dialog_callback)
}

func (p *cCFileDialogCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (file_dialog_callback *CFileDialogCallbackT) Unref() (ret bool) {
	if file_dialog_callback == nil {
		return
	}
	if file_dialog_callback.beUnrefed == byApp {
		ret = BaseRelease(file_dialog_callback.pc_file_dialog_callback)
		file_dialog_callback.beUnrefed = unrefed
	}
	file_dialog_callback.pc_file_dialog_callback = nil
	return ret
}

///
// Continue the file selection. |selected_accept_filter| should be the 0-based
// index of the value selected from the accept filters array passed to
// cef_dialog_handler_t::OnFileDialog. |file_paths| should be a single value
// or a list of values depending on the dialog mode. An NULL |file_paths|
// value is treated the same as calling cancel().
///
func (self *CFileDialogCallbackT) Cont(
	selected_accept_filter int,
	file_paths CStringListT,
) {

	C.cefingo_file_dialog_callback_cont((*C.cef_file_dialog_callback_t)(self.pc_file_dialog_callback), (C.int)(selected_accept_filter), (C.cef_string_list_t)(file_paths))

}

///
// Cancel the file selection.
///
func (self *CFileDialogCallbackT) Cancel() {

	C.cefingo_file_dialog_callback_cancel((*C.cef_file_dialog_callback_t)(self.pc_file_dialog_callback))

}

///
// Implement this structure to handle dialog events. The functions of this
// structure will be called on the browser process UI thread.
///

type cCDialogHandlerT C.cef_dialog_handler_t

// Go type for cef_dialog_handler_t
type CDialogHandlerT struct {
	noCopy            noCopy
	pc_dialog_handler *cCDialogHandlerT
	beUnrefed         unrefedBy
}

func (p *CDialogHandlerT) Pass() (ret *CDialogHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDialogHandlerT((*C.cef_dialog_handler_t)(p.pc_dialog_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDialogHandlerT) NewRef() (newP *CDialogHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_dialog_handler
	BaseAddRef(gop)
	newP = newCDialogHandlerT((*C.cef_dialog_handler_t)(gop), byApp)
	return newP
}

// Go type CDialogHandlerT wraps cef type *C.cef_dialog_handler_t
func newCDialogHandlerT(p *C.cef_dialog_handler_t, unrefedBy unrefedBy) *CDialogHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T130.1:")
	pc := (*cCDialogHandlerT)(p)
	go_dialog_handler := &CDialogHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_dialog_handler, func(g *CDialogHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_dialog_handler != nil {
			Tracef(unsafe.Pointer(g.pc_dialog_handler), "T130.2:")
			BaseRelease(g.pc_dialog_handler)
		}
	})

	return go_dialog_handler
}

// *C.cef_dialog_handler_t has refCounted interface
func (dialog_handler *CDialogHandlerT) HasOneRef() bool {
	return BaseHasOneRef(dialog_handler.pc_dialog_handler)
}

func (p *cCDialogHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (dialog_handler *CDialogHandlerT) Unref() (ret bool) {
	if dialog_handler == nil {
		return
	}
	if dialog_handler.beUnrefed == byApp {
		ret = BaseRelease(dialog_handler.pc_dialog_handler)
		dialog_handler.beUnrefed = unrefed
	}
	dialog_handler.pc_dialog_handler = nil
	return ret
}

///
// Called to run a file chooser dialog. |mode| represents the type of dialog
// to display. |title| to the title to be used for the dialog and may be NULL
// to show the default title (&quot;Open&quot; or &quot;Save&quot; depending on the mode).
// |default_file_path| is the path with optional directory and/or file name
// component that should be initially selected in the dialog. |accept_filters|
// are used to restrict the selectable file types and may any combination of
// (a) valid lower-cased MIME types (e.g. &quot;text/*&quot; or &quot;image/*&quot;), (b)
// individual file extensions (e.g. &quot;.txt&quot; or &quot;.png&quot;), or (c) combined
// description and file extension delimited using &quot;|&quot; and &quot;;&quot; (e.g. &quot;Image
// Types|.png;.gif;.jpg&quot;). |selected_accept_filter| is the 0-based index of
// the filter that should be selected by default. To display a custom dialog
// return true (1) and execute |callback| either inline or at a later time. To
// display the default dialog return false (0).
///
type OnFileDialogHandler interface {
	OnFileDialog(
		self *CDialogHandlerT,
		browser *CBrowserT,
		mode CFileDialogModeT,
		title string,
		default_file_path string,
		accept_filters CStringListT,
		selected_accept_filter int,
		callback *CFileDialogCallbackT,
	) (ret bool)
}

var dialog_handler_handlers = struct {
	handler                map[*cCDialogHandlerT]interface{}
	on_file_dialog_handler map[*cCDialogHandlerT]OnFileDialogHandler
}{
	map[*cCDialogHandlerT]interface{}{},
	map[*cCDialogHandlerT]OnFileDialogHandler{},
}

// allocCDialogHandlerT allocates CDialogHandlerT and construct it
func allocCDialogHandlerT() *CDialogHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_dialog_handler_wrapper_t, "T130.3:")
	cefp := C.cefingo_construct_dialog_handler((*C.cefingo_dialog_handler_wrapper_t)(up))
	cgop := (*cCDialogHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_dialog_handler_t itself in DeassocFunc,
		// or cef_dialog_handler_t is never GCed.
		Tracef(up, "T130.4:")
		unbindAllCDialogHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCDialogHandlerT(cefp, byApp)
}

// NewCDialogHandlerT allocates CDialogHandlerT, construct and bind it
func NewCDialogHandlerT(a interface{}) *CDialogHandlerT {
	return allocCDialogHandlerT().bind(a)
}

func (dialog_handler *CDialogHandlerT) bind(a interface{}) *CDialogHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := dialog_handler.pc_dialog_handler
	dialog_handler_handlers.handler[cp] = a

	if h, ok := a.(OnFileDialogHandler); ok {
		dialog_handler_handlers.on_file_dialog_handler[cp] = h
		noBind = false
	} else {
		delete(dialog_handler_handlers.on_file_dialog_handler, cp)
	}

	if noBind {
		Panicln("F229: *CDialogHandlerT No bind")
	}
	return dialog_handler
}

func unbindAllCDialogHandlerT(cp *cCDialogHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := dialog_handler.pc_dialog_handler
	delete(dialog_handler_handlers.handler, cp)

	delete(dialog_handler_handlers.on_file_dialog_handler, cp)
}

func (dialog_handler *CDialogHandlerT) UnbindAll() {
	unbindAllCDialogHandlerT(dialog_handler.pc_dialog_handler)
	dialog_handler.Unref()
}

func (dialog_handler *CDialogHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := dialog_handler.pc_dialog_handler
	return dialog_handler_handlers.handler[cp]
}

// cef_display_capi.h, include/capi/views/cef_display_capi.h:106:3,

///
// This structure typically, but not always, corresponds to a physical display
// connected to the system. A fake Display may exist on a headless system, or a
// Display may correspond to a remote, virtual display. All size and position
// values are in density independent pixel (DIP) coordinates unless otherwise
// indicated. Methods must be called on the browser process UI thread unless
// otherwise indicated.
///

type cCDisplayT C.cef_display_t

// Go type for cef_display_t
type CDisplayT struct {
	noCopy     noCopy
	pc_display *cCDisplayT
	beUnrefed  unrefedBy
}

func (p *CDisplayT) Pass() (ret *CDisplayT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDisplayT((*C.cef_display_t)(p.pc_display), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDisplayT) NewRef() (newP *CDisplayT) {
	if self == nil {
		return newP
	}
	gop := self.pc_display
	BaseAddRef(gop)
	newP = newCDisplayT((*C.cef_display_t)(gop), byApp)
	return newP
}

// Go type CDisplayT wraps cef type *C.cef_display_t
func newCDisplayT(p *C.cef_display_t, unrefedBy unrefedBy) *CDisplayT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T131.1:")
	pc := (*cCDisplayT)(p)
	go_display := &CDisplayT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_display, func(g *CDisplayT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_display != nil {
			Tracef(unsafe.Pointer(g.pc_display), "T131.2:")
			BaseRelease(g.pc_display)
		}
	})

	return go_display
}

// *C.cef_display_t has refCounted interface
func (display *CDisplayT) HasOneRef() bool {
	return BaseHasOneRef(display.pc_display)
}

func (p *cCDisplayT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (display *CDisplayT) Unref() (ret bool) {
	if display == nil {
		return
	}
	if display.beUnrefed == byApp {
		ret = BaseRelease(display.pc_display)
		display.beUnrefed = unrefed
	}
	display.pc_display = nil
	return ret
}

///
// Returns the unique identifier for this Display.
///
func (self *CDisplayT) GetId() (ret int64) {

	cRet := C.cefingo_display_get_id((*C.cef_display_t)(self.pc_display))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns this Display&#39;s device pixel scale factor. This specifies how much
// the UI should be scaled when the actual output has more pixels than
// standard displays (which is around 100~120dpi). The potential return values
// differ by platform.
///
func (self *CDisplayT) GetDeviceScaleFactor() (ret float32) {

	cRet := C.cefingo_display_get_device_scale_factor((*C.cef_display_t)(self.pc_display))

	ret = (float32)(cRet) // return GoObj
	return ret
}

///
// Convert |point| from DIP coordinates to pixel coordinates using this
// Display&#39;s device scale factor.
///
func (self *CDisplayT) ConvertPointToPixels(
	point *CPointT,
) {

	C.cefingo_display_convert_point_to_pixels((*C.cef_display_t)(self.pc_display), (*C.cef_point_t)(point))

}

///
// Convert |point| from pixel coordinates to DIP coordinates using this
// Display&#39;s device scale factor.
///
func (self *CDisplayT) ConvertPointFromPixels(
	point *CPointT,
) {

	C.cefingo_display_convert_point_from_pixels((*C.cef_display_t)(self.pc_display), (*C.cef_point_t)(point))

}

///
// Returns this Display&#39;s bounds in DIP screen coordinates. This is the full
// size of the display.
///
func (self *CDisplayT) GetBounds() (ret CRectT) {

	cRet := C.cefingo_display_get_bounds((*C.cef_display_t)(self.pc_display))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Returns this Display&#39;s work area in DIP screen coordinates. This excludes
// areas of the display that are occupied with window manager toolbars, etc.
///
func (self *CDisplayT) GetWorkArea() (ret CRectT) {

	cRet := C.cefingo_display_get_work_area((*C.cef_display_t)(self.pc_display))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Returns this Display&#39;s rotation in degrees.
///
func (self *CDisplayT) GetRotation() (ret bool) {

	cRet := C.cefingo_display_get_rotation((*C.cef_display_t)(self.pc_display))

	ret = cRet == 1
	return ret
}

///
// Returns the primary Display.
///
func DisplayGetPrimary() (ret *CDisplayT) {

	cRet := C.cef_display_get_primary()

	ret = newCDisplayT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the Display nearest |point|. Set |input_pixel_coords| to true (1) if
// |point| is in pixel screen coordinates instead of DIP screen coordinates.
///
func DisplayGetNearestPoint(
	point *CPointT,
	input_pixel_coords int,
) (ret *CDisplayT) {

	cRet := C.cef_display_get_nearest_point((*C.cef_point_t)(point), (C.int)(input_pixel_coords))

	ret = newCDisplayT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the Display that most closely intersects |bounds|.  Set
// |input_pixel_coords| to true (1) if |bounds| is in pixel screen coordinates
// instead of DIP screen coordinates.
///
func DisplayGetMatchingBounds(
	bounds *CRectT,
	input_pixel_coords int,
) (ret *CDisplayT) {

	cRet := C.cef_display_get_matching_bounds((*C.cef_rect_t)(bounds), (C.int)(input_pixel_coords))

	ret = newCDisplayT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the total number of Displays. Mirrored displays are excluded; this
// function is intended to return the number of distinct, usable displays.
///
func DisplayGetCount() (ret int64) {

	cRet := C.cef_display_get_count()

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns all Displays. Mirrored displays are excluded; this function is
// intended to return distinct, usable displays.
///
func DisplayGetAlls() (displays []*CDisplayT) {
	_displaysCount := C.size_t(DisplayGetCount()) // =SizeFunc ::cef_display_get_alls:displays
	if _displaysCount == 0 {
		return
	}
	displaysCount := &_displaysCount
	tmpdisplays := unsafe.Pointer(c_calloc(_displaysCount, 8, "T254.1"))
	defer C.free(tmpdisplays)

	C.cef_display_get_alls((*C.size_t)(displaysCount), (**C.cef_display_t)(tmpdisplays))

	displays = make([]*CDisplayT, *displaysCount)
	_tmpdisplays := (*[1 << 30](*C.cef_display_t))(unsafe.Pointer(tmpdisplays))[:*displaysCount:*displaysCount]
	for i := C.size_t(0); i < *displaysCount; i++ {
		displays[i] = newCDisplayT(_tmpdisplays[i], byApp) // Out Slice Param
	}
	return displays
}

// cef_display_handler_capi.h, include/capi/cef_display_handler_capi.h:157:3,

///
// Implement this structure to handle events related to browser display state.
// The functions of this structure will be called on the UI thread.
///

type cCDisplayHandlerT C.cef_display_handler_t

// Go type for cef_display_handler_t
type CDisplayHandlerT struct {
	noCopy             noCopy
	pc_display_handler *cCDisplayHandlerT
	beUnrefed          unrefedBy
}

func (p *CDisplayHandlerT) Pass() (ret *CDisplayHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDisplayHandlerT((*C.cef_display_handler_t)(p.pc_display_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDisplayHandlerT) NewRef() (newP *CDisplayHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_display_handler
	BaseAddRef(gop)
	newP = newCDisplayHandlerT((*C.cef_display_handler_t)(gop), byApp)
	return newP
}

// Go type CDisplayHandlerT wraps cef type *C.cef_display_handler_t
func newCDisplayHandlerT(p *C.cef_display_handler_t, unrefedBy unrefedBy) *CDisplayHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T132.1:")
	pc := (*cCDisplayHandlerT)(p)
	go_display_handler := &CDisplayHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_display_handler, func(g *CDisplayHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_display_handler != nil {
			Tracef(unsafe.Pointer(g.pc_display_handler), "T132.2:")
			BaseRelease(g.pc_display_handler)
		}
	})

	return go_display_handler
}

// *C.cef_display_handler_t has refCounted interface
func (display_handler *CDisplayHandlerT) HasOneRef() bool {
	return BaseHasOneRef(display_handler.pc_display_handler)
}

func (p *cCDisplayHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (display_handler *CDisplayHandlerT) Unref() (ret bool) {
	if display_handler == nil {
		return
	}
	if display_handler.beUnrefed == byApp {
		ret = BaseRelease(display_handler.pc_display_handler)
		display_handler.beUnrefed = unrefed
	}
	display_handler.pc_display_handler = nil
	return ret
}

///
// Called when a frame&#39;s address has changed.
///
type OnAddressChangeHandler interface {
	OnAddressChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		url string,
	)
}

///
// Called when the page title changes.
///
type OnTitleChangeHandler interface {
	OnTitleChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		title string,
	)
}

///
// Called when the page icon changes.
///
type OnFaviconUrlchangeHandler interface {
	OnFaviconUrlchange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		icon_urls CStringListT,
	)
}

///
// Called when web content in the page has toggled fullscreen mode. If
// |fullscreen| is true (1) the content will automatically be sized to fill
// the browser content area. If |fullscreen| is false (0) the content will
// automatically return to its original size and position. The client is
// responsible for resizing the browser if desired.
///
type OnFullscreenModeChangeHandler interface {
	OnFullscreenModeChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		fullscreen int,
	)
}

///
// Called when the browser is about to display a tooltip. |text| contains the
// text that will be displayed in the tooltip. To handle the display of the
// tooltip yourself return true (1). Otherwise, you can optionally modify
// |text| and then return false (0) to allow the browser to display the
// tooltip. When window rendering is disabled the application is responsible
// for drawing tooltips and the return value is ignored.
///
type OnTooltipHandler interface {
	OnTooltip(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		text string,
	) (ret bool, textOut string)
}

///
// Called when the browser receives a status message. |value| contains the
// text that will be displayed in the status message.
///
type OnStatusMessageHandler interface {
	OnStatusMessage(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		value string,
	)
}

///
// Called to display a console message. Return true (1) to stop the message
// from being output to the console.
///
type OnConsoleMessageHandler interface {
	OnConsoleMessage(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		level CLogSeverityT,
		message string,
		source string,
		line int,
	) (ret bool)
}

///
// Called when auto-resize is enabled via
// cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-
// resized. |new_size| will be the desired size in view coordinates. Return
// true (1) if the resize was handled or false (0) for default handling.
///
type OnAutoResizeHandler interface {
	OnAutoResize(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		new_size *CSizeT,
	) (ret bool)
}

///
// Called when the overall page loading progress has changed. |progress|
// ranges from 0.0 to 1.0.
///
type OnLoadingProgressChangeHandler interface {
	OnLoadingProgressChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		progress float64,
	)
}

///
// Called when the browser&#39;s cursor has changed. If |type| is CT_CUSTOM then
// |custom_cursor_info| will be populated with the custom cursor information.
// Return true (1) if the cursor change was handled or false (0) for default
// handling.
///
type OnCursorChangeHandler interface {
	OnCursorChange(
		self *CDisplayHandlerT,
		browser *CBrowserT,
		cursor CCursorHandleT,
		ctype CCursorTypeT,
		custom_cursor_info *CCursorInfoT,
	) (ret bool)
}

var display_handler_handlers = struct {
	handler                            map[*cCDisplayHandlerT]interface{}
	on_address_change_handler          map[*cCDisplayHandlerT]OnAddressChangeHandler
	on_title_change_handler            map[*cCDisplayHandlerT]OnTitleChangeHandler
	on_favicon_urlchange_handler       map[*cCDisplayHandlerT]OnFaviconUrlchangeHandler
	on_fullscreen_mode_change_handler  map[*cCDisplayHandlerT]OnFullscreenModeChangeHandler
	on_tooltip_handler                 map[*cCDisplayHandlerT]OnTooltipHandler
	on_status_message_handler          map[*cCDisplayHandlerT]OnStatusMessageHandler
	on_console_message_handler         map[*cCDisplayHandlerT]OnConsoleMessageHandler
	on_auto_resize_handler             map[*cCDisplayHandlerT]OnAutoResizeHandler
	on_loading_progress_change_handler map[*cCDisplayHandlerT]OnLoadingProgressChangeHandler
	on_cursor_change_handler           map[*cCDisplayHandlerT]OnCursorChangeHandler
}{
	map[*cCDisplayHandlerT]interface{}{},
	map[*cCDisplayHandlerT]OnAddressChangeHandler{},
	map[*cCDisplayHandlerT]OnTitleChangeHandler{},
	map[*cCDisplayHandlerT]OnFaviconUrlchangeHandler{},
	map[*cCDisplayHandlerT]OnFullscreenModeChangeHandler{},
	map[*cCDisplayHandlerT]OnTooltipHandler{},
	map[*cCDisplayHandlerT]OnStatusMessageHandler{},
	map[*cCDisplayHandlerT]OnConsoleMessageHandler{},
	map[*cCDisplayHandlerT]OnAutoResizeHandler{},
	map[*cCDisplayHandlerT]OnLoadingProgressChangeHandler{},
	map[*cCDisplayHandlerT]OnCursorChangeHandler{},
}

// allocCDisplayHandlerT allocates CDisplayHandlerT and construct it
func allocCDisplayHandlerT() *CDisplayHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_display_handler_wrapper_t, "T132.3:")
	cefp := C.cefingo_construct_display_handler((*C.cefingo_display_handler_wrapper_t)(up))
	cgop := (*cCDisplayHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_display_handler_t itself in DeassocFunc,
		// or cef_display_handler_t is never GCed.
		Tracef(up, "T132.4:")
		unbindAllCDisplayHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCDisplayHandlerT(cefp, byApp)
}

// NewCDisplayHandlerT allocates CDisplayHandlerT, construct and bind it
func NewCDisplayHandlerT(a interface{}) *CDisplayHandlerT {
	return allocCDisplayHandlerT().bind(a)
}

func (display_handler *CDisplayHandlerT) bind(a interface{}) *CDisplayHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := display_handler.pc_display_handler
	display_handler_handlers.handler[cp] = a

	if h, ok := a.(OnAddressChangeHandler); ok {
		display_handler_handlers.on_address_change_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_address_change_handler, cp)
	}

	if h, ok := a.(OnTitleChangeHandler); ok {
		display_handler_handlers.on_title_change_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_title_change_handler, cp)
	}

	if h, ok := a.(OnFaviconUrlchangeHandler); ok {
		display_handler_handlers.on_favicon_urlchange_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_favicon_urlchange_handler, cp)
	}

	if h, ok := a.(OnFullscreenModeChangeHandler); ok {
		display_handler_handlers.on_fullscreen_mode_change_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_fullscreen_mode_change_handler, cp)
	}

	if h, ok := a.(OnTooltipHandler); ok {
		display_handler_handlers.on_tooltip_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_tooltip_handler, cp)
	}

	if h, ok := a.(OnStatusMessageHandler); ok {
		display_handler_handlers.on_status_message_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_status_message_handler, cp)
	}

	if h, ok := a.(OnConsoleMessageHandler); ok {
		display_handler_handlers.on_console_message_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_console_message_handler, cp)
	}

	if h, ok := a.(OnAutoResizeHandler); ok {
		display_handler_handlers.on_auto_resize_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_auto_resize_handler, cp)
	}

	if h, ok := a.(OnLoadingProgressChangeHandler); ok {
		display_handler_handlers.on_loading_progress_change_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_loading_progress_change_handler, cp)
	}

	if h, ok := a.(OnCursorChangeHandler); ok {
		display_handler_handlers.on_cursor_change_handler[cp] = h
		noBind = false
	} else {
		delete(display_handler_handlers.on_cursor_change_handler, cp)
	}

	if noBind {
		Panicln("F229: *CDisplayHandlerT No bind")
	}
	return display_handler
}

func unbindAllCDisplayHandlerT(cp *cCDisplayHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := display_handler.pc_display_handler
	delete(display_handler_handlers.handler, cp)

	delete(display_handler_handlers.on_address_change_handler, cp)
	delete(display_handler_handlers.on_title_change_handler, cp)
	delete(display_handler_handlers.on_favicon_urlchange_handler, cp)
	delete(display_handler_handlers.on_fullscreen_mode_change_handler, cp)
	delete(display_handler_handlers.on_tooltip_handler, cp)
	delete(display_handler_handlers.on_status_message_handler, cp)
	delete(display_handler_handlers.on_console_message_handler, cp)
	delete(display_handler_handlers.on_auto_resize_handler, cp)
	delete(display_handler_handlers.on_loading_progress_change_handler, cp)
	delete(display_handler_handlers.on_cursor_change_handler, cp)
}

func (display_handler *CDisplayHandlerT) UnbindAll() {
	unbindAllCDisplayHandlerT(display_handler.pc_display_handler)
	display_handler.Unref()
}

func (display_handler *CDisplayHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := display_handler.pc_display_handler
	return display_handler_handlers.handler[cp]
}

// cef_dom_capi.h, include/capi/cef_dom_capi.h:71:3,

///
// Structure to implement for visiting the DOM. The functions of this structure
// will be called on the render process main thread.
///

type cCDomvisitorT C.cef_domvisitor_t

// Go type for cef_domvisitor_t
type CDomvisitorT struct {
	noCopy        noCopy
	pc_domvisitor *cCDomvisitorT
	beUnrefed     unrefedBy
}

func (p *CDomvisitorT) Pass() (ret *CDomvisitorT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDomvisitorT((*C.cef_domvisitor_t)(p.pc_domvisitor), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDomvisitorT) NewRef() (newP *CDomvisitorT) {
	if self == nil {
		return newP
	}
	gop := self.pc_domvisitor
	BaseAddRef(gop)
	newP = newCDomvisitorT((*C.cef_domvisitor_t)(gop), byApp)
	return newP
}

// Go type CDomvisitorT wraps cef type *C.cef_domvisitor_t
func newCDomvisitorT(p *C.cef_domvisitor_t, unrefedBy unrefedBy) *CDomvisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T133.1:")
	pc := (*cCDomvisitorT)(p)
	go_domvisitor := &CDomvisitorT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_domvisitor, func(g *CDomvisitorT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_domvisitor != nil {
			Tracef(unsafe.Pointer(g.pc_domvisitor), "T133.2:")
			BaseRelease(g.pc_domvisitor)
		}
	})

	return go_domvisitor
}

// *C.cef_domvisitor_t has refCounted interface
func (domvisitor *CDomvisitorT) HasOneRef() bool {
	return BaseHasOneRef(domvisitor.pc_domvisitor)
}

func (p *cCDomvisitorT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (domvisitor *CDomvisitorT) Unref() (ret bool) {
	if domvisitor == nil {
		return
	}
	if domvisitor.beUnrefed == byApp {
		ret = BaseRelease(domvisitor.pc_domvisitor)
		domvisitor.beUnrefed = unrefed
	}
	domvisitor.pc_domvisitor = nil
	return ret
}

///
// Method executed for visiting the DOM. The document object passed to this
// function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
type CDomvisitorTVisitHandler interface {
	Visit(
		self *CDomvisitorT,
		document *CDomdocumentT,
	)
}

var domvisitor_handlers = struct {
	handler       map[*cCDomvisitorT]interface{}
	visit_handler map[*cCDomvisitorT]CDomvisitorTVisitHandler
}{
	map[*cCDomvisitorT]interface{}{},
	map[*cCDomvisitorT]CDomvisitorTVisitHandler{},
}

// allocCDomvisitorT allocates CDomvisitorT and construct it
func allocCDomvisitorT() *CDomvisitorT {
	up := c_calloc(1, C.sizeof_cefingo_domvisitor_wrapper_t, "T133.3:")
	cefp := C.cefingo_construct_domvisitor((*C.cefingo_domvisitor_wrapper_t)(up))
	cgop := (*cCDomvisitorT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_domvisitor_t itself in DeassocFunc,
		// or cef_domvisitor_t is never GCed.
		Tracef(up, "T133.4:")
		unbindAllCDomvisitorT(cgop)
	}))

	BaseAddRef(cgop)
	return newCDomvisitorT(cefp, byApp)
}

// NewCDomvisitorT allocates CDomvisitorT, construct and bind it
func NewCDomvisitorT(a interface{}) *CDomvisitorT {
	return allocCDomvisitorT().bind(a)
}

func (domvisitor *CDomvisitorT) bind(a interface{}) *CDomvisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := domvisitor.pc_domvisitor
	domvisitor_handlers.handler[cp] = a

	if h, ok := a.(CDomvisitorTVisitHandler); ok {
		domvisitor_handlers.visit_handler[cp] = h
		noBind = false
	} else {
		delete(domvisitor_handlers.visit_handler, cp)
	}

	if noBind {
		Panicln("F229: *CDomvisitorT No bind")
	}
	return domvisitor
}

func unbindAllCDomvisitorT(cp *cCDomvisitorT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := domvisitor.pc_domvisitor
	delete(domvisitor_handlers.handler, cp)

	delete(domvisitor_handlers.visit_handler, cp)
}

func (domvisitor *CDomvisitorT) UnbindAll() {
	unbindAllCDomvisitorT(domvisitor.pc_domvisitor)
	domvisitor.Unref()
}

func (domvisitor *CDomvisitorT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := domvisitor.pc_domvisitor
	return domvisitor_handlers.handler[cp]
}

///
// Structure used to represent a DOM document. The functions of this structure
// should only be called on the render process main thread thread.
///

type cCDomdocumentT C.cef_domdocument_t

// Go type for cef_domdocument_t
type CDomdocumentT struct {
	noCopy         noCopy
	pc_domdocument *cCDomdocumentT
	beUnrefed      unrefedBy
}

func (p *CDomdocumentT) Pass() (ret *CDomdocumentT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDomdocumentT((*C.cef_domdocument_t)(p.pc_domdocument), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDomdocumentT) NewRef() (newP *CDomdocumentT) {
	if self == nil {
		return newP
	}
	gop := self.pc_domdocument
	BaseAddRef(gop)
	newP = newCDomdocumentT((*C.cef_domdocument_t)(gop), byApp)
	return newP
}

// Go type CDomdocumentT wraps cef type *C.cef_domdocument_t
func newCDomdocumentT(p *C.cef_domdocument_t, unrefedBy unrefedBy) *CDomdocumentT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T134.1:")
	pc := (*cCDomdocumentT)(p)
	go_domdocument := &CDomdocumentT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_domdocument, func(g *CDomdocumentT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_domdocument != nil {
			Tracef(unsafe.Pointer(g.pc_domdocument), "T134.2:")
			BaseRelease(g.pc_domdocument)
		}
	})

	return go_domdocument
}

// *C.cef_domdocument_t has refCounted interface
func (domdocument *CDomdocumentT) HasOneRef() bool {
	return BaseHasOneRef(domdocument.pc_domdocument)
}

func (p *cCDomdocumentT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (domdocument *CDomdocumentT) Unref() (ret bool) {
	if domdocument == nil {
		return
	}
	if domdocument.beUnrefed == byApp {
		ret = BaseRelease(domdocument.pc_domdocument)
		domdocument.beUnrefed = unrefed
	}
	domdocument.pc_domdocument = nil
	return ret
}

///
// Returns the document type.
///
func (self *CDomdocumentT) GetType() (ret CDomDocumentTypeT) {

	cRet := C.cefingo_domdocument_get_type((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = CDomDocumentTypeT(cRet) // return GoObj
	return ret
}

///
// Returns the root document node.
///
func (self *CDomdocumentT) GetDocument() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_document((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the BODY node of an HTML document.
///
func (self *CDomdocumentT) GetBody() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_body((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the HEAD node of an HTML document.
///
func (self *CDomdocumentT) GetHead() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_head((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the title of an HTML document.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetTitle() (ret string) {

	cRet := C.cefingo_domdocument_get_title((*C.cef_domdocument_t)(self.pc_domdocument))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the document element with the specified ID value.
///
func (self *CDomdocumentT) GetElementById(
	id string,
) (ret *CDomnodeT) {
	c_id := create_cef_string(id)

	cRet := C.cefingo_domdocument_get_element_by_id((*C.cef_domdocument_t)(self.pc_domdocument), c_id.p_cef_string_t)

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the node that currently has keyboard focus.
///
func (self *CDomdocumentT) GetFocusedNode() (ret *CDomnodeT) {

	cRet := C.cefingo_domdocument_get_focused_node((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if a portion of the document is selected.
///
func (self *CDomdocumentT) HasSelection() (ret bool) {

	cRet := C.cefingo_domdocument_has_selection((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = cRet == 1
	return ret
}

///
// Returns the selection offset within the start node.
///
func (self *CDomdocumentT) GetSelectionStartOffset() (ret bool) {

	cRet := C.cefingo_domdocument_get_selection_start_offset((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = cRet == 1
	return ret
}

///
// Returns the selection offset within the end node.
///
func (self *CDomdocumentT) GetSelectionEndOffset() (ret bool) {

	cRet := C.cefingo_domdocument_get_selection_end_offset((*C.cef_domdocument_t)(self.pc_domdocument))

	ret = cRet == 1
	return ret
}

///
// Returns the contents of this selection as markup.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetSelectionAsMarkup() (ret string) {

	cRet := C.cefingo_domdocument_get_selection_as_markup((*C.cef_domdocument_t)(self.pc_domdocument))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the contents of this selection as text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetSelectionAsText() (ret string) {

	cRet := C.cefingo_domdocument_get_selection_as_text((*C.cef_domdocument_t)(self.pc_domdocument))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the base URL for the document.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetBaseUrl() (ret string) {

	cRet := C.cefingo_domdocument_get_base_url((*C.cef_domdocument_t)(self.pc_domdocument))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a complete URL based on the document base URL and the specified
// partial URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomdocumentT) GetCompleteUrl(
	partialURL string,
) (ret string) {
	c_partialURL := create_cef_string(partialURL)

	cRet := C.cefingo_domdocument_get_complete_url((*C.cef_domdocument_t)(self.pc_domdocument), c_partialURL.p_cef_string_t)

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Structure used to represent a DOM node. The functions of this structure
// should only be called on the render process main thread.
///

type cCDomnodeT C.cef_domnode_t

// Go type for cef_domnode_t
type CDomnodeT struct {
	noCopy     noCopy
	pc_domnode *cCDomnodeT
	beUnrefed  unrefedBy
}

func (p *CDomnodeT) Pass() (ret *CDomnodeT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDomnodeT((*C.cef_domnode_t)(p.pc_domnode), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDomnodeT) NewRef() (newP *CDomnodeT) {
	if self == nil {
		return newP
	}
	gop := self.pc_domnode
	BaseAddRef(gop)
	newP = newCDomnodeT((*C.cef_domnode_t)(gop), byApp)
	return newP
}

// Go type CDomnodeT wraps cef type *C.cef_domnode_t
func newCDomnodeT(p *C.cef_domnode_t, unrefedBy unrefedBy) *CDomnodeT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T135.1:")
	pc := (*cCDomnodeT)(p)
	go_domnode := &CDomnodeT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_domnode, func(g *CDomnodeT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_domnode != nil {
			Tracef(unsafe.Pointer(g.pc_domnode), "T135.2:")
			BaseRelease(g.pc_domnode)
		}
	})

	return go_domnode
}

// *C.cef_domnode_t has refCounted interface
func (domnode *CDomnodeT) HasOneRef() bool {
	return BaseHasOneRef(domnode.pc_domnode)
}

func (p *cCDomnodeT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (domnode *CDomnodeT) Unref() (ret bool) {
	if domnode == nil {
		return
	}
	if domnode.beUnrefed == byApp {
		ret = BaseRelease(domnode.pc_domnode)
		domnode.beUnrefed = unrefed
	}
	domnode.pc_domnode = nil
	return ret
}

///
// Returns the type for this node.
///
func (self *CDomnodeT) GetType() (ret CDomNodeTypeT) {

	cRet := C.cefingo_domnode_get_type((*C.cef_domnode_t)(self.pc_domnode))

	ret = CDomNodeTypeT(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if this is a text node.
///
func (self *CDomnodeT) IsText() (ret bool) {

	cRet := C.cefingo_domnode_is_text((*C.cef_domnode_t)(self.pc_domnode))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is an element node.
///
func (self *CDomnodeT) IsElement() (ret bool) {

	cRet := C.cefingo_domnode_is_element((*C.cef_domnode_t)(self.pc_domnode))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is an editable node.
///
func (self *CDomnodeT) IsEditable() (ret bool) {

	cRet := C.cefingo_domnode_is_editable((*C.cef_domnode_t)(self.pc_domnode))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is a form control element node.
///
func (self *CDomnodeT) IsFormControlElement() (ret bool) {

	cRet := C.cefingo_domnode_is_form_control_element((*C.cef_domnode_t)(self.pc_domnode))

	ret = cRet == 1
	return ret
}

///
// Returns the type of this form control element node.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetFormControlElementType() (ret string) {

	cRet := C.cefingo_domnode_get_form_control_element_type((*C.cef_domnode_t)(self.pc_domnode))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CDomnodeT) IsSame(
	that *CDomnodeT,
) (ret bool) {
	var goTmpthat *C.cef_domnode_t
	if that != nil {
		BaseAddRef(that.pc_domnode)
		goTmpthat = (*C.cef_domnode_t)(that.pc_domnode)
	}

	cRet := C.cefingo_domnode_is_same((*C.cef_domnode_t)(self.pc_domnode), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns the name of this node.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetName() (ret string) {

	cRet := C.cefingo_domnode_get_name((*C.cef_domnode_t)(self.pc_domnode))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the value of this node.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetValue() (ret string) {

	cRet := C.cefingo_domnode_get_value((*C.cef_domnode_t)(self.pc_domnode))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the value of this node. Returns true (1) on success.
///
func (self *CDomnodeT) SetValue(
	value string,
) (ret bool) {
	c_value := create_cef_string(value)

	cRet := C.cefingo_domnode_set_value((*C.cef_domnode_t)(self.pc_domnode), c_value.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the contents of this node as markup.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetAsMarkup() (ret string) {

	cRet := C.cefingo_domnode_get_as_markup((*C.cef_domnode_t)(self.pc_domnode))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the document associated with this node.
///
func (self *CDomnodeT) GetDocument() (ret *CDomdocumentT) {

	cRet := C.cefingo_domnode_get_document((*C.cef_domnode_t)(self.pc_domnode))

	ret = newCDomdocumentT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the parent node.
///
func (self *CDomnodeT) GetParent() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_parent((*C.cef_domnode_t)(self.pc_domnode))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the previous sibling node.
///
func (self *CDomnodeT) GetPreviousSibling() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_previous_sibling((*C.cef_domnode_t)(self.pc_domnode))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the next sibling node.
///
func (self *CDomnodeT) GetNextSibling() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_next_sibling((*C.cef_domnode_t)(self.pc_domnode))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if this node has child nodes.
///
func (self *CDomnodeT) HasChildren() (ret bool) {

	cRet := C.cefingo_domnode_has_children((*C.cef_domnode_t)(self.pc_domnode))

	ret = cRet == 1
	return ret
}

///
// Return the first child node.
///
func (self *CDomnodeT) GetFirstChild() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_first_child((*C.cef_domnode_t)(self.pc_domnode))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the last child node.
///
func (self *CDomnodeT) GetLastChild() (ret *CDomnodeT) {

	cRet := C.cefingo_domnode_get_last_child((*C.cef_domnode_t)(self.pc_domnode))

	ret = newCDomnodeT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the tag name of this element.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetElementTagName() (ret string) {

	cRet := C.cefingo_domnode_get_element_tag_name((*C.cef_domnode_t)(self.pc_domnode))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this element has attributes.
///
func (self *CDomnodeT) HasElementAttributes() (ret bool) {

	cRet := C.cefingo_domnode_has_element_attributes((*C.cef_domnode_t)(self.pc_domnode))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this element has an attribute named |attrName|.
///
func (self *CDomnodeT) HasElementAttribute(
	attrName string,
) (ret bool) {
	c_attrName := create_cef_string(attrName)

	cRet := C.cefingo_domnode_has_element_attribute((*C.cef_domnode_t)(self.pc_domnode), c_attrName.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the element attribute named |attrName|.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetElementAttribute(
	attrName string,
) (ret string) {
	c_attrName := create_cef_string(attrName)

	cRet := C.cefingo_domnode_get_element_attribute((*C.cef_domnode_t)(self.pc_domnode), c_attrName.p_cef_string_t)

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a map of all element attributes.
///
func (self *CDomnodeT) GetElementAttributes(
	attrMap CStringMapT,
) {

	C.cefingo_domnode_get_element_attributes((*C.cef_domnode_t)(self.pc_domnode), (C.cef_string_map_t)(attrMap))

}

///
// Set the value for the element attribute named |attrName|. Returns true (1)
// on success.
///
func (self *CDomnodeT) SetElementAttribute(
	attrName string,
	value string,
) (ret bool) {
	c_attrName := create_cef_string(attrName)
	c_value := create_cef_string(value)

	cRet := C.cefingo_domnode_set_element_attribute((*C.cef_domnode_t)(self.pc_domnode), c_attrName.p_cef_string_t, c_value.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the inner text of the element.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDomnodeT) GetElementInnerText() (ret string) {

	cRet := C.cefingo_domnode_get_element_inner_text((*C.cef_domnode_t)(self.pc_domnode))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the bounds of the element.
///
func (self *CDomnodeT) GetElementBounds() (ret CRectT) {

	cRet := C.cefingo_domnode_get_element_bounds((*C.cef_domnode_t)(self.pc_domnode))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

// cef_download_handler_capi.h, include/capi/cef_download_handler_capi.h:69:3,

///
// Callback structure used to asynchronously continue a download.
///

type cCBeforeDownloadCallbackT C.cef_before_download_callback_t

// Go type for cef_before_download_callback_t
type CBeforeDownloadCallbackT struct {
	noCopy                      noCopy
	pc_before_download_callback *cCBeforeDownloadCallbackT
	beUnrefed                   unrefedBy
}

func (p *CBeforeDownloadCallbackT) Pass() (ret *CBeforeDownloadCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBeforeDownloadCallbackT((*C.cef_before_download_callback_t)(p.pc_before_download_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBeforeDownloadCallbackT) NewRef() (newP *CBeforeDownloadCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_before_download_callback
	BaseAddRef(gop)
	newP = newCBeforeDownloadCallbackT((*C.cef_before_download_callback_t)(gop), byApp)
	return newP
}

// Go type CBeforeDownloadCallbackT wraps cef type *C.cef_before_download_callback_t
func newCBeforeDownloadCallbackT(p *C.cef_before_download_callback_t, unrefedBy unrefedBy) *CBeforeDownloadCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T136.1:")
	pc := (*cCBeforeDownloadCallbackT)(p)
	go_before_download_callback := &CBeforeDownloadCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_before_download_callback, func(g *CBeforeDownloadCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_before_download_callback != nil {
			Tracef(unsafe.Pointer(g.pc_before_download_callback), "T136.2:")
			BaseRelease(g.pc_before_download_callback)
		}
	})

	return go_before_download_callback
}

// *C.cef_before_download_callback_t has refCounted interface
func (before_download_callback *CBeforeDownloadCallbackT) HasOneRef() bool {
	return BaseHasOneRef(before_download_callback.pc_before_download_callback)
}

func (p *cCBeforeDownloadCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (before_download_callback *CBeforeDownloadCallbackT) Unref() (ret bool) {
	if before_download_callback == nil {
		return
	}
	if before_download_callback.beUnrefed == byApp {
		ret = BaseRelease(before_download_callback.pc_before_download_callback)
		before_download_callback.beUnrefed = unrefed
	}
	before_download_callback.pc_before_download_callback = nil
	return ret
}

///
// Call to continue the download. Set |download_path| to the full file path
// for the download including the file name or leave blank to use the
// suggested name and the default temp directory. Set |show_dialog| to true
// (1) if you do wish to show the default &quot;Save As&quot; dialog.
///
func (self *CBeforeDownloadCallbackT) Cont(
	download_path string,
	show_dialog int,
) {
	c_download_path := create_cef_string(download_path)

	C.cefingo_before_download_callback_cont((*C.cef_before_download_callback_t)(self.pc_before_download_callback), c_download_path.p_cef_string_t, (C.int)(show_dialog))

}

///
// Callback structure used to asynchronously cancel a download.
///

type cCDownloadItemCallbackT C.cef_download_item_callback_t

// Go type for cef_download_item_callback_t
type CDownloadItemCallbackT struct {
	noCopy                    noCopy
	pc_download_item_callback *cCDownloadItemCallbackT
	beUnrefed                 unrefedBy
}

func (p *CDownloadItemCallbackT) Pass() (ret *CDownloadItemCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDownloadItemCallbackT((*C.cef_download_item_callback_t)(p.pc_download_item_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDownloadItemCallbackT) NewRef() (newP *CDownloadItemCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_download_item_callback
	BaseAddRef(gop)
	newP = newCDownloadItemCallbackT((*C.cef_download_item_callback_t)(gop), byApp)
	return newP
}

// Go type CDownloadItemCallbackT wraps cef type *C.cef_download_item_callback_t
func newCDownloadItemCallbackT(p *C.cef_download_item_callback_t, unrefedBy unrefedBy) *CDownloadItemCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T137.1:")
	pc := (*cCDownloadItemCallbackT)(p)
	go_download_item_callback := &CDownloadItemCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_download_item_callback, func(g *CDownloadItemCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_download_item_callback != nil {
			Tracef(unsafe.Pointer(g.pc_download_item_callback), "T137.2:")
			BaseRelease(g.pc_download_item_callback)
		}
	})

	return go_download_item_callback
}

// *C.cef_download_item_callback_t has refCounted interface
func (download_item_callback *CDownloadItemCallbackT) HasOneRef() bool {
	return BaseHasOneRef(download_item_callback.pc_download_item_callback)
}

func (p *cCDownloadItemCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (download_item_callback *CDownloadItemCallbackT) Unref() (ret bool) {
	if download_item_callback == nil {
		return
	}
	if download_item_callback.beUnrefed == byApp {
		ret = BaseRelease(download_item_callback.pc_download_item_callback)
		download_item_callback.beUnrefed = unrefed
	}
	download_item_callback.pc_download_item_callback = nil
	return ret
}

///
// Call to cancel the download.
///
func (self *CDownloadItemCallbackT) Cancel() {

	C.cefingo_download_item_callback_cancel((*C.cef_download_item_callback_t)(self.pc_download_item_callback))

}

///
// Call to pause the download.
///
func (self *CDownloadItemCallbackT) Pause() {

	C.cefingo_download_item_callback_pause((*C.cef_download_item_callback_t)(self.pc_download_item_callback))

}

///
// Call to resume the download.
///
func (self *CDownloadItemCallbackT) Resume() {

	C.cefingo_download_item_callback_resume((*C.cef_download_item_callback_t)(self.pc_download_item_callback))

}

///
// Structure used to handle file downloads. The functions of this structure will
// called on the browser process UI thread.
///

type cCDownloadHandlerT C.cef_download_handler_t

// Go type for cef_download_handler_t
type CDownloadHandlerT struct {
	noCopy              noCopy
	pc_download_handler *cCDownloadHandlerT
	beUnrefed           unrefedBy
}

func (p *CDownloadHandlerT) Pass() (ret *CDownloadHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDownloadHandlerT((*C.cef_download_handler_t)(p.pc_download_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDownloadHandlerT) NewRef() (newP *CDownloadHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_download_handler
	BaseAddRef(gop)
	newP = newCDownloadHandlerT((*C.cef_download_handler_t)(gop), byApp)
	return newP
}

// Go type CDownloadHandlerT wraps cef type *C.cef_download_handler_t
func newCDownloadHandlerT(p *C.cef_download_handler_t, unrefedBy unrefedBy) *CDownloadHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T138.1:")
	pc := (*cCDownloadHandlerT)(p)
	go_download_handler := &CDownloadHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_download_handler, func(g *CDownloadHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_download_handler != nil {
			Tracef(unsafe.Pointer(g.pc_download_handler), "T138.2:")
			BaseRelease(g.pc_download_handler)
		}
	})

	return go_download_handler
}

// *C.cef_download_handler_t has refCounted interface
func (download_handler *CDownloadHandlerT) HasOneRef() bool {
	return BaseHasOneRef(download_handler.pc_download_handler)
}

func (p *cCDownloadHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (download_handler *CDownloadHandlerT) Unref() (ret bool) {
	if download_handler == nil {
		return
	}
	if download_handler.beUnrefed == byApp {
		ret = BaseRelease(download_handler.pc_download_handler)
		download_handler.beUnrefed = unrefed
	}
	download_handler.pc_download_handler = nil
	return ret
}

///
// Called before a download begins in response to a user-initiated action
// (e.g. alt + link click or link click that returns a `Content-Disposition:
// attachment` response from the server). |url| is the target download URL and
// |request_function| is the target function (GET, POST, etc). Return true (1)
// to proceed with the download or false (0) to cancel the download.
///
type CanDownloadHandler interface {
	CanDownload(
		self *CDownloadHandlerT,
		browser *CBrowserT,
		url string,
		request_method string,
	) (ret bool)
}

///
// Called before a download begins. |suggested_name| is the suggested name for
// the download file. By default the download will be canceled. Execute
// |callback| either asynchronously or in this function to continue the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
type OnBeforeDownloadHandler interface {
	OnBeforeDownload(
		self *CDownloadHandlerT,
		browser *CBrowserT,
		download_item *CDownloadItemT,
		suggested_name string,
		callback *CBeforeDownloadCallbackT,
	)
}

///
// Called when a download&#39;s status or progress information has been updated.
// This may be called multiple times before and after on_before_download().
// Execute |callback| either asynchronously or in this function to cancel the
// download if desired. Do not keep a reference to |download_item| outside of
// this function.
///
type OnDownloadUpdatedHandler interface {
	OnDownloadUpdated(
		self *CDownloadHandlerT,
		browser *CBrowserT,
		download_item *CDownloadItemT,
		callback *CDownloadItemCallbackT,
	)
}

var download_handler_handlers = struct {
	handler                     map[*cCDownloadHandlerT]interface{}
	can_download_handler        map[*cCDownloadHandlerT]CanDownloadHandler
	on_before_download_handler  map[*cCDownloadHandlerT]OnBeforeDownloadHandler
	on_download_updated_handler map[*cCDownloadHandlerT]OnDownloadUpdatedHandler
}{
	map[*cCDownloadHandlerT]interface{}{},
	map[*cCDownloadHandlerT]CanDownloadHandler{},
	map[*cCDownloadHandlerT]OnBeforeDownloadHandler{},
	map[*cCDownloadHandlerT]OnDownloadUpdatedHandler{},
}

// allocCDownloadHandlerT allocates CDownloadHandlerT and construct it
func allocCDownloadHandlerT() *CDownloadHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_download_handler_wrapper_t, "T138.3:")
	cefp := C.cefingo_construct_download_handler((*C.cefingo_download_handler_wrapper_t)(up))
	cgop := (*cCDownloadHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_download_handler_t itself in DeassocFunc,
		// or cef_download_handler_t is never GCed.
		Tracef(up, "T138.4:")
		unbindAllCDownloadHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCDownloadHandlerT(cefp, byApp)
}

// NewCDownloadHandlerT allocates CDownloadHandlerT, construct and bind it
func NewCDownloadHandlerT(a interface{}) *CDownloadHandlerT {
	return allocCDownloadHandlerT().bind(a)
}

func (download_handler *CDownloadHandlerT) bind(a interface{}) *CDownloadHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := download_handler.pc_download_handler
	download_handler_handlers.handler[cp] = a

	if h, ok := a.(CanDownloadHandler); ok {
		download_handler_handlers.can_download_handler[cp] = h
		noBind = false
	} else {
		delete(download_handler_handlers.can_download_handler, cp)
	}

	if h, ok := a.(OnBeforeDownloadHandler); ok {
		download_handler_handlers.on_before_download_handler[cp] = h
		noBind = false
	} else {
		delete(download_handler_handlers.on_before_download_handler, cp)
	}

	if h, ok := a.(OnDownloadUpdatedHandler); ok {
		download_handler_handlers.on_download_updated_handler[cp] = h
		noBind = false
	} else {
		delete(download_handler_handlers.on_download_updated_handler, cp)
	}

	if noBind {
		Panicln("F229: *CDownloadHandlerT No bind")
	}
	return download_handler
}

func unbindAllCDownloadHandlerT(cp *cCDownloadHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := download_handler.pc_download_handler
	delete(download_handler_handlers.handler, cp)

	delete(download_handler_handlers.can_download_handler, cp)
	delete(download_handler_handlers.on_before_download_handler, cp)
	delete(download_handler_handlers.on_download_updated_handler, cp)
}

func (download_handler *CDownloadHandlerT) UnbindAll() {
	unbindAllCDownloadHandlerT(download_handler.pc_download_handler)
	download_handler.Unref()
}

func (download_handler *CDownloadHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := download_handler.pc_download_handler
	return download_handler_handlers.handler[cp]
}

// cef_download_item_capi.h, include/capi/cef_download_item_capi.h:156:3,

///
// Structure used to represent a download item.
///

type cCDownloadItemT C.cef_download_item_t

// Go type for cef_download_item_t
type CDownloadItemT struct {
	noCopy           noCopy
	pc_download_item *cCDownloadItemT
	beUnrefed        unrefedBy
}

func (p *CDownloadItemT) Pass() (ret *CDownloadItemT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDownloadItemT((*C.cef_download_item_t)(p.pc_download_item), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDownloadItemT) NewRef() (newP *CDownloadItemT) {
	if self == nil {
		return newP
	}
	gop := self.pc_download_item
	BaseAddRef(gop)
	newP = newCDownloadItemT((*C.cef_download_item_t)(gop), byApp)
	return newP
}

// Go type CDownloadItemT wraps cef type *C.cef_download_item_t
func newCDownloadItemT(p *C.cef_download_item_t, unrefedBy unrefedBy) *CDownloadItemT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T139.1:")
	pc := (*cCDownloadItemT)(p)
	go_download_item := &CDownloadItemT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_download_item, func(g *CDownloadItemT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_download_item != nil {
			Tracef(unsafe.Pointer(g.pc_download_item), "T139.2:")
			BaseRelease(g.pc_download_item)
		}
	})

	return go_download_item
}

// *C.cef_download_item_t has refCounted interface
func (download_item *CDownloadItemT) HasOneRef() bool {
	return BaseHasOneRef(download_item.pc_download_item)
}

func (p *cCDownloadItemT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (download_item *CDownloadItemT) Unref() (ret bool) {
	if download_item == nil {
		return
	}
	if download_item.beUnrefed == byApp {
		ret = BaseRelease(download_item.pc_download_item)
		download_item.beUnrefed = unrefed
	}
	download_item.pc_download_item = nil
	return ret
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CDownloadItemT) IsValid() (ret bool) {

	cRet := C.cefingo_download_item_is_valid((*C.cef_download_item_t)(self.pc_download_item))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the download is in progress.
///
func (self *CDownloadItemT) IsInProgress() (ret bool) {

	cRet := C.cefingo_download_item_is_in_progress((*C.cef_download_item_t)(self.pc_download_item))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the download is complete.
///
func (self *CDownloadItemT) IsComplete() (ret bool) {

	cRet := C.cefingo_download_item_is_complete((*C.cef_download_item_t)(self.pc_download_item))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the download has been canceled or interrupted.
///
func (self *CDownloadItemT) IsCanceled() (ret bool) {

	cRet := C.cefingo_download_item_is_canceled((*C.cef_download_item_t)(self.pc_download_item))

	ret = cRet == 1
	return ret
}

///
// Returns a simple speed estimate in bytes/s.
///
func (self *CDownloadItemT) GetCurrentSpeed() (ret int64) {

	cRet := C.cefingo_download_item_get_current_speed((*C.cef_download_item_t)(self.pc_download_item))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the rough percent complete or -1 if the receive total size is
// unknown.
///
func (self *CDownloadItemT) GetPercentComplete() (ret bool) {

	cRet := C.cefingo_download_item_get_percent_complete((*C.cef_download_item_t)(self.pc_download_item))

	ret = cRet == 1
	return ret
}

///
// Returns the total number of bytes.
///
func (self *CDownloadItemT) GetTotalBytes() (ret int64) {

	cRet := C.cefingo_download_item_get_total_bytes((*C.cef_download_item_t)(self.pc_download_item))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the number of received bytes.
///
func (self *CDownloadItemT) GetReceivedBytes() (ret int64) {

	cRet := C.cefingo_download_item_get_received_bytes((*C.cef_download_item_t)(self.pc_download_item))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the time that the download started.
///
func (self *CDownloadItemT) GetStartTime() (ret CTimeT) {

	cRet := C.cefingo_download_item_get_start_time((*C.cef_download_item_t)(self.pc_download_item))

	ret = (CTimeT)(cRet) // return GoObj
	return ret
}

///
// Returns the time that the download ended.
///
func (self *CDownloadItemT) GetEndTime() (ret CTimeT) {

	cRet := C.cefingo_download_item_get_end_time((*C.cef_download_item_t)(self.pc_download_item))

	ret = (CTimeT)(cRet) // return GoObj
	return ret
}

///
// Returns the full path to the downloaded or downloading file.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetFullPath() (ret string) {

	cRet := C.cefingo_download_item_get_full_path((*C.cef_download_item_t)(self.pc_download_item))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the unique identifier for this download.
///
func (self *CDownloadItemT) GetId() (ret uint32) {

	cRet := C.cefingo_download_item_get_id((*C.cef_download_item_t)(self.pc_download_item))

	ret = (uint32)(cRet) // return GoObj
	return ret
}

///
// Returns the URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetUrl() (ret string) {

	cRet := C.cefingo_download_item_get_url((*C.cef_download_item_t)(self.pc_download_item))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the original URL before any redirections.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetOriginalUrl() (ret string) {

	cRet := C.cefingo_download_item_get_original_url((*C.cef_download_item_t)(self.pc_download_item))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the suggested file name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetSuggestedFileName() (ret string) {

	cRet := C.cefingo_download_item_get_suggested_file_name((*C.cef_download_item_t)(self.pc_download_item))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the content disposition.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetContentDisposition() (ret string) {

	cRet := C.cefingo_download_item_get_content_disposition((*C.cef_download_item_t)(self.pc_download_item))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the mime type.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDownloadItemT) GetMimeType() (ret string) {

	cRet := C.cefingo_download_item_get_mime_type((*C.cef_download_item_t)(self.pc_download_item))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

// cef_drag_data_capi.h, include/capi/cef_drag_data_capi.h:222:3,

///
// Structure used to represent drag data. The functions of this structure may be
// called on any thread.
///

type cCDragDataT C.cef_drag_data_t

// Go type for cef_drag_data_t
type CDragDataT struct {
	noCopy       noCopy
	pc_drag_data *cCDragDataT
	beUnrefed    unrefedBy
}

func (p *CDragDataT) Pass() (ret *CDragDataT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDragDataT((*C.cef_drag_data_t)(p.pc_drag_data), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDragDataT) NewRef() (newP *CDragDataT) {
	if self == nil {
		return newP
	}
	gop := self.pc_drag_data
	BaseAddRef(gop)
	newP = newCDragDataT((*C.cef_drag_data_t)(gop), byApp)
	return newP
}

// Go type CDragDataT wraps cef type *C.cef_drag_data_t
func newCDragDataT(p *C.cef_drag_data_t, unrefedBy unrefedBy) *CDragDataT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T140.1:")
	pc := (*cCDragDataT)(p)
	go_drag_data := &CDragDataT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_drag_data, func(g *CDragDataT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_drag_data != nil {
			Tracef(unsafe.Pointer(g.pc_drag_data), "T140.2:")
			BaseRelease(g.pc_drag_data)
		}
	})

	return go_drag_data
}

// *C.cef_drag_data_t has refCounted interface
func (drag_data *CDragDataT) HasOneRef() bool {
	return BaseHasOneRef(drag_data.pc_drag_data)
}

func (p *cCDragDataT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (drag_data *CDragDataT) Unref() (ret bool) {
	if drag_data == nil {
		return
	}
	if drag_data.beUnrefed == byApp {
		ret = BaseRelease(drag_data.pc_drag_data)
		drag_data.beUnrefed = unrefed
	}
	drag_data.pc_drag_data = nil
	return ret
}

///
// Returns a copy of the current object.
///
func (self *CDragDataT) Clone() (ret *CDragDataT) {

	cRet := C.cefingo_drag_data_clone((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = newCDragDataT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if this object is read-only.
///
func (self *CDragDataT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_drag_data_is_read_only((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the drag data is a link.
///
func (self *CDragDataT) IsLink() (ret bool) {

	cRet := C.cefingo_drag_data_is_link((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the drag data is a text or html fragment.
///
func (self *CDragDataT) IsFragment() (ret bool) {

	cRet := C.cefingo_drag_data_is_fragment((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the drag data is a file.
///
func (self *CDragDataT) IsFile() (ret bool) {

	cRet := C.cefingo_drag_data_is_file((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = cRet == 1
	return ret
}

///
// Return the link URL that is being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetLinkUrl() (ret string) {

	cRet := C.cefingo_drag_data_get_link_url((*C.cef_drag_data_t)(self.pc_drag_data))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the title associated with the link being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetLinkTitle() (ret string) {

	cRet := C.cefingo_drag_data_get_link_title((*C.cef_drag_data_t)(self.pc_drag_data))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the metadata, if any, associated with the link being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetLinkMetadata() (ret string) {

	cRet := C.cefingo_drag_data_get_link_metadata((*C.cef_drag_data_t)(self.pc_drag_data))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the plain text fragment that is being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFragmentText() (ret string) {

	cRet := C.cefingo_drag_data_get_fragment_text((*C.cef_drag_data_t)(self.pc_drag_data))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the text/html fragment that is being dragged.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFragmentHtml() (ret string) {

	cRet := C.cefingo_drag_data_get_fragment_html((*C.cef_drag_data_t)(self.pc_drag_data))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the base URL that the fragment came from. This value is used for
// resolving relative URLs and may be NULL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFragmentBaseUrl() (ret string) {

	cRet := C.cefingo_drag_data_get_fragment_base_url((*C.cef_drag_data_t)(self.pc_drag_data))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the name of the file being dragged out of the browser window.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDragDataT) GetFileName() (ret string) {

	cRet := C.cefingo_drag_data_get_file_name((*C.cef_drag_data_t)(self.pc_drag_data))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Write the contents of the file being dragged out of the web view into
// |writer|. Returns the number of bytes sent to |writer|. If |writer| is NULL
// this function will return the size of the file contents in bytes. Call
// get_file_name() to get a suggested name for the file.
///
func (self *CDragDataT) GetFileContents(
	writer *CStreamWriterT,
) (ret int64) {
	var goTmpwriter *C.cef_stream_writer_t
	if writer != nil {
		BaseAddRef(writer.pc_stream_writer)
		goTmpwriter = (*C.cef_stream_writer_t)(writer.pc_stream_writer)
	}

	cRet := C.cefingo_drag_data_get_file_contents((*C.cef_drag_data_t)(self.pc_drag_data), goTmpwriter)

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Retrieve the list of file names that are being dragged into the browser
// window.
///
func (self *CDragDataT) GetFileNames(
	names CStringListT,
) (ret bool) {

	cRet := C.cefingo_drag_data_get_file_names((*C.cef_drag_data_t)(self.pc_drag_data), (C.cef_string_list_t)(names))

	ret = cRet == 1
	return ret
}

///
// Set the link URL that is being dragged.
///
func (self *CDragDataT) SetLinkUrl(
	url string,
) {
	c_url := create_cef_string(url)

	C.cefingo_drag_data_set_link_url((*C.cef_drag_data_t)(self.pc_drag_data), c_url.p_cef_string_t)

}

///
// Set the title associated with the link being dragged.
///
func (self *CDragDataT) SetLinkTitle(
	title string,
) {
	c_title := create_cef_string(title)

	C.cefingo_drag_data_set_link_title((*C.cef_drag_data_t)(self.pc_drag_data), c_title.p_cef_string_t)

}

///
// Set the metadata associated with the link being dragged.
///
func (self *CDragDataT) SetLinkMetadata(
	data string,
) {
	c_data := create_cef_string(data)

	C.cefingo_drag_data_set_link_metadata((*C.cef_drag_data_t)(self.pc_drag_data), c_data.p_cef_string_t)

}

///
// Set the plain text fragment that is being dragged.
///
func (self *CDragDataT) SetFragmentText(
	text string,
) {
	c_text := create_cef_string(text)

	C.cefingo_drag_data_set_fragment_text((*C.cef_drag_data_t)(self.pc_drag_data), c_text.p_cef_string_t)

}

///
// Set the text/html fragment that is being dragged.
///
func (self *CDragDataT) SetFragmentHtml(
	html string,
) {
	c_html := create_cef_string(html)

	C.cefingo_drag_data_set_fragment_html((*C.cef_drag_data_t)(self.pc_drag_data), c_html.p_cef_string_t)

}

///
// Set the base URL that the fragment came from.
///
func (self *CDragDataT) SetFragmentBaseUrl(
	base_url string,
) {
	c_base_url := create_cef_string(base_url)

	C.cefingo_drag_data_set_fragment_base_url((*C.cef_drag_data_t)(self.pc_drag_data), c_base_url.p_cef_string_t)

}

///
// Reset the file contents. You should do this before calling
// cef_browser_host_t::DragTargetDragEnter as the web view does not allow us
// to drag in this kind of data.
///
func (self *CDragDataT) ResetFileContents() {

	C.cefingo_drag_data_reset_file_contents((*C.cef_drag_data_t)(self.pc_drag_data))

}

///
// Add a file that is being dragged into the webview.
///
func (self *CDragDataT) AddFile(
	path string,
	display_name string,
) {
	c_path := create_cef_string(path)
	c_display_name := create_cef_string(display_name)

	C.cefingo_drag_data_add_file((*C.cef_drag_data_t)(self.pc_drag_data), c_path.p_cef_string_t, c_display_name.p_cef_string_t)

}

///
// Clear list of filenames.
///
func (self *CDragDataT) ClearFilenames() {

	C.cefingo_drag_data_clear_filenames((*C.cef_drag_data_t)(self.pc_drag_data))

}

///
// Get the image representation of drag data. May return NULL if no image
// representation is available.
///
func (self *CDragDataT) GetImage() (ret *CImageT) {

	cRet := C.cefingo_drag_data_get_image((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = newCImageT(cRet, byApp) // return GoObj
	return ret
}

///
// Get the image hotspot (drag start location relative to image dimensions).
///
func (self *CDragDataT) GetImageHotspot() (ret CPointT) {

	cRet := C.cefingo_drag_data_get_image_hotspot((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = (CPointT)(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if an image representation of drag data is available.
///
func (self *CDragDataT) HasImage() (ret bool) {

	cRet := C.cefingo_drag_data_has_image((*C.cef_drag_data_t)(self.pc_drag_data))

	ret = cRet == 1
	return ret
}

///
// Create a new cef_drag_data_t object.
///
func DragDataCreate() (ret *CDragDataT) {

	cRet := C.cef_drag_data_create()

	ret = newCDragDataT(cRet, byApp) // return GoObj
	return ret
}

// cef_drag_handler_capi.h, include/capi/cef_drag_handler_capi.h:86:3,

///
// Implement this structure to handle events related to dragging. The functions
// of this structure will be called on the UI thread.
///

type cCDragHandlerT C.cef_drag_handler_t

// Go type for cef_drag_handler_t
type CDragHandlerT struct {
	noCopy          noCopy
	pc_drag_handler *cCDragHandlerT
	beUnrefed       unrefedBy
}

func (p *CDragHandlerT) Pass() (ret *CDragHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDragHandlerT((*C.cef_drag_handler_t)(p.pc_drag_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDragHandlerT) NewRef() (newP *CDragHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_drag_handler
	BaseAddRef(gop)
	newP = newCDragHandlerT((*C.cef_drag_handler_t)(gop), byApp)
	return newP
}

// Go type CDragHandlerT wraps cef type *C.cef_drag_handler_t
func newCDragHandlerT(p *C.cef_drag_handler_t, unrefedBy unrefedBy) *CDragHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T141.1:")
	pc := (*cCDragHandlerT)(p)
	go_drag_handler := &CDragHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_drag_handler, func(g *CDragHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_drag_handler != nil {
			Tracef(unsafe.Pointer(g.pc_drag_handler), "T141.2:")
			BaseRelease(g.pc_drag_handler)
		}
	})

	return go_drag_handler
}

// *C.cef_drag_handler_t has refCounted interface
func (drag_handler *CDragHandlerT) HasOneRef() bool {
	return BaseHasOneRef(drag_handler.pc_drag_handler)
}

func (p *cCDragHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (drag_handler *CDragHandlerT) Unref() (ret bool) {
	if drag_handler == nil {
		return
	}
	if drag_handler.beUnrefed == byApp {
		ret = BaseRelease(drag_handler.pc_drag_handler)
		drag_handler.beUnrefed = unrefed
	}
	drag_handler.pc_drag_handler = nil
	return ret
}

///
// Called when an external drag event enters the browser window. |dragData|
// contains the drag event data and |mask| represents the type of drag
// operation. Return false (0) for default drag handling behavior or true (1)
// to cancel the drag event.
///
type OnDragEnterHandler interface {
	OnDragEnter(
		self *CDragHandlerT,
		browser *CBrowserT,
		dragData *CDragDataT,
		mask CDragOperationsMaskT,
	) (ret bool)
}

///
// Called whenever draggable regions for the browser window change. These can
// be specified using the &#39;-webkit-app-region: drag/no-drag&#39; CSS-property. If
// draggable regions are never defined in a document this function will also
// never be called. If the last draggable region is removed from a document
// this function will be called with an NULL vector.
///
type OnDraggableRegionsChangedHandler interface {
	OnDraggableRegionsChanged(
		self *CDragHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		regionsCount int64,
		regions *CDraggableRegionT,
	)
}

var drag_handler_handlers = struct {
	handler                              map[*cCDragHandlerT]interface{}
	on_drag_enter_handler                map[*cCDragHandlerT]OnDragEnterHandler
	on_draggable_regions_changed_handler map[*cCDragHandlerT]OnDraggableRegionsChangedHandler
}{
	map[*cCDragHandlerT]interface{}{},
	map[*cCDragHandlerT]OnDragEnterHandler{},
	map[*cCDragHandlerT]OnDraggableRegionsChangedHandler{},
}

// allocCDragHandlerT allocates CDragHandlerT and construct it
func allocCDragHandlerT() *CDragHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_drag_handler_wrapper_t, "T141.3:")
	cefp := C.cefingo_construct_drag_handler((*C.cefingo_drag_handler_wrapper_t)(up))
	cgop := (*cCDragHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_drag_handler_t itself in DeassocFunc,
		// or cef_drag_handler_t is never GCed.
		Tracef(up, "T141.4:")
		unbindAllCDragHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCDragHandlerT(cefp, byApp)
}

// NewCDragHandlerT allocates CDragHandlerT, construct and bind it
func NewCDragHandlerT(a interface{}) *CDragHandlerT {
	return allocCDragHandlerT().bind(a)
}

func (drag_handler *CDragHandlerT) bind(a interface{}) *CDragHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := drag_handler.pc_drag_handler
	drag_handler_handlers.handler[cp] = a

	if h, ok := a.(OnDragEnterHandler); ok {
		drag_handler_handlers.on_drag_enter_handler[cp] = h
		noBind = false
	} else {
		delete(drag_handler_handlers.on_drag_enter_handler, cp)
	}

	if h, ok := a.(OnDraggableRegionsChangedHandler); ok {
		drag_handler_handlers.on_draggable_regions_changed_handler[cp] = h
		noBind = false
	} else {
		delete(drag_handler_handlers.on_draggable_regions_changed_handler, cp)
	}

	if noBind {
		Panicln("F229: *CDragHandlerT No bind")
	}
	return drag_handler
}

func unbindAllCDragHandlerT(cp *cCDragHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := drag_handler.pc_drag_handler
	delete(drag_handler_handlers.handler, cp)

	delete(drag_handler_handlers.on_drag_enter_handler, cp)
	delete(drag_handler_handlers.on_draggable_regions_changed_handler, cp)
}

func (drag_handler *CDragHandlerT) UnbindAll() {
	unbindAllCDragHandlerT(drag_handler.pc_drag_handler)
	drag_handler.Unref()
}

func (drag_handler *CDragHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := drag_handler.pc_drag_handler
	return drag_handler_handlers.handler[cp]
}

// cef_extension_capi.h, include/capi/cef_extension_capi.h:124:3,

///
// Object representing an extension. Methods may be called on any thread unless
// otherwise indicated.
///

type cCExtensionT C.cef_extension_t

// Go type for cef_extension_t
type CExtensionT struct {
	noCopy       noCopy
	pc_extension *cCExtensionT
	beUnrefed    unrefedBy
}

func (p *CExtensionT) Pass() (ret *CExtensionT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCExtensionT((*C.cef_extension_t)(p.pc_extension), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CExtensionT) NewRef() (newP *CExtensionT) {
	if self == nil {
		return newP
	}
	gop := self.pc_extension
	BaseAddRef(gop)
	newP = newCExtensionT((*C.cef_extension_t)(gop), byApp)
	return newP
}

// Go type CExtensionT wraps cef type *C.cef_extension_t
func newCExtensionT(p *C.cef_extension_t, unrefedBy unrefedBy) *CExtensionT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T142.1:")
	pc := (*cCExtensionT)(p)
	go_extension := &CExtensionT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_extension, func(g *CExtensionT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_extension != nil {
			Tracef(unsafe.Pointer(g.pc_extension), "T142.2:")
			BaseRelease(g.pc_extension)
		}
	})

	return go_extension
}

// *C.cef_extension_t has refCounted interface
func (extension *CExtensionT) HasOneRef() bool {
	return BaseHasOneRef(extension.pc_extension)
}

func (p *cCExtensionT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (extension *CExtensionT) Unref() (ret bool) {
	if extension == nil {
		return
	}
	if extension.beUnrefed == byApp {
		ret = BaseRelease(extension.pc_extension)
		extension.beUnrefed = unrefed
	}
	extension.pc_extension = nil
	return ret
}

///
// Returns the unique extension identifier. This is calculated based on the
// extension public key, if available, or on the extension path. See
// https://developer.chrome.com/extensions/manifest/key for details.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CExtensionT) GetIdentifier() (ret string) {

	cRet := C.cefingo_extension_get_identifier((*C.cef_extension_t)(self.pc_extension))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the absolute path to the extension directory on disk. This value
// will be prefixed with PK_DIR_RESOURCES if a relative path was passed to
// cef_request_context_t::LoadExtension.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CExtensionT) GetPath() (ret string) {

	cRet := C.cefingo_extension_get_path((*C.cef_extension_t)(self.pc_extension))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the extension manifest contents as a cef_dictionary_value_t object.
// See https://developer.chrome.com/extensions/manifest for details.
///
func (self *CExtensionT) GetManifest() (ret *CDictionaryValueT) {

	cRet := C.cefingo_extension_get_manifest((*C.cef_extension_t)(self.pc_extension))

	ret = newCDictionaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if this object is the same extension as |that| object.
// Extensions are considered the same if identifier, path and loader context
// match.
///
func (self *CExtensionT) IsSame(
	that *CExtensionT,
) (ret bool) {
	var goTmpthat *C.cef_extension_t
	if that != nil {
		BaseAddRef(that.pc_extension)
		goTmpthat = (*C.cef_extension_t)(that.pc_extension)
	}

	cRet := C.cefingo_extension_is_same((*C.cef_extension_t)(self.pc_extension), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns the handler for this extension. Will return NULL for internal
// extensions or if no handler was passed to
// cef_request_context_t::LoadExtension.
///
func (self *CExtensionT) GetHandler() (ret *CExtensionHandlerT) {

	cRet := C.cefingo_extension_get_handler((*C.cef_extension_t)(self.pc_extension))

	ret = newCExtensionHandlerT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the request context that loaded this extension. Will return NULL
// for internal extensions or if the extension has been unloaded. See the
// cef_request_context_t::LoadExtension documentation for more information
// about loader contexts. Must be called on the browser process UI thread.
///
func (self *CExtensionT) GetLoaderContext() (ret *CRequestContextT) {

	cRet := C.cefingo_extension_get_loader_context((*C.cef_extension_t)(self.pc_extension))

	ret = newCRequestContextT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if this extension is currently loaded. Must be called on
// the browser process UI thread.
///
func (self *CExtensionT) IsLoaded() (ret bool) {

	cRet := C.cefingo_extension_is_loaded((*C.cef_extension_t)(self.pc_extension))

	ret = cRet == 1
	return ret
}

///
// Unload this extension if it is not an internal extension and is currently
// loaded. Will result in a call to
// cef_extension_handler_t::OnExtensionUnloaded on success.
///
func (self *CExtensionT) Unload() {

	C.cefingo_extension_unload((*C.cef_extension_t)(self.pc_extension))

}

// cef_extension_handler_capi.h, include/capi/cef_extension_handler_capi.h:75:3,

///
// Callback structure used for asynchronous continuation of
// cef_extension_handler_t::GetExtensionResource.
///

type cCGetExtensionResourceCallbackT C.cef_get_extension_resource_callback_t

// Go type for cef_get_extension_resource_callback_t
type CGetExtensionResourceCallbackT struct {
	noCopy                             noCopy
	pc_get_extension_resource_callback *cCGetExtensionResourceCallbackT
	beUnrefed                          unrefedBy
}

func (p *CGetExtensionResourceCallbackT) Pass() (ret *CGetExtensionResourceCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCGetExtensionResourceCallbackT((*C.cef_get_extension_resource_callback_t)(p.pc_get_extension_resource_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CGetExtensionResourceCallbackT) NewRef() (newP *CGetExtensionResourceCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_get_extension_resource_callback
	BaseAddRef(gop)
	newP = newCGetExtensionResourceCallbackT((*C.cef_get_extension_resource_callback_t)(gop), byApp)
	return newP
}

// Go type CGetExtensionResourceCallbackT wraps cef type *C.cef_get_extension_resource_callback_t
func newCGetExtensionResourceCallbackT(p *C.cef_get_extension_resource_callback_t, unrefedBy unrefedBy) *CGetExtensionResourceCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T143.1:")
	pc := (*cCGetExtensionResourceCallbackT)(p)
	go_get_extension_resource_callback := &CGetExtensionResourceCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_get_extension_resource_callback, func(g *CGetExtensionResourceCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_get_extension_resource_callback != nil {
			Tracef(unsafe.Pointer(g.pc_get_extension_resource_callback), "T143.2:")
			BaseRelease(g.pc_get_extension_resource_callback)
		}
	})

	return go_get_extension_resource_callback
}

// *C.cef_get_extension_resource_callback_t has refCounted interface
func (get_extension_resource_callback *CGetExtensionResourceCallbackT) HasOneRef() bool {
	return BaseHasOneRef(get_extension_resource_callback.pc_get_extension_resource_callback)
}

func (p *cCGetExtensionResourceCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (get_extension_resource_callback *CGetExtensionResourceCallbackT) Unref() (ret bool) {
	if get_extension_resource_callback == nil {
		return
	}
	if get_extension_resource_callback.beUnrefed == byApp {
		ret = BaseRelease(get_extension_resource_callback.pc_get_extension_resource_callback)
		get_extension_resource_callback.beUnrefed = unrefed
	}
	get_extension_resource_callback.pc_get_extension_resource_callback = nil
	return ret
}

///
// Continue the request. Read the resource contents from |stream|.
///
func (self *CGetExtensionResourceCallbackT) Cont(
	stream *CStreamReaderT,
) {
	var goTmpstream *C.cef_stream_reader_t
	if stream != nil {
		BaseAddRef(stream.pc_stream_reader)
		goTmpstream = (*C.cef_stream_reader_t)(stream.pc_stream_reader)
	}

	C.cefingo_get_extension_resource_callback_cont((*C.cef_get_extension_resource_callback_t)(self.pc_get_extension_resource_callback), goTmpstream)

}

///
// Cancel the request.
///
func (self *CGetExtensionResourceCallbackT) Cancel() {

	C.cefingo_get_extension_resource_callback_cancel((*C.cef_get_extension_resource_callback_t)(self.pc_get_extension_resource_callback))

}

///
// Implement this structure to handle events related to browser extensions. The
// functions of this structure will be called on the UI thread. See
// cef_request_context_t::LoadExtension for information about extension loading.
///

type cCExtensionHandlerT C.cef_extension_handler_t

// Go type for cef_extension_handler_t
type CExtensionHandlerT struct {
	noCopy               noCopy
	pc_extension_handler *cCExtensionHandlerT
	beUnrefed            unrefedBy
}

func (p *CExtensionHandlerT) Pass() (ret *CExtensionHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCExtensionHandlerT((*C.cef_extension_handler_t)(p.pc_extension_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CExtensionHandlerT) NewRef() (newP *CExtensionHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_extension_handler
	BaseAddRef(gop)
	newP = newCExtensionHandlerT((*C.cef_extension_handler_t)(gop), byApp)
	return newP
}

// Go type CExtensionHandlerT wraps cef type *C.cef_extension_handler_t
func newCExtensionHandlerT(p *C.cef_extension_handler_t, unrefedBy unrefedBy) *CExtensionHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T144.1:")
	pc := (*cCExtensionHandlerT)(p)
	go_extension_handler := &CExtensionHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_extension_handler, func(g *CExtensionHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_extension_handler != nil {
			Tracef(unsafe.Pointer(g.pc_extension_handler), "T144.2:")
			BaseRelease(g.pc_extension_handler)
		}
	})

	return go_extension_handler
}

// *C.cef_extension_handler_t has refCounted interface
func (extension_handler *CExtensionHandlerT) HasOneRef() bool {
	return BaseHasOneRef(extension_handler.pc_extension_handler)
}

func (p *cCExtensionHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (extension_handler *CExtensionHandlerT) Unref() (ret bool) {
	if extension_handler == nil {
		return
	}
	if extension_handler.beUnrefed == byApp {
		ret = BaseRelease(extension_handler.pc_extension_handler)
		extension_handler.beUnrefed = unrefed
	}
	extension_handler.pc_extension_handler = nil
	return ret
}

///
// Called if the cef_request_context_t::LoadExtension request fails. |result|
// will be the error code.
///
type OnExtensionLoadFailedHandler interface {
	OnExtensionLoadFailed(
		self *CExtensionHandlerT,
		result CErrorcodeT,
	)
}

///
// Called if the cef_request_context_t::LoadExtension request succeeds.
// |extension| is the loaded extension.
///
type OnExtensionLoadedHandler interface {
	OnExtensionLoaded(
		self *CExtensionHandlerT,
		extension *CExtensionT,
	)
}

///
// Called after the cef_extension_t::Unload request has completed.
///
type OnExtensionUnloadedHandler interface {
	OnExtensionUnloaded(
		self *CExtensionHandlerT,
		extension *CExtensionT,
	)
}

///
// Called when an extension needs a browser to host a background script
// specified via the &quot;background&quot; manifest key. The browser will have no
// visible window and cannot be displayed. |extension| is the extension that
// is loading the background script. |url| is an internally generated
// reference to an HTML page that will be used to load the background script
// via a &lt;script&gt; src attribute. To allow creation of the browser optionally
// modify |client| and |settings| and return false (0). To cancel creation of
// the browser (and consequently cancel load of the background script) return
// true (1). Successful creation will be indicated by a call to
// cef_life_span_handler_t::OnAfterCreated, and
// cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting
// browser. See https://developer.chrome.com/extensions/event_pages for more
// information about extension background script usage.
///
type OnBeforeBackgroundBrowserHandler interface {
	OnBeforeBackgroundBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		url string,
		client *CClientT,
		settings CBrowserSettingsT,
	) (ret bool, clientOut *CClientT, settingsOut CBrowserSettingsT)
}

///
// Called when an extension API (e.g. chrome.tabs.create) requests creation of
// a new browser. |extension| and |browser| are the source of the API call.
// |active_browser| may optionally be specified via the windowId property or
// returned via the get_active_browser() callback and provides the default
// |client| and |settings| values for the new browser. |index| is the position
// value optionally specified via the index property. |url| is the URL that
// will be loaded in the browser. |active| is true (1) if the new browser
// should be active when opened.  To allow creation of the browser optionally
// modify |windowInfo|, |client| and |settings| and return false (0). To
// cancel creation of the browser return true (1). Successful creation will be
// indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any
// modifications to |windowInfo| will be ignored if |active_browser| is
// wrapped in a cef_browser_view_t.
///
type OnBeforeBrowserHandler interface {
	OnBeforeBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		active_browser *CBrowserT,
		index int,
		url string,
		active int,
		windowInfo CWindowInfoT,
		client *CClientT,
		settings CBrowserSettingsT,
	) (ret bool, windowInfoOut CWindowInfoT, clientOut *CClientT, settingsOut CBrowserSettingsT)
}

///
// Called when no tabId is specified to an extension API call that accepts a
// tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the
// source of the API call. Return the browser that will be acted on by the API
// call or return NULL to act on |browser|. The returned browser must share
// the same cef_request_context_t as |browser|. Incognito browsers should not
// be considered unless the source extension has incognito access enabled, in
// which case |include_incognito| will be true (1).
///
type GetActiveBrowserHandler interface {
	GetActiveBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		include_incognito int,
	) (ret *CBrowserT)
}

///
// Called when the tabId associated with |target_browser| is specified to an
// extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).
// |extension| and |browser| are the source of the API call. Return true (1)
// to allow access of false (0) to deny access. Access to incognito browsers
// should not be allowed unless the source extension has incognito access
// enabled, in which case |include_incognito| will be true (1).
///
type CanAccessBrowserHandler interface {
	CanAccessBrowser(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		include_incognito int,
		target_browser *CBrowserT,
	) (ret bool)
}

///
// Called to retrieve an extension resource that would normally be loaded from
// disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).
// |extension| and |browser| are the source of the resource request. |file| is
// the requested relative file path. To handle the resource request return
// true (1) and execute |callback| either synchronously or asynchronously. For
// the default behavior which reads the resource from the extension directory
// on disk return false (0). Localization substitutions will not be applied to
// resources handled via this function.
///
type GetExtensionResourceHandler interface {
	GetExtensionResource(
		self *CExtensionHandlerT,
		extension *CExtensionT,
		browser *CBrowserT,
		file string,
		callback *CGetExtensionResourceCallbackT,
	) (ret bool)
}

var extension_handler_handlers = struct {
	handler                              map[*cCExtensionHandlerT]interface{}
	on_extension_load_failed_handler     map[*cCExtensionHandlerT]OnExtensionLoadFailedHandler
	on_extension_loaded_handler          map[*cCExtensionHandlerT]OnExtensionLoadedHandler
	on_extension_unloaded_handler        map[*cCExtensionHandlerT]OnExtensionUnloadedHandler
	on_before_background_browser_handler map[*cCExtensionHandlerT]OnBeforeBackgroundBrowserHandler
	on_before_browser_handler            map[*cCExtensionHandlerT]OnBeforeBrowserHandler
	get_active_browser_handler           map[*cCExtensionHandlerT]GetActiveBrowserHandler
	can_access_browser_handler           map[*cCExtensionHandlerT]CanAccessBrowserHandler
	get_extension_resource_handler       map[*cCExtensionHandlerT]GetExtensionResourceHandler
}{
	map[*cCExtensionHandlerT]interface{}{},
	map[*cCExtensionHandlerT]OnExtensionLoadFailedHandler{},
	map[*cCExtensionHandlerT]OnExtensionLoadedHandler{},
	map[*cCExtensionHandlerT]OnExtensionUnloadedHandler{},
	map[*cCExtensionHandlerT]OnBeforeBackgroundBrowserHandler{},
	map[*cCExtensionHandlerT]OnBeforeBrowserHandler{},
	map[*cCExtensionHandlerT]GetActiveBrowserHandler{},
	map[*cCExtensionHandlerT]CanAccessBrowserHandler{},
	map[*cCExtensionHandlerT]GetExtensionResourceHandler{},
}

// allocCExtensionHandlerT allocates CExtensionHandlerT and construct it
func allocCExtensionHandlerT() *CExtensionHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_extension_handler_wrapper_t, "T144.3:")
	cefp := C.cefingo_construct_extension_handler((*C.cefingo_extension_handler_wrapper_t)(up))
	cgop := (*cCExtensionHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_extension_handler_t itself in DeassocFunc,
		// or cef_extension_handler_t is never GCed.
		Tracef(up, "T144.4:")
		unbindAllCExtensionHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCExtensionHandlerT(cefp, byApp)
}

// NewCExtensionHandlerT allocates CExtensionHandlerT, construct and bind it
func NewCExtensionHandlerT(a interface{}) *CExtensionHandlerT {
	return allocCExtensionHandlerT().bind(a)
}

func (extension_handler *CExtensionHandlerT) bind(a interface{}) *CExtensionHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := extension_handler.pc_extension_handler
	extension_handler_handlers.handler[cp] = a

	if h, ok := a.(OnExtensionLoadFailedHandler); ok {
		extension_handler_handlers.on_extension_load_failed_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.on_extension_load_failed_handler, cp)
	}

	if h, ok := a.(OnExtensionLoadedHandler); ok {
		extension_handler_handlers.on_extension_loaded_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.on_extension_loaded_handler, cp)
	}

	if h, ok := a.(OnExtensionUnloadedHandler); ok {
		extension_handler_handlers.on_extension_unloaded_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.on_extension_unloaded_handler, cp)
	}

	if h, ok := a.(OnBeforeBackgroundBrowserHandler); ok {
		extension_handler_handlers.on_before_background_browser_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.on_before_background_browser_handler, cp)
	}

	if h, ok := a.(OnBeforeBrowserHandler); ok {
		extension_handler_handlers.on_before_browser_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.on_before_browser_handler, cp)
	}

	if h, ok := a.(GetActiveBrowserHandler); ok {
		extension_handler_handlers.get_active_browser_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.get_active_browser_handler, cp)
	}

	if h, ok := a.(CanAccessBrowserHandler); ok {
		extension_handler_handlers.can_access_browser_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.can_access_browser_handler, cp)
	}

	if h, ok := a.(GetExtensionResourceHandler); ok {
		extension_handler_handlers.get_extension_resource_handler[cp] = h
		noBind = false
	} else {
		delete(extension_handler_handlers.get_extension_resource_handler, cp)
	}

	if noBind {
		Panicln("F229: *CExtensionHandlerT No bind")
	}
	return extension_handler
}

func unbindAllCExtensionHandlerT(cp *cCExtensionHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := extension_handler.pc_extension_handler
	delete(extension_handler_handlers.handler, cp)

	delete(extension_handler_handlers.on_extension_load_failed_handler, cp)
	delete(extension_handler_handlers.on_extension_loaded_handler, cp)
	delete(extension_handler_handlers.on_extension_unloaded_handler, cp)
	delete(extension_handler_handlers.on_before_background_browser_handler, cp)
	delete(extension_handler_handlers.on_before_browser_handler, cp)
	delete(extension_handler_handlers.get_active_browser_handler, cp)
	delete(extension_handler_handlers.can_access_browser_handler, cp)
	delete(extension_handler_handlers.get_extension_resource_handler, cp)
}

func (extension_handler *CExtensionHandlerT) UnbindAll() {
	unbindAllCExtensionHandlerT(extension_handler.pc_extension_handler)
	extension_handler.Unref()
}

func (extension_handler *CExtensionHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := extension_handler.pc_extension_handler
	return extension_handler_handlers.handler[cp]
}

// cef_file_util_capi.h, include/capi/cef_file_util_capi.h:55:16,

///
// Creates a directory and all parent directories if they don't already exist.
// Returns true (1) on successful creation or if the directory already exists.
// The directory is only readable by the current user. Calling this function on
// the browser process UI or IO threads is not allowed.
///
func CreateDirectory(
	full_path string,
) (ret bool) {
	c_full_path := create_cef_string(full_path)

	cRet := C.cef_create_directory(c_full_path.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Get the temporary directory provided by the system.
//
// WARNING: In general, you should use the temp directory variants below instead
// of this function. Those variants will ensure that the proper permissions are
// set so that other users on the system can't edit them while they're open
// (which could lead to security issues).
///
func GetTempDirectory(
	temp_dir string,
) (ret bool) {
	c_temp_dir := create_cef_string(temp_dir)

	cRet := C.cef_get_temp_directory(c_temp_dir.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Creates a new directory. On Windows if |prefix| is provided the new directory
// name is in the format of "prefixyyyy". Returns true (1) on success and sets
// |new_temp_path| to the full path of the directory that was created. The
// directory is only readable by the current user. Calling this function on the
// browser process UI or IO threads is not allowed.
///
func CreateNewTempDirectory(
	prefix string,
	new_temp_path string,
) (ret bool) {
	c_prefix := create_cef_string(prefix)
	c_new_temp_path := create_cef_string(new_temp_path)

	cRet := C.cef_create_new_temp_directory(c_prefix.p_cef_string_t, c_new_temp_path.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Creates a directory within another directory. Extra characters will be
// appended to |prefix| to ensure that the new directory does not have the same
// name as an existing directory. Returns true (1) on success and sets |new_dir|
// to the full path of the directory that was created. The directory is only
// readable by the current user. Calling this function on the browser process UI
// or IO threads is not allowed.
///
func CreateTempDirectoryInDirectory(
	base_dir string,
	prefix string,
	new_dir string,
) (ret bool) {
	c_base_dir := create_cef_string(base_dir)
	c_prefix := create_cef_string(prefix)
	c_new_dir := create_cef_string(new_dir)

	cRet := C.cef_create_temp_directory_in_directory(c_base_dir.p_cef_string_t, c_prefix.p_cef_string_t, c_new_dir.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the given path exists and is a directory. Calling this
// function on the browser process UI or IO threads is not allowed.
///
func DirectoryExists(
	path string,
) (ret bool) {
	c_path := create_cef_string(path)

	cRet := C.cef_directory_exists(c_path.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Deletes the given path whether it's a file or a directory. If |path| is a
// directory all contents will be deleted.  If |recursive| is true (1) any sub-
// directories and their contents will also be deleted (equivalent to executing
// "rm -rf", so use with caution). On POSIX environments if |path| is a symbolic
// link then only the symlink will be deleted. Returns true (1) on successful
// deletion or if |path| does not exist. Calling this function on the browser
// process UI or IO threads is not allowed.
///
func DeleteFile(
	path string,
	recursive int,
) (ret bool) {
	c_path := create_cef_string(path)

	cRet := C.cef_delete_file(c_path.p_cef_string_t, (C.int)(recursive))

	ret = cRet == 1
	return ret
}

///
// Writes the contents of |src_dir| into a zip archive at |dest_file|. If
// |include_hidden_files| is true (1) files starting with "." will be included.
// Returns true (1) on success.  Calling this function on the browser process UI
// or IO threads is not allowed.
///
func ZipDirectory(
	src_dir string,
	dest_file string,
	include_hidden_files int,
) (ret bool) {
	c_src_dir := create_cef_string(src_dir)
	c_dest_file := create_cef_string(dest_file)

	cRet := C.cef_zip_directory(c_src_dir.p_cef_string_t, c_dest_file.p_cef_string_t, (C.int)(include_hidden_files))

	ret = cRet == 1
	return ret
}

///
// Loads the existing "Certificate Revocation Lists" file that is managed by
// Google Chrome. This file can generally be found in Chrome's User Data
// directory (e.g. "C:\Users\[User]\AppData\Local\Google\Chrome\User Data\" on
// Windows) and is updated periodically by Chrome's component updater service.
// Must be called in the browser process after the context has been initialized.
// See https://dev.chromium.org/Home/chromium-security/crlsets for background.
///
func LoadCrlsetsFile(
	path string,
) {
	c_path := create_cef_string(path)

	C.cef_load_crlsets_file(c_path.p_cef_string_t)

}

// cef_fill_layout_capi.h, include/capi/views/cef_fill_layout_capi.h:59:3,

///
// A simple Layout that causes the associated Panel's one child to be sized to
// match the bounds of its parent. Methods must be called on the browser process
// UI thread unless otherwise indicated.
///

type cCFillLayoutT C.cef_fill_layout_t

// Go type for cef_fill_layout_t
type CFillLayoutT struct {
	noCopy         noCopy
	pc_fill_layout *cCFillLayoutT
	beUnrefed      unrefedBy
}

func (p *CFillLayoutT) Pass() (ret *CFillLayoutT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCFillLayoutT((*C.cef_fill_layout_t)(p.pc_fill_layout), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CFillLayoutT) NewRef() (newP *CFillLayoutT) {
	if self == nil {
		return newP
	}
	gop := self.pc_fill_layout
	BaseAddRef(gop)
	newP = newCFillLayoutT((*C.cef_fill_layout_t)(gop), byApp)
	return newP
}

// Go type CFillLayoutT wraps cef type *C.cef_fill_layout_t
func newCFillLayoutT(p *C.cef_fill_layout_t, unrefedBy unrefedBy) *CFillLayoutT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T145.1:")
	pc := (*cCFillLayoutT)(p)
	go_fill_layout := &CFillLayoutT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_fill_layout, func(g *CFillLayoutT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_fill_layout != nil {
			Tracef(unsafe.Pointer(g.pc_fill_layout), "T145.2:")
			BaseRelease(g.pc_fill_layout)
		}
	})

	return go_fill_layout
}

// *C.cef_fill_layout_t has refCounted interface
func (fill_layout *CFillLayoutT) HasOneRef() bool {
	return BaseHasOneRef(fill_layout.pc_fill_layout)
}

func (p *cCFillLayoutT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (fill_layout *CFillLayoutT) Unref() (ret bool) {
	if fill_layout == nil {
		return
	}
	if fill_layout.beUnrefed == byApp {
		ret = BaseRelease(fill_layout.pc_fill_layout)
		fill_layout.beUnrefed = unrefed
	}
	fill_layout.pc_fill_layout = nil
	return ret
}

// Convert to Base Class Pointer *CLayoutT
func (fill_layout *CFillLayoutT) ToCLayoutT() *CLayoutT {
	p := (*C.cef_layout_t)(unsafe.Pointer(fill_layout.pc_fill_layout))
	BaseAddRef(fill_layout.pc_fill_layout)
	return newCLayoutT(p, byApp)
}

// cef_find_handler_capi.h, include/capi/cef_find_handler_capi.h:76:3,

///
// Implement this structure to handle events related to find results. The
// functions of this structure will be called on the UI thread.
///

type cCFindHandlerT C.cef_find_handler_t

// Go type for cef_find_handler_t
type CFindHandlerT struct {
	noCopy          noCopy
	pc_find_handler *cCFindHandlerT
	beUnrefed       unrefedBy
}

func (p *CFindHandlerT) Pass() (ret *CFindHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCFindHandlerT((*C.cef_find_handler_t)(p.pc_find_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CFindHandlerT) NewRef() (newP *CFindHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_find_handler
	BaseAddRef(gop)
	newP = newCFindHandlerT((*C.cef_find_handler_t)(gop), byApp)
	return newP
}

// Go type CFindHandlerT wraps cef type *C.cef_find_handler_t
func newCFindHandlerT(p *C.cef_find_handler_t, unrefedBy unrefedBy) *CFindHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T146.1:")
	pc := (*cCFindHandlerT)(p)
	go_find_handler := &CFindHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_find_handler, func(g *CFindHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_find_handler != nil {
			Tracef(unsafe.Pointer(g.pc_find_handler), "T146.2:")
			BaseRelease(g.pc_find_handler)
		}
	})

	return go_find_handler
}

// *C.cef_find_handler_t has refCounted interface
func (find_handler *CFindHandlerT) HasOneRef() bool {
	return BaseHasOneRef(find_handler.pc_find_handler)
}

func (p *cCFindHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (find_handler *CFindHandlerT) Unref() (ret bool) {
	if find_handler == nil {
		return
	}
	if find_handler.beUnrefed == byApp {
		ret = BaseRelease(find_handler.pc_find_handler)
		find_handler.beUnrefed = unrefed
	}
	find_handler.pc_find_handler = nil
	return ret
}

///
// Called to report find results returned by cef_browser_host_t::find().
// |identifer| is a unique incremental identifier for the currently active
// search, |count| is the number of matches currently identified,
// |selectionRect| is the location of where the match was found (in window
// coordinates), |activeMatchOrdinal| is the current position in the search
// results, and |finalUpdate| is true (1) if this is the last find
// notification.
///
type OnFindResultHandler interface {
	OnFindResult(
		self *CFindHandlerT,
		browser *CBrowserT,
		identifier int,
		count int,
		selectionRect *CRectT,
		activeMatchOrdinal int,
		finalUpdate int,
	)
}

var find_handler_handlers = struct {
	handler                map[*cCFindHandlerT]interface{}
	on_find_result_handler map[*cCFindHandlerT]OnFindResultHandler
}{
	map[*cCFindHandlerT]interface{}{},
	map[*cCFindHandlerT]OnFindResultHandler{},
}

// allocCFindHandlerT allocates CFindHandlerT and construct it
func allocCFindHandlerT() *CFindHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_find_handler_wrapper_t, "T146.3:")
	cefp := C.cefingo_construct_find_handler((*C.cefingo_find_handler_wrapper_t)(up))
	cgop := (*cCFindHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_find_handler_t itself in DeassocFunc,
		// or cef_find_handler_t is never GCed.
		Tracef(up, "T146.4:")
		unbindAllCFindHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCFindHandlerT(cefp, byApp)
}

// NewCFindHandlerT allocates CFindHandlerT, construct and bind it
func NewCFindHandlerT(a interface{}) *CFindHandlerT {
	return allocCFindHandlerT().bind(a)
}

func (find_handler *CFindHandlerT) bind(a interface{}) *CFindHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := find_handler.pc_find_handler
	find_handler_handlers.handler[cp] = a

	if h, ok := a.(OnFindResultHandler); ok {
		find_handler_handlers.on_find_result_handler[cp] = h
		noBind = false
	} else {
		delete(find_handler_handlers.on_find_result_handler, cp)
	}

	if noBind {
		Panicln("F229: *CFindHandlerT No bind")
	}
	return find_handler
}

func unbindAllCFindHandlerT(cp *cCFindHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := find_handler.pc_find_handler
	delete(find_handler_handlers.handler, cp)

	delete(find_handler_handlers.on_find_result_handler, cp)
}

func (find_handler *CFindHandlerT) UnbindAll() {
	unbindAllCFindHandlerT(find_handler.pc_find_handler)
	find_handler.Unref()
}

func (find_handler *CFindHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := find_handler.pc_find_handler
	return find_handler_handlers.handler[cp]
}

// cef_focus_handler_capi.h, include/capi/cef_focus_handler_capi.h:86:3,

///
// Implement this structure to handle events related to focus. The functions of
// this structure will be called on the UI thread.
///

type cCFocusHandlerT C.cef_focus_handler_t

// Go type for cef_focus_handler_t
type CFocusHandlerT struct {
	noCopy           noCopy
	pc_focus_handler *cCFocusHandlerT
	beUnrefed        unrefedBy
}

func (p *CFocusHandlerT) Pass() (ret *CFocusHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCFocusHandlerT((*C.cef_focus_handler_t)(p.pc_focus_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CFocusHandlerT) NewRef() (newP *CFocusHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_focus_handler
	BaseAddRef(gop)
	newP = newCFocusHandlerT((*C.cef_focus_handler_t)(gop), byApp)
	return newP
}

// Go type CFocusHandlerT wraps cef type *C.cef_focus_handler_t
func newCFocusHandlerT(p *C.cef_focus_handler_t, unrefedBy unrefedBy) *CFocusHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T147.1:")
	pc := (*cCFocusHandlerT)(p)
	go_focus_handler := &CFocusHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_focus_handler, func(g *CFocusHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_focus_handler != nil {
			Tracef(unsafe.Pointer(g.pc_focus_handler), "T147.2:")
			BaseRelease(g.pc_focus_handler)
		}
	})

	return go_focus_handler
}

// *C.cef_focus_handler_t has refCounted interface
func (focus_handler *CFocusHandlerT) HasOneRef() bool {
	return BaseHasOneRef(focus_handler.pc_focus_handler)
}

func (p *cCFocusHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (focus_handler *CFocusHandlerT) Unref() (ret bool) {
	if focus_handler == nil {
		return
	}
	if focus_handler.beUnrefed == byApp {
		ret = BaseRelease(focus_handler.pc_focus_handler)
		focus_handler.beUnrefed = unrefed
	}
	focus_handler.pc_focus_handler = nil
	return ret
}

///
// Called when the browser component is about to loose focus. For instance, if
// focus was on the last HTML element and the user pressed the TAB key. |next|
// will be true (1) if the browser is giving focus to the next component and
// false (0) if the browser is giving focus to the previous component.
///
type OnTakeFocusHandler interface {
	OnTakeFocus(
		self *CFocusHandlerT,
		browser *CBrowserT,
		next int,
	)
}

///
// Called when the browser component is requesting focus. |source| indicates
// where the focus request is originating from. Return false (0) to allow the
// focus to be set or true (1) to cancel setting the focus.
///
type OnSetFocusHandler interface {
	OnSetFocus(
		self *CFocusHandlerT,
		browser *CBrowserT,
		source CFocusSourceT,
	) (ret bool)
}

///
// Called when the browser component has received focus.
///
type OnGotFocusHandler interface {
	OnGotFocus(
		self *CFocusHandlerT,
		browser *CBrowserT,
	)
}

var focus_handler_handlers = struct {
	handler               map[*cCFocusHandlerT]interface{}
	on_take_focus_handler map[*cCFocusHandlerT]OnTakeFocusHandler
	on_set_focus_handler  map[*cCFocusHandlerT]OnSetFocusHandler
	on_got_focus_handler  map[*cCFocusHandlerT]OnGotFocusHandler
}{
	map[*cCFocusHandlerT]interface{}{},
	map[*cCFocusHandlerT]OnTakeFocusHandler{},
	map[*cCFocusHandlerT]OnSetFocusHandler{},
	map[*cCFocusHandlerT]OnGotFocusHandler{},
}

// allocCFocusHandlerT allocates CFocusHandlerT and construct it
func allocCFocusHandlerT() *CFocusHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_focus_handler_wrapper_t, "T147.3:")
	cefp := C.cefingo_construct_focus_handler((*C.cefingo_focus_handler_wrapper_t)(up))
	cgop := (*cCFocusHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_focus_handler_t itself in DeassocFunc,
		// or cef_focus_handler_t is never GCed.
		Tracef(up, "T147.4:")
		unbindAllCFocusHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCFocusHandlerT(cefp, byApp)
}

// NewCFocusHandlerT allocates CFocusHandlerT, construct and bind it
func NewCFocusHandlerT(a interface{}) *CFocusHandlerT {
	return allocCFocusHandlerT().bind(a)
}

func (focus_handler *CFocusHandlerT) bind(a interface{}) *CFocusHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := focus_handler.pc_focus_handler
	focus_handler_handlers.handler[cp] = a

	if h, ok := a.(OnTakeFocusHandler); ok {
		focus_handler_handlers.on_take_focus_handler[cp] = h
		noBind = false
	} else {
		delete(focus_handler_handlers.on_take_focus_handler, cp)
	}

	if h, ok := a.(OnSetFocusHandler); ok {
		focus_handler_handlers.on_set_focus_handler[cp] = h
		noBind = false
	} else {
		delete(focus_handler_handlers.on_set_focus_handler, cp)
	}

	if h, ok := a.(OnGotFocusHandler); ok {
		focus_handler_handlers.on_got_focus_handler[cp] = h
		noBind = false
	} else {
		delete(focus_handler_handlers.on_got_focus_handler, cp)
	}

	if noBind {
		Panicln("F229: *CFocusHandlerT No bind")
	}
	return focus_handler
}

func unbindAllCFocusHandlerT(cp *cCFocusHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := focus_handler.pc_focus_handler
	delete(focus_handler_handlers.handler, cp)

	delete(focus_handler_handlers.on_take_focus_handler, cp)
	delete(focus_handler_handlers.on_set_focus_handler, cp)
	delete(focus_handler_handlers.on_got_focus_handler, cp)
}

func (focus_handler *CFocusHandlerT) UnbindAll() {
	unbindAllCFocusHandlerT(focus_handler.pc_focus_handler)
	focus_handler.Unref()
}

func (focus_handler *CFocusHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := focus_handler.pc_focus_handler
	return focus_handler_handlers.handler[cp]
}

// cef_frame_capi.h, include/capi/cef_frame_capi.h:256:3,

///
// Structure used to represent a frame in the browser window. When used in the
// browser process the functions of this structure may be called on any thread
// unless otherwise indicated in the comments. When used in the render process
// the functions of this structure may only be called on the main thread.
///

type cCFrameT C.cef_frame_t

// Go type for cef_frame_t
type CFrameT struct {
	noCopy    noCopy
	pc_frame  *cCFrameT
	beUnrefed unrefedBy
}

func (p *CFrameT) Pass() (ret *CFrameT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCFrameT((*C.cef_frame_t)(p.pc_frame), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CFrameT) NewRef() (newP *CFrameT) {
	if self == nil {
		return newP
	}
	gop := self.pc_frame
	BaseAddRef(gop)
	newP = newCFrameT((*C.cef_frame_t)(gop), byApp)
	return newP
}

// Go type CFrameT wraps cef type *C.cef_frame_t
func newCFrameT(p *C.cef_frame_t, unrefedBy unrefedBy) *CFrameT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T148.1:")
	pc := (*cCFrameT)(p)
	go_frame := &CFrameT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_frame, func(g *CFrameT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_frame != nil {
			Tracef(unsafe.Pointer(g.pc_frame), "T148.2:")
			BaseRelease(g.pc_frame)
		}
	})

	return go_frame
}

// *C.cef_frame_t has refCounted interface
func (frame *CFrameT) HasOneRef() bool {
	return BaseHasOneRef(frame.pc_frame)
}

func (p *cCFrameT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (frame *CFrameT) Unref() (ret bool) {
	if frame == nil {
		return
	}
	if frame.beUnrefed == byApp {
		ret = BaseRelease(frame.pc_frame)
		frame.beUnrefed = unrefed
	}
	frame.pc_frame = nil
	return ret
}

///
// True if this object is currently attached to a valid frame.
///
func (self *CFrameT) IsValid() (ret bool) {

	cRet := C.cefingo_frame_is_valid((*C.cef_frame_t)(self.pc_frame))

	ret = cRet == 1
	return ret
}

///
// Execute undo in this frame.
///
func (self *CFrameT) Undo() {

	C.cefingo_frame_undo((*C.cef_frame_t)(self.pc_frame))

}

///
// Execute redo in this frame.
///
func (self *CFrameT) Redo() {

	C.cefingo_frame_redo((*C.cef_frame_t)(self.pc_frame))

}

///
// Execute cut in this frame.
///
func (self *CFrameT) Cut() {

	C.cefingo_frame_cut((*C.cef_frame_t)(self.pc_frame))

}

///
// Execute copy in this frame.
///
func (self *CFrameT) Copy() {

	C.cefingo_frame_copy((*C.cef_frame_t)(self.pc_frame))

}

///
// Execute paste in this frame.
///
func (self *CFrameT) Paste() {

	C.cefingo_frame_paste((*C.cef_frame_t)(self.pc_frame))

}

///
// Execute delete in this frame.
///
func (self *CFrameT) Del() {

	C.cefingo_frame_del((*C.cef_frame_t)(self.pc_frame))

}

///
// Execute select all in this frame.
///
func (self *CFrameT) SelectAll() {

	C.cefingo_frame_select_all((*C.cef_frame_t)(self.pc_frame))

}

///
// Save this frame&#39;s HTML source to a temporary file and open it in the
// default text viewing application. This function can only be called from the
// browser process.
///
func (self *CFrameT) ViewSource() {

	C.cefingo_frame_view_source((*C.cef_frame_t)(self.pc_frame))

}

///
// Retrieve this frame&#39;s HTML source as a string sent to the specified
// visitor.
///
func (self *CFrameT) GetSource(
	visitor *CStringVisitorT,
) {
	var goTmpvisitor *C.cef_string_visitor_t
	if visitor != nil {
		BaseAddRef(visitor.pc_string_visitor)
		goTmpvisitor = (*C.cef_string_visitor_t)(visitor.pc_string_visitor)
	}

	C.cefingo_frame_get_source((*C.cef_frame_t)(self.pc_frame), goTmpvisitor)

}

///
// Retrieve this frame&#39;s display text as a string sent to the specified
// visitor.
///
func (self *CFrameT) GetText(
	visitor *CStringVisitorT,
) {
	var goTmpvisitor *C.cef_string_visitor_t
	if visitor != nil {
		BaseAddRef(visitor.pc_string_visitor)
		goTmpvisitor = (*C.cef_string_visitor_t)(visitor.pc_string_visitor)
	}

	C.cefingo_frame_get_text((*C.cef_frame_t)(self.pc_frame), goTmpvisitor)

}

///
// Load the request represented by the |request| object.
//
// WARNING: This function will fail with &quot;bad IPC message&quot; reason
// INVALID_INITIATOR_ORIGIN (213) unless you first navigate to the request
// origin using some other mechanism (LoadURL, link click, etc).
///
func (self *CFrameT) LoadRequest(
	request *CRequestT,
) {
	var goTmprequest *C.cef_request_t
	if request != nil {
		BaseAddRef(request.pc_request)
		goTmprequest = (*C.cef_request_t)(request.pc_request)
	}

	C.cefingo_frame_load_request((*C.cef_frame_t)(self.pc_frame), goTmprequest)

}

///
// Load the specified |url|.
///
func (self *CFrameT) LoadUrl(
	url string,
) {
	c_url := create_cef_string(url)

	C.cefingo_frame_load_url((*C.cef_frame_t)(self.pc_frame), c_url.p_cef_string_t)

}

///
// Execute a string of JavaScript code in this frame. The |script_url|
// parameter is the URL where the script in question can be found, if any. The
// renderer may request this URL to show the developer the source of the
// error.  The |start_line| parameter is the base line number to use for error
// reporting.
///
func (self *CFrameT) ExecuteJavaScript(
	code string,
	script_url string,
	start_line int,
) {
	c_code := create_cef_string(code)
	c_script_url := create_cef_string(script_url)

	C.cefingo_frame_execute_java_script((*C.cef_frame_t)(self.pc_frame), c_code.p_cef_string_t, c_script_url.p_cef_string_t, (C.int)(start_line))

}

///
// Returns true (1) if this is the main (top-level) frame.
///
func (self *CFrameT) IsMain() (ret bool) {

	cRet := C.cefingo_frame_is_main((*C.cef_frame_t)(self.pc_frame))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this is the focused frame.
///
func (self *CFrameT) IsFocused() (ret bool) {

	cRet := C.cefingo_frame_is_focused((*C.cef_frame_t)(self.pc_frame))

	ret = cRet == 1
	return ret
}

///
// Returns the name for this frame. If the frame has an assigned name (for
// example, set via the iframe &quot;name&quot; attribute) then that value will be
// returned. Otherwise a unique name will be constructed based on the frame
// parent hierarchy. The main (top-level) frame will always have an NULL name
// value.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CFrameT) GetName() (ret string) {

	cRet := C.cefingo_frame_get_name((*C.cef_frame_t)(self.pc_frame))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the globally unique identifier for this frame or &lt; 0 if the
// underlying frame does not yet exist.
///
func (self *CFrameT) GetIdentifier() (ret int64) {

	cRet := C.cefingo_frame_get_identifier((*C.cef_frame_t)(self.pc_frame))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the parent of this frame or NULL if this is the main (top-level)
// frame.
///
func (self *CFrameT) GetParent() (ret *CFrameT) {

	cRet := C.cefingo_frame_get_parent((*C.cef_frame_t)(self.pc_frame))

	ret = newCFrameT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the URL currently loaded in this frame.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CFrameT) GetUrl() (ret string) {

	cRet := C.cefingo_frame_get_url((*C.cef_frame_t)(self.pc_frame))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the browser that this frame belongs to.
///
func (self *CFrameT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_frame_get_browser((*C.cef_frame_t)(self.pc_frame))

	ret = newCBrowserT(cRet, byApp) // return GoObj
	return ret
}

///
// Get the V8 context associated with the frame. This function can only be
// called from the render process.
///
func (self *CFrameT) GetV8context() (ret *CV8contextT) {

	cRet := C.cefingo_frame_get_v8context((*C.cef_frame_t)(self.pc_frame))

	ret = newCV8contextT(cRet, byApp) // return GoObj
	return ret
}

///
// Visit the DOM document. This function can only be called from the render
// process.
///
func (self *CFrameT) VisitDom(
	visitor *CDomvisitorT,
) {
	var goTmpvisitor *C.cef_domvisitor_t
	if visitor != nil {
		BaseAddRef(visitor.pc_domvisitor)
		goTmpvisitor = (*C.cef_domvisitor_t)(visitor.pc_domvisitor)
	}

	C.cefingo_frame_visit_dom((*C.cef_frame_t)(self.pc_frame), goTmpvisitor)

}

///
// Create a new URL request that will be treated as originating from this
// frame and the associated browser. This request may be intercepted by the
// client via cef_resource_request_handler_t or cef_scheme_handler_factory_t.
// Use cef_urlrequest_t::Create instead if you do not want the request to have
// this association, in which case it may be handled differently (see
// documentation on that function). Requests may originate from both the
// browser process and the render process.
//
// For requests originating from the browser process:
//   - POST data may only contain a single element of type PDE_TYPE_FILE or
//     PDE_TYPE_BYTES.
// For requests originating from the render process:
//   - POST data may only contain a single element of type PDE_TYPE_BYTES.
//   - If the response contains Content-Disposition or Mime-Type header values
//     that would not normally be rendered then the response may receive
//     special handling inside the browser (for example, via the file download
//     code path instead of the URL request code path).
//
// The |request| object will be marked as read-only after calling this
// function.
///
func (self *CFrameT) CreateUrlrequest(
	request *CRequestT,
	client *CUrlrequestClientT,
) (ret *CUrlrequestT) {
	var goTmprequest *C.cef_request_t
	if request != nil {
		BaseAddRef(request.pc_request)
		goTmprequest = (*C.cef_request_t)(request.pc_request)
	}
	var goTmpclient *C.cef_urlrequest_client_t
	if client != nil {
		BaseAddRef(client.pc_urlrequest_client)
		goTmpclient = (*C.cef_urlrequest_client_t)(client.pc_urlrequest_client)
	}

	cRet := C.cefingo_frame_create_urlrequest((*C.cef_frame_t)(self.pc_frame), goTmprequest, goTmpclient)

	ret = newCUrlrequestT(cRet, byApp) // return GoObj
	return ret
}

///
// Send a message to the specified |target_process|. Ownership of the message
// contents will be transferred and the |message| reference will be
// invalidated. Message delivery is not guaranteed in all cases (for example,
// if the browser is closing, navigating, or if the target process crashes).
// Send an ACK message back from the target process if confirmation is
// required.
///
func (self *CFrameT) SendProcessMessage(
	target_process CProcessIdT,
	message *CProcessMessageT,
) {
	var goTmpmessage *C.cef_process_message_t
	if message != nil {
		BaseAddRef(message.pc_process_message)
		goTmpmessage = (*C.cef_process_message_t)(message.pc_process_message)
	}

	C.cefingo_frame_send_process_message((*C.cef_frame_t)(self.pc_frame), (C.cef_process_id_t)(target_process), goTmpmessage)

}

// cef_frame_handler_capi.h, include/capi/cef_frame_handler_capi.h:188:3,

///
// Implement this structure to handle events related to cef_frame_t life span.
// The order of callbacks is:
//
// (1) During initial cef_browser_host_t creation and navigation of the main
// frame: - cef_frame_handler_t::OnFrameCreated => The initial main frame object
// has been
//   created. Any commands will be queued until the frame is attached.
// - cef_frame_handler_t::OnMainFrameChanged => The initial main frame object
// has
//   been assigned to the browser.
// - cef_life_span_handler_t::OnAfterCreated => The browser is now valid and can
// be
//   used.
// - cef_frame_handler_t::OnFrameAttached => The initial main frame object is
// now
//   connected to its peer in the renderer process. Commands can be routed.
//
// (2) During further cef_browser_host_t navigation/loading of the main frame
// and/or sub-frames: - cef_frame_handler_t::OnFrameCreated => A new main frame
// or sub-frame object has
//   been created. Any commands will be queued until the frame is attached.
// - cef_frame_handler_t::OnFrameAttached => A new main frame or sub-frame
// object is
//   now connected to its peer in the renderer process. Commands can be routed.
// - cef_frame_handler_t::OnFrameDetached => An existing main frame or sub-frame
//   object has lost its connection to the renderer process. If multiple objects
//   are detached at the same time then notifications will be sent for any
//   sub-frame objects before the main frame object. Commands can no longer be
//   routed and will be discarded.
// - cef_frame_handler_t::OnMainFrameChanged => A new main frame object has been
//   assigned to the browser. This will only occur with cross-origin navigation
//   or re-navigation after renderer process termination (due to crashes, etc).
//
// (3) During final cef_browser_host_t destruction of the main frame: -
// cef_frame_handler_t::OnFrameDetached => Any sub-frame objects have lost their
//   connection to the renderer process. Commands can no longer be routed and
//   will be discarded.
// - cef_life_span_handler_t::OnBeforeClose => The browser has been destroyed. -
// cef_frame_handler_t::OnFrameDetached => The main frame object have lost its
//   connection to the renderer process. Notifications will be sent for any
//   sub-frame objects before the main frame object. Commands can no longer be
//   routed and will be discarded.
// - cef_frame_handler_t::OnMainFrameChanged => The final main frame object has
// been
//   removed from the browser.
//
// Cross-origin navigation and/or loading receives special handling.
//
// When the main frame navigates to a different origin the OnMainFrameChanged
// callback (2) will be executed with the old and new main frame objects.
//
// When a new sub-frame is loaded in, or an existing sub-frame is navigated to,
// a different origin from the parent frame, a temporary sub-frame object will
// first be created in the parent's renderer process. That temporary sub-frame
// will then be discarded after the real cross-origin sub-frame is created in
// the new/target renderer process. The client will receive cross-origin
// navigation callbacks (2) for the transition from the temporary sub-frame to
// the real sub-frame. The temporary sub-frame will not recieve or execute
// commands during this transitional period (any sent commands will be
// discarded).
//
// When a new popup browser is created in a different origin from the parent
// browser, a temporary main frame object for the popup will first be created in
// the parent's renderer process. That temporary main frame will then be
// discarded after the real cross-origin main frame is created in the new/target
// renderer process. The client will recieve creation and initial navigation
// callbacks (1) for the temporary main frame, followed by cross-origin
// navigation callbacks (2) for the transition from the temporary main frame to
// the real main frame. The temporary main frame may receive and execute
// commands during this transitional period (any sent commands may be executed,
// but the behavior is potentially undesirable since they execute in the parent
// browser's renderer process and not the new/target renderer process).
//
// Callbacks will not be executed for placeholders that may be created during
// pre-commit navigation for sub-frames that do not yet exist in the renderer
// process. Placeholders will have cef_frame_t::get_identifier() == -4.
//
// The functions of this structure will be called on the UI thread unless
// otherwise indicated.
///

type cCFrameHandlerT C.cef_frame_handler_t

// Go type for cef_frame_handler_t
type CFrameHandlerT struct {
	noCopy           noCopy
	pc_frame_handler *cCFrameHandlerT
	beUnrefed        unrefedBy
}

func (p *CFrameHandlerT) Pass() (ret *CFrameHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCFrameHandlerT((*C.cef_frame_handler_t)(p.pc_frame_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CFrameHandlerT) NewRef() (newP *CFrameHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_frame_handler
	BaseAddRef(gop)
	newP = newCFrameHandlerT((*C.cef_frame_handler_t)(gop), byApp)
	return newP
}

// Go type CFrameHandlerT wraps cef type *C.cef_frame_handler_t
func newCFrameHandlerT(p *C.cef_frame_handler_t, unrefedBy unrefedBy) *CFrameHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T391.1:")
	pc := (*cCFrameHandlerT)(p)
	go_frame_handler := &CFrameHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_frame_handler, func(g *CFrameHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_frame_handler != nil {
			Tracef(unsafe.Pointer(g.pc_frame_handler), "T391.2:")
			BaseRelease(g.pc_frame_handler)
		}
	})

	return go_frame_handler
}

// *C.cef_frame_handler_t has refCounted interface
func (frame_handler *CFrameHandlerT) HasOneRef() bool {
	return BaseHasOneRef(frame_handler.pc_frame_handler)
}

func (p *cCFrameHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (frame_handler *CFrameHandlerT) Unref() (ret bool) {
	if frame_handler == nil {
		return
	}
	if frame_handler.beUnrefed == byApp {
		ret = BaseRelease(frame_handler.pc_frame_handler)
		frame_handler.beUnrefed = unrefed
	}
	frame_handler.pc_frame_handler = nil
	return ret
}

///
// Called when a new frame is created. This will be the first notification
// that references |frame|. Any commands that require transport to the
// associated renderer process (LoadRequest, SendProcessMessage, GetSource,
// etc.) will be queued until OnFrameAttached is called for |frame|.
///
func (self *CFrameHandlerT) OnFrameCreated(
	browser *CBrowserT,
	frame *CFrameT,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		BaseAddRef(browser.pc_browser)
		goTmpbrowser = (*C.cef_browser_t)(browser.pc_browser)
	}
	var goTmpframe *C.cef_frame_t
	if frame != nil {
		BaseAddRef(frame.pc_frame)
		goTmpframe = (*C.cef_frame_t)(frame.pc_frame)
	}

	C.cefingo_frame_handler_on_frame_created((*C.cef_frame_handler_t)(self.pc_frame_handler), goTmpbrowser, goTmpframe)

}

///
// Called when a frame can begin routing commands to/from the associated
// renderer process. |reattached| will be true (1) if the frame was re-
// attached after exiting the BackForwardCache. Any commands that were queued
// have now been dispatched.
///
func (self *CFrameHandlerT) OnFrameAttached(
	browser *CBrowserT,
	frame *CFrameT,
	reattached int,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		BaseAddRef(browser.pc_browser)
		goTmpbrowser = (*C.cef_browser_t)(browser.pc_browser)
	}
	var goTmpframe *C.cef_frame_t
	if frame != nil {
		BaseAddRef(frame.pc_frame)
		goTmpframe = (*C.cef_frame_t)(frame.pc_frame)
	}

	C.cefingo_frame_handler_on_frame_attached((*C.cef_frame_handler_t)(self.pc_frame_handler), goTmpbrowser, goTmpframe, (C.int)(reattached))

}

///
// Called when a frame loses its connection to the renderer process and will
// be destroyed. Any pending or future commands will be discarded and
// cef_frame_t::is_valid() will now return false (0) for |frame|. If called
// after cef_life_span_handler_t::on_before_close() during browser destruction
// then cef_browser_t::is_valid() will return false (0) for |browser|.
///
func (self *CFrameHandlerT) OnFrameDetached(
	browser *CBrowserT,
	frame *CFrameT,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		BaseAddRef(browser.pc_browser)
		goTmpbrowser = (*C.cef_browser_t)(browser.pc_browser)
	}
	var goTmpframe *C.cef_frame_t
	if frame != nil {
		BaseAddRef(frame.pc_frame)
		goTmpframe = (*C.cef_frame_t)(frame.pc_frame)
	}

	C.cefingo_frame_handler_on_frame_detached((*C.cef_frame_handler_t)(self.pc_frame_handler), goTmpbrowser, goTmpframe)

}

///
// Called when the main frame changes due to (a) initial browser creation, (b)
// final browser destruction, (c) cross-origin navigation or (d) re-navigation
// after renderer process termination (due to crashes, etc). |old_frame| will
// be NULL and |new_frame| will be non-NULL when a main frame is assigned to
// |browser| for the first time. |old_frame| will be non-NULL and |new_frame|
// will be NULL and  when a main frame is removed from |browser| for the last
// time. Both |old_frame| and |new_frame| will be non-NULL for cross-origin
// navigations or re-navigation after renderer process termination. This
// function will be called after on_frame_created() for |new_frame| and/or
// after on_frame_detached() for |old_frame|. If called after
// cef_life_span_handler_t::on_before_close() during browser destruction then
// cef_browser_t::is_valid() will return false (0) for |browser|.
///
func (self *CFrameHandlerT) OnMainFrameChanged(
	browser *CBrowserT,
	old_frame *CFrameT,
	new_frame *CFrameT,
) {
	var goTmpbrowser *C.cef_browser_t
	if browser != nil {
		BaseAddRef(browser.pc_browser)
		goTmpbrowser = (*C.cef_browser_t)(browser.pc_browser)
	}
	var goTmpold_frame *C.cef_frame_t
	if old_frame != nil {
		BaseAddRef(old_frame.pc_frame)
		goTmpold_frame = (*C.cef_frame_t)(old_frame.pc_frame)
	}
	var goTmpnew_frame *C.cef_frame_t
	if new_frame != nil {
		BaseAddRef(new_frame.pc_frame)
		goTmpnew_frame = (*C.cef_frame_t)(new_frame.pc_frame)
	}

	C.cefingo_frame_handler_on_main_frame_changed((*C.cef_frame_handler_t)(self.pc_frame_handler), goTmpbrowser, goTmpold_frame, goTmpnew_frame)

}

// cef_image_capi.h, include/capi/cef_image_capi.h:193:3,

///
// Container for a single image represented at different scale factors. All
// image representations should be the same size in density independent pixel
// (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels
// then the image at scale factor 2.0 should be 200x200 pixels -- both images
// will display with a DIP size of 100x100 units. The functions of this
// structure can be called on any browser process thread.
///

type cCImageT C.cef_image_t

// Go type for cef_image_t
type CImageT struct {
	noCopy    noCopy
	pc_image  *cCImageT
	beUnrefed unrefedBy
}

func (p *CImageT) Pass() (ret *CImageT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCImageT((*C.cef_image_t)(p.pc_image), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CImageT) NewRef() (newP *CImageT) {
	if self == nil {
		return newP
	}
	gop := self.pc_image
	BaseAddRef(gop)
	newP = newCImageT((*C.cef_image_t)(gop), byApp)
	return newP
}

// Go type CImageT wraps cef type *C.cef_image_t
func newCImageT(p *C.cef_image_t, unrefedBy unrefedBy) *CImageT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T149.1:")
	pc := (*cCImageT)(p)
	go_image := &CImageT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_image, func(g *CImageT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_image != nil {
			Tracef(unsafe.Pointer(g.pc_image), "T149.2:")
			BaseRelease(g.pc_image)
		}
	})

	return go_image
}

// *C.cef_image_t has refCounted interface
func (image *CImageT) HasOneRef() bool {
	return BaseHasOneRef(image.pc_image)
}

func (p *cCImageT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (image *CImageT) Unref() (ret bool) {
	if image == nil {
		return
	}
	if image.beUnrefed == byApp {
		ret = BaseRelease(image.pc_image)
		image.beUnrefed = unrefed
	}
	image.pc_image = nil
	return ret
}

///
// Returns true (1) if this Image is NULL.
///
func (self *CImageT) IsEmpty() (ret bool) {

	cRet := C.cefingo_image_is_empty((*C.cef_image_t)(self.pc_image))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this Image and |that| Image share the same underlying
// storage. Will also return true (1) if both images are NULL.
///
func (self *CImageT) IsSame(
	that *CImageT,
) (ret bool) {
	var goTmpthat *C.cef_image_t
	if that != nil {
		BaseAddRef(that.pc_image)
		goTmpthat = (*C.cef_image_t)(that.pc_image)
	}

	cRet := C.cefingo_image_is_same((*C.cef_image_t)(self.pc_image), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Add a bitmap image representation for |scale_factor|. Only 32-bit RGBA/BGRA
// formats are supported. |pixel_width| and |pixel_height| are the bitmap
// representation size in pixel coordinates. |pixel_data| is the array of
// pixel data and should be |pixel_width| x |pixel_height| x 4 bytes in size.
// |color_type| and |alpha_type| values specify the pixel format.
///
func (self *CImageT) AddBitmap(
	scale_factor float32,
	pixel_width int,
	pixel_height int,
	color_type CColorTypeT,
	alpha_type CAlphaTypeT,
	pixel_data []byte,
) (ret bool) {
	pixel_data_size := len(pixel_data)
	tmppixel_data := C.CBytes(pixel_data)
	defer C.free(tmppixel_data)

	cRet := C.cefingo_image_add_bitmap((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor), (C.int)(pixel_width), (C.int)(pixel_height), (C.cef_color_type_t)(color_type), (C.cef_alpha_type_t)(alpha_type), tmppixel_data, (C.size_t)(pixel_data_size))

	ret = cRet == 1
	return ret
}

///
// Add a PNG image representation for |scale_factor|. |png_data| is the image
// data of size |png_data_size|. Any alpha transparency in the PNG data will
// be maintained.
///
func (self *CImageT) AddPng(
	scale_factor float32,
	png_data []byte,
) (ret bool) {
	png_data_size := len(png_data)
	tmppng_data := C.CBytes(png_data)
	defer C.free(tmppng_data)

	cRet := C.cefingo_image_add_png((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor), tmppng_data, (C.size_t)(png_data_size))

	ret = cRet == 1
	return ret
}

///
// Create a JPEG image representation for |scale_factor|. |jpeg_data| is the
// image data of size |jpeg_data_size|. The JPEG format does not support
// transparency so the alpha byte will be set to 0xFF for all pixels.
///
func (self *CImageT) AddJpeg(
	scale_factor float32,
	jpeg_data []byte,
) (ret bool) {
	jpeg_data_size := len(jpeg_data)
	tmpjpeg_data := C.CBytes(jpeg_data)
	defer C.free(tmpjpeg_data)

	cRet := C.cefingo_image_add_jpeg((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor), tmpjpeg_data, (C.size_t)(jpeg_data_size))

	ret = cRet == 1
	return ret
}

///
// Returns the image width in density independent pixel (DIP) units.
///
func (self *CImageT) GetWidth() (ret int64) {

	cRet := C.cefingo_image_get_width((*C.cef_image_t)(self.pc_image))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the image height in density independent pixel (DIP) units.
///
func (self *CImageT) GetHeight() (ret int64) {

	cRet := C.cefingo_image_get_height((*C.cef_image_t)(self.pc_image))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if this image contains a representation for
// |scale_factor|.
///
func (self *CImageT) HasRepresentation(
	scale_factor float32,
) (ret bool) {

	cRet := C.cefingo_image_has_representation((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor))

	ret = cRet == 1
	return ret
}

///
// Removes the representation for |scale_factor|. Returns true (1) on success.
///
func (self *CImageT) RemoveRepresentation(
	scale_factor float32,
) (ret bool) {

	cRet := C.cefingo_image_remove_representation((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor))

	ret = cRet == 1
	return ret
}

///
// Returns information for the representation that most closely matches
// |scale_factor|. |actual_scale_factor| is the actual scale factor for the
// representation. |pixel_width| and |pixel_height| are the representation
// size in pixel coordinates. Returns true (1) on success.
///
func (self *CImageT) GetRepresentationInfo(
	scale_factor float32,
) (ret bool, actual_scale_factor float32, pixel_width int, pixel_height int) {
	var tmpactual_scale_factor C.float
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_representation_info((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor), &tmpactual_scale_factor, &tmppixel_width, &tmppixel_height)

	actual_scale_factor = (float32)(tmpactual_scale_factor)
	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = cRet == 1
	return ret, actual_scale_factor, pixel_width, pixel_height
}

///
// Returns the bitmap representation that most closely matches |scale_factor|.
// Only 32-bit RGBA/BGRA formats are supported. |color_type| and |alpha_type|
// values specify the desired output pixel format. |pixel_width| and
// |pixel_height| are the output representation size in pixel coordinates.
// Returns a cef_binary_value_t containing the pixel data on success or NULL
// on failure.
///
func (self *CImageT) GetAsBitmap(
	scale_factor float32,
	color_type CColorTypeT,
	alpha_type CAlphaTypeT,
) (ret *CBinaryValueT, pixel_width int, pixel_height int) {
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_as_bitmap((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor), (C.cef_color_type_t)(color_type), (C.cef_alpha_type_t)(alpha_type), &tmppixel_width, &tmppixel_height)

	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret, pixel_width, pixel_height
}

///
// Returns the PNG representation that most closely matches |scale_factor|. If
// |with_transparency| is true (1) any alpha transparency in the image will be
// represented in the resulting PNG data. |pixel_width| and |pixel_height| are
// the output representation size in pixel coordinates. Returns a
// cef_binary_value_t containing the PNG image data on success or NULL on
// failure.
///
func (self *CImageT) GetAsPng(
	scale_factor float32,
	with_transparency int,
) (ret *CBinaryValueT, pixel_width int, pixel_height int) {
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_as_png((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor), (C.int)(with_transparency), &tmppixel_width, &tmppixel_height)

	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret, pixel_width, pixel_height
}

///
// Returns the JPEG representation that most closely matches |scale_factor|.
// |quality| determines the compression level with 0 == lowest and 100 ==
// highest. The JPEG format does not support alpha transparency and the alpha
// channel, if any, will be discarded. |pixel_width| and |pixel_height| are
// the output representation size in pixel coordinates. Returns a
// cef_binary_value_t containing the JPEG image data on success or NULL on
// failure.
///
func (self *CImageT) GetAsJpeg(
	scale_factor float32,
	quality int,
) (ret *CBinaryValueT, pixel_width int, pixel_height int) {
	var tmppixel_width C.int
	var tmppixel_height C.int

	cRet := C.cefingo_image_get_as_jpeg((*C.cef_image_t)(self.pc_image), (C.float)(scale_factor), (C.int)(quality), &tmppixel_width, &tmppixel_height)

	pixel_width = (int)(tmppixel_width)
	pixel_height = (int)(tmppixel_height)

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret, pixel_width, pixel_height
}

///
// Create a new cef_image_t. It will initially be NULL. Use the Add*() functions
// to add representations at different scale factors.
///
func ImageCreate() (ret *CImageT) {

	cRet := C.cef_image_create()

	ret = newCImageT(cRet, byApp) // return GoObj
	return ret
}

// cef_jsdialog_handler_capi.h, include/capi/cef_jsdialog_handler_capi.h:67:3,

///
// Callback structure used for asynchronous continuation of JavaScript dialog
// requests.
///

type cCJsdialogCallbackT C.cef_jsdialog_callback_t

// Go type for cef_jsdialog_callback_t
type CJsdialogCallbackT struct {
	noCopy               noCopy
	pc_jsdialog_callback *cCJsdialogCallbackT
	beUnrefed            unrefedBy
}

func (p *CJsdialogCallbackT) Pass() (ret *CJsdialogCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCJsdialogCallbackT((*C.cef_jsdialog_callback_t)(p.pc_jsdialog_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CJsdialogCallbackT) NewRef() (newP *CJsdialogCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_jsdialog_callback
	BaseAddRef(gop)
	newP = newCJsdialogCallbackT((*C.cef_jsdialog_callback_t)(gop), byApp)
	return newP
}

// Go type CJsdialogCallbackT wraps cef type *C.cef_jsdialog_callback_t
func newCJsdialogCallbackT(p *C.cef_jsdialog_callback_t, unrefedBy unrefedBy) *CJsdialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T150.1:")
	pc := (*cCJsdialogCallbackT)(p)
	go_jsdialog_callback := &CJsdialogCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_jsdialog_callback, func(g *CJsdialogCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_jsdialog_callback != nil {
			Tracef(unsafe.Pointer(g.pc_jsdialog_callback), "T150.2:")
			BaseRelease(g.pc_jsdialog_callback)
		}
	})

	return go_jsdialog_callback
}

// *C.cef_jsdialog_callback_t has refCounted interface
func (jsdialog_callback *CJsdialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(jsdialog_callback.pc_jsdialog_callback)
}

func (p *cCJsdialogCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (jsdialog_callback *CJsdialogCallbackT) Unref() (ret bool) {
	if jsdialog_callback == nil {
		return
	}
	if jsdialog_callback.beUnrefed == byApp {
		ret = BaseRelease(jsdialog_callback.pc_jsdialog_callback)
		jsdialog_callback.beUnrefed = unrefed
	}
	jsdialog_callback.pc_jsdialog_callback = nil
	return ret
}

///
// Continue the JS dialog request. Set |success| to true (1) if the OK button
// was pressed. The |user_input| value should be specified for prompt dialogs.
///
func (self *CJsdialogCallbackT) Cont(
	success int,
	user_input string,
) {
	c_user_input := create_cef_string(user_input)

	C.cefingo_jsdialog_callback_cont((*C.cef_jsdialog_callback_t)(self.pc_jsdialog_callback), (C.int)(success), c_user_input.p_cef_string_t)

}

///
// Implement this structure to handle events related to JavaScript dialogs. The
// functions of this structure will be called on the UI thread.
///

type cCJsdialogHandlerT C.cef_jsdialog_handler_t

// Go type for cef_jsdialog_handler_t
type CJsdialogHandlerT struct {
	noCopy              noCopy
	pc_jsdialog_handler *cCJsdialogHandlerT
	beUnrefed           unrefedBy
}

func (p *CJsdialogHandlerT) Pass() (ret *CJsdialogHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCJsdialogHandlerT((*C.cef_jsdialog_handler_t)(p.pc_jsdialog_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CJsdialogHandlerT) NewRef() (newP *CJsdialogHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_jsdialog_handler
	BaseAddRef(gop)
	newP = newCJsdialogHandlerT((*C.cef_jsdialog_handler_t)(gop), byApp)
	return newP
}

// Go type CJsdialogHandlerT wraps cef type *C.cef_jsdialog_handler_t
func newCJsdialogHandlerT(p *C.cef_jsdialog_handler_t, unrefedBy unrefedBy) *CJsdialogHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T151.1:")
	pc := (*cCJsdialogHandlerT)(p)
	go_jsdialog_handler := &CJsdialogHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_jsdialog_handler, func(g *CJsdialogHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_jsdialog_handler != nil {
			Tracef(unsafe.Pointer(g.pc_jsdialog_handler), "T151.2:")
			BaseRelease(g.pc_jsdialog_handler)
		}
	})

	return go_jsdialog_handler
}

// *C.cef_jsdialog_handler_t has refCounted interface
func (jsdialog_handler *CJsdialogHandlerT) HasOneRef() bool {
	return BaseHasOneRef(jsdialog_handler.pc_jsdialog_handler)
}

func (p *cCJsdialogHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (jsdialog_handler *CJsdialogHandlerT) Unref() (ret bool) {
	if jsdialog_handler == nil {
		return
	}
	if jsdialog_handler.beUnrefed == byApp {
		ret = BaseRelease(jsdialog_handler.pc_jsdialog_handler)
		jsdialog_handler.beUnrefed = unrefed
	}
	jsdialog_handler.pc_jsdialog_handler = nil
	return ret
}

///
// Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be
// passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure
// and user-friendly display string. The |default_prompt_text| value will be
// specified for prompt dialogs only. Set |suppress_message| to true (1) and
// return false (0) to suppress the message (suppressing messages is
// preferable to immediately executing the callback as this is used to detect
// presumably malicious behavior like spamming alert messages in
// onbeforeunload). Set |suppress_message| to false (0) and return false (0)
// to use the default implementation (the default implementation will show one
// modal dialog at a time and suppress any additional dialog requests until
// the displayed dialog is dismissed). Return true (1) if the application will
// use a custom dialog or if the callback has been executed immediately.
// Custom dialogs may be either modal or modeless. If a custom dialog is used
// the application must execute |callback| once the custom dialog is
// dismissed.
///
type OnJsdialogHandler interface {
	OnJsdialog(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
		origin_url string,
		dialog_type CJsdialogTypeT,
		message_text string,
		default_prompt_text string,
		callback *CJsdialogCallbackT,
	) (ret bool, suppress_message int)
}

///
// Called to run a dialog asking the user if they want to leave a page. Return
// false (0) to use the default dialog implementation. Return true (1) if the
// application will use a custom dialog or if the callback has been executed
// immediately. Custom dialogs may be either modal or modeless. If a custom
// dialog is used the application must execute |callback| once the custom
// dialog is dismissed.
///
type OnBeforeUnloadDialogHandler interface {
	OnBeforeUnloadDialog(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
		message_text string,
		is_reload int,
		callback *CJsdialogCallbackT,
	) (ret bool)
}

///
// Called to cancel any pending dialogs and reset any saved dialog state. Will
// be called due to events like page navigation irregardless of whether any
// dialogs are currently pending.
///
type OnResetDialogStateHandler interface {
	OnResetDialogState(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
	)
}

///
// Called when the default implementation dialog is closed.
///
type OnDialogClosedHandler interface {
	OnDialogClosed(
		self *CJsdialogHandlerT,
		browser *CBrowserT,
	)
}

var jsdialog_handler_handlers = struct {
	handler                         map[*cCJsdialogHandlerT]interface{}
	on_jsdialog_handler             map[*cCJsdialogHandlerT]OnJsdialogHandler
	on_before_unload_dialog_handler map[*cCJsdialogHandlerT]OnBeforeUnloadDialogHandler
	on_reset_dialog_state_handler   map[*cCJsdialogHandlerT]OnResetDialogStateHandler
	on_dialog_closed_handler        map[*cCJsdialogHandlerT]OnDialogClosedHandler
}{
	map[*cCJsdialogHandlerT]interface{}{},
	map[*cCJsdialogHandlerT]OnJsdialogHandler{},
	map[*cCJsdialogHandlerT]OnBeforeUnloadDialogHandler{},
	map[*cCJsdialogHandlerT]OnResetDialogStateHandler{},
	map[*cCJsdialogHandlerT]OnDialogClosedHandler{},
}

// allocCJsdialogHandlerT allocates CJsdialogHandlerT and construct it
func allocCJsdialogHandlerT() *CJsdialogHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_jsdialog_handler_wrapper_t, "T151.3:")
	cefp := C.cefingo_construct_jsdialog_handler((*C.cefingo_jsdialog_handler_wrapper_t)(up))
	cgop := (*cCJsdialogHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_jsdialog_handler_t itself in DeassocFunc,
		// or cef_jsdialog_handler_t is never GCed.
		Tracef(up, "T151.4:")
		unbindAllCJsdialogHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCJsdialogHandlerT(cefp, byApp)
}

// NewCJsdialogHandlerT allocates CJsdialogHandlerT, construct and bind it
func NewCJsdialogHandlerT(a interface{}) *CJsdialogHandlerT {
	return allocCJsdialogHandlerT().bind(a)
}

func (jsdialog_handler *CJsdialogHandlerT) bind(a interface{}) *CJsdialogHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := jsdialog_handler.pc_jsdialog_handler
	jsdialog_handler_handlers.handler[cp] = a

	if h, ok := a.(OnJsdialogHandler); ok {
		jsdialog_handler_handlers.on_jsdialog_handler[cp] = h
		noBind = false
	} else {
		delete(jsdialog_handler_handlers.on_jsdialog_handler, cp)
	}

	if h, ok := a.(OnBeforeUnloadDialogHandler); ok {
		jsdialog_handler_handlers.on_before_unload_dialog_handler[cp] = h
		noBind = false
	} else {
		delete(jsdialog_handler_handlers.on_before_unload_dialog_handler, cp)
	}

	if h, ok := a.(OnResetDialogStateHandler); ok {
		jsdialog_handler_handlers.on_reset_dialog_state_handler[cp] = h
		noBind = false
	} else {
		delete(jsdialog_handler_handlers.on_reset_dialog_state_handler, cp)
	}

	if h, ok := a.(OnDialogClosedHandler); ok {
		jsdialog_handler_handlers.on_dialog_closed_handler[cp] = h
		noBind = false
	} else {
		delete(jsdialog_handler_handlers.on_dialog_closed_handler, cp)
	}

	if noBind {
		Panicln("F229: *CJsdialogHandlerT No bind")
	}
	return jsdialog_handler
}

func unbindAllCJsdialogHandlerT(cp *cCJsdialogHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := jsdialog_handler.pc_jsdialog_handler
	delete(jsdialog_handler_handlers.handler, cp)

	delete(jsdialog_handler_handlers.on_jsdialog_handler, cp)
	delete(jsdialog_handler_handlers.on_before_unload_dialog_handler, cp)
	delete(jsdialog_handler_handlers.on_reset_dialog_state_handler, cp)
	delete(jsdialog_handler_handlers.on_dialog_closed_handler, cp)
}

func (jsdialog_handler *CJsdialogHandlerT) UnbindAll() {
	unbindAllCJsdialogHandlerT(jsdialog_handler.pc_jsdialog_handler)
	jsdialog_handler.Unref()
}

func (jsdialog_handler *CJsdialogHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := jsdialog_handler.pc_jsdialog_handler
	return jsdialog_handler_handlers.handler[cp]
}

// cef_keyboard_handler_capi.h, include/capi/cef_keyboard_handler_capi.h:83:3,

///
// Implement this structure to handle events related to keyboard input. The
// functions of this structure will be called on the UI thread.
///

type cCKeyboardHandlerT C.cef_keyboard_handler_t

// Go type for cef_keyboard_handler_t
type CKeyboardHandlerT struct {
	noCopy              noCopy
	pc_keyboard_handler *cCKeyboardHandlerT
	beUnrefed           unrefedBy
}

func (p *CKeyboardHandlerT) Pass() (ret *CKeyboardHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCKeyboardHandlerT((*C.cef_keyboard_handler_t)(p.pc_keyboard_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CKeyboardHandlerT) NewRef() (newP *CKeyboardHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_keyboard_handler
	BaseAddRef(gop)
	newP = newCKeyboardHandlerT((*C.cef_keyboard_handler_t)(gop), byApp)
	return newP
}

// Go type CKeyboardHandlerT wraps cef type *C.cef_keyboard_handler_t
func newCKeyboardHandlerT(p *C.cef_keyboard_handler_t, unrefedBy unrefedBy) *CKeyboardHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T152.1:")
	pc := (*cCKeyboardHandlerT)(p)
	go_keyboard_handler := &CKeyboardHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_keyboard_handler, func(g *CKeyboardHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_keyboard_handler != nil {
			Tracef(unsafe.Pointer(g.pc_keyboard_handler), "T152.2:")
			BaseRelease(g.pc_keyboard_handler)
		}
	})

	return go_keyboard_handler
}

// *C.cef_keyboard_handler_t has refCounted interface
func (keyboard_handler *CKeyboardHandlerT) HasOneRef() bool {
	return BaseHasOneRef(keyboard_handler.pc_keyboard_handler)
}

func (p *cCKeyboardHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (keyboard_handler *CKeyboardHandlerT) Unref() (ret bool) {
	if keyboard_handler == nil {
		return
	}
	if keyboard_handler.beUnrefed == byApp {
		ret = BaseRelease(keyboard_handler.pc_keyboard_handler)
		keyboard_handler.beUnrefed = unrefed
	}
	keyboard_handler.pc_keyboard_handler = nil
	return ret
}

///
// Called before a keyboard event is sent to the renderer. |event| contains
// information about the keyboard event. |os_event| is the operating system
// event message, if any. Return true (1) if the event was handled or false
// (0) otherwise. If the event will be handled in on_key_event() as a keyboard
// shortcut set |is_keyboard_shortcut| to true (1) and return false (0).
///
type OnPreKeyEventHandler interface {
	OnPreKeyEvent(
		self *CKeyboardHandlerT,
		browser *CBrowserT,
		event *CKeyEventT,
		os_event CEventHandleT,
	) (ret bool, is_keyboard_shortcut int)
}

///
// Called after the renderer and JavaScript in the page has had a chance to
// handle the event. |event| contains information about the keyboard event.
// |os_event| is the operating system event message, if any. Return true (1)
// if the keyboard event was handled or false (0) otherwise.
///
type CKeyboardHandlerTOnKeyEventHandler interface {
	OnKeyEvent(
		self *CKeyboardHandlerT,
		browser *CBrowserT,
		event *CKeyEventT,
		os_event CEventHandleT,
	) (ret bool)
}

var keyboard_handler_handlers = struct {
	handler                  map[*cCKeyboardHandlerT]interface{}
	on_pre_key_event_handler map[*cCKeyboardHandlerT]OnPreKeyEventHandler
	on_key_event_handler     map[*cCKeyboardHandlerT]CKeyboardHandlerTOnKeyEventHandler
}{
	map[*cCKeyboardHandlerT]interface{}{},
	map[*cCKeyboardHandlerT]OnPreKeyEventHandler{},
	map[*cCKeyboardHandlerT]CKeyboardHandlerTOnKeyEventHandler{},
}

// allocCKeyboardHandlerT allocates CKeyboardHandlerT and construct it
func allocCKeyboardHandlerT() *CKeyboardHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_keyboard_handler_wrapper_t, "T152.3:")
	cefp := C.cefingo_construct_keyboard_handler((*C.cefingo_keyboard_handler_wrapper_t)(up))
	cgop := (*cCKeyboardHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_keyboard_handler_t itself in DeassocFunc,
		// or cef_keyboard_handler_t is never GCed.
		Tracef(up, "T152.4:")
		unbindAllCKeyboardHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCKeyboardHandlerT(cefp, byApp)
}

// NewCKeyboardHandlerT allocates CKeyboardHandlerT, construct and bind it
func NewCKeyboardHandlerT(a interface{}) *CKeyboardHandlerT {
	return allocCKeyboardHandlerT().bind(a)
}

func (keyboard_handler *CKeyboardHandlerT) bind(a interface{}) *CKeyboardHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := keyboard_handler.pc_keyboard_handler
	keyboard_handler_handlers.handler[cp] = a

	if h, ok := a.(OnPreKeyEventHandler); ok {
		keyboard_handler_handlers.on_pre_key_event_handler[cp] = h
		noBind = false
	} else {
		delete(keyboard_handler_handlers.on_pre_key_event_handler, cp)
	}

	if h, ok := a.(CKeyboardHandlerTOnKeyEventHandler); ok {
		keyboard_handler_handlers.on_key_event_handler[cp] = h
		noBind = false
	} else {
		delete(keyboard_handler_handlers.on_key_event_handler, cp)
	}

	if noBind {
		Panicln("F229: *CKeyboardHandlerT No bind")
	}
	return keyboard_handler
}

func unbindAllCKeyboardHandlerT(cp *cCKeyboardHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := keyboard_handler.pc_keyboard_handler
	delete(keyboard_handler_handlers.handler, cp)

	delete(keyboard_handler_handlers.on_pre_key_event_handler, cp)
	delete(keyboard_handler_handlers.on_key_event_handler, cp)
}

func (keyboard_handler *CKeyboardHandlerT) UnbindAll() {
	unbindAllCKeyboardHandlerT(keyboard_handler.pc_keyboard_handler)
	keyboard_handler.Unref()
}

func (keyboard_handler *CKeyboardHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := keyboard_handler.pc_keyboard_handler
	return keyboard_handler_handlers.handler[cp]
}

// cef_label_button_capi.h, include/capi/views/cef_label_button_capi.h:146:3,

///
// LabelButton is a button with optional text and/or icon. Methods must be
// called on the browser process UI thread unless otherwise indicated.
///

type cCLabelButtonT C.cef_label_button_t

// Go type for cef_label_button_t
type CLabelButtonT struct {
	noCopy          noCopy
	pc_label_button *cCLabelButtonT
	beUnrefed       unrefedBy
}

func (p *CLabelButtonT) Pass() (ret *CLabelButtonT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCLabelButtonT((*C.cef_label_button_t)(p.pc_label_button), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CLabelButtonT) NewRef() (newP *CLabelButtonT) {
	if self == nil {
		return newP
	}
	gop := self.pc_label_button
	BaseAddRef(gop)
	newP = newCLabelButtonT((*C.cef_label_button_t)(gop), byApp)
	return newP
}

// Go type CLabelButtonT wraps cef type *C.cef_label_button_t
func newCLabelButtonT(p *C.cef_label_button_t, unrefedBy unrefedBy) *CLabelButtonT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T153.1:")
	pc := (*cCLabelButtonT)(p)
	go_label_button := &CLabelButtonT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_label_button, func(g *CLabelButtonT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_label_button != nil {
			Tracef(unsafe.Pointer(g.pc_label_button), "T153.2:")
			BaseRelease(g.pc_label_button)
		}
	})

	return go_label_button
}

// *C.cef_label_button_t has refCounted interface
func (label_button *CLabelButtonT) HasOneRef() bool {
	return BaseHasOneRef(label_button.pc_label_button)
}

func (p *cCLabelButtonT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (label_button *CLabelButtonT) Unref() (ret bool) {
	if label_button == nil {
		return
	}
	if label_button.beUnrefed == byApp {
		ret = BaseRelease(label_button.pc_label_button)
		label_button.beUnrefed = unrefed
	}
	label_button.pc_label_button = nil
	return ret
}

// Convert to Base Class Pointer *CButtonT
func (label_button *CLabelButtonT) ToCButtonT() *CButtonT {
	p := (*C.cef_button_t)(unsafe.Pointer(label_button.pc_label_button))
	BaseAddRef(label_button.pc_label_button)
	return newCButtonT(p, byApp)
}

///
// Returns this LabelButton as a MenuButton or NULL if this is not a
// MenuButton.
///
func (self *CLabelButtonT) AsMenuButton() (ret *CMenuButtonT) {

	cRet := C.cefingo_label_button_as_menu_button((*C.cef_label_button_t)(self.pc_label_button))

	ret = newCMenuButtonT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the text shown on the LabelButton. By default |text| will also be used
// as the accessible name.
///
func (self *CLabelButtonT) SetText(
	text string,
) {
	c_text := create_cef_string(text)

	C.cefingo_label_button_set_text((*C.cef_label_button_t)(self.pc_label_button), c_text.p_cef_string_t)

}

///
// Returns the text shown on the LabelButton.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CLabelButtonT) GetText() (ret string) {

	cRet := C.cefingo_label_button_get_text((*C.cef_label_button_t)(self.pc_label_button))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the image shown for |button_state|. When this Button is drawn if no
// image exists for the current state then the image for
// CEF_BUTTON_STATE_NORMAL, if any, will be shown.
///
func (self *CLabelButtonT) SetImage(
	button_state CButtonStateT,
	image *CImageT,
) {
	var goTmpimage *C.cef_image_t
	if image != nil {
		BaseAddRef(image.pc_image)
		goTmpimage = (*C.cef_image_t)(image.pc_image)
	}

	C.cefingo_label_button_set_image((*C.cef_label_button_t)(self.pc_label_button), (C.cef_button_state_t)(button_state), goTmpimage)

}

///
// Returns the image shown for |button_state|. If no image exists for that
// state then the image for CEF_BUTTON_STATE_NORMAL will be returned.
///
func (self *CLabelButtonT) GetImage(
	button_state CButtonStateT,
) (ret *CImageT) {

	cRet := C.cefingo_label_button_get_image((*C.cef_label_button_t)(self.pc_label_button), (C.cef_button_state_t)(button_state))

	ret = newCImageT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the text color shown for the specified button |for_state| to |color|.
///
func (self *CLabelButtonT) SetTextColor(
	for_state CButtonStateT,
	color CColorT,
) {

	C.cefingo_label_button_set_text_color((*C.cef_label_button_t)(self.pc_label_button), (C.cef_button_state_t)(for_state), (C.cef_color_t)(color))

}

///
// Sets the text colors shown for the non-disabled states to |color|.
///
func (self *CLabelButtonT) SetEnabledTextColors(
	color CColorT,
) {

	C.cefingo_label_button_set_enabled_text_colors((*C.cef_label_button_t)(self.pc_label_button), (C.cef_color_t)(color))

}

///
// Sets the font list. The format is &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;,
// where: - FONT_FAMILY_LIST is a comma-separated list of font family names, -
// STYLES is an optional space-separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CLabelButtonT) SetFontList(
	font_list string,
) {
	c_font_list := create_cef_string(font_list)

	C.cefingo_label_button_set_font_list((*C.cef_label_button_t)(self.pc_label_button), c_font_list.p_cef_string_t)

}

///
// Sets the horizontal alignment; reversed in RTL. Default is
// CEF_HORIZONTAL_ALIGNMENT_CENTER.
///
func (self *CLabelButtonT) SetHorizontalAlignment(
	alignment CHorizontalAlignmentT,
) {

	C.cefingo_label_button_set_horizontal_alignment((*C.cef_label_button_t)(self.pc_label_button), (C.cef_horizontal_alignment_t)(alignment))

}

///
// Reset the minimum size of this LabelButton to |size|.
///
func (self *CLabelButtonT) SetMinimumSize(
	size *CSizeT,
) {

	C.cefingo_label_button_set_minimum_size((*C.cef_label_button_t)(self.pc_label_button), (*C.cef_size_t)(size))

}

///
// Reset the maximum size of this LabelButton to |size|.
///
func (self *CLabelButtonT) SetMaximumSize(
	size *CSizeT,
) {

	C.cefingo_label_button_set_maximum_size((*C.cef_label_button_t)(self.pc_label_button), (*C.cef_size_t)(size))

}

///
// Create a new LabelButton. A |delegate| must be provided to handle the button
// click. |text| will be shown on the LabelButton and used as the default
// accessible name.
///
func LabelButtonCreate(
	delegate *CButtonDelegateT,
	text string,
) (ret *CLabelButtonT) {
	var goTmpdelegate *C.cef_button_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_button_delegate)
		goTmpdelegate = (*C.cef_button_delegate_t)(delegate.pc_button_delegate)
	}
	c_text := create_cef_string(text)

	cRet := C.cef_label_button_create(goTmpdelegate, c_text.p_cef_string_t)

	ret = newCLabelButtonT(cRet, byApp) // return GoObj
	return ret
}

// cef_layout_capi.h, include/capi/views/cef_layout_capi.h:79:3,

///
// A Layout handles the sizing of the children of a Panel according to
// implementation-specific heuristics. Methods must be called on the browser
// process UI thread unless otherwise indicated.
///

type cCLayoutT C.cef_layout_t

// Go type for cef_layout_t
type CLayoutT struct {
	noCopy    noCopy
	pc_layout *cCLayoutT
	beUnrefed unrefedBy
}

func (p *CLayoutT) Pass() (ret *CLayoutT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCLayoutT((*C.cef_layout_t)(p.pc_layout), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CLayoutT) NewRef() (newP *CLayoutT) {
	if self == nil {
		return newP
	}
	gop := self.pc_layout
	BaseAddRef(gop)
	newP = newCLayoutT((*C.cef_layout_t)(gop), byApp)
	return newP
}

// Go type CLayoutT wraps cef type *C.cef_layout_t
func newCLayoutT(p *C.cef_layout_t, unrefedBy unrefedBy) *CLayoutT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T154.1:")
	pc := (*cCLayoutT)(p)
	go_layout := &CLayoutT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_layout, func(g *CLayoutT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_layout != nil {
			Tracef(unsafe.Pointer(g.pc_layout), "T154.2:")
			BaseRelease(g.pc_layout)
		}
	})

	return go_layout
}

// *C.cef_layout_t has refCounted interface
func (layout *CLayoutT) HasOneRef() bool {
	return BaseHasOneRef(layout.pc_layout)
}

func (p *cCLayoutT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (layout *CLayoutT) Unref() (ret bool) {
	if layout == nil {
		return
	}
	if layout.beUnrefed == byApp {
		ret = BaseRelease(layout.pc_layout)
		layout.beUnrefed = unrefed
	}
	layout.pc_layout = nil
	return ret
}

///
// Returns this Layout as a BoxLayout or NULL if this is not a BoxLayout.
///
func (self *CLayoutT) AsBoxLayout() (ret *CBoxLayoutT) {

	cRet := C.cefingo_layout_as_box_layout((*C.cef_layout_t)(self.pc_layout))

	ret = newCBoxLayoutT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns this Layout as a FillLayout or NULL if this is not a FillLayout.
///
func (self *CLayoutT) AsFillLayout() (ret *CFillLayoutT) {

	cRet := C.cefingo_layout_as_fill_layout((*C.cef_layout_t)(self.pc_layout))

	ret = newCFillLayoutT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if this Layout is valid.
///
func (self *CLayoutT) IsValid() (ret bool) {

	cRet := C.cefingo_layout_is_valid((*C.cef_layout_t)(self.pc_layout))

	ret = cRet == 1
	return ret
}

// cef_life_span_handler_capi.h, include/capi/cef_life_span_handler_capi.h:218:3,

///
// Implement this structure to handle events related to browser life span. The
// functions of this structure will be called on the UI thread unless otherwise
// indicated.
///

type cCLifeSpanHandlerT C.cef_life_span_handler_t

// Go type for cef_life_span_handler_t
type CLifeSpanHandlerT struct {
	noCopy               noCopy
	pc_life_span_handler *cCLifeSpanHandlerT
	beUnrefed            unrefedBy
}

func (p *CLifeSpanHandlerT) Pass() (ret *CLifeSpanHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCLifeSpanHandlerT((*C.cef_life_span_handler_t)(p.pc_life_span_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CLifeSpanHandlerT) NewRef() (newP *CLifeSpanHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_life_span_handler
	BaseAddRef(gop)
	newP = newCLifeSpanHandlerT((*C.cef_life_span_handler_t)(gop), byApp)
	return newP
}

// Go type CLifeSpanHandlerT wraps cef type *C.cef_life_span_handler_t
func newCLifeSpanHandlerT(p *C.cef_life_span_handler_t, unrefedBy unrefedBy) *CLifeSpanHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T155.1:")
	pc := (*cCLifeSpanHandlerT)(p)
	go_life_span_handler := &CLifeSpanHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_life_span_handler, func(g *CLifeSpanHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_life_span_handler != nil {
			Tracef(unsafe.Pointer(g.pc_life_span_handler), "T155.2:")
			BaseRelease(g.pc_life_span_handler)
		}
	})

	return go_life_span_handler
}

// *C.cef_life_span_handler_t has refCounted interface
func (life_span_handler *CLifeSpanHandlerT) HasOneRef() bool {
	return BaseHasOneRef(life_span_handler.pc_life_span_handler)
}

func (p *cCLifeSpanHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (life_span_handler *CLifeSpanHandlerT) Unref() (ret bool) {
	if life_span_handler == nil {
		return
	}
	if life_span_handler.beUnrefed == byApp {
		ret = BaseRelease(life_span_handler.pc_life_span_handler)
		life_span_handler.beUnrefed = unrefed
	}
	life_span_handler.pc_life_span_handler = nil
	return ret
}

///
// Called on the UI thread before a new popup browser is created. The
// |browser| and |frame| values represent the source of the popup request. The
// |target_url| and |target_frame_name| values indicate where the popup
// browser should navigate and may be NULL if not specified with the request.
// The |target_disposition| value indicates where the user intended to open
// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
// be true (1) if the popup was opened via explicit user gesture (e.g.
// clicking a link) or false (0) if the popup opened automatically (e.g. via
// the DomContentLoaded event). The |popupFeatures| structure contains
// additional information about the requested popup window. To allow creation
// of the popup browser optionally modify |windowInfo|, |client|, |settings|
// and |no_javascript_access| and return false (0). To cancel creation of the
// popup browser return true (1). The |client| and |settings| values will
// default to the source browser&#39;s values. If the |no_javascript_access| value
// is set to false (0) the new browser will not be scriptable and may not be
// hosted in the same renderer process as the source browser. Any
// modifications to |windowInfo| will be ignored if the parent browser is
// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
// the parent browser is destroyed before the popup browser creation completes
// (indicated by a call to OnAfterCreated for the popup browser). The
// |extra_info| parameter provides an opportunity to specify extra information
// specific to the created popup browser that will be passed to
// cef_render_process_handler_t::on_browser_created() in the render process.
///
type OnBeforePopupHandler interface {
	OnBeforePopup(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		target_url string,
		target_frame_name string,
		target_disposition CWindowOpenDispositionT,
		user_gesture int,
		popupFeatures *CPopupFeaturesT,
		windowInfo CWindowInfoT,
		client *CClientT,
		settings CBrowserSettingsT,
		no_javascript_access bool,
	) (ret bool, windowInfoOut CWindowInfoT, clientOut *CClientT, settingsOut CBrowserSettingsT, extra_info *CDictionaryValueT, no_javascript_accessOut bool)
}

///
// Called after a new browser is created. It is now safe to begin performing
// actions with |browser|. cef_frame_handler_t callbacks related to initial
// main frame creation will arrive before this callback. See
// cef_frame_handler_t documentation for additional usage information.
///
type OnAfterCreatedHandler interface {
	OnAfterCreated(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
	)
}

///
// Called when a browser has recieved a request to close. This may result
// directly from a call to cef_browser_host_t::*close_browser() or indirectly
// if the browser is parented to a top-level window created by CEF and the
// user attempts to close that window (by clicking the &#39;X&#39;, for example). The
// do_close() function will be called after the JavaScript &#39;onunload&#39; event
// has been fired.
//
// An application should handle top-level owner window close notifications by
// calling cef_browser_host_t::try_close_browser() or
// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
// to close immediately (see the examples below). This gives CEF an
// opportunity to process the &#39;onbeforeunload&#39; event and optionally cancel the
// close before do_close() is called.
//
// When windowed rendering is enabled CEF will internally create a window or
// view to host the browser. In that case returning false (0) from do_close()
// will send the standard close notification to the browser&#39;s top-level owner
// window (e.g. WM_CLOSE on Windows, performClose: on OS X, &quot;delete_event&quot; on
// Linux or cef_window_delegate_t::can_close() callback from Views). If the
// browser&#39;s host window/view has already been destroyed (via view hierarchy
// tear-down, for example) then do_close() will not be called for that browser
// since is no longer possible to cancel the close.
//
// When windowed rendering is disabled returning false (0) from do_close()
// will cause the browser object to be destroyed immediately.
//
// If the browser&#39;s top-level owner window requires a non-standard close
// notification then send that notification from do_close() and return true
// (1).
//
// The cef_life_span_handler_t::on_before_close() function will be called
// after do_close() (if do_close() is called) and immediately before the
// browser object is destroyed. The application should only exit after
// on_before_close() has been called for all existing browsers.
//
// The below examples describe what should happen during window close when the
// browser is parented to an application-provided top-level window.
//
// Example 1: Using cef_browser_host_t::try_close_browser(). This is
// recommended for clients using standard close handling and windows created
// on the browser process UI thread. 1.  User clicks the window close button
// which sends a close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
//     TryCloseBrowser() returns false so the client cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// CEF sends a close notification to the application&#39;s top-level window
//     (because DoClose() returned false by default).
// 7.  Application&#39;s top-level window receives the close notification and
//     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
//     allows the window close.
// 8.  Application&#39;s top-level window is destroyed. 9.  Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 10. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
//
// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
// implementing the do_close() callback. This is recommended for clients using
// non-standard close handling or windows that were not created on the browser
// process UI thread. 1.  User clicks the window close button which sends a
// close notification to
//     the application&#39;s top-level window.
// 2.  Application&#39;s top-level window receives the close notification and:
//     A. Calls CefBrowserHost::CloseBrowser(false).
//     B. Cancels the window close.
// 3.  JavaScript &#39;onbeforeunload&#39; handler executes and shows the close
//     confirmation dialog (which can be overridden via
//     CefJSDialogHandler::OnBeforeUnloadDialog()).
// 4.  User approves the close. 5.  JavaScript &#39;onunload&#39; handler executes. 6.
// Application&#39;s do_close() handler is called. Application will:
//     A. Set a flag to indicate that the next close attempt will be allowed.
//     B. Return false.
// 7.  CEF sends an close notification to the application&#39;s top-level window.
// 8.  Application&#39;s top-level window receives the close notification and
//     allows the window to close based on the flag from #6B.
// 9.  Application&#39;s top-level window is destroyed. 10. Application&#39;s
// on_before_close() handler is called and the browser object
//     is destroyed.
// 11. Application exits by calling cef_quit_message_loop() if no other
// browsers
//     exist.
///
type DoCloseHandler interface {
	DoClose(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
	) (ret bool)
}

///
// Called just before a browser is destroyed. Release all references to the
// browser object and do not attempt to execute any functions on the browser
// object (other than IsValid, GetIdentifier or IsSame) after this callback
// returns. cef_frame_handler_t callbacks related to final main frame
// destruction will arrive after this callback and cef_browser_t::IsValid will
// return false (0) at that time. Any in-progress network requests associated
// with |browser| will be aborted when the browser is destroyed, and
// cef_resource_request_handler_t callbacks related to those requests may
// still arrive on the IO thread after this callback. See cef_frame_handler_t
// and do_close() documentation for additional usage information.
///
type OnBeforeCloseHandler interface {
	OnBeforeClose(
		self *CLifeSpanHandlerT,
		browser *CBrowserT,
	)
}

var life_span_handler_handlers = struct {
	handler                  map[*cCLifeSpanHandlerT]interface{}
	on_before_popup_handler  map[*cCLifeSpanHandlerT]OnBeforePopupHandler
	on_after_created_handler map[*cCLifeSpanHandlerT]OnAfterCreatedHandler
	do_close_handler         map[*cCLifeSpanHandlerT]DoCloseHandler
	on_before_close_handler  map[*cCLifeSpanHandlerT]OnBeforeCloseHandler
}{
	map[*cCLifeSpanHandlerT]interface{}{},
	map[*cCLifeSpanHandlerT]OnBeforePopupHandler{},
	map[*cCLifeSpanHandlerT]OnAfterCreatedHandler{},
	map[*cCLifeSpanHandlerT]DoCloseHandler{},
	map[*cCLifeSpanHandlerT]OnBeforeCloseHandler{},
}

// allocCLifeSpanHandlerT allocates CLifeSpanHandlerT and construct it
func allocCLifeSpanHandlerT() *CLifeSpanHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_life_span_handler_wrapper_t, "T155.3:")
	cefp := C.cefingo_construct_life_span_handler((*C.cefingo_life_span_handler_wrapper_t)(up))
	cgop := (*cCLifeSpanHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_life_span_handler_t itself in DeassocFunc,
		// or cef_life_span_handler_t is never GCed.
		Tracef(up, "T155.4:")
		unbindAllCLifeSpanHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCLifeSpanHandlerT(cefp, byApp)
}

// NewCLifeSpanHandlerT allocates CLifeSpanHandlerT, construct and bind it
func NewCLifeSpanHandlerT(a interface{}) *CLifeSpanHandlerT {
	return allocCLifeSpanHandlerT().bind(a)
}

func (life_span_handler *CLifeSpanHandlerT) bind(a interface{}) *CLifeSpanHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := life_span_handler.pc_life_span_handler
	life_span_handler_handlers.handler[cp] = a

	if h, ok := a.(OnBeforePopupHandler); ok {
		life_span_handler_handlers.on_before_popup_handler[cp] = h
		noBind = false
	} else {
		delete(life_span_handler_handlers.on_before_popup_handler, cp)
	}

	if h, ok := a.(OnAfterCreatedHandler); ok {
		life_span_handler_handlers.on_after_created_handler[cp] = h
		noBind = false
	} else {
		delete(life_span_handler_handlers.on_after_created_handler, cp)
	}

	if h, ok := a.(DoCloseHandler); ok {
		life_span_handler_handlers.do_close_handler[cp] = h
		noBind = false
	} else {
		delete(life_span_handler_handlers.do_close_handler, cp)
	}

	if h, ok := a.(OnBeforeCloseHandler); ok {
		life_span_handler_handlers.on_before_close_handler[cp] = h
		noBind = false
	} else {
		delete(life_span_handler_handlers.on_before_close_handler, cp)
	}

	if noBind {
		Panicln("F229: *CLifeSpanHandlerT No bind")
	}
	return life_span_handler
}

func unbindAllCLifeSpanHandlerT(cp *cCLifeSpanHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := life_span_handler.pc_life_span_handler
	delete(life_span_handler_handlers.handler, cp)

	delete(life_span_handler_handlers.on_before_popup_handler, cp)
	delete(life_span_handler_handlers.on_after_created_handler, cp)
	delete(life_span_handler_handlers.do_close_handler, cp)
	delete(life_span_handler_handlers.on_before_close_handler, cp)
}

func (life_span_handler *CLifeSpanHandlerT) UnbindAll() {
	unbindAllCLifeSpanHandlerT(life_span_handler.pc_life_span_handler)
	life_span_handler.Unref()
}

func (life_span_handler *CLifeSpanHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := life_span_handler.pc_life_span_handler
	return life_span_handler_handlers.handler[cp]
}

// cef_load_handler_capi.h, include/capi/cef_load_handler_capi.h:120:3,

///
// Implement this structure to handle events related to browser load status. The
// functions of this structure will be called on the browser process UI thread
// or render process main thread (TID_RENDERER).
///

type cCLoadHandlerT C.cef_load_handler_t

// Go type for cef_load_handler_t
type CLoadHandlerT struct {
	noCopy          noCopy
	pc_load_handler *cCLoadHandlerT
	beUnrefed       unrefedBy
}

func (p *CLoadHandlerT) Pass() (ret *CLoadHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCLoadHandlerT((*C.cef_load_handler_t)(p.pc_load_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CLoadHandlerT) NewRef() (newP *CLoadHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_load_handler
	BaseAddRef(gop)
	newP = newCLoadHandlerT((*C.cef_load_handler_t)(gop), byApp)
	return newP
}

// Go type CLoadHandlerT wraps cef type *C.cef_load_handler_t
func newCLoadHandlerT(p *C.cef_load_handler_t, unrefedBy unrefedBy) *CLoadHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T156.1:")
	pc := (*cCLoadHandlerT)(p)
	go_load_handler := &CLoadHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_load_handler, func(g *CLoadHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_load_handler != nil {
			Tracef(unsafe.Pointer(g.pc_load_handler), "T156.2:")
			BaseRelease(g.pc_load_handler)
		}
	})

	return go_load_handler
}

// *C.cef_load_handler_t has refCounted interface
func (load_handler *CLoadHandlerT) HasOneRef() bool {
	return BaseHasOneRef(load_handler.pc_load_handler)
}

func (p *cCLoadHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (load_handler *CLoadHandlerT) Unref() (ret bool) {
	if load_handler == nil {
		return
	}
	if load_handler.beUnrefed == byApp {
		ret = BaseRelease(load_handler.pc_load_handler)
		load_handler.beUnrefed = unrefed
	}
	load_handler.pc_load_handler = nil
	return ret
}

///
// Called when the loading state has changed. This callback will be executed
// twice -- once when loading is initiated either programmatically or by user
// action, and once when loading is terminated due to completion, cancellation
// of failure. It will be called before any calls to OnLoadStart and after all
// calls to OnLoadError and/or OnLoadEnd.
///
type OnLoadingStateChangeHandler interface {
	OnLoadingStateChange(
		self *CLoadHandlerT,
		browser *CBrowserT,
		isLoading bool,
		canGoBack bool,
		canGoForward bool,
	)
}

///
// Called after a navigation has been committed and before the browser begins
// loading contents in the frame. The |frame| value will never be NULL -- call
// the is_main() function to check if this frame is the main frame.
// |transition_type| provides information about the source of the navigation
// and an accurate value is only available in the browser process. Multiple
// frames may be loading at the same time. Sub-frames may start or continue
// loading after the main frame load has ended. This function will not be
// called for same page navigations (fragments, history state, etc.) or for
// navigations that fail or are canceled before commit. For notification of
// overall browser load status use OnLoadingStateChange instead.
///
type OnLoadStartHandler interface {
	OnLoadStart(
		self *CLoadHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		transition_type CTransitionTypeT,
	)
}

///
// Called when the browser is done loading a frame. The |frame| value will
// never be NULL -- call the is_main() function to check if this frame is the
// main frame. Multiple frames may be loading at the same time. Sub-frames may
// start or continue loading after the main frame load has ended. This
// function will not be called for same page navigations (fragments, history
// state, etc.) or for navigations that fail or are canceled before commit.
// For notification of overall browser load status use OnLoadingStateChange
// instead.
///
type OnLoadEndHandler interface {
	OnLoadEnd(
		self *CLoadHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		httpStatusCode int,
	)
}

///
// Called when a navigation fails or is canceled. This function may be called
// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
// after commit. |errorCode| is the error code number, |errorText| is the
// error text and |failedUrl| is the URL that failed to load. See
// net\base\net_error_list.h for complete descriptions of the error codes.
///
type OnLoadErrorHandler interface {
	OnLoadError(
		self *CLoadHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		errorCode CErrorcodeT,
		errorText string,
		failedUrl string,
	)
}

var load_handler_handlers = struct {
	handler                         map[*cCLoadHandlerT]interface{}
	on_loading_state_change_handler map[*cCLoadHandlerT]OnLoadingStateChangeHandler
	on_load_start_handler           map[*cCLoadHandlerT]OnLoadStartHandler
	on_load_end_handler             map[*cCLoadHandlerT]OnLoadEndHandler
	on_load_error_handler           map[*cCLoadHandlerT]OnLoadErrorHandler
}{
	map[*cCLoadHandlerT]interface{}{},
	map[*cCLoadHandlerT]OnLoadingStateChangeHandler{},
	map[*cCLoadHandlerT]OnLoadStartHandler{},
	map[*cCLoadHandlerT]OnLoadEndHandler{},
	map[*cCLoadHandlerT]OnLoadErrorHandler{},
}

// allocCLoadHandlerT allocates CLoadHandlerT and construct it
func allocCLoadHandlerT() *CLoadHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_load_handler_wrapper_t, "T156.3:")
	cefp := C.cefingo_construct_load_handler((*C.cefingo_load_handler_wrapper_t)(up))
	cgop := (*cCLoadHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_load_handler_t itself in DeassocFunc,
		// or cef_load_handler_t is never GCed.
		Tracef(up, "T156.4:")
		unbindAllCLoadHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCLoadHandlerT(cefp, byApp)
}

// NewCLoadHandlerT allocates CLoadHandlerT, construct and bind it
func NewCLoadHandlerT(a interface{}) *CLoadHandlerT {
	return allocCLoadHandlerT().bind(a)
}

func (load_handler *CLoadHandlerT) bind(a interface{}) *CLoadHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := load_handler.pc_load_handler
	load_handler_handlers.handler[cp] = a

	if h, ok := a.(OnLoadingStateChangeHandler); ok {
		load_handler_handlers.on_loading_state_change_handler[cp] = h
		noBind = false
	} else {
		delete(load_handler_handlers.on_loading_state_change_handler, cp)
	}

	if h, ok := a.(OnLoadStartHandler); ok {
		load_handler_handlers.on_load_start_handler[cp] = h
		noBind = false
	} else {
		delete(load_handler_handlers.on_load_start_handler, cp)
	}

	if h, ok := a.(OnLoadEndHandler); ok {
		load_handler_handlers.on_load_end_handler[cp] = h
		noBind = false
	} else {
		delete(load_handler_handlers.on_load_end_handler, cp)
	}

	if h, ok := a.(OnLoadErrorHandler); ok {
		load_handler_handlers.on_load_error_handler[cp] = h
		noBind = false
	} else {
		delete(load_handler_handlers.on_load_error_handler, cp)
	}

	if noBind {
		Panicln("F229: *CLoadHandlerT No bind")
	}
	return load_handler
}

func unbindAllCLoadHandlerT(cp *cCLoadHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := load_handler.pc_load_handler
	delete(load_handler_handlers.handler, cp)

	delete(load_handler_handlers.on_loading_state_change_handler, cp)
	delete(load_handler_handlers.on_load_start_handler, cp)
	delete(load_handler_handlers.on_load_end_handler, cp)
	delete(load_handler_handlers.on_load_error_handler, cp)
}

func (load_handler *CLoadHandlerT) UnbindAll() {
	unbindAllCLoadHandlerT(load_handler.pc_load_handler)
	load_handler.Unref()
}

func (load_handler *CLoadHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := load_handler.pc_load_handler
	return load_handler_handlers.handler[cp]
}

// cef_media_router_capi.h, include/capi/cef_media_router_capi.h:111:3,

///
// Supports discovery of and communication with media devices on the local
// network via the Cast and DIAL protocols. The functions of this structure may
// be called on any browser process thread unless otherwise indicated.
///

type cCMediaRouterT C.cef_media_router_t

// Go type for cef_media_router_t
type CMediaRouterT struct {
	noCopy          noCopy
	pc_media_router *cCMediaRouterT
	beUnrefed       unrefedBy
}

func (p *CMediaRouterT) Pass() (ret *CMediaRouterT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMediaRouterT((*C.cef_media_router_t)(p.pc_media_router), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMediaRouterT) NewRef() (newP *CMediaRouterT) {
	if self == nil {
		return newP
	}
	gop := self.pc_media_router
	BaseAddRef(gop)
	newP = newCMediaRouterT((*C.cef_media_router_t)(gop), byApp)
	return newP
}

// Go type CMediaRouterT wraps cef type *C.cef_media_router_t
func newCMediaRouterT(p *C.cef_media_router_t, unrefedBy unrefedBy) *CMediaRouterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T157.1:")
	pc := (*cCMediaRouterT)(p)
	go_media_router := &CMediaRouterT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_media_router, func(g *CMediaRouterT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_media_router != nil {
			Tracef(unsafe.Pointer(g.pc_media_router), "T157.2:")
			BaseRelease(g.pc_media_router)
		}
	})

	return go_media_router
}

// *C.cef_media_router_t has refCounted interface
func (media_router *CMediaRouterT) HasOneRef() bool {
	return BaseHasOneRef(media_router.pc_media_router)
}

func (p *cCMediaRouterT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (media_router *CMediaRouterT) Unref() (ret bool) {
	if media_router == nil {
		return
	}
	if media_router.beUnrefed == byApp {
		ret = BaseRelease(media_router.pc_media_router)
		media_router.beUnrefed = unrefed
	}
	media_router.pc_media_router = nil
	return ret
}

///
// Add an observer for MediaRouter events. The observer will remain registered
// until the returned Registration object is destroyed.
///
func (self *CMediaRouterT) AddObserver(
	observer *CMediaObserverT,
) (ret *CRegistrationT) {
	var goTmpobserver *C.cef_media_observer_t
	if observer != nil {
		BaseAddRef(observer.pc_media_observer)
		goTmpobserver = (*C.cef_media_observer_t)(observer.pc_media_observer)
	}

	cRet := C.cefingo_media_router_add_observer((*C.cef_media_router_t)(self.pc_media_router), goTmpobserver)

	ret = newCRegistrationT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns a MediaSource object for the specified media source URN. Supported
// URN schemes include &quot;cast:&quot; and &quot;dial:&quot;, and will be already known by the
// client application (e.g. &quot;cast:&lt;appId&gt;?clientId=&lt;clientId&gt;&quot;).
///
func (self *CMediaRouterT) GetSource(
	urn string,
) (ret *CMediaSourceT) {
	c_urn := create_cef_string(urn)

	cRet := C.cefingo_media_router_get_source((*C.cef_media_router_t)(self.pc_media_router), c_urn.p_cef_string_t)

	ret = newCMediaSourceT(cRet, byApp) // return GoObj
	return ret
}

///
// Trigger an asynchronous call to cef_media_observer_t::OnSinks on all
// registered observers.
///
func (self *CMediaRouterT) NotifyCurrentSinks() {

	C.cefingo_media_router_notify_current_sinks((*C.cef_media_router_t)(self.pc_media_router))

}

///
// Create a new route between |source| and |sink|. Source and sink must be
// valid, compatible (as reported by cef_media_sink_t::IsCompatibleWith), and
// a route between them must not already exist. |callback| will be executed on
// success or failure. If route creation succeeds it will also trigger an
// asynchronous call to cef_media_observer_t::OnRoutes on all registered
// observers.
///
func (self *CMediaRouterT) CreateRoute(
	source *CMediaSourceT,
	sink *CMediaSinkT,
	callback *CMediaRouteCreateCallbackT,
) {
	var goTmpsource *C.cef_media_source_t
	if source != nil {
		BaseAddRef(source.pc_media_source)
		goTmpsource = (*C.cef_media_source_t)(source.pc_media_source)
	}
	var goTmpsink *C.cef_media_sink_t
	if sink != nil {
		BaseAddRef(sink.pc_media_sink)
		goTmpsink = (*C.cef_media_sink_t)(sink.pc_media_sink)
	}
	var goTmpcallback *C.cef_media_route_create_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_media_route_create_callback)
		goTmpcallback = (*C.cef_media_route_create_callback_t)(callback.pc_media_route_create_callback)
	}

	C.cefingo_media_router_create_route((*C.cef_media_router_t)(self.pc_media_router), goTmpsource, goTmpsink, goTmpcallback)

}

///
// Trigger an asynchronous call to cef_media_observer_t::OnRoutes on all
// registered observers.
///
func (self *CMediaRouterT) NotifyCurrentRoutes() {

	C.cefingo_media_router_notify_current_routes((*C.cef_media_router_t)(self.pc_media_router))

}

///
// Returns the MediaRouter object associated with the global request context. If
// |callback| is non-NULL it will be executed asnychronously on the UI thread
// after the manager's storage has been initialized. Equivalent to calling cef_r
// equest_context_t::cef_request_context_get_global_context()->get_media_router(
// ).
///
func MediaRouterGetGlobal(
	callback *CCompletionCallbackT,
) (ret *CMediaRouterT) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	cRet := C.cef_media_router_get_global(goTmpcallback)

	ret = newCMediaRouterT(cRet, byApp) // return GoObj
	return ret
}

///
// Implemented by the client to observe MediaRouter events and registered via
// cef_media_router_t::AddObserver. The functions of this structure will be
// called on the browser process UI thread.
///

type cCMediaObserverT C.cef_media_observer_t

// Go type for cef_media_observer_t
type CMediaObserverT struct {
	noCopy            noCopy
	pc_media_observer *cCMediaObserverT
	beUnrefed         unrefedBy
}

func (p *CMediaObserverT) Pass() (ret *CMediaObserverT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMediaObserverT((*C.cef_media_observer_t)(p.pc_media_observer), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMediaObserverT) NewRef() (newP *CMediaObserverT) {
	if self == nil {
		return newP
	}
	gop := self.pc_media_observer
	BaseAddRef(gop)
	newP = newCMediaObserverT((*C.cef_media_observer_t)(gop), byApp)
	return newP
}

// Go type CMediaObserverT wraps cef type *C.cef_media_observer_t
func newCMediaObserverT(p *C.cef_media_observer_t, unrefedBy unrefedBy) *CMediaObserverT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T158.1:")
	pc := (*cCMediaObserverT)(p)
	go_media_observer := &CMediaObserverT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_media_observer, func(g *CMediaObserverT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_media_observer != nil {
			Tracef(unsafe.Pointer(g.pc_media_observer), "T158.2:")
			BaseRelease(g.pc_media_observer)
		}
	})

	return go_media_observer
}

// *C.cef_media_observer_t has refCounted interface
func (media_observer *CMediaObserverT) HasOneRef() bool {
	return BaseHasOneRef(media_observer.pc_media_observer)
}

func (p *cCMediaObserverT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (media_observer *CMediaObserverT) Unref() (ret bool) {
	if media_observer == nil {
		return
	}
	if media_observer.beUnrefed == byApp {
		ret = BaseRelease(media_observer.pc_media_observer)
		media_observer.beUnrefed = unrefed
	}
	media_observer.pc_media_observer = nil
	return ret
}

///
// The list of available media sinks has changed or
// cef_media_router_t::NotifyCurrentSinks was called.
///
type OnSinksHandler interface {
	OnSinks(
		self *CMediaObserverT,
		sinks []*CMediaSinkT,
	)
}

///
// The list of available media routes has changed or
// cef_media_router_t::NotifyCurrentRoutes was called.
///
type OnRoutesHandler interface {
	OnRoutes(
		self *CMediaObserverT,
		routes []*CMediaRouteT,
	)
}

///
// The connection state of |route| has changed.
///
type OnRouteStateChangedHandler interface {
	OnRouteStateChanged(
		self *CMediaObserverT,
		route *CMediaRouteT,
		state CMediaRouteConnectionStateT,
	)
}

///
// A message was recieved over |route|. |message| is only valid for the scope
// of this callback and should be copied if necessary.
///
type OnRouteMessageReceivedHandler interface {
	OnRouteMessageReceived(
		self *CMediaObserverT,
		route *CMediaRouteT,
		message []byte,
	)
}

var media_observer_handlers = struct {
	handler                           map[*cCMediaObserverT]interface{}
	on_sinks_handler                  map[*cCMediaObserverT]OnSinksHandler
	on_routes_handler                 map[*cCMediaObserverT]OnRoutesHandler
	on_route_state_changed_handler    map[*cCMediaObserverT]OnRouteStateChangedHandler
	on_route_message_received_handler map[*cCMediaObserverT]OnRouteMessageReceivedHandler
}{
	map[*cCMediaObserverT]interface{}{},
	map[*cCMediaObserverT]OnSinksHandler{},
	map[*cCMediaObserverT]OnRoutesHandler{},
	map[*cCMediaObserverT]OnRouteStateChangedHandler{},
	map[*cCMediaObserverT]OnRouteMessageReceivedHandler{},
}

// allocCMediaObserverT allocates CMediaObserverT and construct it
func allocCMediaObserverT() *CMediaObserverT {
	up := c_calloc(1, C.sizeof_cefingo_media_observer_wrapper_t, "T158.3:")
	cefp := C.cefingo_construct_media_observer((*C.cefingo_media_observer_wrapper_t)(up))
	cgop := (*cCMediaObserverT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_media_observer_t itself in DeassocFunc,
		// or cef_media_observer_t is never GCed.
		Tracef(up, "T158.4:")
		unbindAllCMediaObserverT(cgop)
	}))

	BaseAddRef(cgop)
	return newCMediaObserverT(cefp, byApp)
}

// NewCMediaObserverT allocates CMediaObserverT, construct and bind it
func NewCMediaObserverT(a interface{}) *CMediaObserverT {
	return allocCMediaObserverT().bind(a)
}

func (media_observer *CMediaObserverT) bind(a interface{}) *CMediaObserverT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := media_observer.pc_media_observer
	media_observer_handlers.handler[cp] = a

	if h, ok := a.(OnSinksHandler); ok {
		media_observer_handlers.on_sinks_handler[cp] = h
		noBind = false
	} else {
		delete(media_observer_handlers.on_sinks_handler, cp)
	}

	if h, ok := a.(OnRoutesHandler); ok {
		media_observer_handlers.on_routes_handler[cp] = h
		noBind = false
	} else {
		delete(media_observer_handlers.on_routes_handler, cp)
	}

	if h, ok := a.(OnRouteStateChangedHandler); ok {
		media_observer_handlers.on_route_state_changed_handler[cp] = h
		noBind = false
	} else {
		delete(media_observer_handlers.on_route_state_changed_handler, cp)
	}

	if h, ok := a.(OnRouteMessageReceivedHandler); ok {
		media_observer_handlers.on_route_message_received_handler[cp] = h
		noBind = false
	} else {
		delete(media_observer_handlers.on_route_message_received_handler, cp)
	}

	if noBind {
		Panicln("F229: *CMediaObserverT No bind")
	}
	return media_observer
}

func unbindAllCMediaObserverT(cp *cCMediaObserverT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := media_observer.pc_media_observer
	delete(media_observer_handlers.handler, cp)

	delete(media_observer_handlers.on_sinks_handler, cp)
	delete(media_observer_handlers.on_routes_handler, cp)
	delete(media_observer_handlers.on_route_state_changed_handler, cp)
	delete(media_observer_handlers.on_route_message_received_handler, cp)
}

func (media_observer *CMediaObserverT) UnbindAll() {
	unbindAllCMediaObserverT(media_observer.pc_media_observer)
	media_observer.Unref()
}

func (media_observer *CMediaObserverT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := media_observer.pc_media_observer
	return media_observer_handlers.handler[cp]
}

///
// Represents the route between a media source and sink. Instances of this
// object are created via cef_media_router_t::CreateRoute and retrieved via
// cef_media_observer_t::OnRoutes. Contains the status and metadata of a routing
// operation. The functions of this structure may be called on any browser
// process thread unless otherwise indicated.
///

type cCMediaRouteT C.cef_media_route_t

// Go type for cef_media_route_t
type CMediaRouteT struct {
	noCopy         noCopy
	pc_media_route *cCMediaRouteT
	beUnrefed      unrefedBy
}

func (p *CMediaRouteT) Pass() (ret *CMediaRouteT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMediaRouteT((*C.cef_media_route_t)(p.pc_media_route), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMediaRouteT) NewRef() (newP *CMediaRouteT) {
	if self == nil {
		return newP
	}
	gop := self.pc_media_route
	BaseAddRef(gop)
	newP = newCMediaRouteT((*C.cef_media_route_t)(gop), byApp)
	return newP
}

// Go type CMediaRouteT wraps cef type *C.cef_media_route_t
func newCMediaRouteT(p *C.cef_media_route_t, unrefedBy unrefedBy) *CMediaRouteT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T159.1:")
	pc := (*cCMediaRouteT)(p)
	go_media_route := &CMediaRouteT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_media_route, func(g *CMediaRouteT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_media_route != nil {
			Tracef(unsafe.Pointer(g.pc_media_route), "T159.2:")
			BaseRelease(g.pc_media_route)
		}
	})

	return go_media_route
}

// *C.cef_media_route_t has refCounted interface
func (media_route *CMediaRouteT) HasOneRef() bool {
	return BaseHasOneRef(media_route.pc_media_route)
}

func (p *cCMediaRouteT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (media_route *CMediaRouteT) Unref() (ret bool) {
	if media_route == nil {
		return
	}
	if media_route.beUnrefed == byApp {
		ret = BaseRelease(media_route.pc_media_route)
		media_route.beUnrefed = unrefed
	}
	media_route.pc_media_route = nil
	return ret
}

///
// Returns the ID for this route.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaRouteT) GetId() (ret string) {

	cRet := C.cefingo_media_route_get_id((*C.cef_media_route_t)(self.pc_media_route))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the source associated with this route.
///
func (self *CMediaRouteT) GetSource() (ret *CMediaSourceT) {

	cRet := C.cefingo_media_route_get_source((*C.cef_media_route_t)(self.pc_media_route))

	ret = newCMediaSourceT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the sink associated with this route.
///
func (self *CMediaRouteT) GetSink() (ret *CMediaSinkT) {

	cRet := C.cefingo_media_route_get_sink((*C.cef_media_route_t)(self.pc_media_route))

	ret = newCMediaSinkT(cRet, byApp) // return GoObj
	return ret
}

///
// Send a message over this route. |message| will be copied if necessary.
///
func (self *CMediaRouteT) SendRouteMessage(
	message []byte,
) {
	message_size := len(message)
	tmpmessage := C.CBytes(message)
	defer C.free(tmpmessage)

	C.cefingo_media_route_send_route_message((*C.cef_media_route_t)(self.pc_media_route), tmpmessage, (C.size_t)(message_size))

}

///
// Terminate this route. Will result in an asynchronous call to
// cef_media_observer_t::OnRoutes on all registered observers.
///
func (self *CMediaRouteT) Terminate() {

	C.cefingo_media_route_terminate((*C.cef_media_route_t)(self.pc_media_route))

}

///
// Callback structure for cef_media_router_t::CreateRoute. The functions of this
// structure will be called on the browser process UI thread.
///

type cCMediaRouteCreateCallbackT C.cef_media_route_create_callback_t

// Go type for cef_media_route_create_callback_t
type CMediaRouteCreateCallbackT struct {
	noCopy                         noCopy
	pc_media_route_create_callback *cCMediaRouteCreateCallbackT
	beUnrefed                      unrefedBy
}

func (p *CMediaRouteCreateCallbackT) Pass() (ret *CMediaRouteCreateCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMediaRouteCreateCallbackT((*C.cef_media_route_create_callback_t)(p.pc_media_route_create_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMediaRouteCreateCallbackT) NewRef() (newP *CMediaRouteCreateCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_media_route_create_callback
	BaseAddRef(gop)
	newP = newCMediaRouteCreateCallbackT((*C.cef_media_route_create_callback_t)(gop), byApp)
	return newP
}

// Go type CMediaRouteCreateCallbackT wraps cef type *C.cef_media_route_create_callback_t
func newCMediaRouteCreateCallbackT(p *C.cef_media_route_create_callback_t, unrefedBy unrefedBy) *CMediaRouteCreateCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T160.1:")
	pc := (*cCMediaRouteCreateCallbackT)(p)
	go_media_route_create_callback := &CMediaRouteCreateCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_media_route_create_callback, func(g *CMediaRouteCreateCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_media_route_create_callback != nil {
			Tracef(unsafe.Pointer(g.pc_media_route_create_callback), "T160.2:")
			BaseRelease(g.pc_media_route_create_callback)
		}
	})

	return go_media_route_create_callback
}

// *C.cef_media_route_create_callback_t has refCounted interface
func (media_route_create_callback *CMediaRouteCreateCallbackT) HasOneRef() bool {
	return BaseHasOneRef(media_route_create_callback.pc_media_route_create_callback)
}

func (p *cCMediaRouteCreateCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (media_route_create_callback *CMediaRouteCreateCallbackT) Unref() (ret bool) {
	if media_route_create_callback == nil {
		return
	}
	if media_route_create_callback.beUnrefed == byApp {
		ret = BaseRelease(media_route_create_callback.pc_media_route_create_callback)
		media_route_create_callback.beUnrefed = unrefed
	}
	media_route_create_callback.pc_media_route_create_callback = nil
	return ret
}

///
// Method that will be executed when the route creation has finished. |result|
// will be CEF_MRCR_OK if the route creation succeeded. |error| will be a
// description of the error if the route creation failed. |route| is the
// resulting route, or NULL if the route creation failed.
///
func (self *CMediaRouteCreateCallbackT) OnMediaRouteCreateFinished(
	result CMediaRouteCreateResultT,
	error string,
	route *CMediaRouteT,
) {
	c_error := create_cef_string(error)
	var goTmproute *C.cef_media_route_t
	if route != nil {
		BaseAddRef(route.pc_media_route)
		goTmproute = (*C.cef_media_route_t)(route.pc_media_route)
	}

	C.cefingo_media_route_create_callback_on_media_route_create_finished((*C.cef_media_route_create_callback_t)(self.pc_media_route_create_callback), (C.cef_media_route_create_result_t)(result), c_error.p_cef_string_t, goTmproute)

}

///
// Represents a sink to which media can be routed. Instances of this object are
// retrieved via cef_media_observer_t::OnSinks. The functions of this structure
// may be called on any browser process thread unless otherwise indicated.
///

type cCMediaSinkT C.cef_media_sink_t

// Go type for cef_media_sink_t
type CMediaSinkT struct {
	noCopy        noCopy
	pc_media_sink *cCMediaSinkT
	beUnrefed     unrefedBy
}

func (p *CMediaSinkT) Pass() (ret *CMediaSinkT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMediaSinkT((*C.cef_media_sink_t)(p.pc_media_sink), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMediaSinkT) NewRef() (newP *CMediaSinkT) {
	if self == nil {
		return newP
	}
	gop := self.pc_media_sink
	BaseAddRef(gop)
	newP = newCMediaSinkT((*C.cef_media_sink_t)(gop), byApp)
	return newP
}

// Go type CMediaSinkT wraps cef type *C.cef_media_sink_t
func newCMediaSinkT(p *C.cef_media_sink_t, unrefedBy unrefedBy) *CMediaSinkT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T161.1:")
	pc := (*cCMediaSinkT)(p)
	go_media_sink := &CMediaSinkT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_media_sink, func(g *CMediaSinkT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_media_sink != nil {
			Tracef(unsafe.Pointer(g.pc_media_sink), "T161.2:")
			BaseRelease(g.pc_media_sink)
		}
	})

	return go_media_sink
}

// *C.cef_media_sink_t has refCounted interface
func (media_sink *CMediaSinkT) HasOneRef() bool {
	return BaseHasOneRef(media_sink.pc_media_sink)
}

func (p *cCMediaSinkT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (media_sink *CMediaSinkT) Unref() (ret bool) {
	if media_sink == nil {
		return
	}
	if media_sink.beUnrefed == byApp {
		ret = BaseRelease(media_sink.pc_media_sink)
		media_sink.beUnrefed = unrefed
	}
	media_sink.pc_media_sink = nil
	return ret
}

///
// Returns the ID for this sink.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSinkT) GetId() (ret string) {

	cRet := C.cefingo_media_sink_get_id((*C.cef_media_sink_t)(self.pc_media_sink))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the name of this sink.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSinkT) GetName() (ret string) {

	cRet := C.cefingo_media_sink_get_name((*C.cef_media_sink_t)(self.pc_media_sink))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the description of this sink.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSinkT) GetDescription() (ret string) {

	cRet := C.cefingo_media_sink_get_description((*C.cef_media_sink_t)(self.pc_media_sink))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the icon type for this sink.
///
func (self *CMediaSinkT) GetIconType() (ret CMediaSinkIconTypeT) {

	cRet := C.cefingo_media_sink_get_icon_type((*C.cef_media_sink_t)(self.pc_media_sink))

	ret = CMediaSinkIconTypeT(cRet) // return GoObj
	return ret
}

///
// Asynchronously retrieves device info.
///
func (self *CMediaSinkT) GetDeviceInfo(
	callback *CMediaSinkDeviceInfoCallbackT,
) {
	var goTmpcallback *C.cef_media_sink_device_info_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_media_sink_device_info_callback)
		goTmpcallback = (*C.cef_media_sink_device_info_callback_t)(callback.pc_media_sink_device_info_callback)
	}

	C.cefingo_media_sink_get_device_info((*C.cef_media_sink_t)(self.pc_media_sink), goTmpcallback)

}

///
// Returns true (1) if this sink accepts content via Cast.
///
func (self *CMediaSinkT) IsCastSink() (ret bool) {

	cRet := C.cefingo_media_sink_is_cast_sink((*C.cef_media_sink_t)(self.pc_media_sink))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this sink accepts content via DIAL.
///
func (self *CMediaSinkT) IsDialSink() (ret bool) {

	cRet := C.cefingo_media_sink_is_dial_sink((*C.cef_media_sink_t)(self.pc_media_sink))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this sink is compatible with |source|.
///
func (self *CMediaSinkT) IsCompatibleWith(
	source *CMediaSourceT,
) (ret bool) {
	var goTmpsource *C.cef_media_source_t
	if source != nil {
		BaseAddRef(source.pc_media_source)
		goTmpsource = (*C.cef_media_source_t)(source.pc_media_source)
	}

	cRet := C.cefingo_media_sink_is_compatible_with((*C.cef_media_sink_t)(self.pc_media_sink), goTmpsource)

	ret = cRet == 1
	return ret
}

///
// Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of this
// structure will be called on the browser process UI thread.
///

type cCMediaSinkDeviceInfoCallbackT C.cef_media_sink_device_info_callback_t

// Go type for cef_media_sink_device_info_callback_t
type CMediaSinkDeviceInfoCallbackT struct {
	noCopy                             noCopy
	pc_media_sink_device_info_callback *cCMediaSinkDeviceInfoCallbackT
	beUnrefed                          unrefedBy
}

func (p *CMediaSinkDeviceInfoCallbackT) Pass() (ret *CMediaSinkDeviceInfoCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMediaSinkDeviceInfoCallbackT((*C.cef_media_sink_device_info_callback_t)(p.pc_media_sink_device_info_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMediaSinkDeviceInfoCallbackT) NewRef() (newP *CMediaSinkDeviceInfoCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_media_sink_device_info_callback
	BaseAddRef(gop)
	newP = newCMediaSinkDeviceInfoCallbackT((*C.cef_media_sink_device_info_callback_t)(gop), byApp)
	return newP
}

// Go type CMediaSinkDeviceInfoCallbackT wraps cef type *C.cef_media_sink_device_info_callback_t
func newCMediaSinkDeviceInfoCallbackT(p *C.cef_media_sink_device_info_callback_t, unrefedBy unrefedBy) *CMediaSinkDeviceInfoCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T338.1:")
	pc := (*cCMediaSinkDeviceInfoCallbackT)(p)
	go_media_sink_device_info_callback := &CMediaSinkDeviceInfoCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_media_sink_device_info_callback, func(g *CMediaSinkDeviceInfoCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_media_sink_device_info_callback != nil {
			Tracef(unsafe.Pointer(g.pc_media_sink_device_info_callback), "T338.2:")
			BaseRelease(g.pc_media_sink_device_info_callback)
		}
	})

	return go_media_sink_device_info_callback
}

// *C.cef_media_sink_device_info_callback_t has refCounted interface
func (media_sink_device_info_callback *CMediaSinkDeviceInfoCallbackT) HasOneRef() bool {
	return BaseHasOneRef(media_sink_device_info_callback.pc_media_sink_device_info_callback)
}

func (p *cCMediaSinkDeviceInfoCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (media_sink_device_info_callback *CMediaSinkDeviceInfoCallbackT) Unref() (ret bool) {
	if media_sink_device_info_callback == nil {
		return
	}
	if media_sink_device_info_callback.beUnrefed == byApp {
		ret = BaseRelease(media_sink_device_info_callback.pc_media_sink_device_info_callback)
		media_sink_device_info_callback.beUnrefed = unrefed
	}
	media_sink_device_info_callback.pc_media_sink_device_info_callback = nil
	return ret
}

///
// Method that will be executed asyncronously once device information has been
// retrieved.
///
func (self *CMediaSinkDeviceInfoCallbackT) OnMediaSinkDeviceInfo(
	device_info *CMediaSinkDeviceInfoT,
) {

	C.cefingo_media_sink_device_info_callback_on_media_sink_device_info((*C.cef_media_sink_device_info_callback_t)(self.pc_media_sink_device_info_callback), (*C.cef_media_sink_device_info_t)(device_info))

}

///
// Represents a source from which media can be routed. Instances of this object
// are retrieved via cef_media_router_t::GetSource. The functions of this
// structure may be called on any browser process thread unless otherwise
// indicated.
///

type cCMediaSourceT C.cef_media_source_t

// Go type for cef_media_source_t
type CMediaSourceT struct {
	noCopy          noCopy
	pc_media_source *cCMediaSourceT
	beUnrefed       unrefedBy
}

func (p *CMediaSourceT) Pass() (ret *CMediaSourceT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMediaSourceT((*C.cef_media_source_t)(p.pc_media_source), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMediaSourceT) NewRef() (newP *CMediaSourceT) {
	if self == nil {
		return newP
	}
	gop := self.pc_media_source
	BaseAddRef(gop)
	newP = newCMediaSourceT((*C.cef_media_source_t)(gop), byApp)
	return newP
}

// Go type CMediaSourceT wraps cef type *C.cef_media_source_t
func newCMediaSourceT(p *C.cef_media_source_t, unrefedBy unrefedBy) *CMediaSourceT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T162.1:")
	pc := (*cCMediaSourceT)(p)
	go_media_source := &CMediaSourceT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_media_source, func(g *CMediaSourceT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_media_source != nil {
			Tracef(unsafe.Pointer(g.pc_media_source), "T162.2:")
			BaseRelease(g.pc_media_source)
		}
	})

	return go_media_source
}

// *C.cef_media_source_t has refCounted interface
func (media_source *CMediaSourceT) HasOneRef() bool {
	return BaseHasOneRef(media_source.pc_media_source)
}

func (p *cCMediaSourceT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (media_source *CMediaSourceT) Unref() (ret bool) {
	if media_source == nil {
		return
	}
	if media_source.beUnrefed == byApp {
		ret = BaseRelease(media_source.pc_media_source)
		media_source.beUnrefed = unrefed
	}
	media_source.pc_media_source = nil
	return ret
}

///
// Returns the ID (media source URN or URL) for this source.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMediaSourceT) GetId() (ret string) {

	cRet := C.cefingo_media_source_get_id((*C.cef_media_source_t)(self.pc_media_source))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this source outputs its content via Cast.
///
func (self *CMediaSourceT) IsCastSource() (ret bool) {

	cRet := C.cefingo_media_source_is_cast_source((*C.cef_media_source_t)(self.pc_media_source))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this source outputs its content via DIAL.
///
func (self *CMediaSourceT) IsDialSource() (ret bool) {

	cRet := C.cefingo_media_source_is_dial_source((*C.cef_media_source_t)(self.pc_media_source))

	ret = cRet == 1
	return ret
}

// cef_menu_button_capi.h, include/capi/views/cef_menu_button_capi.h:79:3,

///
// MenuButton is a button with optional text, icon and/or menu marker that shows
// a menu when clicked with the left mouse button. All size and position values
// are in density independent pixels (DIP) unless otherwise indicated. Methods
// must be called on the browser process UI thread unless otherwise indicated.
///

type cCMenuButtonT C.cef_menu_button_t

// Go type for cef_menu_button_t
type CMenuButtonT struct {
	noCopy         noCopy
	pc_menu_button *cCMenuButtonT
	beUnrefed      unrefedBy
}

func (p *CMenuButtonT) Pass() (ret *CMenuButtonT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMenuButtonT((*C.cef_menu_button_t)(p.pc_menu_button), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMenuButtonT) NewRef() (newP *CMenuButtonT) {
	if self == nil {
		return newP
	}
	gop := self.pc_menu_button
	BaseAddRef(gop)
	newP = newCMenuButtonT((*C.cef_menu_button_t)(gop), byApp)
	return newP
}

// Go type CMenuButtonT wraps cef type *C.cef_menu_button_t
func newCMenuButtonT(p *C.cef_menu_button_t, unrefedBy unrefedBy) *CMenuButtonT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T163.1:")
	pc := (*cCMenuButtonT)(p)
	go_menu_button := &CMenuButtonT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_menu_button, func(g *CMenuButtonT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_menu_button != nil {
			Tracef(unsafe.Pointer(g.pc_menu_button), "T163.2:")
			BaseRelease(g.pc_menu_button)
		}
	})

	return go_menu_button
}

// *C.cef_menu_button_t has refCounted interface
func (menu_button *CMenuButtonT) HasOneRef() bool {
	return BaseHasOneRef(menu_button.pc_menu_button)
}

func (p *cCMenuButtonT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (menu_button *CMenuButtonT) Unref() (ret bool) {
	if menu_button == nil {
		return
	}
	if menu_button.beUnrefed == byApp {
		ret = BaseRelease(menu_button.pc_menu_button)
		menu_button.beUnrefed = unrefed
	}
	menu_button.pc_menu_button = nil
	return ret
}

// Convert to Base Class Pointer *CLabelButtonT
func (menu_button *CMenuButtonT) ToCLabelButtonT() *CLabelButtonT {
	p := (*C.cef_label_button_t)(unsafe.Pointer(menu_button.pc_menu_button))
	BaseAddRef(menu_button.pc_menu_button)
	return newCLabelButtonT(p, byApp)
}

///
// Show a menu with contents |menu_model|. |screen_point| specifies the menu
// position in screen coordinates. |anchor_position| specifies how the menu
// will be anchored relative to |screen_point|. This function should be called
// from cef_menu_button_delegate_t::on_menu_button_pressed().
///
func (self *CMenuButtonT) ShowMenu(
	menu_model *CMenuModelT,
	screen_point *CPointT,
	anchor_position CMenuAnchorPositionT,
) {
	var goTmpmenu_model *C.cef_menu_model_t
	if menu_model != nil {
		BaseAddRef(menu_model.pc_menu_model)
		goTmpmenu_model = (*C.cef_menu_model_t)(menu_model.pc_menu_model)
	}

	C.cefingo_menu_button_show_menu((*C.cef_menu_button_t)(self.pc_menu_button), goTmpmenu_model, (*C.cef_point_t)(screen_point), (C.cef_menu_anchor_position_t)(anchor_position))

}

///
// Show the menu for this button. Results in a call to
// cef_menu_button_delegate_t::on_menu_button_pressed().
///
func (self *CMenuButtonT) TriggerMenu() {

	C.cefingo_menu_button_trigger_menu((*C.cef_menu_button_t)(self.pc_menu_button))

}

///
// Create a new MenuButton. A |delegate| must be provided to call show_menu()
// when the button is clicked. |text| will be shown on the MenuButton and used
// as the default accessible name. If |with_frame| is true (1) the button will
// have a visible frame at all times, center alignment, additional padding and a
// default minimum size of 70x33 DIP. If |with_frame| is false (0) the button
// will only have a visible frame on hover/press, left alignment, less padding
// and no default minimum size.
///
func MenuButtonCreate(
	delegate *CMenuButtonDelegateT,
	text string,
) (ret *CMenuButtonT) {
	var goTmpdelegate *C.cef_menu_button_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_menu_button_delegate)
		goTmpdelegate = (*C.cef_menu_button_delegate_t)(delegate.pc_menu_button_delegate)
	}
	c_text := create_cef_string(text)

	cRet := C.cef_menu_button_create(goTmpdelegate, c_text.p_cef_string_t)

	ret = newCMenuButtonT(cRet, byApp) // return GoObj
	return ret
}

// cef_menu_button_delegate_capi.h, include/capi/views/cef_menu_button_delegate_capi.h:59:3,

///
// MenuButton pressed lock is released when this object is destroyed.
///

type cCMenuButtonPressedLockT C.cef_menu_button_pressed_lock_t

// Go type for cef_menu_button_pressed_lock_t
type CMenuButtonPressedLockT struct {
	noCopy                      noCopy
	pc_menu_button_pressed_lock *cCMenuButtonPressedLockT
	beUnrefed                   unrefedBy
}

func (p *CMenuButtonPressedLockT) Pass() (ret *CMenuButtonPressedLockT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMenuButtonPressedLockT((*C.cef_menu_button_pressed_lock_t)(p.pc_menu_button_pressed_lock), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMenuButtonPressedLockT) NewRef() (newP *CMenuButtonPressedLockT) {
	if self == nil {
		return newP
	}
	gop := self.pc_menu_button_pressed_lock
	BaseAddRef(gop)
	newP = newCMenuButtonPressedLockT((*C.cef_menu_button_pressed_lock_t)(gop), byApp)
	return newP
}

// Go type CMenuButtonPressedLockT wraps cef type *C.cef_menu_button_pressed_lock_t
func newCMenuButtonPressedLockT(p *C.cef_menu_button_pressed_lock_t, unrefedBy unrefedBy) *CMenuButtonPressedLockT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T164.1:")
	pc := (*cCMenuButtonPressedLockT)(p)
	go_menu_button_pressed_lock := &CMenuButtonPressedLockT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_menu_button_pressed_lock, func(g *CMenuButtonPressedLockT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_menu_button_pressed_lock != nil {
			Tracef(unsafe.Pointer(g.pc_menu_button_pressed_lock), "T164.2:")
			BaseRelease(g.pc_menu_button_pressed_lock)
		}
	})

	return go_menu_button_pressed_lock
}

// *C.cef_menu_button_pressed_lock_t has refCounted interface
func (menu_button_pressed_lock *CMenuButtonPressedLockT) HasOneRef() bool {
	return BaseHasOneRef(menu_button_pressed_lock.pc_menu_button_pressed_lock)
}

func (p *cCMenuButtonPressedLockT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (menu_button_pressed_lock *CMenuButtonPressedLockT) Unref() (ret bool) {
	if menu_button_pressed_lock == nil {
		return
	}
	if menu_button_pressed_lock.beUnrefed == byApp {
		ret = BaseRelease(menu_button_pressed_lock.pc_menu_button_pressed_lock)
		menu_button_pressed_lock.beUnrefed = unrefed
	}
	menu_button_pressed_lock.pc_menu_button_pressed_lock = nil
	return ret
}

///
// Implement this structure to handle MenuButton events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCMenuButtonDelegateT C.cef_menu_button_delegate_t

// Go type for cef_menu_button_delegate_t
type CMenuButtonDelegateT struct {
	noCopy                  noCopy
	pc_menu_button_delegate *cCMenuButtonDelegateT
	beUnrefed               unrefedBy
}

func (p *CMenuButtonDelegateT) Pass() (ret *CMenuButtonDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMenuButtonDelegateT((*C.cef_menu_button_delegate_t)(p.pc_menu_button_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMenuButtonDelegateT) NewRef() (newP *CMenuButtonDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_menu_button_delegate
	BaseAddRef(gop)
	newP = newCMenuButtonDelegateT((*C.cef_menu_button_delegate_t)(gop), byApp)
	return newP
}

// Go type CMenuButtonDelegateT wraps cef type *C.cef_menu_button_delegate_t
func newCMenuButtonDelegateT(p *C.cef_menu_button_delegate_t, unrefedBy unrefedBy) *CMenuButtonDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T165.1:")
	pc := (*cCMenuButtonDelegateT)(p)
	go_menu_button_delegate := &CMenuButtonDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_menu_button_delegate, func(g *CMenuButtonDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_menu_button_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_menu_button_delegate), "T165.2:")
			BaseRelease(g.pc_menu_button_delegate)
		}
	})

	return go_menu_button_delegate
}

// *C.cef_menu_button_delegate_t has refCounted interface
func (menu_button_delegate *CMenuButtonDelegateT) HasOneRef() bool {
	return BaseHasOneRef(menu_button_delegate.pc_menu_button_delegate)
}

func (p *cCMenuButtonDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (menu_button_delegate *CMenuButtonDelegateT) Unref() (ret bool) {
	if menu_button_delegate == nil {
		return
	}
	if menu_button_delegate.beUnrefed == byApp {
		ret = BaseRelease(menu_button_delegate.pc_menu_button_delegate)
		menu_button_delegate.beUnrefed = unrefed
	}
	menu_button_delegate.pc_menu_button_delegate = nil
	return ret
}

// Convert to Base Class Pointer *CButtonDelegateT
func (menu_button_delegate *CMenuButtonDelegateT) ToCButtonDelegateT() *CButtonDelegateT {
	p := (*C.cef_button_delegate_t)(unsafe.Pointer(menu_button_delegate.pc_menu_button_delegate))
	BaseAddRef(menu_button_delegate.pc_menu_button_delegate)
	return newCButtonDelegateT(p, byApp)
}

///
// Called when |button| is pressed. Call cef_menu_button_t::show_menu() to
// show a popup menu at |screen_point|. When showing a custom popup such as a
// window keep a reference to |button_pressed_lock| until the popup is hidden
// to maintain the pressed button state.
///
type OnMenuButtonPressedHandler interface {
	OnMenuButtonPressed(
		self *CMenuButtonDelegateT,
		menu_button *CMenuButtonT,
		screen_point *CPointT,
		button_pressed_lock *CMenuButtonPressedLockT,
	)
}

var menu_button_delegate_handlers = struct {
	handler                         map[*cCMenuButtonDelegateT]interface{}
	on_menu_button_pressed_handler  map[*cCMenuButtonDelegateT]OnMenuButtonPressedHandler
	on_button_pressed_handler       map[*cCMenuButtonDelegateT]OnButtonPressedHandler
	on_button_state_changed_handler map[*cCMenuButtonDelegateT]OnButtonStateChangedHandler
	get_preferred_size_handler      map[*cCMenuButtonDelegateT]GetPreferredSizeHandler
	get_minimum_size_handler        map[*cCMenuButtonDelegateT]GetMinimumSizeHandler
	get_maximum_size_handler        map[*cCMenuButtonDelegateT]GetMaximumSizeHandler
	get_height_for_width_handler    map[*cCMenuButtonDelegateT]GetHeightForWidthHandler
	on_parent_view_changed_handler  map[*cCMenuButtonDelegateT]OnParentViewChangedHandler
	on_child_view_changed_handler   map[*cCMenuButtonDelegateT]OnChildViewChangedHandler
	on_window_changed_handler       map[*cCMenuButtonDelegateT]OnWindowChangedHandler
	on_layout_changed_handler       map[*cCMenuButtonDelegateT]OnLayoutChangedHandler
	on_focus_handler                map[*cCMenuButtonDelegateT]OnFocusHandler
	on_blur_handler                 map[*cCMenuButtonDelegateT]OnBlurHandler
}{
	map[*cCMenuButtonDelegateT]interface{}{},
	map[*cCMenuButtonDelegateT]OnMenuButtonPressedHandler{},
	map[*cCMenuButtonDelegateT]OnButtonPressedHandler{},
	map[*cCMenuButtonDelegateT]OnButtonStateChangedHandler{},
	map[*cCMenuButtonDelegateT]GetPreferredSizeHandler{},
	map[*cCMenuButtonDelegateT]GetMinimumSizeHandler{},
	map[*cCMenuButtonDelegateT]GetMaximumSizeHandler{},
	map[*cCMenuButtonDelegateT]GetHeightForWidthHandler{},
	map[*cCMenuButtonDelegateT]OnParentViewChangedHandler{},
	map[*cCMenuButtonDelegateT]OnChildViewChangedHandler{},
	map[*cCMenuButtonDelegateT]OnWindowChangedHandler{},
	map[*cCMenuButtonDelegateT]OnLayoutChangedHandler{},
	map[*cCMenuButtonDelegateT]OnFocusHandler{},
	map[*cCMenuButtonDelegateT]OnBlurHandler{},
}

// allocCMenuButtonDelegateT allocates CMenuButtonDelegateT and construct it
func allocCMenuButtonDelegateT() *CMenuButtonDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_menu_button_delegate_wrapper_t, "T165.3:")
	cefp := C.cefingo_construct_menu_button_delegate((*C.cefingo_menu_button_delegate_wrapper_t)(up))
	cgop := (*cCMenuButtonDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_menu_button_delegate_t itself in DeassocFunc,
		// or cef_menu_button_delegate_t is never GCed.
		Tracef(up, "T165.4:")
		unbindAllCMenuButtonDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCMenuButtonDelegateT(cefp, byApp)
}

// NewCMenuButtonDelegateT allocates CMenuButtonDelegateT, construct and bind it
func NewCMenuButtonDelegateT(a interface{}) *CMenuButtonDelegateT {
	return allocCMenuButtonDelegateT().bind(a)
}

func (menu_button_delegate *CMenuButtonDelegateT) bind(a interface{}) *CMenuButtonDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := menu_button_delegate.pc_menu_button_delegate
	menu_button_delegate_handlers.handler[cp] = a

	if h, ok := a.(OnMenuButtonPressedHandler); ok {
		menu_button_delegate_handlers.on_menu_button_pressed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_menu_button_pressed_handler, cp)
	}

	if h, ok := a.(OnButtonPressedHandler); ok {
		menu_button_delegate_handlers.on_button_pressed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_button_pressed_handler, cp)
	}

	if h, ok := a.(OnButtonStateChangedHandler); ok {
		menu_button_delegate_handlers.on_button_state_changed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_button_state_changed_handler, cp)
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		menu_button_delegate_handlers.get_preferred_size_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.get_preferred_size_handler, cp)
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		menu_button_delegate_handlers.get_minimum_size_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.get_minimum_size_handler, cp)
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		menu_button_delegate_handlers.get_maximum_size_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.get_maximum_size_handler, cp)
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		menu_button_delegate_handlers.get_height_for_width_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.get_height_for_width_handler, cp)
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		menu_button_delegate_handlers.on_parent_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_parent_view_changed_handler, cp)
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		menu_button_delegate_handlers.on_child_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_child_view_changed_handler, cp)
	}

	if h, ok := a.(OnWindowChangedHandler); ok {
		menu_button_delegate_handlers.on_window_changed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_window_changed_handler, cp)
	}

	if h, ok := a.(OnLayoutChangedHandler); ok {
		menu_button_delegate_handlers.on_layout_changed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_layout_changed_handler, cp)
	}

	if h, ok := a.(OnFocusHandler); ok {
		menu_button_delegate_handlers.on_focus_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_focus_handler, cp)
	}

	if h, ok := a.(OnBlurHandler); ok {
		menu_button_delegate_handlers.on_blur_handler[cp] = h
		noBind = false
	} else {
		delete(menu_button_delegate_handlers.on_blur_handler, cp)
	}

	if noBind {
		Panicln("F229: *CMenuButtonDelegateT No bind")
	}
	return menu_button_delegate
}

func unbindAllCMenuButtonDelegateT(cp *cCMenuButtonDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := menu_button_delegate.pc_menu_button_delegate
	delete(menu_button_delegate_handlers.handler, cp)

	delete(menu_button_delegate_handlers.on_menu_button_pressed_handler, cp)
	delete(menu_button_delegate_handlers.on_button_pressed_handler, cp)
	delete(menu_button_delegate_handlers.on_button_state_changed_handler, cp)
	delete(menu_button_delegate_handlers.get_preferred_size_handler, cp)
	delete(menu_button_delegate_handlers.get_minimum_size_handler, cp)
	delete(menu_button_delegate_handlers.get_maximum_size_handler, cp)
	delete(menu_button_delegate_handlers.get_height_for_width_handler, cp)
	delete(menu_button_delegate_handlers.on_parent_view_changed_handler, cp)
	delete(menu_button_delegate_handlers.on_child_view_changed_handler, cp)
	delete(menu_button_delegate_handlers.on_window_changed_handler, cp)
	delete(menu_button_delegate_handlers.on_layout_changed_handler, cp)
	delete(menu_button_delegate_handlers.on_focus_handler, cp)
	delete(menu_button_delegate_handlers.on_blur_handler, cp)
}

func (menu_button_delegate *CMenuButtonDelegateT) UnbindAll() {
	unbindAllCMenuButtonDelegateT(menu_button_delegate.pc_menu_button_delegate)
	menu_button_delegate.Unref()
}

func (menu_button_delegate *CMenuButtonDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := menu_button_delegate.pc_menu_button_delegate
	return menu_button_delegate_handlers.handler[cp]
}

// cef_menu_model_capi.h, include/capi/cef_menu_model_capi.h:499:3,

///
// Supports creation and modification of menus. See cef_menu_id_t for the
// command ids that have default implementations. All user-defined command ids
// should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of
// this structure can only be accessed on the browser process the UI thread.
///

type cCMenuModelT C.cef_menu_model_t

// Go type for cef_menu_model_t
type CMenuModelT struct {
	noCopy        noCopy
	pc_menu_model *cCMenuModelT
	beUnrefed     unrefedBy
}

func (p *CMenuModelT) Pass() (ret *CMenuModelT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMenuModelT((*C.cef_menu_model_t)(p.pc_menu_model), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMenuModelT) NewRef() (newP *CMenuModelT) {
	if self == nil {
		return newP
	}
	gop := self.pc_menu_model
	BaseAddRef(gop)
	newP = newCMenuModelT((*C.cef_menu_model_t)(gop), byApp)
	return newP
}

// Go type CMenuModelT wraps cef type *C.cef_menu_model_t
func newCMenuModelT(p *C.cef_menu_model_t, unrefedBy unrefedBy) *CMenuModelT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T166.1:")
	pc := (*cCMenuModelT)(p)
	go_menu_model := &CMenuModelT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_menu_model, func(g *CMenuModelT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_menu_model != nil {
			Tracef(unsafe.Pointer(g.pc_menu_model), "T166.2:")
			BaseRelease(g.pc_menu_model)
		}
	})

	return go_menu_model
}

// *C.cef_menu_model_t has refCounted interface
func (menu_model *CMenuModelT) HasOneRef() bool {
	return BaseHasOneRef(menu_model.pc_menu_model)
}

func (p *cCMenuModelT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (menu_model *CMenuModelT) Unref() (ret bool) {
	if menu_model == nil {
		return
	}
	if menu_model.beUnrefed == byApp {
		ret = BaseRelease(menu_model.pc_menu_model)
		menu_model.beUnrefed = unrefed
	}
	menu_model.pc_menu_model = nil
	return ret
}

///
// Returns true (1) if this menu is a submenu.
///
func (self *CMenuModelT) IsSubMenu() (ret bool) {

	cRet := C.cefingo_menu_model_is_sub_menu((*C.cef_menu_model_t)(self.pc_menu_model))

	ret = cRet == 1
	return ret
}

///
// Clears the menu. Returns true (1) on success.
///
func (self *CMenuModelT) Clear() (ret bool) {

	cRet := C.cefingo_menu_model_clear((*C.cef_menu_model_t)(self.pc_menu_model))

	ret = cRet == 1
	return ret
}

///
// Returns the number of items in this menu.
///
func (self *CMenuModelT) GetCount() (ret bool) {

	cRet := C.cefingo_menu_model_get_count((*C.cef_menu_model_t)(self.pc_menu_model))

	ret = cRet == 1
	return ret
}

///
// Add a separator to the menu. Returns true (1) on success.
///
func (self *CMenuModelT) AddSeparator() (ret bool) {

	cRet := C.cefingo_menu_model_add_separator((*C.cef_menu_model_t)(self.pc_menu_model))

	ret = cRet == 1
	return ret
}

///
// Add an item to the menu. Returns true (1) on success.
///
func (self *CMenuModelT) AddItem(
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_add_item((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), c_label.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Add a check item to the menu. Returns true (1) on success.
///
func (self *CMenuModelT) AddCheckItem(
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_add_check_item((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), c_label.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Add a radio item to the menu. Only a single item with the specified
// |group_id| can be checked at a time. Returns true (1) on success.
///
func (self *CMenuModelT) AddRadioItem(
	command_id int,
	label string,
	group_id int,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_add_radio_item((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), c_label.p_cef_string_t, (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Add a sub-menu to the menu. The new sub-menu is returned.
///
func (self *CMenuModelT) AddSubMenu(
	command_id int,
	label string,
) (ret *CMenuModelT) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_add_sub_menu((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), c_label.p_cef_string_t)

	ret = newCMenuModelT(cRet, byApp) // return GoObj
	return ret
}

///
// Insert a separator in the menu at the specified |index|. Returns true (1)
// on success.
///
func (self *CMenuModelT) InsertSeparatorAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_insert_separator_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Insert an item in the menu at the specified |index|. Returns true (1) on
// success.
///
func (self *CMenuModelT) InsertItemAt(
	index int,
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_insert_item_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(command_id), c_label.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Insert a check item in the menu at the specified |index|. Returns true (1)
// on success.
///
func (self *CMenuModelT) InsertCheckItemAt(
	index int,
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_insert_check_item_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(command_id), c_label.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Insert a radio item in the menu at the specified |index|. Only a single
// item with the specified |group_id| can be checked at a time. Returns true
// (1) on success.
///
func (self *CMenuModelT) InsertRadioItemAt(
	index int,
	command_id int,
	label string,
	group_id int,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_insert_radio_item_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(command_id), c_label.p_cef_string_t, (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Insert a sub-menu in the menu at the specified |index|. The new sub-menu is
// returned.
///
func (self *CMenuModelT) InsertSubMenuAt(
	index int,
	command_id int,
	label string,
) (ret *CMenuModelT) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_insert_sub_menu_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(command_id), c_label.p_cef_string_t)

	ret = newCMenuModelT(cRet, byApp) // return GoObj
	return ret
}

///
// Removes the item with the specified |command_id|. Returns true (1) on
// success.
///
func (self *CMenuModelT) Remove(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Removes the item at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) RemoveAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the index associated with the specified |command_id| or -1 if not
// found due to the command id not existing in the menu.
///
func (self *CMenuModelT) GetIndexOf(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_index_of((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns the command id at the specified |index| or -1 if not found due to
// invalid range or the index being a separator.
///
func (self *CMenuModelT) GetCommandIdAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_command_id_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Sets the command id at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) SetCommandIdAt(
	index int,
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_command_id_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns the label for the specified |command_id| or NULL if not found.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMenuModelT) GetLabel(
	command_id int,
) (ret string) {

	cRet := C.cefingo_menu_model_get_label((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the label at the specified |index| or NULL if not found due to
// invalid range or the index being a separator.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CMenuModelT) GetLabelAt(
	index int,
) (ret string) {

	cRet := C.cefingo_menu_model_get_label_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the label for the specified |command_id|. Returns true (1) on success.
///
func (self *CMenuModelT) SetLabel(
	command_id int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_set_label((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), c_label.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Set the label at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) SetLabelAt(
	index int,
	label string,
) (ret bool) {
	c_label := create_cef_string(label)

	cRet := C.cefingo_menu_model_set_label_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), c_label.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the item type for the specified |command_id|.
///
func (self *CMenuModelT) GetType(
	command_id int,
) (ret CMenuItemTypeT) {

	cRet := C.cefingo_menu_model_get_type((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = CMenuItemTypeT(cRet) // return GoObj
	return ret
}

///
// Returns the item type at the specified |index|.
///
func (self *CMenuModelT) GetTypeAt(
	index int,
) (ret CMenuItemTypeT) {

	cRet := C.cefingo_menu_model_get_type_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = CMenuItemTypeT(cRet) // return GoObj
	return ret
}

///
// Returns the group id for the specified |command_id| or -1 if invalid.
///
func (self *CMenuModelT) GetGroupId(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_group_id((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns the group id at the specified |index| or -1 if invalid.
///
func (self *CMenuModelT) GetGroupIdAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_group_id_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Sets the group id for the specified |command_id|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetGroupId(
	command_id int,
	group_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_group_id((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Sets the group id at the specified |index|. Returns true (1) on success.
///
func (self *CMenuModelT) SetGroupIdAt(
	index int,
	group_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_group_id_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(group_id))

	ret = cRet == 1
	return ret
}

///
// Returns the submenu for the specified |command_id| or NULL if invalid.
///
func (self *CMenuModelT) GetSubMenu(
	command_id int,
) (ret *CMenuModelT) {

	cRet := C.cefingo_menu_model_get_sub_menu((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = newCMenuModelT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the submenu at the specified |index| or NULL if invalid.
///
func (self *CMenuModelT) GetSubMenuAt(
	index int,
) (ret *CMenuModelT) {

	cRet := C.cefingo_menu_model_get_sub_menu_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = newCMenuModelT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if the specified |command_id| is visible.
///
func (self *CMenuModelT) IsVisible(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_visible((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| is visible.
///
func (self *CMenuModelT) IsVisibleAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_visible_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Change the visibility of the specified |command_id|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetVisible(
	command_id int,
	visible int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_visible((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), (C.int)(visible))

	ret = cRet == 1
	return ret
}

///
// Change the visibility at the specified |index|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetVisibleAt(
	index int,
	visible int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_visible_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(visible))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |command_id| is enabled.
///
func (self *CMenuModelT) IsEnabled(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_enabled((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| is enabled.
///
func (self *CMenuModelT) IsEnabledAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_enabled_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Change the enabled status of the specified |command_id|. Returns true (1)
// on success.
///
func (self *CMenuModelT) SetEnabled(
	command_id int,
	enabled int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_enabled((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), (C.int)(enabled))

	ret = cRet == 1
	return ret
}

///
// Change the enabled status at the specified |index|. Returns true (1) on
// success.
///
func (self *CMenuModelT) SetEnabledAt(
	index int,
	enabled int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_enabled_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(enabled))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |command_id| is checked. Only applies to
// check and radio items.
///
func (self *CMenuModelT) IsChecked(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_checked((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| is checked. Only applies to check
// and radio items.
///
func (self *CMenuModelT) IsCheckedAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_is_checked_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Check the specified |command_id|. Only applies to check and radio items.
// Returns true (1) on success.
///
func (self *CMenuModelT) SetChecked(
	command_id int,
	checked int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_checked((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), (C.int)(checked))

	ret = cRet == 1
	return ret
}

///
// Check the specified |index|. Only applies to check and radio items. Returns
// true (1) on success.
///
func (self *CMenuModelT) SetCheckedAt(
	index int,
	checked int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_checked_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(checked))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |command_id| has a keyboard accelerator
// assigned.
///
func (self *CMenuModelT) HasAccelerator(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_has_accelerator((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the specified |index| has a keyboard accelerator
// assigned.
///
func (self *CMenuModelT) HasAcceleratorAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_has_accelerator_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Set the keyboard accelerator for the specified |command_id|. |key_code| can
// be any virtual key or character value. Returns true (1) on success.
///
func (self *CMenuModelT) SetAccelerator(
	command_id int,
	key_code int,
	shift_pressed int,
	ctrl_pressed int,
	alt_pressed int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_accelerator((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), (C.int)(key_code), (C.int)(shift_pressed), (C.int)(ctrl_pressed), (C.int)(alt_pressed))

	ret = cRet == 1
	return ret
}

///
// Set the keyboard accelerator at the specified |index|. |key_code| can be
// any virtual key or character value. Returns true (1) on success.
///
func (self *CMenuModelT) SetAcceleratorAt(
	index int,
	key_code int,
	shift_pressed int,
	ctrl_pressed int,
	alt_pressed int,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_accelerator_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.int)(key_code), (C.int)(shift_pressed), (C.int)(ctrl_pressed), (C.int)(alt_pressed))

	ret = cRet == 1
	return ret
}

///
// Remove the keyboard accelerator for the specified |command_id|. Returns
// true (1) on success.
///
func (self *CMenuModelT) RemoveAccelerator(
	command_id int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove_accelerator((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id))

	ret = cRet == 1
	return ret
}

///
// Remove the keyboard accelerator at the specified |index|. Returns true (1)
// on success.
///
func (self *CMenuModelT) RemoveAcceleratorAt(
	index int,
) (ret bool) {

	cRet := C.cefingo_menu_model_remove_accelerator_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Retrieves the keyboard accelerator for the specified |command_id|. Returns
// true (1) on success.
///
func (self *CMenuModelT) GetAccelerator(
	command_id int,
) (ret bool, key_code int, shift_pressed int, ctrl_pressed int, alt_pressed int) {
	var tmpkey_code C.int
	var tmpshift_pressed C.int
	var tmpctrl_pressed C.int
	var tmpalt_pressed C.int

	cRet := C.cefingo_menu_model_get_accelerator((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), &tmpkey_code, &tmpshift_pressed, &tmpctrl_pressed, &tmpalt_pressed)

	key_code = (int)(tmpkey_code)
	shift_pressed = (int)(tmpshift_pressed)
	ctrl_pressed = (int)(tmpctrl_pressed)
	alt_pressed = (int)(tmpalt_pressed)

	ret = cRet == 1
	return ret, key_code, shift_pressed, ctrl_pressed, alt_pressed
}

///
// Retrieves the keyboard accelerator for the specified |index|. Returns true
// (1) on success.
///
func (self *CMenuModelT) GetAcceleratorAt(
	index int,
) (ret bool, key_code int, shift_pressed int, ctrl_pressed int, alt_pressed int) {
	var tmpkey_code C.int
	var tmpshift_pressed C.int
	var tmpctrl_pressed C.int
	var tmpalt_pressed C.int

	cRet := C.cefingo_menu_model_get_accelerator_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), &tmpkey_code, &tmpshift_pressed, &tmpctrl_pressed, &tmpalt_pressed)

	key_code = (int)(tmpkey_code)
	shift_pressed = (int)(tmpshift_pressed)
	ctrl_pressed = (int)(tmpctrl_pressed)
	alt_pressed = (int)(tmpalt_pressed)

	ret = cRet == 1
	return ret, key_code, shift_pressed, ctrl_pressed, alt_pressed
}

///
// Set the explicit color for |command_id| and |color_type| to |color|.
// Specify a |color| value of 0 to remove the explicit color. If no explicit
// color or default color is set for |color_type| then the system color will
// be used. Returns true (1) on success.
///
func (self *CMenuModelT) SetColor(
	command_id int,
	color_type CMenuColorTypeT,
	color CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_color((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), (C.cef_menu_color_type_t)(color_type), (C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Set the explicit color for |command_id| and |index| to |color|. Specify a
// |color| value of 0 to remove the explicit color. Specify an |index| value
// of -1 to set the default color for items that do not have an explicit color
// set. If no explicit color or default color is set for |color_type| then the
// system color will be used. Returns true (1) on success.
///
func (self *CMenuModelT) SetColorAt(
	index int,
	color_type CMenuColorTypeT,
	color CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_set_color_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.cef_menu_color_type_t)(color_type), (C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Returns in |color| the color that was explicitly set for |command_id| and
// |color_type|. If a color was not set then 0 will be returned in |color|.
// Returns true (1) on success.
///
func (self *CMenuModelT) GetColor(
	command_id int,
	color_type CMenuColorTypeT,
	color *CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_color((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), (C.cef_menu_color_type_t)(color_type), (*C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Returns in |color| the color that was explicitly set for |command_id| and
// |color_type|. Specify an |index| value of -1 to return the default color in
// |color|. If a color was not set then 0 will be returned in |color|. Returns
// true (1) on success.
///
func (self *CMenuModelT) GetColorAt(
	index int,
	color_type CMenuColorTypeT,
	color *CColorT,
) (ret bool) {

	cRet := C.cefingo_menu_model_get_color_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), (C.cef_menu_color_type_t)(color_type), (*C.cef_color_t)(color))

	ret = cRet == 1
	return ret
}

///
// Sets the font list for the specified |command_id|. If |font_list| is NULL
// the system font will be used. Returns true (1) on success. The format is
// &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;, where: - FONT_FAMILY_LIST is a comma-
// separated list of font family names, - STYLES is an optional space-
// separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CMenuModelT) SetFontList(
	command_id int,
	font_list string,
) (ret bool) {
	c_font_list := create_cef_string(font_list)

	cRet := C.cefingo_menu_model_set_font_list((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(command_id), c_font_list.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Sets the font list for the specified |index|. Specify an |index| value of
// -1 to set the default font. If |font_list| is NULL the system font will be
// used. Returns true (1) on success. The format is
// &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;, where: - FONT_FAMILY_LIST is a comma-
// separated list of font family names, - STYLES is an optional space-
// separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CMenuModelT) SetFontListAt(
	index int,
	font_list string,
) (ret bool) {
	c_font_list := create_cef_string(font_list)

	cRet := C.cefingo_menu_model_set_font_list_at((*C.cef_menu_model_t)(self.pc_menu_model), (C.int)(index), c_font_list.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Create a new MenuModel with the specified |delegate|.
///
func MenuModelCreate(
	delegate *CMenuModelDelegateT,
) (ret *CMenuModelT) {
	var goTmpdelegate *C.cef_menu_model_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_menu_model_delegate)
		goTmpdelegate = (*C.cef_menu_model_delegate_t)(delegate.pc_menu_model_delegate)
	}

	cRet := C.cef_menu_model_create(goTmpdelegate)

	ret = newCMenuModelT(cRet, byApp) // return GoObj
	return ret
}

// cef_menu_model_delegate_capi.h, include/capi/cef_menu_model_delegate_capi.h:117:3,

///
// Implement this structure to handle menu model events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCMenuModelDelegateT C.cef_menu_model_delegate_t

// Go type for cef_menu_model_delegate_t
type CMenuModelDelegateT struct {
	noCopy                 noCopy
	pc_menu_model_delegate *cCMenuModelDelegateT
	beUnrefed              unrefedBy
}

func (p *CMenuModelDelegateT) Pass() (ret *CMenuModelDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCMenuModelDelegateT((*C.cef_menu_model_delegate_t)(p.pc_menu_model_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CMenuModelDelegateT) NewRef() (newP *CMenuModelDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_menu_model_delegate
	BaseAddRef(gop)
	newP = newCMenuModelDelegateT((*C.cef_menu_model_delegate_t)(gop), byApp)
	return newP
}

// Go type CMenuModelDelegateT wraps cef type *C.cef_menu_model_delegate_t
func newCMenuModelDelegateT(p *C.cef_menu_model_delegate_t, unrefedBy unrefedBy) *CMenuModelDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T167.1:")
	pc := (*cCMenuModelDelegateT)(p)
	go_menu_model_delegate := &CMenuModelDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_menu_model_delegate, func(g *CMenuModelDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_menu_model_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_menu_model_delegate), "T167.2:")
			BaseRelease(g.pc_menu_model_delegate)
		}
	})

	return go_menu_model_delegate
}

// *C.cef_menu_model_delegate_t has refCounted interface
func (menu_model_delegate *CMenuModelDelegateT) HasOneRef() bool {
	return BaseHasOneRef(menu_model_delegate.pc_menu_model_delegate)
}

func (p *cCMenuModelDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (menu_model_delegate *CMenuModelDelegateT) Unref() (ret bool) {
	if menu_model_delegate == nil {
		return
	}
	if menu_model_delegate.beUnrefed == byApp {
		ret = BaseRelease(menu_model_delegate.pc_menu_model_delegate)
		menu_model_delegate.beUnrefed = unrefed
	}
	menu_model_delegate.pc_menu_model_delegate = nil
	return ret
}

///
// Perform the action associated with the specified |command_id| and optional
// |event_flags|.
///
type ExecuteCommandHandler interface {
	ExecuteCommand(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		command_id int,
		event_flags CEventFlagsT,
	)
}

///
// Called when the user moves the mouse outside the menu and over the owning
// window.
///
type MouseOutsideMenuHandler interface {
	MouseOutsideMenu(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		screen_point *CPointT,
	)
}

///
// Called on unhandled open submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
type UnhandledOpenSubmenuHandler interface {
	UnhandledOpenSubmenu(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		is_rtl int,
	)
}

///
// Called on unhandled close submenu keyboard commands. |is_rtl| will be true
// (1) if the menu is displaying a right-to-left language.
///
type UnhandledCloseSubmenuHandler interface {
	UnhandledCloseSubmenu(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		is_rtl int,
	)
}

///
// The menu is about to show.
///
type MenuWillShowHandler interface {
	MenuWillShow(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
	)
}

///
// The menu has closed.
///
type MenuClosedHandler interface {
	MenuClosed(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
	)
}

///
// Optionally modify a menu item label. Return true (1) if |label| was
// modified.
///
type FormatLabelHandler interface {
	FormatLabel(
		self *CMenuModelDelegateT,
		menu_model *CMenuModelT,
		label string,
	) (ret bool, labelOut string)
}

var menu_model_delegate_handlers = struct {
	handler                         map[*cCMenuModelDelegateT]interface{}
	execute_command_handler         map[*cCMenuModelDelegateT]ExecuteCommandHandler
	mouse_outside_menu_handler      map[*cCMenuModelDelegateT]MouseOutsideMenuHandler
	unhandled_open_submenu_handler  map[*cCMenuModelDelegateT]UnhandledOpenSubmenuHandler
	unhandled_close_submenu_handler map[*cCMenuModelDelegateT]UnhandledCloseSubmenuHandler
	menu_will_show_handler          map[*cCMenuModelDelegateT]MenuWillShowHandler
	menu_closed_handler             map[*cCMenuModelDelegateT]MenuClosedHandler
	format_label_handler            map[*cCMenuModelDelegateT]FormatLabelHandler
}{
	map[*cCMenuModelDelegateT]interface{}{},
	map[*cCMenuModelDelegateT]ExecuteCommandHandler{},
	map[*cCMenuModelDelegateT]MouseOutsideMenuHandler{},
	map[*cCMenuModelDelegateT]UnhandledOpenSubmenuHandler{},
	map[*cCMenuModelDelegateT]UnhandledCloseSubmenuHandler{},
	map[*cCMenuModelDelegateT]MenuWillShowHandler{},
	map[*cCMenuModelDelegateT]MenuClosedHandler{},
	map[*cCMenuModelDelegateT]FormatLabelHandler{},
}

// allocCMenuModelDelegateT allocates CMenuModelDelegateT and construct it
func allocCMenuModelDelegateT() *CMenuModelDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_menu_model_delegate_wrapper_t, "T167.3:")
	cefp := C.cefingo_construct_menu_model_delegate((*C.cefingo_menu_model_delegate_wrapper_t)(up))
	cgop := (*cCMenuModelDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_menu_model_delegate_t itself in DeassocFunc,
		// or cef_menu_model_delegate_t is never GCed.
		Tracef(up, "T167.4:")
		unbindAllCMenuModelDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCMenuModelDelegateT(cefp, byApp)
}

// NewCMenuModelDelegateT allocates CMenuModelDelegateT, construct and bind it
func NewCMenuModelDelegateT(a interface{}) *CMenuModelDelegateT {
	return allocCMenuModelDelegateT().bind(a)
}

func (menu_model_delegate *CMenuModelDelegateT) bind(a interface{}) *CMenuModelDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := menu_model_delegate.pc_menu_model_delegate
	menu_model_delegate_handlers.handler[cp] = a

	if h, ok := a.(ExecuteCommandHandler); ok {
		menu_model_delegate_handlers.execute_command_handler[cp] = h
		noBind = false
	} else {
		delete(menu_model_delegate_handlers.execute_command_handler, cp)
	}

	if h, ok := a.(MouseOutsideMenuHandler); ok {
		menu_model_delegate_handlers.mouse_outside_menu_handler[cp] = h
		noBind = false
	} else {
		delete(menu_model_delegate_handlers.mouse_outside_menu_handler, cp)
	}

	if h, ok := a.(UnhandledOpenSubmenuHandler); ok {
		menu_model_delegate_handlers.unhandled_open_submenu_handler[cp] = h
		noBind = false
	} else {
		delete(menu_model_delegate_handlers.unhandled_open_submenu_handler, cp)
	}

	if h, ok := a.(UnhandledCloseSubmenuHandler); ok {
		menu_model_delegate_handlers.unhandled_close_submenu_handler[cp] = h
		noBind = false
	} else {
		delete(menu_model_delegate_handlers.unhandled_close_submenu_handler, cp)
	}

	if h, ok := a.(MenuWillShowHandler); ok {
		menu_model_delegate_handlers.menu_will_show_handler[cp] = h
		noBind = false
	} else {
		delete(menu_model_delegate_handlers.menu_will_show_handler, cp)
	}

	if h, ok := a.(MenuClosedHandler); ok {
		menu_model_delegate_handlers.menu_closed_handler[cp] = h
		noBind = false
	} else {
		delete(menu_model_delegate_handlers.menu_closed_handler, cp)
	}

	if h, ok := a.(FormatLabelHandler); ok {
		menu_model_delegate_handlers.format_label_handler[cp] = h
		noBind = false
	} else {
		delete(menu_model_delegate_handlers.format_label_handler, cp)
	}

	if noBind {
		Panicln("F229: *CMenuModelDelegateT No bind")
	}
	return menu_model_delegate
}

func unbindAllCMenuModelDelegateT(cp *cCMenuModelDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := menu_model_delegate.pc_menu_model_delegate
	delete(menu_model_delegate_handlers.handler, cp)

	delete(menu_model_delegate_handlers.execute_command_handler, cp)
	delete(menu_model_delegate_handlers.mouse_outside_menu_handler, cp)
	delete(menu_model_delegate_handlers.unhandled_open_submenu_handler, cp)
	delete(menu_model_delegate_handlers.unhandled_close_submenu_handler, cp)
	delete(menu_model_delegate_handlers.menu_will_show_handler, cp)
	delete(menu_model_delegate_handlers.menu_closed_handler, cp)
	delete(menu_model_delegate_handlers.format_label_handler, cp)
}

func (menu_model_delegate *CMenuModelDelegateT) UnbindAll() {
	unbindAllCMenuModelDelegateT(menu_model_delegate.pc_menu_model_delegate)
	menu_model_delegate.Unref()
}

func (menu_model_delegate *CMenuModelDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := menu_model_delegate.pc_menu_model_delegate
	return menu_model_delegate_handlers.handler[cp]
}

// cef_navigation_entry_capi.h, include/capi/cef_navigation_entry_capi.h:126:3,

///
// Structure used to represent an entry in navigation history.
///

type cCNavigationEntryT C.cef_navigation_entry_t

// Go type for cef_navigation_entry_t
type CNavigationEntryT struct {
	noCopy              noCopy
	pc_navigation_entry *cCNavigationEntryT
	beUnrefed           unrefedBy
}

func (p *CNavigationEntryT) Pass() (ret *CNavigationEntryT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCNavigationEntryT((*C.cef_navigation_entry_t)(p.pc_navigation_entry), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CNavigationEntryT) NewRef() (newP *CNavigationEntryT) {
	if self == nil {
		return newP
	}
	gop := self.pc_navigation_entry
	BaseAddRef(gop)
	newP = newCNavigationEntryT((*C.cef_navigation_entry_t)(gop), byApp)
	return newP
}

// Go type CNavigationEntryT wraps cef type *C.cef_navigation_entry_t
func newCNavigationEntryT(p *C.cef_navigation_entry_t, unrefedBy unrefedBy) *CNavigationEntryT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T168.1:")
	pc := (*cCNavigationEntryT)(p)
	go_navigation_entry := &CNavigationEntryT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_navigation_entry, func(g *CNavigationEntryT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_navigation_entry != nil {
			Tracef(unsafe.Pointer(g.pc_navigation_entry), "T168.2:")
			BaseRelease(g.pc_navigation_entry)
		}
	})

	return go_navigation_entry
}

// *C.cef_navigation_entry_t has refCounted interface
func (navigation_entry *CNavigationEntryT) HasOneRef() bool {
	return BaseHasOneRef(navigation_entry.pc_navigation_entry)
}

func (p *cCNavigationEntryT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (navigation_entry *CNavigationEntryT) Unref() (ret bool) {
	if navigation_entry == nil {
		return
	}
	if navigation_entry.beUnrefed == byApp {
		ret = BaseRelease(navigation_entry.pc_navigation_entry)
		navigation_entry.beUnrefed = unrefed
	}
	navigation_entry.pc_navigation_entry = nil
	return ret
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CNavigationEntryT) IsValid() (ret bool) {

	cRet := C.cefingo_navigation_entry_is_valid((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	ret = cRet == 1
	return ret
}

///
// Returns the actual URL of the page. For some pages this may be data: URL or
// similar. Use get_display_url() to return a display-friendly version.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetUrl() (ret string) {

	cRet := C.cefingo_navigation_entry_get_url((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a display-friendly version of the URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetDisplayUrl() (ret string) {

	cRet := C.cefingo_navigation_entry_get_display_url((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the original URL that was entered by the user before any redirects.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetOriginalUrl() (ret string) {

	cRet := C.cefingo_navigation_entry_get_original_url((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the title set by the page. This value may be NULL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CNavigationEntryT) GetTitle() (ret string) {

	cRet := C.cefingo_navigation_entry_get_title((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the transition type which indicates what the user did to move to
// this page from the previous page.
///
func (self *CNavigationEntryT) GetTransitionType() (ret CTransitionTypeT) {

	cRet := C.cefingo_navigation_entry_get_transition_type((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	ret = CTransitionTypeT(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if this navigation includes post data.
///
func (self *CNavigationEntryT) HasPostData() (ret bool) {

	cRet := C.cefingo_navigation_entry_has_post_data((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	ret = cRet == 1
	return ret
}

///
// Returns the time for the last known successful navigation completion. A
// navigation may be completed more than once if the page is reloaded. May be
// 0 if the navigation has not yet completed.
///
func (self *CNavigationEntryT) GetCompletionTime() (ret CTimeT) {

	cRet := C.cefingo_navigation_entry_get_completion_time((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	ret = (CTimeT)(cRet) // return GoObj
	return ret
}

///
// Returns the HTTP status code for the last known successful navigation
// response. May be 0 if the response has not yet been received or if the
// navigation has not yet completed.
///
func (self *CNavigationEntryT) GetHttpStatusCode() (ret bool) {

	cRet := C.cefingo_navigation_entry_get_http_status_code((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	ret = cRet == 1
	return ret
}

///
// Returns the SSL information for this navigation entry.
///
func (self *CNavigationEntryT) GetSslstatus() (ret *CSslstatusT) {

	cRet := C.cefingo_navigation_entry_get_sslstatus((*C.cef_navigation_entry_t)(self.pc_navigation_entry))

	ret = newCSslstatusT(cRet, byApp) // return GoObj
	return ret
}

// cef_origin_whitelist_capi.h, include/capi/cef_origin_whitelist_capi.h:85:16,

///
// Add an entry to the cross-origin access whitelist.
//
// The same-origin policy restricts how scripts hosted from different origins
// (scheme + domain + port) can communicate. By default, scripts can only access
// resources with the same origin. Scripts hosted on the HTTP and HTTPS schemes
// (but no other schemes) can use the "Access-Control-Allow-Origin" header to
// allow cross-origin requests. For example, https://source.example.com can make
// XMLHttpRequest requests on http://target.example.com if the
// http://target.example.com request returns an "Access-Control-Allow-Origin:
// https://source.example.com" response header.
//
// Scripts in separate frames or iframes and hosted from the same protocol and
// domain suffix can execute cross-origin JavaScript if both pages set the
// document.domain value to the same domain suffix. For example,
// scheme://foo.example.com and scheme://bar.example.com can communicate using
// JavaScript if both domains set document.domain="example.com".
//
// This function is used to allow access to origins that would otherwise violate
// the same-origin policy. Scripts hosted underneath the fully qualified
// |source_origin| URL (like http://www.example.com) will be allowed access to
// all resources hosted on the specified |target_protocol| and |target_domain|.
// If |target_domain| is non-NULL and |allow_target_subdomains| if false (0)
// only exact domain matches will be allowed. If |target_domain| contains a top-
// level domain component (like "example.com") and |allow_target_subdomains| is
// true (1) sub-domain matches will be allowed. If |target_domain| is NULL and
// |allow_target_subdomains| if true (1) all domains and IP addresses will be
// allowed.
//
// This function cannot be used to bypass the restrictions on local or display
// isolated schemes. See the comments on CefRegisterCustomScheme for more
// information.
//
// This function may be called on any thread. Returns false (0) if
// |source_origin| is invalid or the whitelist cannot be accessed.
///
func AddCrossOriginWhitelistEntry(
	source_origin string,
	target_protocol string,
	target_domain string,
	allow_target_subdomains int,
) (ret bool) {
	c_source_origin := create_cef_string(source_origin)
	c_target_protocol := create_cef_string(target_protocol)
	c_target_domain := create_cef_string(target_domain)

	cRet := C.cef_add_cross_origin_whitelist_entry(c_source_origin.p_cef_string_t, c_target_protocol.p_cef_string_t, c_target_domain.p_cef_string_t, (C.int)(allow_target_subdomains))

	ret = cRet == 1
	return ret
}

///
// Remove an entry from the cross-origin access whitelist. Returns false (0) if
// |source_origin| is invalid or the whitelist cannot be accessed.
///
func RemoveCrossOriginWhitelistEntry(
	source_origin string,
	target_protocol string,
	target_domain string,
	allow_target_subdomains int,
) (ret bool) {
	c_source_origin := create_cef_string(source_origin)
	c_target_protocol := create_cef_string(target_protocol)
	c_target_domain := create_cef_string(target_domain)

	cRet := C.cef_remove_cross_origin_whitelist_entry(c_source_origin.p_cef_string_t, c_target_protocol.p_cef_string_t, c_target_domain.p_cef_string_t, (C.int)(allow_target_subdomains))

	ret = cRet == 1
	return ret
}

///
// Remove all entries from the cross-origin access whitelist. Returns false (0)
// if the whitelist cannot be accessed.
///
func ClearCrossOriginWhitelist() (ret bool) {

	cRet := C.cef_clear_cross_origin_whitelist()

	ret = cRet == 1
	return ret
}

// cef_overlay_controller_capi.h, include/capi/views/cef_overlay_controller_capi.h:210:3,

///
// Controller for an overlay that contains a contents View added via
// cef_window_t::AddOverlayView. Methods exposed by this controller should be
// called in preference to functions of the same name exposed by the contents
// View unless otherwise indicated. Methods must be called on the browser
// process UI thread unless otherwise indicated.
///

type cCOverlayControllerT C.cef_overlay_controller_t

// Go type for cef_overlay_controller_t
type COverlayControllerT struct {
	noCopy                noCopy
	pc_overlay_controller *cCOverlayControllerT
	beUnrefed             unrefedBy
}

func (p *COverlayControllerT) Pass() (ret *COverlayControllerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCOverlayControllerT((*C.cef_overlay_controller_t)(p.pc_overlay_controller), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *COverlayControllerT) NewRef() (newP *COverlayControllerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_overlay_controller
	BaseAddRef(gop)
	newP = newCOverlayControllerT((*C.cef_overlay_controller_t)(gop), byApp)
	return newP
}

// Go type COverlayControllerT wraps cef type *C.cef_overlay_controller_t
func newCOverlayControllerT(p *C.cef_overlay_controller_t, unrefedBy unrefedBy) *COverlayControllerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T392.1:")
	pc := (*cCOverlayControllerT)(p)
	go_overlay_controller := &COverlayControllerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_overlay_controller, func(g *COverlayControllerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_overlay_controller != nil {
			Tracef(unsafe.Pointer(g.pc_overlay_controller), "T392.2:")
			BaseRelease(g.pc_overlay_controller)
		}
	})

	return go_overlay_controller
}

// *C.cef_overlay_controller_t has refCounted interface
func (overlay_controller *COverlayControllerT) HasOneRef() bool {
	return BaseHasOneRef(overlay_controller.pc_overlay_controller)
}

func (p *cCOverlayControllerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (overlay_controller *COverlayControllerT) Unref() (ret bool) {
	if overlay_controller == nil {
		return
	}
	if overlay_controller.beUnrefed == byApp {
		ret = BaseRelease(overlay_controller.pc_overlay_controller)
		overlay_controller.beUnrefed = unrefed
	}
	overlay_controller.pc_overlay_controller = nil
	return ret
}

///
// Returns true (1) if this object is valid.
///
func (self *COverlayControllerT) IsValid() (ret bool) {

	cRet := C.cefingo_overlay_controller_is_valid((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is the same as |that| object.
///
func (self *COverlayControllerT) IsSame(
	that *COverlayControllerT,
) (ret bool) {
	var goTmpthat *C.cef_overlay_controller_t
	if that != nil {
		BaseAddRef(that.pc_overlay_controller)
		goTmpthat = (*C.cef_overlay_controller_t)(that.pc_overlay_controller)
	}

	cRet := C.cefingo_overlay_controller_is_same((*C.cef_overlay_controller_t)(self.pc_overlay_controller), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns the contents View for this overlay.
///
func (self *COverlayControllerT) GetContentsView() (ret *CViewT) {

	cRet := C.cefingo_overlay_controller_get_contents_view((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = newCViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the top-level Window hosting this overlay. Use this function
// instead of calling get_window() on the contents View.
///
func (self *COverlayControllerT) GetWindow() (ret *CWindowT) {

	cRet := C.cefingo_overlay_controller_get_window((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = newCWindowT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the docking mode for this overlay.
///
func (self *COverlayControllerT) GetDockingMode() (ret CDockingModeT) {

	cRet := C.cefingo_overlay_controller_get_docking_mode((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = CDockingModeT(cRet) // return GoObj
	return ret
}

///
// Destroy this overlay.
///
func (self *COverlayControllerT) Destroy() {

	C.cefingo_overlay_controller_destroy((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

}

///
// Sets the bounds (size and position) of this overlay. This will set the
// bounds of the contents View to match and trigger a re-layout if necessary.
// |bounds| is in parent coordinates and any insets configured on this overlay
// will be ignored. Use this function only for overlays created with a docking
// mode value of CEF_DOCKING_MODE_CUSTOM. With other docking modes modify the
// insets of this overlay and/or layout of the contents View and call
// size_to_preferred_size() instead to calculate the new size and re-position
// the overlay if necessary.
///
func (self *COverlayControllerT) SetBounds(
	bounds *CRectT,
) {

	C.cefingo_overlay_controller_set_bounds((*C.cef_overlay_controller_t)(self.pc_overlay_controller), (*C.cef_rect_t)(bounds))

}

///
// Returns the bounds (size and position) of this overlay in parent
// coordinates.
///
func (self *COverlayControllerT) GetBounds() (ret CRectT) {

	cRet := C.cefingo_overlay_controller_get_bounds((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Returns the bounds (size and position) of this overlay in DIP screen
// coordinates.
///
func (self *COverlayControllerT) GetBoundsInScreen() (ret CRectT) {

	cRet := C.cefingo_overlay_controller_get_bounds_in_screen((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Sets the size of this overlay without changing the position. This will set
// the size of the contents View to match and trigger a re-layout if
// necessary. |size| is in parent coordinates and any insets configured on
// this overlay will be ignored. Use this function only for overlays created
// with a docking mode value of CEF_DOCKING_MODE_CUSTOM. With other docking
// modes modify the insets of this overlay and/or layout of the contents View
// and call size_to_preferred_size() instead to calculate the new size and re-
// position the overlay if necessary.
///
func (self *COverlayControllerT) SetSize(
	size *CSizeT,
) {

	C.cefingo_overlay_controller_set_size((*C.cef_overlay_controller_t)(self.pc_overlay_controller), (*C.cef_size_t)(size))

}

///
// Returns the size of this overlay in parent coordinates.
///
func (self *COverlayControllerT) GetSize() (ret CSizeT) {

	cRet := C.cefingo_overlay_controller_get_size((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = (CSizeT)(cRet) // return GoObj
	return ret
}

///
// Sets the position of this overlay without changing the size. |position| is
// in parent coordinates and any insets configured on this overlay will be
// ignored. Use this function only for overlays created with a docking mode
// value of CEF_DOCKING_MODE_CUSTOM. With other docking modes modify the
// insets of this overlay and/or layout of the contents View and call
// size_to_preferred_size() instead to calculate the new size and re-position
// the overlay if necessary.
///
func (self *COverlayControllerT) SetPosition(
	position *CPointT,
) {

	C.cefingo_overlay_controller_set_position((*C.cef_overlay_controller_t)(self.pc_overlay_controller), (*C.cef_point_t)(position))

}

///
// Returns the position of this overlay in parent coordinates.
///
func (self *COverlayControllerT) GetPosition() (ret CPointT) {

	cRet := C.cefingo_overlay_controller_get_position((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = (CPointT)(cRet) // return GoObj
	return ret
}

///
// Sets the insets for this overlay. |insets| is in parent coordinates. Use
// this function only for overlays created with a docking mode value other
// than CEF_DOCKING_MODE_CUSTOM.
///
func (self *COverlayControllerT) SetInsets(
	insets *CInsetsT,
) {

	C.cefingo_overlay_controller_set_insets((*C.cef_overlay_controller_t)(self.pc_overlay_controller), (*C.cef_insets_t)(insets))

}

///
// Returns the insets for this overlay in parent coordinates.
///
func (self *COverlayControllerT) GetInsets() (ret CInsetsT) {

	cRet := C.cefingo_overlay_controller_get_insets((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = (CInsetsT)(cRet) // return GoObj
	return ret
}

///
// Size this overlay to its preferred size and trigger a re-layout if
// necessary. The position of overlays created with a docking mode value of
// CEF_DOCKING_MODE_CUSTOM will not be modified by calling this function. With
// other docking modes this function may re-position the overlay if necessary
// to accommodate the new size and any insets configured on the contents View.
///
func (self *COverlayControllerT) SizeToPreferredSize() {

	C.cefingo_overlay_controller_size_to_preferred_size((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

}

///
// Sets whether this overlay is visible. Overlays are hidden by default. If
// this overlay is hidden then it and any child Views will not be drawn and,
// if any of those Views currently have focus, then focus will also be
// cleared. Painting is scheduled as needed.
///
func (self *COverlayControllerT) SetVisible(
	visible int,
) {

	C.cefingo_overlay_controller_set_visible((*C.cef_overlay_controller_t)(self.pc_overlay_controller), (C.int)(visible))

}

///
// Returns whether this overlay is visible. A View may be visible but still
// not drawn in a Window if any parent Views are hidden. Call is_drawn() to
// determine whether this overlay and all parent Views are visible and will be
// drawn.
///
func (self *COverlayControllerT) IsVisible() (ret bool) {

	cRet := C.cefingo_overlay_controller_is_visible((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = cRet == 1
	return ret
}

///
// Returns whether this overlay is visible and drawn in a Window. A View is
// drawn if it and all parent Views are visible. To determine if the
// containing Window is visible to the user on-screen call is_visible() on the
// Window.
///
func (self *COverlayControllerT) IsDrawn() (ret bool) {

	cRet := C.cefingo_overlay_controller_is_drawn((*C.cef_overlay_controller_t)(self.pc_overlay_controller))

	ret = cRet == 1
	return ret
}

// cef_panel_capi.h, include/capi/views/cef_panel_capi.h:139:3,

///
// A Panel is a container in the views hierarchy that can contain other Views as
// children. Methods must be called on the browser process UI thread unless
// otherwise indicated.
///

type cCPanelT C.cef_panel_t

// Go type for cef_panel_t
type CPanelT struct {
	noCopy    noCopy
	pc_panel  *cCPanelT
	beUnrefed unrefedBy
}

func (p *CPanelT) Pass() (ret *CPanelT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPanelT((*C.cef_panel_t)(p.pc_panel), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPanelT) NewRef() (newP *CPanelT) {
	if self == nil {
		return newP
	}
	gop := self.pc_panel
	BaseAddRef(gop)
	newP = newCPanelT((*C.cef_panel_t)(gop), byApp)
	return newP
}

// Go type CPanelT wraps cef type *C.cef_panel_t
func newCPanelT(p *C.cef_panel_t, unrefedBy unrefedBy) *CPanelT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T169.1:")
	pc := (*cCPanelT)(p)
	go_panel := &CPanelT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_panel, func(g *CPanelT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_panel != nil {
			Tracef(unsafe.Pointer(g.pc_panel), "T169.2:")
			BaseRelease(g.pc_panel)
		}
	})

	return go_panel
}

// *C.cef_panel_t has refCounted interface
func (panel *CPanelT) HasOneRef() bool {
	return BaseHasOneRef(panel.pc_panel)
}

func (p *cCPanelT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (panel *CPanelT) Unref() (ret bool) {
	if panel == nil {
		return
	}
	if panel.beUnrefed == byApp {
		ret = BaseRelease(panel.pc_panel)
		panel.beUnrefed = unrefed
	}
	panel.pc_panel = nil
	return ret
}

// Convert to Base Class Pointer *CViewT
func (panel *CPanelT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(panel.pc_panel))
	BaseAddRef(panel.pc_panel)
	return newCViewT(p, byApp)
}

///
// Returns this Panel as a Window or NULL if this is not a Window.
///
func (self *CPanelT) AsWindow() (ret *CWindowT) {

	cRet := C.cefingo_panel_as_window((*C.cef_panel_t)(self.pc_panel))

	ret = newCWindowT(cRet, byApp) // return GoObj
	return ret
}

///
// Set this Panel&#39;s Layout to FillLayout and return the FillLayout object.
///
func (self *CPanelT) SetToFillLayout() (ret *CFillLayoutT) {

	cRet := C.cefingo_panel_set_to_fill_layout((*C.cef_panel_t)(self.pc_panel))

	ret = newCFillLayoutT(cRet, byApp) // return GoObj
	return ret
}

///
// Set this Panel&#39;s Layout to BoxLayout and return the BoxLayout object.
///
func (self *CPanelT) SetToBoxLayout(
	settings *CBoxLayoutSettingsT,
) (ret *CBoxLayoutT) {

	cRet := C.cefingo_panel_set_to_box_layout((*C.cef_panel_t)(self.pc_panel), (*C.cef_box_layout_settings_t)(settings))

	ret = newCBoxLayoutT(cRet, byApp) // return GoObj
	return ret
}

///
// Get the Layout.
///
func (self *CPanelT) GetLayout() (ret *CLayoutT) {

	cRet := C.cefingo_panel_get_layout((*C.cef_panel_t)(self.pc_panel))

	ret = newCLayoutT(cRet, byApp) // return GoObj
	return ret
}

///
// Lay out the child Views (set their bounds based on sizing heuristics
// specific to the current Layout).
///
func (self *CPanelT) Layout() {

	C.cefingo_panel_layout((*C.cef_panel_t)(self.pc_panel))

}

///
// Add a child View.
///
func (self *CPanelT) AddChildView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	C.cefingo_panel_add_child_view((*C.cef_panel_t)(self.pc_panel), goTmpview)

}

///
// Add a child View at the specified |index|. If |index| matches the result of
// GetChildCount() then the View will be added at the end.
///
func (self *CPanelT) AddChildViewAt(
	view *CViewT,
	index int,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	C.cefingo_panel_add_child_view_at((*C.cef_panel_t)(self.pc_panel), goTmpview, (C.int)(index))

}

///
// Move the child View to the specified |index|. A negative value for |index|
// will move the View to the end.
///
func (self *CPanelT) ReorderChildView(
	view *CViewT,
	index int,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	C.cefingo_panel_reorder_child_view((*C.cef_panel_t)(self.pc_panel), goTmpview, (C.int)(index))

}

///
// Remove a child View. The View can then be added to another Panel.
///
func (self *CPanelT) RemoveChildView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	C.cefingo_panel_remove_child_view((*C.cef_panel_t)(self.pc_panel), goTmpview)

}

///
// Remove all child Views. The removed Views will be deleted if the client
// holds no references to them.
///
func (self *CPanelT) RemoveAllChildViews() {

	C.cefingo_panel_remove_all_child_views((*C.cef_panel_t)(self.pc_panel))

}

///
// Returns the number of child Views.
///
func (self *CPanelT) GetChildViewCount() (ret int64) {

	cRet := C.cefingo_panel_get_child_view_count((*C.cef_panel_t)(self.pc_panel))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the child View at the specified |index|.
///
func (self *CPanelT) GetChildViewAt(
	index int,
) (ret *CViewT) {

	cRet := C.cefingo_panel_get_child_view_at((*C.cef_panel_t)(self.pc_panel), (C.int)(index))

	ret = newCViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new Panel.
///
func PanelCreate(
	delegate *CPanelDelegateT,
) (ret *CPanelT) {
	var goTmpdelegate *C.cef_panel_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_panel_delegate)
		goTmpdelegate = (*C.cef_panel_delegate_t)(delegate.pc_panel_delegate)
	}

	cRet := C.cef_panel_create(goTmpdelegate)

	ret = newCPanelT(cRet, byApp) // return GoObj
	return ret
}

// cef_panel_delegate_capi.h, include/capi/views/cef_panel_delegate_capi.h:59:3,

///
// Implement this structure to handle Panel events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCPanelDelegateT C.cef_panel_delegate_t

// Go type for cef_panel_delegate_t
type CPanelDelegateT struct {
	noCopy            noCopy
	pc_panel_delegate *cCPanelDelegateT
	beUnrefed         unrefedBy
}

func (p *CPanelDelegateT) Pass() (ret *CPanelDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPanelDelegateT((*C.cef_panel_delegate_t)(p.pc_panel_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPanelDelegateT) NewRef() (newP *CPanelDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_panel_delegate
	BaseAddRef(gop)
	newP = newCPanelDelegateT((*C.cef_panel_delegate_t)(gop), byApp)
	return newP
}

// Go type CPanelDelegateT wraps cef type *C.cef_panel_delegate_t
func newCPanelDelegateT(p *C.cef_panel_delegate_t, unrefedBy unrefedBy) *CPanelDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T170.1:")
	pc := (*cCPanelDelegateT)(p)
	go_panel_delegate := &CPanelDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_panel_delegate, func(g *CPanelDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_panel_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_panel_delegate), "T170.2:")
			BaseRelease(g.pc_panel_delegate)
		}
	})

	return go_panel_delegate
}

// *C.cef_panel_delegate_t has refCounted interface
func (panel_delegate *CPanelDelegateT) HasOneRef() bool {
	return BaseHasOneRef(panel_delegate.pc_panel_delegate)
}

func (p *cCPanelDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (panel_delegate *CPanelDelegateT) Unref() (ret bool) {
	if panel_delegate == nil {
		return
	}
	if panel_delegate.beUnrefed == byApp {
		ret = BaseRelease(panel_delegate.pc_panel_delegate)
		panel_delegate.beUnrefed = unrefed
	}
	panel_delegate.pc_panel_delegate = nil
	return ret
}

// Convert to Base Class Pointer *CViewDelegateT
func (panel_delegate *CPanelDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(panel_delegate.pc_panel_delegate))
	BaseAddRef(panel_delegate.pc_panel_delegate)
	return newCViewDelegateT(p, byApp)
}

var panel_delegate_handlers = struct {
	handler                        map[*cCPanelDelegateT]interface{}
	get_preferred_size_handler     map[*cCPanelDelegateT]GetPreferredSizeHandler
	get_minimum_size_handler       map[*cCPanelDelegateT]GetMinimumSizeHandler
	get_maximum_size_handler       map[*cCPanelDelegateT]GetMaximumSizeHandler
	get_height_for_width_handler   map[*cCPanelDelegateT]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*cCPanelDelegateT]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*cCPanelDelegateT]OnChildViewChangedHandler
	on_window_changed_handler      map[*cCPanelDelegateT]OnWindowChangedHandler
	on_layout_changed_handler      map[*cCPanelDelegateT]OnLayoutChangedHandler
	on_focus_handler               map[*cCPanelDelegateT]OnFocusHandler
	on_blur_handler                map[*cCPanelDelegateT]OnBlurHandler
}{
	map[*cCPanelDelegateT]interface{}{},
	map[*cCPanelDelegateT]GetPreferredSizeHandler{},
	map[*cCPanelDelegateT]GetMinimumSizeHandler{},
	map[*cCPanelDelegateT]GetMaximumSizeHandler{},
	map[*cCPanelDelegateT]GetHeightForWidthHandler{},
	map[*cCPanelDelegateT]OnParentViewChangedHandler{},
	map[*cCPanelDelegateT]OnChildViewChangedHandler{},
	map[*cCPanelDelegateT]OnWindowChangedHandler{},
	map[*cCPanelDelegateT]OnLayoutChangedHandler{},
	map[*cCPanelDelegateT]OnFocusHandler{},
	map[*cCPanelDelegateT]OnBlurHandler{},
}

// allocCPanelDelegateT allocates CPanelDelegateT and construct it
func allocCPanelDelegateT() *CPanelDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_panel_delegate_wrapper_t, "T170.3:")
	cefp := C.cefingo_construct_panel_delegate((*C.cefingo_panel_delegate_wrapper_t)(up))
	cgop := (*cCPanelDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_panel_delegate_t itself in DeassocFunc,
		// or cef_panel_delegate_t is never GCed.
		Tracef(up, "T170.4:")
		unbindAllCPanelDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCPanelDelegateT(cefp, byApp)
}

// NewCPanelDelegateT allocates CPanelDelegateT, construct and bind it
func NewCPanelDelegateT(a interface{}) *CPanelDelegateT {
	return allocCPanelDelegateT().bind(a)
}

func (panel_delegate *CPanelDelegateT) bind(a interface{}) *CPanelDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := panel_delegate.pc_panel_delegate
	panel_delegate_handlers.handler[cp] = a

	if h, ok := a.(GetPreferredSizeHandler); ok {
		panel_delegate_handlers.get_preferred_size_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.get_preferred_size_handler, cp)
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		panel_delegate_handlers.get_minimum_size_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.get_minimum_size_handler, cp)
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		panel_delegate_handlers.get_maximum_size_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.get_maximum_size_handler, cp)
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		panel_delegate_handlers.get_height_for_width_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.get_height_for_width_handler, cp)
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		panel_delegate_handlers.on_parent_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.on_parent_view_changed_handler, cp)
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		panel_delegate_handlers.on_child_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.on_child_view_changed_handler, cp)
	}

	if h, ok := a.(OnWindowChangedHandler); ok {
		panel_delegate_handlers.on_window_changed_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.on_window_changed_handler, cp)
	}

	if h, ok := a.(OnLayoutChangedHandler); ok {
		panel_delegate_handlers.on_layout_changed_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.on_layout_changed_handler, cp)
	}

	if h, ok := a.(OnFocusHandler); ok {
		panel_delegate_handlers.on_focus_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.on_focus_handler, cp)
	}

	if h, ok := a.(OnBlurHandler); ok {
		panel_delegate_handlers.on_blur_handler[cp] = h
		noBind = false
	} else {
		delete(panel_delegate_handlers.on_blur_handler, cp)
	}

	if noBind {
		Panicln("F229: *CPanelDelegateT No bind")
	}
	return panel_delegate
}

func unbindAllCPanelDelegateT(cp *cCPanelDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := panel_delegate.pc_panel_delegate
	delete(panel_delegate_handlers.handler, cp)

	delete(panel_delegate_handlers.get_preferred_size_handler, cp)
	delete(panel_delegate_handlers.get_minimum_size_handler, cp)
	delete(panel_delegate_handlers.get_maximum_size_handler, cp)
	delete(panel_delegate_handlers.get_height_for_width_handler, cp)
	delete(panel_delegate_handlers.on_parent_view_changed_handler, cp)
	delete(panel_delegate_handlers.on_child_view_changed_handler, cp)
	delete(panel_delegate_handlers.on_window_changed_handler, cp)
	delete(panel_delegate_handlers.on_layout_changed_handler, cp)
	delete(panel_delegate_handlers.on_focus_handler, cp)
	delete(panel_delegate_handlers.on_blur_handler, cp)
}

func (panel_delegate *CPanelDelegateT) UnbindAll() {
	unbindAllCPanelDelegateT(panel_delegate.pc_panel_delegate)
	panel_delegate.Unref()
}

func (panel_delegate *CPanelDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := panel_delegate.pc_panel_delegate
	return panel_delegate_handlers.handler[cp]
}

// cef_print_handler_capi.h, include/capi/cef_print_handler_capi.h:70:3,

///
// Callback structure for asynchronous continuation of print dialog requests.
///

type cCPrintDialogCallbackT C.cef_print_dialog_callback_t

// Go type for cef_print_dialog_callback_t
type CPrintDialogCallbackT struct {
	noCopy                   noCopy
	pc_print_dialog_callback *cCPrintDialogCallbackT
	beUnrefed                unrefedBy
}

func (p *CPrintDialogCallbackT) Pass() (ret *CPrintDialogCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPrintDialogCallbackT((*C.cef_print_dialog_callback_t)(p.pc_print_dialog_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPrintDialogCallbackT) NewRef() (newP *CPrintDialogCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_print_dialog_callback
	BaseAddRef(gop)
	newP = newCPrintDialogCallbackT((*C.cef_print_dialog_callback_t)(gop), byApp)
	return newP
}

// Go type CPrintDialogCallbackT wraps cef type *C.cef_print_dialog_callback_t
func newCPrintDialogCallbackT(p *C.cef_print_dialog_callback_t, unrefedBy unrefedBy) *CPrintDialogCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T171.1:")
	pc := (*cCPrintDialogCallbackT)(p)
	go_print_dialog_callback := &CPrintDialogCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_print_dialog_callback, func(g *CPrintDialogCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_print_dialog_callback != nil {
			Tracef(unsafe.Pointer(g.pc_print_dialog_callback), "T171.2:")
			BaseRelease(g.pc_print_dialog_callback)
		}
	})

	return go_print_dialog_callback
}

// *C.cef_print_dialog_callback_t has refCounted interface
func (print_dialog_callback *CPrintDialogCallbackT) HasOneRef() bool {
	return BaseHasOneRef(print_dialog_callback.pc_print_dialog_callback)
}

func (p *cCPrintDialogCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (print_dialog_callback *CPrintDialogCallbackT) Unref() (ret bool) {
	if print_dialog_callback == nil {
		return
	}
	if print_dialog_callback.beUnrefed == byApp {
		ret = BaseRelease(print_dialog_callback.pc_print_dialog_callback)
		print_dialog_callback.beUnrefed = unrefed
	}
	print_dialog_callback.pc_print_dialog_callback = nil
	return ret
}

///
// Continue printing with the specified |settings|.
///
func (self *CPrintDialogCallbackT) Cont(
	settings *CPrintSettingsT,
) {
	var goTmpsettings *C.cef_print_settings_t
	if settings != nil {
		BaseAddRef(settings.pc_print_settings)
		goTmpsettings = (*C.cef_print_settings_t)(settings.pc_print_settings)
	}

	C.cefingo_print_dialog_callback_cont((*C.cef_print_dialog_callback_t)(self.pc_print_dialog_callback), goTmpsettings)

}

///
// Cancel the printing.
///
func (self *CPrintDialogCallbackT) Cancel() {

	C.cefingo_print_dialog_callback_cancel((*C.cef_print_dialog_callback_t)(self.pc_print_dialog_callback))

}

///
// Callback structure for asynchronous continuation of print job requests.
///

type cCPrintJobCallbackT C.cef_print_job_callback_t

// Go type for cef_print_job_callback_t
type CPrintJobCallbackT struct {
	noCopy                noCopy
	pc_print_job_callback *cCPrintJobCallbackT
	beUnrefed             unrefedBy
}

func (p *CPrintJobCallbackT) Pass() (ret *CPrintJobCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPrintJobCallbackT((*C.cef_print_job_callback_t)(p.pc_print_job_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPrintJobCallbackT) NewRef() (newP *CPrintJobCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_print_job_callback
	BaseAddRef(gop)
	newP = newCPrintJobCallbackT((*C.cef_print_job_callback_t)(gop), byApp)
	return newP
}

// Go type CPrintJobCallbackT wraps cef type *C.cef_print_job_callback_t
func newCPrintJobCallbackT(p *C.cef_print_job_callback_t, unrefedBy unrefedBy) *CPrintJobCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T172.1:")
	pc := (*cCPrintJobCallbackT)(p)
	go_print_job_callback := &CPrintJobCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_print_job_callback, func(g *CPrintJobCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_print_job_callback != nil {
			Tracef(unsafe.Pointer(g.pc_print_job_callback), "T172.2:")
			BaseRelease(g.pc_print_job_callback)
		}
	})

	return go_print_job_callback
}

// *C.cef_print_job_callback_t has refCounted interface
func (print_job_callback *CPrintJobCallbackT) HasOneRef() bool {
	return BaseHasOneRef(print_job_callback.pc_print_job_callback)
}

func (p *cCPrintJobCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (print_job_callback *CPrintJobCallbackT) Unref() (ret bool) {
	if print_job_callback == nil {
		return
	}
	if print_job_callback.beUnrefed == byApp {
		ret = BaseRelease(print_job_callback.pc_print_job_callback)
		print_job_callback.beUnrefed = unrefed
	}
	print_job_callback.pc_print_job_callback = nil
	return ret
}

///
// Indicate completion of the print job.
///
func (self *CPrintJobCallbackT) Cont() {

	C.cefingo_print_job_callback_cont((*C.cef_print_job_callback_t)(self.pc_print_job_callback))

}

///
// Implement this structure to handle printing on Linux. Each browser will have
// only one print job in progress at a time. The functions of this structure
// will be called on the browser process UI thread.
///

type cCPrintHandlerT C.cef_print_handler_t

// Go type for cef_print_handler_t
type CPrintHandlerT struct {
	noCopy           noCopy
	pc_print_handler *cCPrintHandlerT
	beUnrefed        unrefedBy
}

func (p *CPrintHandlerT) Pass() (ret *CPrintHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPrintHandlerT((*C.cef_print_handler_t)(p.pc_print_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPrintHandlerT) NewRef() (newP *CPrintHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_print_handler
	BaseAddRef(gop)
	newP = newCPrintHandlerT((*C.cef_print_handler_t)(gop), byApp)
	return newP
}

// Go type CPrintHandlerT wraps cef type *C.cef_print_handler_t
func newCPrintHandlerT(p *C.cef_print_handler_t, unrefedBy unrefedBy) *CPrintHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T173.1:")
	pc := (*cCPrintHandlerT)(p)
	go_print_handler := &CPrintHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_print_handler, func(g *CPrintHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_print_handler != nil {
			Tracef(unsafe.Pointer(g.pc_print_handler), "T173.2:")
			BaseRelease(g.pc_print_handler)
		}
	})

	return go_print_handler
}

// *C.cef_print_handler_t has refCounted interface
func (print_handler *CPrintHandlerT) HasOneRef() bool {
	return BaseHasOneRef(print_handler.pc_print_handler)
}

func (p *cCPrintHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (print_handler *CPrintHandlerT) Unref() (ret bool) {
	if print_handler == nil {
		return
	}
	if print_handler.beUnrefed == byApp {
		ret = BaseRelease(print_handler.pc_print_handler)
		print_handler.beUnrefed = unrefed
	}
	print_handler.pc_print_handler = nil
	return ret
}

///
// Called when printing has started for the specified |browser|. This function
// will be called before the other OnPrint*() functions and irrespective of
// how printing was initiated (e.g. cef_browser_host_t::print(), JavaScript
// window.print() or PDF extension print button).
///
type OnPrintStartHandler interface {
	OnPrintStart(
		self *CPrintHandlerT,
		browser *CBrowserT,
	)
}

///
// Synchronize |settings| with client state. If |get_defaults| is true (1)
// then populate |settings| with the default print settings. Do not keep a
// reference to |settings| outside of this callback.
///
type OnPrintSettingsHandler interface {
	OnPrintSettings(
		self *CPrintHandlerT,
		browser *CBrowserT,
		settings *CPrintSettingsT,
		get_defaults int,
	)
}

///
// Show the print dialog. Execute |callback| once the dialog is dismissed.
// Return true (1) if the dialog will be displayed or false (0) to cancel the
// printing immediately.
///
type OnPrintDialogHandler interface {
	OnPrintDialog(
		self *CPrintHandlerT,
		browser *CBrowserT,
		has_selection int,
		callback *CPrintDialogCallbackT,
	) (ret bool)
}

///
// Send the print job to the printer. Execute |callback| once the job is
// completed. Return true (1) if the job will proceed or false (0) to cancel
// the job immediately.
///
type OnPrintJobHandler interface {
	OnPrintJob(
		self *CPrintHandlerT,
		browser *CBrowserT,
		document_name string,
		pdf_file_path string,
		callback *CPrintJobCallbackT,
	) (ret bool)
}

///
// Reset client state related to printing.
///
type OnPrintResetHandler interface {
	OnPrintReset(
		self *CPrintHandlerT,
		browser *CBrowserT,
	)
}

///
// Return the PDF paper size in device units. Used in combination with
// cef_browser_host_t::print_to_pdf().
///
type GetPdfPaperSizeHandler interface {
	GetPdfPaperSize(
		self *CPrintHandlerT,
		browser *CBrowserT,
		device_units_per_inch int,
	) (ret CSizeT)
}

var print_handler_handlers = struct {
	handler                    map[*cCPrintHandlerT]interface{}
	on_print_start_handler     map[*cCPrintHandlerT]OnPrintStartHandler
	on_print_settings_handler  map[*cCPrintHandlerT]OnPrintSettingsHandler
	on_print_dialog_handler    map[*cCPrintHandlerT]OnPrintDialogHandler
	on_print_job_handler       map[*cCPrintHandlerT]OnPrintJobHandler
	on_print_reset_handler     map[*cCPrintHandlerT]OnPrintResetHandler
	get_pdf_paper_size_handler map[*cCPrintHandlerT]GetPdfPaperSizeHandler
}{
	map[*cCPrintHandlerT]interface{}{},
	map[*cCPrintHandlerT]OnPrintStartHandler{},
	map[*cCPrintHandlerT]OnPrintSettingsHandler{},
	map[*cCPrintHandlerT]OnPrintDialogHandler{},
	map[*cCPrintHandlerT]OnPrintJobHandler{},
	map[*cCPrintHandlerT]OnPrintResetHandler{},
	map[*cCPrintHandlerT]GetPdfPaperSizeHandler{},
}

// allocCPrintHandlerT allocates CPrintHandlerT and construct it
func allocCPrintHandlerT() *CPrintHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_print_handler_wrapper_t, "T173.3:")
	cefp := C.cefingo_construct_print_handler((*C.cefingo_print_handler_wrapper_t)(up))
	cgop := (*cCPrintHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_print_handler_t itself in DeassocFunc,
		// or cef_print_handler_t is never GCed.
		Tracef(up, "T173.4:")
		unbindAllCPrintHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCPrintHandlerT(cefp, byApp)
}

// NewCPrintHandlerT allocates CPrintHandlerT, construct and bind it
func NewCPrintHandlerT(a interface{}) *CPrintHandlerT {
	return allocCPrintHandlerT().bind(a)
}

func (print_handler *CPrintHandlerT) bind(a interface{}) *CPrintHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := print_handler.pc_print_handler
	print_handler_handlers.handler[cp] = a

	if h, ok := a.(OnPrintStartHandler); ok {
		print_handler_handlers.on_print_start_handler[cp] = h
		noBind = false
	} else {
		delete(print_handler_handlers.on_print_start_handler, cp)
	}

	if h, ok := a.(OnPrintSettingsHandler); ok {
		print_handler_handlers.on_print_settings_handler[cp] = h
		noBind = false
	} else {
		delete(print_handler_handlers.on_print_settings_handler, cp)
	}

	if h, ok := a.(OnPrintDialogHandler); ok {
		print_handler_handlers.on_print_dialog_handler[cp] = h
		noBind = false
	} else {
		delete(print_handler_handlers.on_print_dialog_handler, cp)
	}

	if h, ok := a.(OnPrintJobHandler); ok {
		print_handler_handlers.on_print_job_handler[cp] = h
		noBind = false
	} else {
		delete(print_handler_handlers.on_print_job_handler, cp)
	}

	if h, ok := a.(OnPrintResetHandler); ok {
		print_handler_handlers.on_print_reset_handler[cp] = h
		noBind = false
	} else {
		delete(print_handler_handlers.on_print_reset_handler, cp)
	}

	if h, ok := a.(GetPdfPaperSizeHandler); ok {
		print_handler_handlers.get_pdf_paper_size_handler[cp] = h
		noBind = false
	} else {
		delete(print_handler_handlers.get_pdf_paper_size_handler, cp)
	}

	if noBind {
		Panicln("F229: *CPrintHandlerT No bind")
	}
	return print_handler
}

func unbindAllCPrintHandlerT(cp *cCPrintHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := print_handler.pc_print_handler
	delete(print_handler_handlers.handler, cp)

	delete(print_handler_handlers.on_print_start_handler, cp)
	delete(print_handler_handlers.on_print_settings_handler, cp)
	delete(print_handler_handlers.on_print_dialog_handler, cp)
	delete(print_handler_handlers.on_print_job_handler, cp)
	delete(print_handler_handlers.on_print_reset_handler, cp)
	delete(print_handler_handlers.get_pdf_paper_size_handler, cp)
}

func (print_handler *CPrintHandlerT) UnbindAll() {
	unbindAllCPrintHandlerT(print_handler.pc_print_handler)
	print_handler.Unref()
}

func (print_handler *CPrintHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := print_handler.pc_print_handler
	return print_handler_handlers.handler[cp]
}

// cef_print_settings_capi.h, include/capi/cef_print_settings_capi.h:191:3,

///
// Structure representing print settings.
///

type cCPrintSettingsT C.cef_print_settings_t

// Go type for cef_print_settings_t
type CPrintSettingsT struct {
	noCopy            noCopy
	pc_print_settings *cCPrintSettingsT
	beUnrefed         unrefedBy
}

func (p *CPrintSettingsT) Pass() (ret *CPrintSettingsT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPrintSettingsT((*C.cef_print_settings_t)(p.pc_print_settings), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPrintSettingsT) NewRef() (newP *CPrintSettingsT) {
	if self == nil {
		return newP
	}
	gop := self.pc_print_settings
	BaseAddRef(gop)
	newP = newCPrintSettingsT((*C.cef_print_settings_t)(gop), byApp)
	return newP
}

// Go type CPrintSettingsT wraps cef type *C.cef_print_settings_t
func newCPrintSettingsT(p *C.cef_print_settings_t, unrefedBy unrefedBy) *CPrintSettingsT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T174.1:")
	pc := (*cCPrintSettingsT)(p)
	go_print_settings := &CPrintSettingsT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_print_settings, func(g *CPrintSettingsT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_print_settings != nil {
			Tracef(unsafe.Pointer(g.pc_print_settings), "T174.2:")
			BaseRelease(g.pc_print_settings)
		}
	})

	return go_print_settings
}

// *C.cef_print_settings_t has refCounted interface
func (print_settings *CPrintSettingsT) HasOneRef() bool {
	return BaseHasOneRef(print_settings.pc_print_settings)
}

func (p *cCPrintSettingsT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (print_settings *CPrintSettingsT) Unref() (ret bool) {
	if print_settings == nil {
		return
	}
	if print_settings.beUnrefed == byApp {
		ret = BaseRelease(print_settings.pc_print_settings)
		print_settings.beUnrefed = unrefed
	}
	print_settings.pc_print_settings = nil
	return ret
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CPrintSettingsT) IsValid() (ret bool) {

	cRet := C.cefingo_print_settings_is_valid((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CPrintSettingsT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_print_settings_is_read_only((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = cRet == 1
	return ret
}

///
// Set the page orientation.
///
func (self *CPrintSettingsT) SetOrientation(
	landscape int,
) {

	C.cefingo_print_settings_set_orientation((*C.cef_print_settings_t)(self.pc_print_settings), (C.int)(landscape))

}

///
// Returns true (1) if the orientation is landscape.
///
func (self *CPrintSettingsT) IsLandscape() (ret bool) {

	cRet := C.cefingo_print_settings_is_landscape((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = cRet == 1
	return ret
}

///
// Set the printer printable area in device units. Some platforms already
// provide flipped area. Set |landscape_needs_flip| to false (0) on those
// platforms to avoid double flipping.
///
func (self *CPrintSettingsT) SetPrinterPrintableArea(
	physical_size_device_units *CSizeT,
	printable_area_device_units *CRectT,
	landscape_needs_flip int,
) {

	C.cefingo_print_settings_set_printer_printable_area((*C.cef_print_settings_t)(self.pc_print_settings), (*C.cef_size_t)(physical_size_device_units), (*C.cef_rect_t)(printable_area_device_units), (C.int)(landscape_needs_flip))

}

///
// Set the device name.
///
func (self *CPrintSettingsT) SetDeviceName(
	name string,
) {
	c_name := create_cef_string(name)

	C.cefingo_print_settings_set_device_name((*C.cef_print_settings_t)(self.pc_print_settings), c_name.p_cef_string_t)

}

///
// Get the device name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CPrintSettingsT) GetDeviceName() (ret string) {

	cRet := C.cefingo_print_settings_get_device_name((*C.cef_print_settings_t)(self.pc_print_settings))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the DPI (dots per inch).
///
func (self *CPrintSettingsT) SetDpi(
	dpi int,
) {

	C.cefingo_print_settings_set_dpi((*C.cef_print_settings_t)(self.pc_print_settings), (C.int)(dpi))

}

///
// Get the DPI (dots per inch).
///
func (self *CPrintSettingsT) GetDpi() (ret bool) {

	cRet := C.cefingo_print_settings_get_dpi((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = cRet == 1
	return ret
}

///
// Set the page ranges.
///
func (self *CPrintSettingsT) SetPageRanges(
	rangesCount int64,
	ranges *CRangeT,
) {

	C.cefingo_print_settings_set_page_ranges((*C.cef_print_settings_t)(self.pc_print_settings), (C.size_t)(rangesCount), (*C.cef_range_t)(ranges))

}

///
// Returns the number of page ranges that currently exist.
///
func (self *CPrintSettingsT) GetPageRangesCount() (ret int64) {

	cRet := C.cefingo_print_settings_get_page_ranges_count((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Set whether only the selection will be printed.
///
func (self *CPrintSettingsT) SetSelectionOnly(
	selection_only int,
) {

	C.cefingo_print_settings_set_selection_only((*C.cef_print_settings_t)(self.pc_print_settings), (C.int)(selection_only))

}

///
// Returns true (1) if only the selection will be printed.
///
func (self *CPrintSettingsT) IsSelectionOnly() (ret bool) {

	cRet := C.cefingo_print_settings_is_selection_only((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = cRet == 1
	return ret
}

///
// Set whether pages will be collated.
///
func (self *CPrintSettingsT) SetCollate(
	collate int,
) {

	C.cefingo_print_settings_set_collate((*C.cef_print_settings_t)(self.pc_print_settings), (C.int)(collate))

}

///
// Returns true (1) if pages will be collated.
///
func (self *CPrintSettingsT) WillCollate() (ret bool) {

	cRet := C.cefingo_print_settings_will_collate((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = cRet == 1
	return ret
}

///
// Set the color model.
///
func (self *CPrintSettingsT) SetColorModel(
	model CColorModelT,
) {

	C.cefingo_print_settings_set_color_model((*C.cef_print_settings_t)(self.pc_print_settings), (C.cef_color_model_t)(model))

}

///
// Get the color model.
///
func (self *CPrintSettingsT) GetColorModel() (ret CColorModelT) {

	cRet := C.cefingo_print_settings_get_color_model((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = CColorModelT(cRet) // return GoObj
	return ret
}

///
// Set the number of copies.
///
func (self *CPrintSettingsT) SetCopies(
	copies int,
) {

	C.cefingo_print_settings_set_copies((*C.cef_print_settings_t)(self.pc_print_settings), (C.int)(copies))

}

///
// Get the number of copies.
///
func (self *CPrintSettingsT) GetCopies() (ret bool) {

	cRet := C.cefingo_print_settings_get_copies((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = cRet == 1
	return ret
}

///
// Set the duplex mode.
///
func (self *CPrintSettingsT) SetDuplexMode(
	mode CDuplexModeT,
) {

	C.cefingo_print_settings_set_duplex_mode((*C.cef_print_settings_t)(self.pc_print_settings), (C.cef_duplex_mode_t)(mode))

}

///
// Get the duplex mode.
///
func (self *CPrintSettingsT) GetDuplexMode() (ret CDuplexModeT) {

	cRet := C.cefingo_print_settings_get_duplex_mode((*C.cef_print_settings_t)(self.pc_print_settings))

	ret = CDuplexModeT(cRet) // return GoObj
	return ret
}

///
// Create a new cef_print_settings_t object.
///
func PrintSettingsCreate() (ret *CPrintSettingsT) {

	cRet := C.cef_print_settings_create()

	ret = newCPrintSettingsT(cRet, byApp) // return GoObj
	return ret
}

// cef_process_message_capi.h, include/capi/cef_process_message_capi.h:89:3,

///
// Structure representing a message. Can be used on any process and thread.
///

type cCProcessMessageT C.cef_process_message_t

// Go type for cef_process_message_t
type CProcessMessageT struct {
	noCopy             noCopy
	pc_process_message *cCProcessMessageT
	beUnrefed          unrefedBy
}

func (p *CProcessMessageT) Pass() (ret *CProcessMessageT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCProcessMessageT((*C.cef_process_message_t)(p.pc_process_message), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CProcessMessageT) NewRef() (newP *CProcessMessageT) {
	if self == nil {
		return newP
	}
	gop := self.pc_process_message
	BaseAddRef(gop)
	newP = newCProcessMessageT((*C.cef_process_message_t)(gop), byApp)
	return newP
}

// Go type CProcessMessageT wraps cef type *C.cef_process_message_t
func newCProcessMessageT(p *C.cef_process_message_t, unrefedBy unrefedBy) *CProcessMessageT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T175.1:")
	pc := (*cCProcessMessageT)(p)
	go_process_message := &CProcessMessageT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_process_message, func(g *CProcessMessageT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_process_message != nil {
			Tracef(unsafe.Pointer(g.pc_process_message), "T175.2:")
			BaseRelease(g.pc_process_message)
		}
	})

	return go_process_message
}

// *C.cef_process_message_t has refCounted interface
func (process_message *CProcessMessageT) HasOneRef() bool {
	return BaseHasOneRef(process_message.pc_process_message)
}

func (p *cCProcessMessageT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (process_message *CProcessMessageT) Unref() (ret bool) {
	if process_message == nil {
		return
	}
	if process_message.beUnrefed == byApp {
		ret = BaseRelease(process_message.pc_process_message)
		process_message.beUnrefed = unrefed
	}
	process_message.pc_process_message = nil
	return ret
}

///
// Returns true (1) if this object is valid. Do not call any other functions
// if this function returns false (0).
///
func (self *CProcessMessageT) IsValid() (ret bool) {

	cRet := C.cefingo_process_message_is_valid((*C.cef_process_message_t)(self.pc_process_message))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CProcessMessageT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_process_message_is_read_only((*C.cef_process_message_t)(self.pc_process_message))

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object.
///
func (self *CProcessMessageT) Copy() (ret *CProcessMessageT) {

	cRet := C.cefingo_process_message_copy((*C.cef_process_message_t)(self.pc_process_message))

	ret = newCProcessMessageT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the message name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CProcessMessageT) GetName() (ret string) {

	cRet := C.cefingo_process_message_get_name((*C.cef_process_message_t)(self.pc_process_message))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the list of arguments.
///
func (self *CProcessMessageT) GetArgumentList() (ret *CListValueT) {

	cRet := C.cefingo_process_message_get_argument_list((*C.cef_process_message_t)(self.pc_process_message))

	ret = newCListValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_process_message_t object with the specified name.
///
func ProcessMessageCreate(
	name string,
) (ret *CProcessMessageT) {
	c_name := create_cef_string(name)

	cRet := C.cef_process_message_create(c_name.p_cef_string_t)

	ret = newCProcessMessageT(cRet, byApp) // return GoObj
	return ret
}

// cef_registration_capi.h, include/capi/cef_registration_capi.h:57:3,

///
// Generic callback structure used for managing the lifespan of a registration.
///

type cCRegistrationT C.cef_registration_t

// Go type for cef_registration_t
type CRegistrationT struct {
	noCopy          noCopy
	pc_registration *cCRegistrationT
	beUnrefed       unrefedBy
}

func (p *CRegistrationT) Pass() (ret *CRegistrationT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRegistrationT((*C.cef_registration_t)(p.pc_registration), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRegistrationT) NewRef() (newP *CRegistrationT) {
	if self == nil {
		return newP
	}
	gop := self.pc_registration
	BaseAddRef(gop)
	newP = newCRegistrationT((*C.cef_registration_t)(gop), byApp)
	return newP
}

// Go type CRegistrationT wraps cef type *C.cef_registration_t
func newCRegistrationT(p *C.cef_registration_t, unrefedBy unrefedBy) *CRegistrationT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T176.1:")
	pc := (*cCRegistrationT)(p)
	go_registration := &CRegistrationT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_registration, func(g *CRegistrationT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_registration != nil {
			Tracef(unsafe.Pointer(g.pc_registration), "T176.2:")
			BaseRelease(g.pc_registration)
		}
	})

	return go_registration
}

// *C.cef_registration_t has refCounted interface
func (registration *CRegistrationT) HasOneRef() bool {
	return BaseHasOneRef(registration.pc_registration)
}

func (p *cCRegistrationT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (registration *CRegistrationT) Unref() (ret bool) {
	if registration == nil {
		return
	}
	if registration.beUnrefed == byApp {
		ret = BaseRelease(registration.pc_registration)
		registration.beUnrefed = unrefed
	}
	registration.pc_registration = nil
	return ret
}

// cef_render_handler_capi.h, include/capi/cef_render_handler_capi.h:234:3,

///
// Implement this structure to handle events when window rendering is disabled.
// The functions of this structure will be called on the UI thread.
///

type cCRenderHandlerT C.cef_render_handler_t

// Go type for cef_render_handler_t
type CRenderHandlerT struct {
	noCopy            noCopy
	pc_render_handler *cCRenderHandlerT
	beUnrefed         unrefedBy
}

func (p *CRenderHandlerT) Pass() (ret *CRenderHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRenderHandlerT((*C.cef_render_handler_t)(p.pc_render_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRenderHandlerT) NewRef() (newP *CRenderHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_render_handler
	BaseAddRef(gop)
	newP = newCRenderHandlerT((*C.cef_render_handler_t)(gop), byApp)
	return newP
}

// Go type CRenderHandlerT wraps cef type *C.cef_render_handler_t
func newCRenderHandlerT(p *C.cef_render_handler_t, unrefedBy unrefedBy) *CRenderHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T177.1:")
	pc := (*cCRenderHandlerT)(p)
	go_render_handler := &CRenderHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_render_handler, func(g *CRenderHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_render_handler != nil {
			Tracef(unsafe.Pointer(g.pc_render_handler), "T177.2:")
			BaseRelease(g.pc_render_handler)
		}
	})

	return go_render_handler
}

// *C.cef_render_handler_t has refCounted interface
func (render_handler *CRenderHandlerT) HasOneRef() bool {
	return BaseHasOneRef(render_handler.pc_render_handler)
}

func (p *cCRenderHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (render_handler *CRenderHandlerT) Unref() (ret bool) {
	if render_handler == nil {
		return
	}
	if render_handler.beUnrefed == byApp {
		ret = BaseRelease(render_handler.pc_render_handler)
		render_handler.beUnrefed = unrefed
	}
	render_handler.pc_render_handler = nil
	return ret
}

///
// Return the handler for accessibility notifications. If no handler is
// provided the default implementation will be used.
///
type GetAccessibilityHandlerHandler interface {
	GetAccessibilityHandler(
		self *CRenderHandlerT,
	) (ret *CAccessibilityHandlerT)
}

///
// Called to retrieve the root window rectangle in screen coordinates. Return
// true (1) if the rectangle was provided. If this function returns false (0)
// the rectangle from GetViewRect will be used.
///
type GetRootScreenRectHandler interface {
	GetRootScreenRect(
		self *CRenderHandlerT,
		browser *CBrowserT,
	) (ret bool, rect CRectT)
}

///
// Called to retrieve the view rectangle which is relative to screen
// coordinates. This function must always provide a non-NULL rectangle.
///
type GetViewRectHandler interface {
	GetViewRect(
		self *CRenderHandlerT,
		browser *CBrowserT,
	) (rect CRectT)
}

///
// Called to retrieve the translation from view coordinates to actual screen
// coordinates. Return true (1) if the screen coordinates were provided.
///
type GetScreenPointHandler interface {
	GetScreenPoint(
		self *CRenderHandlerT,
		browser *CBrowserT,
		viewX int,
		viewY int,
	) (ret bool, screenX int, screenY int)
}

///
// Called to allow the client to fill in the CefScreenInfo object with
// appropriate values. Return true (1) if the |screen_info| structure has been
// modified.
//
// If the screen info rectangle is left NULL the rectangle from GetViewRect
// will be used. If the rectangle is still NULL or invalid popups may not be
// drawn correctly.
///
type GetScreenInfoHandler interface {
	GetScreenInfo(
		self *CRenderHandlerT,
		browser *CBrowserT,
		screen_info CScreenInfoT,
	) (ret bool, screen_infoOut CScreenInfoT)
}

///
// Called when the browser wants to show or hide the popup widget. The popup
// should be shown if |show| is true (1) and hidden if |show| is false (0).
///
type OnPopupShowHandler interface {
	OnPopupShow(
		self *CRenderHandlerT,
		browser *CBrowserT,
		show int,
	)
}

///
// Called when the browser wants to move or resize the popup widget. |rect|
// contains the new location and size in view coordinates.
///
type OnPopupSizeHandler interface {
	OnPopupSize(
		self *CRenderHandlerT,
		browser *CBrowserT,
		rect *CRectT,
	)
}

///
// Called when an element should be painted. Pixel values passed to this
// function are scaled relative to view coordinates based on the value of
// CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|
// indicates whether the element is the view or the popup widget. |buffer|
// contains the pixel data for the whole image. |dirtyRects| contains the set
// of rectangles in pixel coordinates that need to be repainted. |buffer| will
// be |width|*|height|*4 bytes in size and represents a BGRA image with an
// upper-left origin. This function is only called when
// cef_window_tInfo::shared_texture_enabled is set to false (0).
///
type OnPaintHandler interface {
	OnPaint(
		self *CRenderHandlerT,
		browser *CBrowserT,
		ctype CPaintElementTypeT,
		dirtyRects []CRectT,
		buffer unsafe.Pointer,
		width int,
		height int,
	)
}

///
// Called when an element has been rendered to the shared texture handle.
// |type| indicates whether the element is the view or the popup widget.
// |dirtyRects| contains the set of rectangles in pixel coordinates that need
// to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that
// can be accessed via ID3D11Device using the OpenSharedResource function.
// This function is only called when cef_window_tInfo::shared_texture_enabled
// is set to true (1), and is currently only supported on Windows.
///
type OnAcceleratedPaintHandler interface {
	OnAcceleratedPaint(
		self *CRenderHandlerT,
		browser *CBrowserT,
		ctype CPaintElementTypeT,
		dirtyRectsCount int64,
		dirtyRects *CRectT,
		shared_handle unsafe.Pointer,
	)
}

///
// Called when the user starts dragging content in the web view. Contextual
// information about the dragged content is supplied by |drag_data|. (|x|,
// |y|) is the drag start location in screen coordinates. OS APIs that run a
// system message loop may be used within the StartDragging call.
//
// Return false (0) to abort the drag operation. Don&#39;t call any of
// cef_browser_host_t::DragSource*Ended* functions after returning false (0).
//
// Return true (1) to handle the drag operation. Call
// cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either
// synchronously or asynchronously to inform the web view that the drag
// operation has ended.
///
type StartDraggingHandler interface {
	StartDragging(
		self *CRenderHandlerT,
		browser *CBrowserT,
		drag_data *CDragDataT,
		allowed_ops CDragOperationsMaskT,
		x int,
		y int,
	) (ret bool)
}

///
// Called when the web view wants to update the mouse cursor during a drag &amp;
// drop operation. |operation| describes the allowed operation (none, move,
// copy, link).
///
type UpdateDragCursorHandler interface {
	UpdateDragCursor(
		self *CRenderHandlerT,
		browser *CBrowserT,
		operation CDragOperationsMaskT,
	)
}

///
// Called when the scroll offset has changed.
///
type OnScrollOffsetChangedHandler interface {
	OnScrollOffsetChanged(
		self *CRenderHandlerT,
		browser *CBrowserT,
		x float64,
		y float64,
	)
}

///
// Called when the IME composition range has changed. |selected_range| is the
// range of characters that have been selected. |character_bounds| is the
// bounds of each character in view coordinates.
///
type OnImeCompositionRangeChangedHandler interface {
	OnImeCompositionRangeChanged(
		self *CRenderHandlerT,
		browser *CBrowserT,
		selected_range *CRangeT,
		character_boundsCount int64,
		character_bounds *CRectT,
	)
}

///
// Called when text selection has changed for the specified |browser|.
// |selected_text| is the currently selected text and |selected_range| is the
// character range.
///
type OnTextSelectionChangedHandler interface {
	OnTextSelectionChanged(
		self *CRenderHandlerT,
		browser *CBrowserT,
		selected_text string,
		selected_range *CRangeT,
	)
}

///
// Called when an on-screen keyboard should be shown or hidden for the
// specified |browser|. |input_mode| specifies what kind of keyboard should be
// opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard
// for this browser should be hidden.
///
type OnVirtualKeyboardRequestedHandler interface {
	OnVirtualKeyboardRequested(
		self *CRenderHandlerT,
		browser *CBrowserT,
		input_mode CTextInputModeT,
	)
}

var render_handler_handlers = struct {
	handler                                  map[*cCRenderHandlerT]interface{}
	get_accessibility_handler_handler        map[*cCRenderHandlerT]GetAccessibilityHandlerHandler
	get_root_screen_rect_handler             map[*cCRenderHandlerT]GetRootScreenRectHandler
	get_view_rect_handler                    map[*cCRenderHandlerT]GetViewRectHandler
	get_screen_point_handler                 map[*cCRenderHandlerT]GetScreenPointHandler
	get_screen_info_handler                  map[*cCRenderHandlerT]GetScreenInfoHandler
	on_popup_show_handler                    map[*cCRenderHandlerT]OnPopupShowHandler
	on_popup_size_handler                    map[*cCRenderHandlerT]OnPopupSizeHandler
	on_paint_handler                         map[*cCRenderHandlerT]OnPaintHandler
	on_accelerated_paint_handler             map[*cCRenderHandlerT]OnAcceleratedPaintHandler
	start_dragging_handler                   map[*cCRenderHandlerT]StartDraggingHandler
	update_drag_cursor_handler               map[*cCRenderHandlerT]UpdateDragCursorHandler
	on_scroll_offset_changed_handler         map[*cCRenderHandlerT]OnScrollOffsetChangedHandler
	on_ime_composition_range_changed_handler map[*cCRenderHandlerT]OnImeCompositionRangeChangedHandler
	on_text_selection_changed_handler        map[*cCRenderHandlerT]OnTextSelectionChangedHandler
	on_virtual_keyboard_requested_handler    map[*cCRenderHandlerT]OnVirtualKeyboardRequestedHandler
}{
	map[*cCRenderHandlerT]interface{}{},
	map[*cCRenderHandlerT]GetAccessibilityHandlerHandler{},
	map[*cCRenderHandlerT]GetRootScreenRectHandler{},
	map[*cCRenderHandlerT]GetViewRectHandler{},
	map[*cCRenderHandlerT]GetScreenPointHandler{},
	map[*cCRenderHandlerT]GetScreenInfoHandler{},
	map[*cCRenderHandlerT]OnPopupShowHandler{},
	map[*cCRenderHandlerT]OnPopupSizeHandler{},
	map[*cCRenderHandlerT]OnPaintHandler{},
	map[*cCRenderHandlerT]OnAcceleratedPaintHandler{},
	map[*cCRenderHandlerT]StartDraggingHandler{},
	map[*cCRenderHandlerT]UpdateDragCursorHandler{},
	map[*cCRenderHandlerT]OnScrollOffsetChangedHandler{},
	map[*cCRenderHandlerT]OnImeCompositionRangeChangedHandler{},
	map[*cCRenderHandlerT]OnTextSelectionChangedHandler{},
	map[*cCRenderHandlerT]OnVirtualKeyboardRequestedHandler{},
}

// allocCRenderHandlerT allocates CRenderHandlerT and construct it
func allocCRenderHandlerT() *CRenderHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_render_handler_wrapper_t, "T177.3:")
	cefp := C.cefingo_construct_render_handler((*C.cefingo_render_handler_wrapper_t)(up))
	cgop := (*cCRenderHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_render_handler_t itself in DeassocFunc,
		// or cef_render_handler_t is never GCed.
		Tracef(up, "T177.4:")
		unbindAllCRenderHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCRenderHandlerT(cefp, byApp)
}

// NewCRenderHandlerT allocates CRenderHandlerT, construct and bind it
func NewCRenderHandlerT(a interface{}) *CRenderHandlerT {
	return allocCRenderHandlerT().bind(a)
}

func (render_handler *CRenderHandlerT) bind(a interface{}) *CRenderHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := render_handler.pc_render_handler
	render_handler_handlers.handler[cp] = a

	if h, ok := a.(GetAccessibilityHandlerHandler); ok {
		render_handler_handlers.get_accessibility_handler_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.get_accessibility_handler_handler, cp)
	}

	if h, ok := a.(GetRootScreenRectHandler); ok {
		render_handler_handlers.get_root_screen_rect_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.get_root_screen_rect_handler, cp)
	}

	if h, ok := a.(GetViewRectHandler); ok {
		render_handler_handlers.get_view_rect_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.get_view_rect_handler, cp)
	}

	if h, ok := a.(GetScreenPointHandler); ok {
		render_handler_handlers.get_screen_point_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.get_screen_point_handler, cp)
	}

	if h, ok := a.(GetScreenInfoHandler); ok {
		render_handler_handlers.get_screen_info_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.get_screen_info_handler, cp)
	}

	if h, ok := a.(OnPopupShowHandler); ok {
		render_handler_handlers.on_popup_show_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_popup_show_handler, cp)
	}

	if h, ok := a.(OnPopupSizeHandler); ok {
		render_handler_handlers.on_popup_size_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_popup_size_handler, cp)
	}

	if h, ok := a.(OnPaintHandler); ok {
		render_handler_handlers.on_paint_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_paint_handler, cp)
	}

	if h, ok := a.(OnAcceleratedPaintHandler); ok {
		render_handler_handlers.on_accelerated_paint_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_accelerated_paint_handler, cp)
	}

	if h, ok := a.(StartDraggingHandler); ok {
		render_handler_handlers.start_dragging_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.start_dragging_handler, cp)
	}

	if h, ok := a.(UpdateDragCursorHandler); ok {
		render_handler_handlers.update_drag_cursor_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.update_drag_cursor_handler, cp)
	}

	if h, ok := a.(OnScrollOffsetChangedHandler); ok {
		render_handler_handlers.on_scroll_offset_changed_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_scroll_offset_changed_handler, cp)
	}

	if h, ok := a.(OnImeCompositionRangeChangedHandler); ok {
		render_handler_handlers.on_ime_composition_range_changed_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_ime_composition_range_changed_handler, cp)
	}

	if h, ok := a.(OnTextSelectionChangedHandler); ok {
		render_handler_handlers.on_text_selection_changed_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_text_selection_changed_handler, cp)
	}

	if h, ok := a.(OnVirtualKeyboardRequestedHandler); ok {
		render_handler_handlers.on_virtual_keyboard_requested_handler[cp] = h
		noBind = false
	} else {
		delete(render_handler_handlers.on_virtual_keyboard_requested_handler, cp)
	}

	if noBind {
		Panicln("F229: *CRenderHandlerT No bind")
	}
	return render_handler
}

func unbindAllCRenderHandlerT(cp *cCRenderHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := render_handler.pc_render_handler
	delete(render_handler_handlers.handler, cp)

	delete(render_handler_handlers.get_accessibility_handler_handler, cp)
	delete(render_handler_handlers.get_root_screen_rect_handler, cp)
	delete(render_handler_handlers.get_view_rect_handler, cp)
	delete(render_handler_handlers.get_screen_point_handler, cp)
	delete(render_handler_handlers.get_screen_info_handler, cp)
	delete(render_handler_handlers.on_popup_show_handler, cp)
	delete(render_handler_handlers.on_popup_size_handler, cp)
	delete(render_handler_handlers.on_paint_handler, cp)
	delete(render_handler_handlers.on_accelerated_paint_handler, cp)
	delete(render_handler_handlers.start_dragging_handler, cp)
	delete(render_handler_handlers.update_drag_cursor_handler, cp)
	delete(render_handler_handlers.on_scroll_offset_changed_handler, cp)
	delete(render_handler_handlers.on_ime_composition_range_changed_handler, cp)
	delete(render_handler_handlers.on_text_selection_changed_handler, cp)
	delete(render_handler_handlers.on_virtual_keyboard_requested_handler, cp)
}

func (render_handler *CRenderHandlerT) UnbindAll() {
	unbindAllCRenderHandlerT(render_handler.pc_render_handler)
	render_handler.Unref()
}

func (render_handler *CRenderHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := render_handler.pc_render_handler
	return render_handler_handlers.handler[cp]
}

// cef_render_process_handler_capi.h, include/capi/cef_render_process_handler_capi.h:162:3,

///
// Structure used to implement render process callbacks. The functions of this
// structure will be called on the render process main thread (TID_RENDERER)
// unless otherwise indicated.
///

type cCRenderProcessHandlerT C.cef_render_process_handler_t

// Go type for cef_render_process_handler_t
type CRenderProcessHandlerT struct {
	noCopy                    noCopy
	pc_render_process_handler *cCRenderProcessHandlerT
	beUnrefed                 unrefedBy
}

func (p *CRenderProcessHandlerT) Pass() (ret *CRenderProcessHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRenderProcessHandlerT((*C.cef_render_process_handler_t)(p.pc_render_process_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRenderProcessHandlerT) NewRef() (newP *CRenderProcessHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_render_process_handler
	BaseAddRef(gop)
	newP = newCRenderProcessHandlerT((*C.cef_render_process_handler_t)(gop), byApp)
	return newP
}

// Go type CRenderProcessHandlerT wraps cef type *C.cef_render_process_handler_t
func newCRenderProcessHandlerT(p *C.cef_render_process_handler_t, unrefedBy unrefedBy) *CRenderProcessHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T178.1:")
	pc := (*cCRenderProcessHandlerT)(p)
	go_render_process_handler := &CRenderProcessHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_render_process_handler, func(g *CRenderProcessHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_render_process_handler != nil {
			Tracef(unsafe.Pointer(g.pc_render_process_handler), "T178.2:")
			BaseRelease(g.pc_render_process_handler)
		}
	})

	return go_render_process_handler
}

// *C.cef_render_process_handler_t has refCounted interface
func (render_process_handler *CRenderProcessHandlerT) HasOneRef() bool {
	return BaseHasOneRef(render_process_handler.pc_render_process_handler)
}

func (p *cCRenderProcessHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (render_process_handler *CRenderProcessHandlerT) Unref() (ret bool) {
	if render_process_handler == nil {
		return
	}
	if render_process_handler.beUnrefed == byApp {
		ret = BaseRelease(render_process_handler.pc_render_process_handler)
		render_process_handler.beUnrefed = unrefed
	}
	render_process_handler.pc_render_process_handler = nil
	return ret
}

///
// Called after WebKit has been initialized.
///
type OnWebKitInitializedHandler interface {
	OnWebKitInitialized(
		self *CRenderProcessHandlerT,
	)
}

///
// Called after a browser has been created. When browsing cross-origin a new
// browser will be created before the old browser with the same identifier is
// destroyed. |extra_info| is an optional read-only value originating from
// cef_browser_host_t::cef_browser_host_create_browser(),
// cef_browser_host_t::cef_browser_host_create_browser_sync(),
// cef_life_span_handler_t::on_before_popup() or
// cef_browser_view_t::cef_browser_view_create().
///
type CRenderProcessHandlerTOnBrowserCreatedHandler interface {
	OnBrowserCreated(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		extra_info *CDictionaryValueT,
	)
}

///
// Called before a browser is destroyed.
///
type CRenderProcessHandlerTOnBrowserDestroyedHandler interface {
	OnBrowserDestroyed(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
	)
}

///
// Return the handler for browser load status events.
///
type CRenderProcessHandlerTGetLoadHandlerHandler interface {
	GetLoadHandler(
		self *CRenderProcessHandlerT,
	) (ret *CLoadHandlerT)
}

///
// Called immediately after the V8 context for a frame has been created. To
// retrieve the JavaScript &#39;window&#39; object use the
// cef_v8context_t::get_global() function. V8 handles can only be accessed
// from the thread on which they are created. A task runner for posting tasks
// on the associated thread can be retrieved via the
// cef_v8context_t::get_task_runner() function.
///
type OnContextCreatedHandler interface {
	OnContextCreated(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		context *CV8contextT,
	)
}

///
// Called immediately before the V8 context for a frame is released. No
// references to the context should be kept after this function is called.
///
type OnContextReleasedHandler interface {
	OnContextReleased(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		context *CV8contextT,
	)
}

///
// Called for global uncaught exceptions in a frame. Execution of this
// callback is disabled by default. To enable set
// CefSettings.uncaught_exception_stack_size &gt; 0.
///
type OnUncaughtExceptionHandler interface {
	OnUncaughtException(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		context *CV8contextT,
		exception *CV8exceptionT,
		stackTrace *CV8stackTraceT,
	)
}

///
// Called when a new node in the the browser gets focus. The |node| value may
// be NULL if no specific node has gained focus. The node object passed to
// this function represents a snapshot of the DOM at the time this function is
// executed. DOM objects are only valid for the scope of this function. Do not
// keep references to or attempt to access any DOM objects outside the scope
// of this function.
///
type OnFocusedNodeChangedHandler interface {
	OnFocusedNodeChanged(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		node *CDomnodeT,
	)
}

///
// Called when a new message is received from a different process. Return true
// (1) if the message was handled or false (0) otherwise. It is safe to keep a
// reference to |message| outside of this callback.
///
type CRenderProcessHandlerTOnProcessMessageReceivedHandler interface {
	OnProcessMessageReceived(
		self *CRenderProcessHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		source_process CProcessIdT,
		message *CProcessMessageT,
	) (ret bool)
}

var render_process_handler_handlers = struct {
	handler                             map[*cCRenderProcessHandlerT]interface{}
	on_web_kit_initialized_handler      map[*cCRenderProcessHandlerT]OnWebKitInitializedHandler
	on_browser_created_handler          map[*cCRenderProcessHandlerT]CRenderProcessHandlerTOnBrowserCreatedHandler
	on_browser_destroyed_handler        map[*cCRenderProcessHandlerT]CRenderProcessHandlerTOnBrowserDestroyedHandler
	get_load_handler_handler            map[*cCRenderProcessHandlerT]CRenderProcessHandlerTGetLoadHandlerHandler
	on_context_created_handler          map[*cCRenderProcessHandlerT]OnContextCreatedHandler
	on_context_released_handler         map[*cCRenderProcessHandlerT]OnContextReleasedHandler
	on_uncaught_exception_handler       map[*cCRenderProcessHandlerT]OnUncaughtExceptionHandler
	on_focused_node_changed_handler     map[*cCRenderProcessHandlerT]OnFocusedNodeChangedHandler
	on_process_message_received_handler map[*cCRenderProcessHandlerT]CRenderProcessHandlerTOnProcessMessageReceivedHandler
}{
	map[*cCRenderProcessHandlerT]interface{}{},
	map[*cCRenderProcessHandlerT]OnWebKitInitializedHandler{},
	map[*cCRenderProcessHandlerT]CRenderProcessHandlerTOnBrowserCreatedHandler{},
	map[*cCRenderProcessHandlerT]CRenderProcessHandlerTOnBrowserDestroyedHandler{},
	map[*cCRenderProcessHandlerT]CRenderProcessHandlerTGetLoadHandlerHandler{},
	map[*cCRenderProcessHandlerT]OnContextCreatedHandler{},
	map[*cCRenderProcessHandlerT]OnContextReleasedHandler{},
	map[*cCRenderProcessHandlerT]OnUncaughtExceptionHandler{},
	map[*cCRenderProcessHandlerT]OnFocusedNodeChangedHandler{},
	map[*cCRenderProcessHandlerT]CRenderProcessHandlerTOnProcessMessageReceivedHandler{},
}

// allocCRenderProcessHandlerT allocates CRenderProcessHandlerT and construct it
func allocCRenderProcessHandlerT() *CRenderProcessHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_render_process_handler_wrapper_t, "T178.3:")
	cefp := C.cefingo_construct_render_process_handler((*C.cefingo_render_process_handler_wrapper_t)(up))
	cgop := (*cCRenderProcessHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_render_process_handler_t itself in DeassocFunc,
		// or cef_render_process_handler_t is never GCed.
		Tracef(up, "T178.4:")
		unbindAllCRenderProcessHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCRenderProcessHandlerT(cefp, byApp)
}

// NewCRenderProcessHandlerT allocates CRenderProcessHandlerT, construct and bind it
func NewCRenderProcessHandlerT(a interface{}) *CRenderProcessHandlerT {
	return allocCRenderProcessHandlerT().bind(a)
}

func (render_process_handler *CRenderProcessHandlerT) bind(a interface{}) *CRenderProcessHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := render_process_handler.pc_render_process_handler
	render_process_handler_handlers.handler[cp] = a

	if h, ok := a.(OnWebKitInitializedHandler); ok {
		render_process_handler_handlers.on_web_kit_initialized_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_web_kit_initialized_handler, cp)
	}

	if h, ok := a.(CRenderProcessHandlerTOnBrowserCreatedHandler); ok {
		render_process_handler_handlers.on_browser_created_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_browser_created_handler, cp)
	}

	if h, ok := a.(CRenderProcessHandlerTOnBrowserDestroyedHandler); ok {
		render_process_handler_handlers.on_browser_destroyed_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_browser_destroyed_handler, cp)
	}

	if h, ok := a.(CRenderProcessHandlerTGetLoadHandlerHandler); ok {
		render_process_handler_handlers.get_load_handler_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.get_load_handler_handler, cp)
	}

	if h, ok := a.(OnContextCreatedHandler); ok {
		render_process_handler_handlers.on_context_created_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_context_created_handler, cp)
	}

	if h, ok := a.(OnContextReleasedHandler); ok {
		render_process_handler_handlers.on_context_released_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_context_released_handler, cp)
	}

	if h, ok := a.(OnUncaughtExceptionHandler); ok {
		render_process_handler_handlers.on_uncaught_exception_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_uncaught_exception_handler, cp)
	}

	if h, ok := a.(OnFocusedNodeChangedHandler); ok {
		render_process_handler_handlers.on_focused_node_changed_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_focused_node_changed_handler, cp)
	}

	if h, ok := a.(CRenderProcessHandlerTOnProcessMessageReceivedHandler); ok {
		render_process_handler_handlers.on_process_message_received_handler[cp] = h
		noBind = false
	} else {
		delete(render_process_handler_handlers.on_process_message_received_handler, cp)
	}

	if noBind {
		Panicln("F229: *CRenderProcessHandlerT No bind")
	}
	return render_process_handler
}

func unbindAllCRenderProcessHandlerT(cp *cCRenderProcessHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := render_process_handler.pc_render_process_handler
	delete(render_process_handler_handlers.handler, cp)

	delete(render_process_handler_handlers.on_web_kit_initialized_handler, cp)
	delete(render_process_handler_handlers.on_browser_created_handler, cp)
	delete(render_process_handler_handlers.on_browser_destroyed_handler, cp)
	delete(render_process_handler_handlers.get_load_handler_handler, cp)
	delete(render_process_handler_handlers.on_context_created_handler, cp)
	delete(render_process_handler_handlers.on_context_released_handler, cp)
	delete(render_process_handler_handlers.on_uncaught_exception_handler, cp)
	delete(render_process_handler_handlers.on_focused_node_changed_handler, cp)
	delete(render_process_handler_handlers.on_process_message_received_handler, cp)
}

func (render_process_handler *CRenderProcessHandlerT) UnbindAll() {
	unbindAllCRenderProcessHandlerT(render_process_handler.pc_render_process_handler)
	render_process_handler.Unref()
}

func (render_process_handler *CRenderProcessHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := render_process_handler.pc_render_process_handler
	return render_process_handler_handlers.handler[cp]
}

// cef_request_capi.h, include/capi/cef_request_capi.h:217:3,

///
// Structure used to represent a web request. The functions of this structure
// may be called on any thread.
///

type cCRequestT C.cef_request_t

// Go type for cef_request_t
type CRequestT struct {
	noCopy     noCopy
	pc_request *cCRequestT
	beUnrefed  unrefedBy
}

func (p *CRequestT) Pass() (ret *CRequestT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRequestT((*C.cef_request_t)(p.pc_request), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRequestT) NewRef() (newP *CRequestT) {
	if self == nil {
		return newP
	}
	gop := self.pc_request
	BaseAddRef(gop)
	newP = newCRequestT((*C.cef_request_t)(gop), byApp)
	return newP
}

// Go type CRequestT wraps cef type *C.cef_request_t
func newCRequestT(p *C.cef_request_t, unrefedBy unrefedBy) *CRequestT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T180.1:")
	pc := (*cCRequestT)(p)
	go_request := &CRequestT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_request, func(g *CRequestT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_request != nil {
			Tracef(unsafe.Pointer(g.pc_request), "T180.2:")
			BaseRelease(g.pc_request)
		}
	})

	return go_request
}

// *C.cef_request_t has refCounted interface
func (request *CRequestT) HasOneRef() bool {
	return BaseHasOneRef(request.pc_request)
}

func (p *cCRequestT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (request *CRequestT) Unref() (ret bool) {
	if request == nil {
		return
	}
	if request.beUnrefed == byApp {
		ret = BaseRelease(request.pc_request)
		request.beUnrefed = unrefed
	}
	request.pc_request = nil
	return ret
}

///
// Returns true (1) if this object is read-only.
///
func (self *CRequestT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_request_is_read_only((*C.cef_request_t)(self.pc_request))

	ret = cRet == 1
	return ret
}

///
// Get the fully qualified URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetUrl() (ret string) {

	cRet := C.cefingo_request_get_url((*C.cef_request_t)(self.pc_request))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the fully qualified URL.
///
func (self *CRequestT) SetUrl(
	url string,
) {
	c_url := create_cef_string(url)

	C.cefingo_request_set_url((*C.cef_request_t)(self.pc_request), c_url.p_cef_string_t)

}

///
// Get the request function type. The value will default to POST if post data
// is provided and GET otherwise.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetMethod() (ret string) {

	cRet := C.cefingo_request_get_method((*C.cef_request_t)(self.pc_request))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the request function type.
///
func (self *CRequestT) SetMethod(
	method string,
) {
	c_method := create_cef_string(method)

	C.cefingo_request_set_method((*C.cef_request_t)(self.pc_request), c_method.p_cef_string_t)

}

///
// Set the referrer URL and policy. If non-NULL the referrer URL must be fully
// qualified with an HTTP or HTTPS scheme component. Any username, password or
// ref component will be removed.
///
func (self *CRequestT) SetReferrer(
	referrer_url string,
	policy CReferrerPolicyT,
) {
	c_referrer_url := create_cef_string(referrer_url)

	C.cefingo_request_set_referrer((*C.cef_request_t)(self.pc_request), c_referrer_url.p_cef_string_t, (C.cef_referrer_policy_t)(policy))

}

///
// Get the referrer URL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetReferrerUrl() (ret string) {

	cRet := C.cefingo_request_get_referrer_url((*C.cef_request_t)(self.pc_request))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Get the referrer policy.
///
func (self *CRequestT) GetReferrerPolicy() (ret CReferrerPolicyT) {

	cRet := C.cefingo_request_get_referrer_policy((*C.cef_request_t)(self.pc_request))

	ret = CReferrerPolicyT(cRet) // return GoObj
	return ret
}

///
// Get the post data.
///
func (self *CRequestT) GetPostData() (ret *CPostDataT) {

	cRet := C.cefingo_request_get_post_data((*C.cef_request_t)(self.pc_request))

	ret = newCPostDataT(cRet, byApp) // return GoObj
	return ret
}

///
// Set the post data.
///
func (self *CRequestT) SetPostData(
	postData *CPostDataT,
) {
	var goTmppostData *C.cef_post_data_t
	if postData != nil {
		BaseAddRef(postData.pc_post_data)
		goTmppostData = (*C.cef_post_data_t)(postData.pc_post_data)
	}

	C.cefingo_request_set_post_data((*C.cef_request_t)(self.pc_request), goTmppostData)

}

///
// Get the header values. Will not include the Referer value if any.
///
func (self *CRequestT) GetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_request_get_header_map((*C.cef_request_t)(self.pc_request), (C.cef_string_multimap_t)(headerMap))

}

///
// Set the header values. If a Referer value exists in the header map it will
// be removed and ignored.
///
func (self *CRequestT) SetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_request_set_header_map((*C.cef_request_t)(self.pc_request), (C.cef_string_multimap_t)(headerMap))

}

///
// Returns the first header value for |name| or an NULL string if not found.
// Will not return the Referer value if any. Use GetHeaderMap instead if
// |name| might have multiple values.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetHeaderByName(
	name string,
) (ret string) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_request_get_header_by_name((*C.cef_request_t)(self.pc_request), c_name.p_cef_string_t)

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the header |name| to |value|. If |overwrite| is true (1) any existing
// values will be replaced with the new value. If |overwrite| is false (0) any
// existing values will not be overwritten. The Referer value cannot be set
// using this function.
///
func (self *CRequestT) SetHeaderByName(
	name string,
	value string,
	overwrite int,
) {
	c_name := create_cef_string(name)
	c_value := create_cef_string(value)

	C.cefingo_request_set_header_by_name((*C.cef_request_t)(self.pc_request), c_name.p_cef_string_t, c_value.p_cef_string_t, (C.int)(overwrite))

}

///
// Set all values at one time.
///
func (self *CRequestT) Set(
	url string,
	method string,
	postData *CPostDataT,
	headerMap CStringMultimapT,
) {
	c_url := create_cef_string(url)
	c_method := create_cef_string(method)
	var goTmppostData *C.cef_post_data_t
	if postData != nil {
		BaseAddRef(postData.pc_post_data)
		goTmppostData = (*C.cef_post_data_t)(postData.pc_post_data)
	}

	C.cefingo_request_set((*C.cef_request_t)(self.pc_request), c_url.p_cef_string_t, c_method.p_cef_string_t, goTmppostData, (C.cef_string_multimap_t)(headerMap))

}

///
// Get the flags used in combination with cef_urlrequest_t. See
// cef_urlrequest_flags_t for supported values.
///
func (self *CRequestT) GetFlags() (ret bool) {

	cRet := C.cefingo_request_get_flags((*C.cef_request_t)(self.pc_request))

	ret = cRet == 1
	return ret
}

///
// Set the flags used in combination with cef_urlrequest_t.  See
// cef_urlrequest_flags_t for supported values.
///
func (self *CRequestT) SetFlags(
	flags int,
) {

	C.cefingo_request_set_flags((*C.cef_request_t)(self.pc_request), (C.int)(flags))

}

///
// Get the URL to the first party for cookies used in combination with
// cef_urlrequest_t.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestT) GetFirstPartyForCookies() (ret string) {

	cRet := C.cefingo_request_get_first_party_for_cookies((*C.cef_request_t)(self.pc_request))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the URL to the first party for cookies used in combination with
// cef_urlrequest_t.
///
func (self *CRequestT) SetFirstPartyForCookies(
	url string,
) {
	c_url := create_cef_string(url)

	C.cefingo_request_set_first_party_for_cookies((*C.cef_request_t)(self.pc_request), c_url.p_cef_string_t)

}

///
// Get the resource type for this request. Only available in the browser
// process.
///
func (self *CRequestT) GetResourceType() (ret CResourceTypeT) {

	cRet := C.cefingo_request_get_resource_type((*C.cef_request_t)(self.pc_request))

	ret = CResourceTypeT(cRet) // return GoObj
	return ret
}

///
// Get the transition type for this request. Only available in the browser
// process and only applies to requests that represent a main frame or sub-
// frame navigation.
///
func (self *CRequestT) GetTransitionType() (ret CTransitionTypeT) {

	cRet := C.cefingo_request_get_transition_type((*C.cef_request_t)(self.pc_request))

	ret = CTransitionTypeT(cRet) // return GoObj
	return ret
}

///
// Returns the globally unique identifier for this request or 0 if not
// specified. Can be used by cef_resource_request_handler_t implementations in
// the browser process to track a single request across multiple callbacks.
///
func (self *CRequestT) GetIdentifier() (ret uint64) {

	cRet := C.cefingo_request_get_identifier((*C.cef_request_t)(self.pc_request))

	ret = (uint64)(cRet) // return GoObj
	return ret
}

///
// Create a new cef_request_t object.
///
func RequestCreate() (ret *CRequestT) {

	cRet := C.cef_request_create()

	ret = newCRequestT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure used to represent post data for a web request. The functions of
// this structure may be called on any thread.
///

type cCPostDataT C.cef_post_data_t

// Go type for cef_post_data_t
type CPostDataT struct {
	noCopy       noCopy
	pc_post_data *cCPostDataT
	beUnrefed    unrefedBy
}

func (p *CPostDataT) Pass() (ret *CPostDataT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPostDataT((*C.cef_post_data_t)(p.pc_post_data), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPostDataT) NewRef() (newP *CPostDataT) {
	if self == nil {
		return newP
	}
	gop := self.pc_post_data
	BaseAddRef(gop)
	newP = newCPostDataT((*C.cef_post_data_t)(gop), byApp)
	return newP
}

// Go type CPostDataT wraps cef type *C.cef_post_data_t
func newCPostDataT(p *C.cef_post_data_t, unrefedBy unrefedBy) *CPostDataT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T181.1:")
	pc := (*cCPostDataT)(p)
	go_post_data := &CPostDataT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_post_data, func(g *CPostDataT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_post_data != nil {
			Tracef(unsafe.Pointer(g.pc_post_data), "T181.2:")
			BaseRelease(g.pc_post_data)
		}
	})

	return go_post_data
}

// *C.cef_post_data_t has refCounted interface
func (post_data *CPostDataT) HasOneRef() bool {
	return BaseHasOneRef(post_data.pc_post_data)
}

func (p *cCPostDataT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (post_data *CPostDataT) Unref() (ret bool) {
	if post_data == nil {
		return
	}
	if post_data.beUnrefed == byApp {
		ret = BaseRelease(post_data.pc_post_data)
		post_data.beUnrefed = unrefed
	}
	post_data.pc_post_data = nil
	return ret
}

///
// Returns true (1) if this object is read-only.
///
func (self *CPostDataT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_post_data_is_read_only((*C.cef_post_data_t)(self.pc_post_data))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the underlying POST data includes elements that are not
// represented by this cef_post_data_t object (for example, multi-part file
// upload data). Modifying cef_post_data_t objects with excluded elements may
// result in the request failing.
///
func (self *CPostDataT) HasExcludedElements() (ret bool) {

	cRet := C.cefingo_post_data_has_excluded_elements((*C.cef_post_data_t)(self.pc_post_data))

	ret = cRet == 1
	return ret
}

///
// Returns the number of existing post data elements.
///
func (self *CPostDataT) GetElementCount() (ret int64) {

	cRet := C.cefingo_post_data_get_element_count((*C.cef_post_data_t)(self.pc_post_data))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Retrieve the post data elements.
///
func (self *CPostDataT) GetElements() (elements []*CPostDataElementT) {
	_elementsCount := C.size_t(self.GetElementCount()) // =SizeFunc cef_post_data_t::get_elements:elements
	if _elementsCount == 0 {
		return
	}
	elementsCount := &_elementsCount
	tmpelements := unsafe.Pointer(c_calloc(_elementsCount, 8, "T181.3"))
	defer C.free(tmpelements)

	C.cefingo_post_data_get_elements((*C.cef_post_data_t)(self.pc_post_data), (*C.size_t)(elementsCount), (**C.cef_post_data_element_t)(tmpelements))

	elements = make([]*CPostDataElementT, *elementsCount)
	_tmpelements := (*[1 << 30](*C.cef_post_data_element_t))(unsafe.Pointer(tmpelements))[:*elementsCount:*elementsCount]
	for i := C.size_t(0); i < *elementsCount; i++ {
		elements[i] = newCPostDataElementT(_tmpelements[i], byApp) // Out Slice Param
	}
	return elements
}

///
// Remove the specified post data element.  Returns true (1) if the removal
// succeeds.
///
func (self *CPostDataT) RemoveElement(
	element *CPostDataElementT,
) (ret bool) {
	var goTmpelement *C.cef_post_data_element_t
	if element != nil {
		BaseAddRef(element.pc_post_data_element)
		goTmpelement = (*C.cef_post_data_element_t)(element.pc_post_data_element)
	}

	cRet := C.cefingo_post_data_remove_element((*C.cef_post_data_t)(self.pc_post_data), goTmpelement)

	ret = cRet == 1
	return ret
}

///
// Add the specified post data element.  Returns true (1) if the add succeeds.
///
func (self *CPostDataT) AddElement(
	element *CPostDataElementT,
) (ret bool) {
	var goTmpelement *C.cef_post_data_element_t
	if element != nil {
		BaseAddRef(element.pc_post_data_element)
		goTmpelement = (*C.cef_post_data_element_t)(element.pc_post_data_element)
	}

	cRet := C.cefingo_post_data_add_element((*C.cef_post_data_t)(self.pc_post_data), goTmpelement)

	ret = cRet == 1
	return ret
}

///
// Remove all existing post data elements.
///
func (self *CPostDataT) RemoveElements() {

	C.cefingo_post_data_remove_elements((*C.cef_post_data_t)(self.pc_post_data))

}

///
// Create a new cef_post_data_t object.
///
func PostDataCreate() (ret *CPostDataT) {

	cRet := C.cef_post_data_create()

	ret = newCPostDataT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure used to represent a single element in the request post data. The
// functions of this structure may be called on any thread.
///

type cCPostDataElementT C.cef_post_data_element_t

// Go type for cef_post_data_element_t
type CPostDataElementT struct {
	noCopy               noCopy
	pc_post_data_element *cCPostDataElementT
	beUnrefed            unrefedBy
}

func (p *CPostDataElementT) Pass() (ret *CPostDataElementT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCPostDataElementT((*C.cef_post_data_element_t)(p.pc_post_data_element), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CPostDataElementT) NewRef() (newP *CPostDataElementT) {
	if self == nil {
		return newP
	}
	gop := self.pc_post_data_element
	BaseAddRef(gop)
	newP = newCPostDataElementT((*C.cef_post_data_element_t)(gop), byApp)
	return newP
}

// Go type CPostDataElementT wraps cef type *C.cef_post_data_element_t
func newCPostDataElementT(p *C.cef_post_data_element_t, unrefedBy unrefedBy) *CPostDataElementT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T182.1:")
	pc := (*cCPostDataElementT)(p)
	go_post_data_element := &CPostDataElementT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_post_data_element, func(g *CPostDataElementT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_post_data_element != nil {
			Tracef(unsafe.Pointer(g.pc_post_data_element), "T182.2:")
			BaseRelease(g.pc_post_data_element)
		}
	})

	return go_post_data_element
}

// *C.cef_post_data_element_t has refCounted interface
func (post_data_element *CPostDataElementT) HasOneRef() bool {
	return BaseHasOneRef(post_data_element.pc_post_data_element)
}

func (p *cCPostDataElementT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (post_data_element *CPostDataElementT) Unref() (ret bool) {
	if post_data_element == nil {
		return
	}
	if post_data_element.beUnrefed == byApp {
		ret = BaseRelease(post_data_element.pc_post_data_element)
		post_data_element.beUnrefed = unrefed
	}
	post_data_element.pc_post_data_element = nil
	return ret
}

///
// Returns true (1) if this object is read-only.
///
func (self *CPostDataElementT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_post_data_element_is_read_only((*C.cef_post_data_element_t)(self.pc_post_data_element))

	ret = cRet == 1
	return ret
}

///
// Remove all contents from the post data element.
///
func (self *CPostDataElementT) SetToEmpty() {

	C.cefingo_post_data_element_set_to_empty((*C.cef_post_data_element_t)(self.pc_post_data_element))

}

///
// The post data element will represent a file.
///
func (self *CPostDataElementT) SetToFile(
	fileName string,
) {
	c_fileName := create_cef_string(fileName)

	C.cefingo_post_data_element_set_to_file((*C.cef_post_data_element_t)(self.pc_post_data_element), c_fileName.p_cef_string_t)

}

///
// The post data element will represent bytes.  The bytes passed in will be
// copied.
///
func (self *CPostDataElementT) SetToBytes(
	bytes []byte,
) {
	size := len(bytes)
	tmpbytes := C.CBytes(bytes)
	defer C.free(tmpbytes)

	C.cefingo_post_data_element_set_to_bytes((*C.cef_post_data_element_t)(self.pc_post_data_element), (C.size_t)(size), tmpbytes)

}

///
// Return the type of this post data element.
///
func (self *CPostDataElementT) GetType() (ret CPostdataelementTypeT) {

	cRet := C.cefingo_post_data_element_get_type((*C.cef_post_data_element_t)(self.pc_post_data_element))

	ret = CPostdataelementTypeT(cRet) // return GoObj
	return ret
}

///
// Return the file name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CPostDataElementT) GetFile() (ret string) {

	cRet := C.cefingo_post_data_element_get_file((*C.cef_post_data_element_t)(self.pc_post_data_element))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Return the number of bytes.
///
func (self *CPostDataElementT) GetBytesCount() (ret int64) {

	cRet := C.cefingo_post_data_element_get_bytes_count((*C.cef_post_data_element_t)(self.pc_post_data_element))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Read up to |size| bytes into |bytes| and return the number of bytes
// actually read.
///
func (self *CPostDataElementT) GetBytes(
	size int64,
	bytes unsafe.Pointer,
) (ret int64) {

	cRet := C.cefingo_post_data_element_get_bytes((*C.cef_post_data_element_t)(self.pc_post_data_element), (C.size_t)(size), bytes)

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Create a new cef_post_data_element_t object.
///
func PostDataElementCreate() (ret *CPostDataElementT) {

	cRet := C.cef_post_data_element_create()

	ret = newCPostDataElementT(cRet, byApp) // return GoObj
	return ret
}

// cef_request_context_capi.h, include/capi/cef_request_context_capi.h:74:3,

///
// Callback structure for cef_request_context_t::ResolveHost.
///

type cCResolveCallbackT C.cef_resolve_callback_t

// Go type for cef_resolve_callback_t
type CResolveCallbackT struct {
	noCopy              noCopy
	pc_resolve_callback *cCResolveCallbackT
	beUnrefed           unrefedBy
}

func (p *CResolveCallbackT) Pass() (ret *CResolveCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResolveCallbackT((*C.cef_resolve_callback_t)(p.pc_resolve_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResolveCallbackT) NewRef() (newP *CResolveCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_resolve_callback
	BaseAddRef(gop)
	newP = newCResolveCallbackT((*C.cef_resolve_callback_t)(gop), byApp)
	return newP
}

// Go type CResolveCallbackT wraps cef type *C.cef_resolve_callback_t
func newCResolveCallbackT(p *C.cef_resolve_callback_t, unrefedBy unrefedBy) *CResolveCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T183.1:")
	pc := (*cCResolveCallbackT)(p)
	go_resolve_callback := &CResolveCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_resolve_callback, func(g *CResolveCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_resolve_callback != nil {
			Tracef(unsafe.Pointer(g.pc_resolve_callback), "T183.2:")
			BaseRelease(g.pc_resolve_callback)
		}
	})

	return go_resolve_callback
}

// *C.cef_resolve_callback_t has refCounted interface
func (resolve_callback *CResolveCallbackT) HasOneRef() bool {
	return BaseHasOneRef(resolve_callback.pc_resolve_callback)
}

func (p *cCResolveCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (resolve_callback *CResolveCallbackT) Unref() (ret bool) {
	if resolve_callback == nil {
		return
	}
	if resolve_callback.beUnrefed == byApp {
		ret = BaseRelease(resolve_callback.pc_resolve_callback)
		resolve_callback.beUnrefed = unrefed
	}
	resolve_callback.pc_resolve_callback = nil
	return ret
}

///
// Called on the UI thread after the ResolveHost request has completed.
// |result| will be the result code. |resolved_ips| will be the list of
// resolved IP addresses or NULL if the resolution failed.
///
func (self *CResolveCallbackT) OnResolveCompleted(
	result CErrorcodeT,
	resolved_ips CStringListT,
) {

	C.cefingo_resolve_callback_on_resolve_completed((*C.cef_resolve_callback_t)(self.pc_resolve_callback), (C.cef_errorcode_t)(result), (C.cef_string_list_t)(resolved_ips))

}

///
// A request context provides request handling for a set of related browser or
// URL request objects. A request context can be specified when creating a new
// browser via the cef_browser_host_t static factory functions or when creating
// a new URL request via the cef_urlrequest_t static factory functions. Browser
// objects with different request contexts will never be hosted in the same
// render process. Browser objects with the same request context may or may not
// be hosted in the same render process depending on the process model. Browser
// objects created indirectly via the JavaScript window.open function or
// targeted links will share the same render process and the same request
// context as the source browser. When running in single-process mode there is
// only a single render process (the main process) and so all browsers created
// in single-process mode will share the same request context. This will be the
// first request context passed into a cef_browser_host_t static factory
// function and all other request context objects will be ignored.
///

type cCRequestContextT C.cef_request_context_t

// Go type for cef_request_context_t
type CRequestContextT struct {
	noCopy             noCopy
	pc_request_context *cCRequestContextT
	beUnrefed          unrefedBy
}

func (p *CRequestContextT) Pass() (ret *CRequestContextT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRequestContextT((*C.cef_request_context_t)(p.pc_request_context), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRequestContextT) NewRef() (newP *CRequestContextT) {
	if self == nil {
		return newP
	}
	gop := self.pc_request_context
	BaseAddRef(gop)
	newP = newCRequestContextT((*C.cef_request_context_t)(gop), byApp)
	return newP
}

// Go type CRequestContextT wraps cef type *C.cef_request_context_t
func newCRequestContextT(p *C.cef_request_context_t, unrefedBy unrefedBy) *CRequestContextT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T184.1:")
	pc := (*cCRequestContextT)(p)
	go_request_context := &CRequestContextT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_request_context, func(g *CRequestContextT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_request_context != nil {
			Tracef(unsafe.Pointer(g.pc_request_context), "T184.2:")
			BaseRelease(g.pc_request_context)
		}
	})

	return go_request_context
}

// *C.cef_request_context_t has refCounted interface
func (request_context *CRequestContextT) HasOneRef() bool {
	return BaseHasOneRef(request_context.pc_request_context)
}

func (p *cCRequestContextT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (request_context *CRequestContextT) Unref() (ret bool) {
	if request_context == nil {
		return
	}
	if request_context.beUnrefed == byApp {
		ret = BaseRelease(request_context.pc_request_context)
		request_context.beUnrefed = unrefed
	}
	request_context.pc_request_context = nil
	return ret
}

///
// Returns true (1) if this object is pointing to the same context as |that|
// object.
///
func (self *CRequestContextT) IsSame(
	other *CRequestContextT,
) (ret bool) {
	var goTmpother *C.cef_request_context_t
	if other != nil {
		BaseAddRef(other.pc_request_context)
		goTmpother = (*C.cef_request_context_t)(other.pc_request_context)
	}

	cRet := C.cefingo_request_context_is_same((*C.cef_request_context_t)(self.pc_request_context), goTmpother)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is sharing the same storage as |that|
// object.
///
func (self *CRequestContextT) IsSharingWith(
	other *CRequestContextT,
) (ret bool) {
	var goTmpother *C.cef_request_context_t
	if other != nil {
		BaseAddRef(other.pc_request_context)
		goTmpother = (*C.cef_request_context_t)(other.pc_request_context)
	}

	cRet := C.cefingo_request_context_is_sharing_with((*C.cef_request_context_t)(self.pc_request_context), goTmpother)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is the global context. The global context
// is used by default when creating a browser or URL request with a NULL
// context argument.
///
func (self *CRequestContextT) IsGlobal() (ret bool) {

	cRet := C.cefingo_request_context_is_global((*C.cef_request_context_t)(self.pc_request_context))

	ret = cRet == 1
	return ret
}

///
// Returns the handler for this context if any.
///
func (self *CRequestContextT) GetHandler() (ret *CRequestContextHandlerT) {

	cRet := C.cefingo_request_context_get_handler((*C.cef_request_context_t)(self.pc_request_context))

	ret = newCRequestContextHandlerT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the cache path for this object. If NULL an &quot;incognito mode&quot; in-
// memory cache is being used.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CRequestContextT) GetCachePath() (ret string) {

	cRet := C.cefingo_request_context_get_cache_path((*C.cef_request_context_t)(self.pc_request_context))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the cookie manager for this object. If |callback| is non-NULL it
// will be executed asnychronously on the UI thread after the manager&#39;s
// storage has been initialized.
///
func (self *CRequestContextT) GetCookieManager(
	callback *CCompletionCallbackT,
) (ret *CCookieManagerT) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	cRet := C.cefingo_request_context_get_cookie_manager((*C.cef_request_context_t)(self.pc_request_context), goTmpcallback)

	ret = newCCookieManagerT(cRet, byApp) // return GoObj
	return ret
}

///
// Register a scheme handler factory for the specified |scheme_name| and
// optional |domain_name|. An NULL |domain_name| value for a standard scheme
// will cause the factory to match all domain names. The |domain_name| value
// will be ignored for non-standard schemes. If |scheme_name| is a built-in
// scheme and no handler is returned by |factory| then the built-in scheme
// handler factory will be called. If |scheme_name| is a custom scheme then
// you must also implement the cef_app_t::on_register_custom_schemes()
// function in all processes. This function may be called multiple times to
// change or remove the factory that matches the specified |scheme_name| and
// optional |domain_name|. Returns false (0) if an error occurs. This function
// may be called on any thread in the browser process.
///
func (self *CRequestContextT) RegisterSchemeHandlerFactory(
	scheme_name string,
	domain_name string,
	factory *CSchemeHandlerFactoryT,
) (ret bool) {
	c_scheme_name := create_cef_string(scheme_name)
	c_domain_name := create_cef_string(domain_name)
	var goTmpfactory *C.cef_scheme_handler_factory_t
	if factory != nil {
		BaseAddRef(factory.pc_scheme_handler_factory)
		goTmpfactory = (*C.cef_scheme_handler_factory_t)(factory.pc_scheme_handler_factory)
	}

	cRet := C.cefingo_request_context_register_scheme_handler_factory((*C.cef_request_context_t)(self.pc_request_context), c_scheme_name.p_cef_string_t, c_domain_name.p_cef_string_t, goTmpfactory)

	ret = cRet == 1
	return ret
}

///
// Clear all registered scheme handler factories. Returns false (0) on error.
// This function may be called on any thread in the browser process.
///
func (self *CRequestContextT) ClearSchemeHandlerFactories() (ret bool) {

	cRet := C.cefingo_request_context_clear_scheme_handler_factories((*C.cef_request_context_t)(self.pc_request_context))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if a preference with the specified |name| exists. This
// function must be called on the browser process UI thread.
///
func (self *CRequestContextT) HasPreference(
	name string,
) (ret bool) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_request_context_has_preference((*C.cef_request_context_t)(self.pc_request_context), c_name.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the value for the preference with the specified |name|. Returns
// NULL if the preference does not exist. The returned object contains a copy
// of the underlying preference value and modifications to the returned object
// will not modify the underlying preference value. This function must be
// called on the browser process UI thread.
///
func (self *CRequestContextT) GetPreference(
	name string,
) (ret *CValueT) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_request_context_get_preference((*C.cef_request_context_t)(self.pc_request_context), c_name.p_cef_string_t)

	ret = newCValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns all preferences as a dictionary. If |include_defaults| is true (1)
// then preferences currently at their default value will be included. The
// returned object contains a copy of the underlying preference values and
// modifications to the returned object will not modify the underlying
// preference values. This function must be called on the browser process UI
// thread.
///
func (self *CRequestContextT) GetAllPreferences(
	include_defaults int,
) (ret *CDictionaryValueT) {

	cRet := C.cefingo_request_context_get_all_preferences((*C.cef_request_context_t)(self.pc_request_context), (C.int)(include_defaults))

	ret = newCDictionaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if the preference with the specified |name| can be
// modified using SetPreference. As one example preferences set via the
// command-line usually cannot be modified. This function must be called on
// the browser process UI thread.
///
func (self *CRequestContextT) CanSetPreference(
	name string,
) (ret bool) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_request_context_can_set_preference((*C.cef_request_context_t)(self.pc_request_context), c_name.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Set the |value| associated with preference |name|. Returns true (1) if the
// value is set successfully and false (0) otherwise. If |value| is NULL the
// preference will be restored to its default value. If setting the preference
// fails then |error| will be populated with a detailed description of the
// problem. This function must be called on the browser process UI thread.
///
func (self *CRequestContextT) SetPreference(
	name string,
	value *CValueT,
) (ret bool, error string) {
	c_name := create_cef_string(name)
	var goTmpvalue *C.cef_value_t
	if value != nil {
		BaseAddRef(value.pc_value)
		goTmpvalue = (*C.cef_value_t)(value.pc_value)
	}
	tmpc_error := create_cef_string("")

	cRet := C.cefingo_request_context_set_preference((*C.cef_request_context_t)(self.pc_request_context), c_name.p_cef_string_t, goTmpvalue, tmpc_error.p_cef_string_t)

	error = string_from_cef_string(tmpc_error.p_cef_string_t)

	ret = cRet == 1
	return ret, error
}

///
// Clears all certificate exceptions that were added as part of handling
// cef_request_handler_t::on_certificate_error(). If you call this it is
// recommended that you also call close_all_connections() or you risk not
// being prompted again for server certificates if you reconnect quickly. If
// |callback| is non-NULL it will be executed on the UI thread after
// completion.
///
func (self *CRequestContextT) ClearCertificateExceptions(
	callback *CCompletionCallbackT,
) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	C.cefingo_request_context_clear_certificate_exceptions((*C.cef_request_context_t)(self.pc_request_context), goTmpcallback)

}

///
// Clears all HTTP authentication credentials that were added as part of
// handling GetAuthCredentials. If |callback| is non-NULL it will be executed
// on the UI thread after completion.
///
func (self *CRequestContextT) ClearHttpAuthCredentials(
	callback *CCompletionCallbackT,
) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	C.cefingo_request_context_clear_http_auth_credentials((*C.cef_request_context_t)(self.pc_request_context), goTmpcallback)

}

///
// Clears all active and idle connections that Chromium currently has. This is
// only recommended if you have released all other CEF objects but don&#39;t yet
// want to call cef_shutdown(). If |callback| is non-NULL it will be executed
// on the UI thread after completion.
///
func (self *CRequestContextT) CloseAllConnections(
	callback *CCompletionCallbackT,
) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	C.cefingo_request_context_close_all_connections((*C.cef_request_context_t)(self.pc_request_context), goTmpcallback)

}

///
// Attempts to resolve |origin| to a list of associated IP addresses.
// |callback| will be executed on the UI thread after completion.
///
func (self *CRequestContextT) ResolveHost(
	origin string,
	callback *CResolveCallbackT,
) {
	c_origin := create_cef_string(origin)
	var goTmpcallback *C.cef_resolve_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_resolve_callback)
		goTmpcallback = (*C.cef_resolve_callback_t)(callback.pc_resolve_callback)
	}

	C.cefingo_request_context_resolve_host((*C.cef_request_context_t)(self.pc_request_context), c_origin.p_cef_string_t, goTmpcallback)

}

///
// Load an extension.
//
// If extension resources will be read from disk using the default load
// implementation then |root_directory| should be the absolute path to the
// extension resources directory and |manifest| should be NULL. If extension
// resources will be provided by the client (e.g. via cef_request_handler_t
// and/or cef_extension_handler_t) then |root_directory| should be a path
// component unique to the extension (if not absolute this will be internally
// prefixed with the PK_DIR_RESOURCES path) and |manifest| should contain the
// contents that would otherwise be read from the &quot;manifest.json&quot; file on
// disk.
//
// The loaded extension will be accessible in all contexts sharing the same
// storage (HasExtension returns true (1)). However, only the context on which
// this function was called is considered the loader (DidLoadExtension returns
// true (1)) and only the loader will receive cef_request_context_handler_t
// callbacks for the extension.
//
// cef_extension_handler_t::OnExtensionLoaded will be called on load success
// or cef_extension_handler_t::OnExtensionLoadFailed will be called on load
// failure.
//
// If the extension specifies a background script via the &quot;background&quot;
// manifest key then cef_extension_handler_t::OnBeforeBackgroundBrowser will
// be called to create the background browser. See that function for
// additional information about background scripts.
//
// For visible extension views the client application should evaluate the
// manifest to determine the correct extension URL to load and then pass that
// URL to the cef_browser_host_t::CreateBrowser* function after the extension
// has loaded. For example, the client can look for the &quot;browser_action&quot;
// manifest key as documented at
// https://developer.chrome.com/extensions/browserAction. Extension URLs take
// the form &quot;chrome-extension://&lt;extension_id&gt;/&lt;path&gt;&quot;.
//
// Browsers that host extensions differ from normal browsers as follows:
//  - Can access chrome.* JavaScript APIs if allowed by the manifest. Visit
//    chrome://extensions-support for the list of extension APIs currently
//    supported by CEF.
//  - Main frame navigation to non-extension content is blocked.
//  - Pinch-zooming is disabled.
//  - CefBrowserHost::GetExtension returns the hosted extension.
//  - CefBrowserHost::IsBackgroundHost returns true for background hosts.
//
// See https://developer.chrome.com/extensions for extension implementation
// and usage documentation.
///
func (self *CRequestContextT) LoadExtension(
	root_directory string,
	manifest *CDictionaryValueT,
	handler *CExtensionHandlerT,
) {
	c_root_directory := create_cef_string(root_directory)
	var goTmpmanifest *C.cef_dictionary_value_t
	if manifest != nil {
		BaseAddRef(manifest.pc_dictionary_value)
		goTmpmanifest = (*C.cef_dictionary_value_t)(manifest.pc_dictionary_value)
	}
	var goTmphandler *C.cef_extension_handler_t
	if handler != nil {
		BaseAddRef(handler.pc_extension_handler)
		goTmphandler = (*C.cef_extension_handler_t)(handler.pc_extension_handler)
	}

	C.cefingo_request_context_load_extension((*C.cef_request_context_t)(self.pc_request_context), c_root_directory.p_cef_string_t, goTmpmanifest, goTmphandler)

}

///
// Returns true (1) if this context was used to load the extension identified
// by |extension_id|. Other contexts sharing the same storage will also have
// access to the extension (see HasExtension). This function must be called on
// the browser process UI thread.
///
func (self *CRequestContextT) DidLoadExtension(
	extension_id string,
) (ret bool) {
	c_extension_id := create_cef_string(extension_id)

	cRet := C.cefingo_request_context_did_load_extension((*C.cef_request_context_t)(self.pc_request_context), c_extension_id.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this context has access to the extension identified by
// |extension_id|. This may not be the context that was used to load the
// extension (see DidLoadExtension). This function must be called on the
// browser process UI thread.
///
func (self *CRequestContextT) HasExtension(
	extension_id string,
) (ret bool) {
	c_extension_id := create_cef_string(extension_id)

	cRet := C.cefingo_request_context_has_extension((*C.cef_request_context_t)(self.pc_request_context), c_extension_id.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Retrieve the list of all extensions that this context has access to (see
// HasExtension). |extension_ids| will be populated with the list of extension
// ID values. Returns true (1) on success. This function must be called on the
// browser process UI thread.
///
func (self *CRequestContextT) GetExtensions(
	extension_ids CStringListT,
) (ret bool) {

	cRet := C.cefingo_request_context_get_extensions((*C.cef_request_context_t)(self.pc_request_context), (C.cef_string_list_t)(extension_ids))

	ret = cRet == 1
	return ret
}

///
// Returns the extension matching |extension_id| or NULL if no matching
// extension is accessible in this context (see HasExtension). This function
// must be called on the browser process UI thread.
///
func (self *CRequestContextT) GetExtension(
	extension_id string,
) (ret *CExtensionT) {
	c_extension_id := create_cef_string(extension_id)

	cRet := C.cefingo_request_context_get_extension((*C.cef_request_context_t)(self.pc_request_context), c_extension_id.p_cef_string_t)

	ret = newCExtensionT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the MediaRouter object associated with this context.  If |callback|
// is non-NULL it will be executed asnychronously on the UI thread after the
// manager&#39;s context has been initialized.
///
func (self *CRequestContextT) GetMediaRouter(
	callback *CCompletionCallbackT,
) (ret *CMediaRouterT) {
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	cRet := C.cefingo_request_context_get_media_router((*C.cef_request_context_t)(self.pc_request_context), goTmpcallback)

	ret = newCMediaRouterT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the global context object.
///
func RequestContextGetGlobalContext() (ret *CRequestContextT) {

	cRet := C.cef_request_context_get_global_context()

	ret = newCRequestContextT(cRet, byApp) // return GoObj
	return ret
}

///
// Creates a new context object with the specified |settings| and optional
// |handler|.
///
func RequestContextCreateContext(
	settings *CRequestContextSettingsT,
	handler *CRequestContextHandlerT,
) (ret *CRequestContextT) {
	var goTmphandler *C.cef_request_context_handler_t
	if handler != nil {
		BaseAddRef(handler.pc_request_context_handler)
		goTmphandler = (*C.cef_request_context_handler_t)(handler.pc_request_context_handler)
	}

	cRet := C.cef_request_context_create_context((*C.cef_request_context_settings_t)(settings), goTmphandler)

	ret = newCRequestContextT(cRet, byApp) // return GoObj
	return ret
}

///
// Creates a new context object that shares storage with |other| and uses an
// optional |handler|.
///
func CreateContextShared(
	other *CRequestContextT,
	handler *CRequestContextHandlerT,
) (ret *CRequestContextT) {
	var goTmpother *C.cef_request_context_t
	if other != nil {
		BaseAddRef(other.pc_request_context)
		goTmpother = (*C.cef_request_context_t)(other.pc_request_context)
	}
	var goTmphandler *C.cef_request_context_handler_t
	if handler != nil {
		BaseAddRef(handler.pc_request_context_handler)
		goTmphandler = (*C.cef_request_context_handler_t)(handler.pc_request_context_handler)
	}

	cRet := C.cef_create_context_shared(goTmpother, goTmphandler)

	ret = newCRequestContextT(cRet, byApp) // return GoObj
	return ret
}

// cef_request_context_handler_capi.h, include/capi/cef_request_context_handler_capi.h:100:3,

///
// Implement this structure to provide handler implementations. The handler
// instance will not be released until all objects related to the context have
// been destroyed.
///

type cCRequestContextHandlerT C.cef_request_context_handler_t

// Go type for cef_request_context_handler_t
type CRequestContextHandlerT struct {
	noCopy                     noCopy
	pc_request_context_handler *cCRequestContextHandlerT
	beUnrefed                  unrefedBy
}

func (p *CRequestContextHandlerT) Pass() (ret *CRequestContextHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRequestContextHandlerT((*C.cef_request_context_handler_t)(p.pc_request_context_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRequestContextHandlerT) NewRef() (newP *CRequestContextHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_request_context_handler
	BaseAddRef(gop)
	newP = newCRequestContextHandlerT((*C.cef_request_context_handler_t)(gop), byApp)
	return newP
}

// Go type CRequestContextHandlerT wraps cef type *C.cef_request_context_handler_t
func newCRequestContextHandlerT(p *C.cef_request_context_handler_t, unrefedBy unrefedBy) *CRequestContextHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T185.1:")
	pc := (*cCRequestContextHandlerT)(p)
	go_request_context_handler := &CRequestContextHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_request_context_handler, func(g *CRequestContextHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_request_context_handler != nil {
			Tracef(unsafe.Pointer(g.pc_request_context_handler), "T185.2:")
			BaseRelease(g.pc_request_context_handler)
		}
	})

	return go_request_context_handler
}

// *C.cef_request_context_handler_t has refCounted interface
func (request_context_handler *CRequestContextHandlerT) HasOneRef() bool {
	return BaseHasOneRef(request_context_handler.pc_request_context_handler)
}

func (p *cCRequestContextHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (request_context_handler *CRequestContextHandlerT) Unref() (ret bool) {
	if request_context_handler == nil {
		return
	}
	if request_context_handler.beUnrefed == byApp {
		ret = BaseRelease(request_context_handler.pc_request_context_handler)
		request_context_handler.beUnrefed = unrefed
	}
	request_context_handler.pc_request_context_handler = nil
	return ret
}

///
// Called on the browser process UI thread immediately after the request
// context has been initialized.
///
type OnRequestContextInitializedHandler interface {
	OnRequestContextInitialized(
		self *CRequestContextHandlerT,
		request_context *CRequestContextT,
	)
}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request, and may be NULL for requests originating from service workers or
// cef_urlrequest_t. |request| represents the request contents and cannot be
// modified in this callback. |is_navigation| will be true (1) if the resource
// request is a navigation. |is_download| will be true (1) if the resource
// request is a download. |request_initiator| is the origin (scheme + domain)
// of the page that initiated the request. Set |disable_default_handling| to
// true (1) to disable default handling of the request, in which case it will
// need to be handled via cef_resource_request_handler_t::GetResourceHandler
// or it will be canceled. To allow the resource load to proceed with default
// handling return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. This function will not be called if
// the client associated with |browser| returns a non-NULL value from
// cef_request_handler_t::GetResourceRequestHandler for the same request
// (identified by cef_request_t::GetIdentifier).
///
type CRequestContextHandlerTGetResourceRequestHandlerHandler interface {
	GetResourceRequestHandler(
		self *CRequestContextHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		is_navigation int,
		is_download int,
		request_initiator string,
	) (ret *CResourceRequestHandlerT, disable_default_handling bool)
}

var request_context_handler_handlers = struct {
	handler                                map[*cCRequestContextHandlerT]interface{}
	on_request_context_initialized_handler map[*cCRequestContextHandlerT]OnRequestContextInitializedHandler
	get_resource_request_handler_handler   map[*cCRequestContextHandlerT]CRequestContextHandlerTGetResourceRequestHandlerHandler
}{
	map[*cCRequestContextHandlerT]interface{}{},
	map[*cCRequestContextHandlerT]OnRequestContextInitializedHandler{},
	map[*cCRequestContextHandlerT]CRequestContextHandlerTGetResourceRequestHandlerHandler{},
}

// allocCRequestContextHandlerT allocates CRequestContextHandlerT and construct it
func allocCRequestContextHandlerT() *CRequestContextHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_request_context_handler_wrapper_t, "T185.3:")
	cefp := C.cefingo_construct_request_context_handler((*C.cefingo_request_context_handler_wrapper_t)(up))
	cgop := (*cCRequestContextHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_request_context_handler_t itself in DeassocFunc,
		// or cef_request_context_handler_t is never GCed.
		Tracef(up, "T185.4:")
		unbindAllCRequestContextHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCRequestContextHandlerT(cefp, byApp)
}

// NewCRequestContextHandlerT allocates CRequestContextHandlerT, construct and bind it
func NewCRequestContextHandlerT(a interface{}) *CRequestContextHandlerT {
	return allocCRequestContextHandlerT().bind(a)
}

func (request_context_handler *CRequestContextHandlerT) bind(a interface{}) *CRequestContextHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := request_context_handler.pc_request_context_handler
	request_context_handler_handlers.handler[cp] = a

	if h, ok := a.(OnRequestContextInitializedHandler); ok {
		request_context_handler_handlers.on_request_context_initialized_handler[cp] = h
		noBind = false
	} else {
		delete(request_context_handler_handlers.on_request_context_initialized_handler, cp)
	}

	if h, ok := a.(CRequestContextHandlerTGetResourceRequestHandlerHandler); ok {
		request_context_handler_handlers.get_resource_request_handler_handler[cp] = h
		noBind = false
	} else {
		delete(request_context_handler_handlers.get_resource_request_handler_handler, cp)
	}

	if noBind {
		Panicln("F229: *CRequestContextHandlerT No bind")
	}
	return request_context_handler
}

func unbindAllCRequestContextHandlerT(cp *cCRequestContextHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := request_context_handler.pc_request_context_handler
	delete(request_context_handler_handlers.handler, cp)

	delete(request_context_handler_handlers.on_request_context_initialized_handler, cp)
	delete(request_context_handler_handlers.get_resource_request_handler_handler, cp)
}

func (request_context_handler *CRequestContextHandlerT) UnbindAll() {
	unbindAllCRequestContextHandlerT(request_context_handler.pc_request_context_handler)
	request_context_handler.Unref()
}

func (request_context_handler *CRequestContextHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := request_context_handler.pc_request_context_handler
	return request_context_handler_handlers.handler[cp]
}

// cef_request_handler_capi.h, include/capi/cef_request_handler_capi.h:73:3,

///
// Callback structure used to select a client certificate for authentication.
///

type cCSelectClientCertificateCallbackT C.cef_select_client_certificate_callback_t

// Go type for cef_select_client_certificate_callback_t
type CSelectClientCertificateCallbackT struct {
	noCopy                                noCopy
	pc_select_client_certificate_callback *cCSelectClientCertificateCallbackT
	beUnrefed                             unrefedBy
}

func (p *CSelectClientCertificateCallbackT) Pass() (ret *CSelectClientCertificateCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCSelectClientCertificateCallbackT((*C.cef_select_client_certificate_callback_t)(p.pc_select_client_certificate_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CSelectClientCertificateCallbackT) NewRef() (newP *CSelectClientCertificateCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_select_client_certificate_callback
	BaseAddRef(gop)
	newP = newCSelectClientCertificateCallbackT((*C.cef_select_client_certificate_callback_t)(gop), byApp)
	return newP
}

// Go type CSelectClientCertificateCallbackT wraps cef type *C.cef_select_client_certificate_callback_t
func newCSelectClientCertificateCallbackT(p *C.cef_select_client_certificate_callback_t, unrefedBy unrefedBy) *CSelectClientCertificateCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T186.1:")
	pc := (*cCSelectClientCertificateCallbackT)(p)
	go_select_client_certificate_callback := &CSelectClientCertificateCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_select_client_certificate_callback, func(g *CSelectClientCertificateCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_select_client_certificate_callback != nil {
			Tracef(unsafe.Pointer(g.pc_select_client_certificate_callback), "T186.2:")
			BaseRelease(g.pc_select_client_certificate_callback)
		}
	})

	return go_select_client_certificate_callback
}

// *C.cef_select_client_certificate_callback_t has refCounted interface
func (select_client_certificate_callback *CSelectClientCertificateCallbackT) HasOneRef() bool {
	return BaseHasOneRef(select_client_certificate_callback.pc_select_client_certificate_callback)
}

func (p *cCSelectClientCertificateCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (select_client_certificate_callback *CSelectClientCertificateCallbackT) Unref() (ret bool) {
	if select_client_certificate_callback == nil {
		return
	}
	if select_client_certificate_callback.beUnrefed == byApp {
		ret = BaseRelease(select_client_certificate_callback.pc_select_client_certificate_callback)
		select_client_certificate_callback.beUnrefed = unrefed
	}
	select_client_certificate_callback.pc_select_client_certificate_callback = nil
	return ret
}

///
// Chooses the specified certificate for client certificate authentication.
// NULL value means that no client certificate should be used.
///
func (self *CSelectClientCertificateCallbackT) Select(
	cert *CX509certificateT,
) {
	var goTmpcert *C.cef_x509certificate_t
	if cert != nil {
		BaseAddRef(cert.pc_x509certificate)
		goTmpcert = (*C.cef_x509certificate_t)(cert.pc_x509certificate)
	}

	C.cefingo_select_client_certificate_callback_select((*C.cef_select_client_certificate_callback_t)(self.pc_select_client_certificate_callback), goTmpcert)

}

///
// Implement this structure to handle events related to browser requests. The
// functions of this structure will be called on the thread indicated.
///

type cCRequestHandlerT C.cef_request_handler_t

// Go type for cef_request_handler_t
type CRequestHandlerT struct {
	noCopy             noCopy
	pc_request_handler *cCRequestHandlerT
	beUnrefed          unrefedBy
}

func (p *CRequestHandlerT) Pass() (ret *CRequestHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCRequestHandlerT((*C.cef_request_handler_t)(p.pc_request_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CRequestHandlerT) NewRef() (newP *CRequestHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_request_handler
	BaseAddRef(gop)
	newP = newCRequestHandlerT((*C.cef_request_handler_t)(gop), byApp)
	return newP
}

// Go type CRequestHandlerT wraps cef type *C.cef_request_handler_t
func newCRequestHandlerT(p *C.cef_request_handler_t, unrefedBy unrefedBy) *CRequestHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T187.1:")
	pc := (*cCRequestHandlerT)(p)
	go_request_handler := &CRequestHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_request_handler, func(g *CRequestHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_request_handler != nil {
			Tracef(unsafe.Pointer(g.pc_request_handler), "T187.2:")
			BaseRelease(g.pc_request_handler)
		}
	})

	return go_request_handler
}

// *C.cef_request_handler_t has refCounted interface
func (request_handler *CRequestHandlerT) HasOneRef() bool {
	return BaseHasOneRef(request_handler.pc_request_handler)
}

func (p *cCRequestHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (request_handler *CRequestHandlerT) Unref() (ret bool) {
	if request_handler == nil {
		return
	}
	if request_handler.beUnrefed == byApp {
		ret = BaseRelease(request_handler.pc_request_handler)
		request_handler.beUnrefed = unrefed
	}
	request_handler.pc_request_handler = nil
	return ret
}

///
// Called on the UI thread before browser navigation. Return true (1) to
// cancel the navigation or false (0) to allow the navigation to proceed. The
// |request| object cannot be modified in this callback.
// cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.
// If the navigation is allowed cef_load_handler_t::OnLoadStart and
// cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled
// cef_load_handler_t::OnLoadError will be called with an |errorCode| value of
// ERR_ABORTED. The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event).
///
type OnBeforeBrowseHandler interface {
	OnBeforeBrowse(
		self *CRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		user_gesture bool,
		is_redirect bool,
	) (ret bool)
}

///
// Called on the UI thread before OnBeforeBrowse in certain limited cases
// where navigating a new or different browser might be desirable. This
// includes user-initiated navigation that might open in a special way (e.g.
// links clicked via middle-click or ctrl + left-click) and certain types of
// cross-origin navigation initiated from the renderer process (e.g.
// navigating the top-level frame to/from a file URL). The |browser| and
// |frame| values represent the source of the navigation. The
// |target_disposition| value indicates where the user intended to navigate
// the browser based on standard Chromium behaviors (e.g. current tab, new
// tab, etc). The |user_gesture| value will be true (1) if the browser
// navigated via explicit user gesture (e.g. clicking a link) or false (0) if
// it navigated automatically (e.g. via the DomContentLoaded event). Return
// true (1) to cancel the navigation or false (0) to allow the navigation to
// proceed in the source browser&#39;s top-level frame.
///
type OnOpenUrlfromTabHandler interface {
	OnOpenUrlfromTab(
		self *CRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		target_url string,
		target_disposition CWindowOpenDispositionT,
		user_gesture bool,
	) (ret bool)
}

///
// Called on the browser process IO thread before a resource request is
// initiated. The |browser| and |frame| values represent the source of the
// request. |request| represents the request contents and cannot be modified
// in this callback. |is_navigation| will be true (1) if the resource request
// is a navigation. |is_download| will be true (1) if the resource request is
// a download. |request_initiator| is the origin (scheme + domain) of the page
// that initiated the request. Set |disable_default_handling| to true (1) to
// disable default handling of the request, in which case it will need to be
// handled via cef_resource_request_handler_t::GetResourceHandler or it will
// be canceled. To allow the resource load to proceed with default handling
// return NULL. To specify a handler for the resource return a
// cef_resource_request_handler_t object. If this callback returns NULL the
// same function will be called on the associated
// cef_request_context_handler_t, if any.
///
type CRequestHandlerTGetResourceRequestHandlerHandler interface {
	GetResourceRequestHandler(
		self *CRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		is_navigation int,
		is_download int,
		request_initiator string,
	) (ret *CResourceRequestHandlerT, disable_default_handling bool)
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |origin_url| is the origin making this authentication request. |isProxy|
// indicates whether the host is a proxy server. |host| contains the hostname
// and |port| contains the port number. |realm| is the realm of the challenge
// and may be NULL. |scheme| is the authentication scheme used, such as
// &quot;basic&quot; or &quot;digest&quot;, and will be NULL if the source of the request is an
// FTP server. Return true (1) to continue the request and call
// cef_auth_callback_t::cont() either in this function or at a later time when
// the authentication information is available. Return false (0) to cancel the
// request immediately.
///
type CRequestHandlerTGetAuthCredentialsHandler interface {
	GetAuthCredentials(
		self *CRequestHandlerT,
		browser *CBrowserT,
		origin_url string,
		isProxy int,
		host string,
		port int,
		realm string,
		scheme string,
		callback *CAuthCallbackT,
	) (ret bool)
}

///
// Called on the IO thread when JavaScript requests a specific storage quota
// size via the webkitStorageInfo.requestQuota function. |origin_url| is the
// origin of the page making the request. |new_size| is the requested quota
// size in bytes. Return true (1) to continue the request and call
// cef_callback_t functions either in this function or at a later time to
// grant or deny the request. Return false (0) to cancel the request
// immediately.
///
type OnQuotaRequestHandler interface {
	OnQuotaRequest(
		self *CRequestHandlerT,
		browser *CBrowserT,
		origin_url string,
		new_size int64,
		callback *CCallbackT,
	) (ret bool)
}

///
// Called on the UI thread to handle requests for URLs with an invalid SSL
// certificate. Return true (1) and call cef_callback_t functions either in
// this function or at a later time to continue or cancel the request. Return
// false (0) to cancel the request immediately. If
// CefSettings.ignore_certificate_errors is set all invalid certificates will
// be accepted without calling this function.
///
type OnCertificateErrorHandler interface {
	OnCertificateError(
		self *CRequestHandlerT,
		browser *CBrowserT,
		cert_error CErrorcodeT,
		request_url string,
		ssl_info *CSslinfoT,
		callback *CCallbackT,
	) (ret bool)
}

///
// Called on the UI thread when a client certificate is being requested for
// authentication. Return false (0) to use the default behavior and
// automatically select the first certificate available. Return true (1) and
// call cef_select_client_certificate_callback_t::Select either in this
// function or at a later time to select a certificate. Do not call Select or
// call it with NULL to continue without using any certificate. |isProxy|
// indicates whether the host is an HTTPS proxy or the origin server. |host|
// and |port| contains the hostname and port of the SSL server. |certificates|
// is the list of certificates to choose from; this list has already been
// pruned by Chromium so that it only contains certificates from issuers that
// the server trusts.
///
type OnSelectClientCertificateHandler interface {
	OnSelectClientCertificate(
		self *CRequestHandlerT,
		browser *CBrowserT,
		isProxy int,
		host string,
		port int,
		certificates []*CX509certificateT,
		callback *CSelectClientCertificateCallbackT,
	) (ret bool)
}

///
// Called on the browser process UI thread when the render view associated
// with |browser| is ready to receive/handle IPC messages in the render
// process.
///
type OnRenderViewReadyHandler interface {
	OnRenderViewReady(
		self *CRequestHandlerT,
		browser *CBrowserT,
	)
}

///
// Called on the browser process UI thread when the render process terminates
// unexpectedly. |status| indicates how the process terminated.
///
type OnRenderProcessTerminatedHandler interface {
	OnRenderProcessTerminated(
		self *CRequestHandlerT,
		browser *CBrowserT,
		status CTerminationStatusT,
	)
}

///
// Called on the browser process UI thread when the window.document object of
// the main frame has been created.
///
type OnDocumentAvailableInMainFrameHandler interface {
	OnDocumentAvailableInMainFrame(
		self *CRequestHandlerT,
		browser *CBrowserT,
	)
}

var request_handler_handlers = struct {
	handler                                     map[*cCRequestHandlerT]interface{}
	on_before_browse_handler                    map[*cCRequestHandlerT]OnBeforeBrowseHandler
	on_open_urlfrom_tab_handler                 map[*cCRequestHandlerT]OnOpenUrlfromTabHandler
	get_resource_request_handler_handler        map[*cCRequestHandlerT]CRequestHandlerTGetResourceRequestHandlerHandler
	get_auth_credentials_handler                map[*cCRequestHandlerT]CRequestHandlerTGetAuthCredentialsHandler
	on_quota_request_handler                    map[*cCRequestHandlerT]OnQuotaRequestHandler
	on_certificate_error_handler                map[*cCRequestHandlerT]OnCertificateErrorHandler
	on_select_client_certificate_handler        map[*cCRequestHandlerT]OnSelectClientCertificateHandler
	on_render_view_ready_handler                map[*cCRequestHandlerT]OnRenderViewReadyHandler
	on_render_process_terminated_handler        map[*cCRequestHandlerT]OnRenderProcessTerminatedHandler
	on_document_available_in_main_frame_handler map[*cCRequestHandlerT]OnDocumentAvailableInMainFrameHandler
}{
	map[*cCRequestHandlerT]interface{}{},
	map[*cCRequestHandlerT]OnBeforeBrowseHandler{},
	map[*cCRequestHandlerT]OnOpenUrlfromTabHandler{},
	map[*cCRequestHandlerT]CRequestHandlerTGetResourceRequestHandlerHandler{},
	map[*cCRequestHandlerT]CRequestHandlerTGetAuthCredentialsHandler{},
	map[*cCRequestHandlerT]OnQuotaRequestHandler{},
	map[*cCRequestHandlerT]OnCertificateErrorHandler{},
	map[*cCRequestHandlerT]OnSelectClientCertificateHandler{},
	map[*cCRequestHandlerT]OnRenderViewReadyHandler{},
	map[*cCRequestHandlerT]OnRenderProcessTerminatedHandler{},
	map[*cCRequestHandlerT]OnDocumentAvailableInMainFrameHandler{},
}

// allocCRequestHandlerT allocates CRequestHandlerT and construct it
func allocCRequestHandlerT() *CRequestHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_request_handler_wrapper_t, "T187.3:")
	cefp := C.cefingo_construct_request_handler((*C.cefingo_request_handler_wrapper_t)(up))
	cgop := (*cCRequestHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_request_handler_t itself in DeassocFunc,
		// or cef_request_handler_t is never GCed.
		Tracef(up, "T187.4:")
		unbindAllCRequestHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCRequestHandlerT(cefp, byApp)
}

// NewCRequestHandlerT allocates CRequestHandlerT, construct and bind it
func NewCRequestHandlerT(a interface{}) *CRequestHandlerT {
	return allocCRequestHandlerT().bind(a)
}

func (request_handler *CRequestHandlerT) bind(a interface{}) *CRequestHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := request_handler.pc_request_handler
	request_handler_handlers.handler[cp] = a

	if h, ok := a.(OnBeforeBrowseHandler); ok {
		request_handler_handlers.on_before_browse_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_before_browse_handler, cp)
	}

	if h, ok := a.(OnOpenUrlfromTabHandler); ok {
		request_handler_handlers.on_open_urlfrom_tab_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_open_urlfrom_tab_handler, cp)
	}

	if h, ok := a.(CRequestHandlerTGetResourceRequestHandlerHandler); ok {
		request_handler_handlers.get_resource_request_handler_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.get_resource_request_handler_handler, cp)
	}

	if h, ok := a.(CRequestHandlerTGetAuthCredentialsHandler); ok {
		request_handler_handlers.get_auth_credentials_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.get_auth_credentials_handler, cp)
	}

	if h, ok := a.(OnQuotaRequestHandler); ok {
		request_handler_handlers.on_quota_request_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_quota_request_handler, cp)
	}

	if h, ok := a.(OnCertificateErrorHandler); ok {
		request_handler_handlers.on_certificate_error_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_certificate_error_handler, cp)
	}

	if h, ok := a.(OnSelectClientCertificateHandler); ok {
		request_handler_handlers.on_select_client_certificate_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_select_client_certificate_handler, cp)
	}

	if h, ok := a.(OnRenderViewReadyHandler); ok {
		request_handler_handlers.on_render_view_ready_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_render_view_ready_handler, cp)
	}

	if h, ok := a.(OnRenderProcessTerminatedHandler); ok {
		request_handler_handlers.on_render_process_terminated_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_render_process_terminated_handler, cp)
	}

	if h, ok := a.(OnDocumentAvailableInMainFrameHandler); ok {
		request_handler_handlers.on_document_available_in_main_frame_handler[cp] = h
		noBind = false
	} else {
		delete(request_handler_handlers.on_document_available_in_main_frame_handler, cp)
	}

	if noBind {
		Panicln("F229: *CRequestHandlerT No bind")
	}
	return request_handler
}

func unbindAllCRequestHandlerT(cp *cCRequestHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := request_handler.pc_request_handler
	delete(request_handler_handlers.handler, cp)

	delete(request_handler_handlers.on_before_browse_handler, cp)
	delete(request_handler_handlers.on_open_urlfrom_tab_handler, cp)
	delete(request_handler_handlers.get_resource_request_handler_handler, cp)
	delete(request_handler_handlers.get_auth_credentials_handler, cp)
	delete(request_handler_handlers.on_quota_request_handler, cp)
	delete(request_handler_handlers.on_certificate_error_handler, cp)
	delete(request_handler_handlers.on_select_client_certificate_handler, cp)
	delete(request_handler_handlers.on_render_view_ready_handler, cp)
	delete(request_handler_handlers.on_render_process_terminated_handler, cp)
	delete(request_handler_handlers.on_document_available_in_main_frame_handler, cp)
}

func (request_handler *CRequestHandlerT) UnbindAll() {
	unbindAllCRequestHandlerT(request_handler.pc_request_handler)
	request_handler.Unref()
}

func (request_handler *CRequestHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := request_handler.pc_request_handler
	return request_handler_handlers.handler[cp]
}

// cef_resource_bundle_handler_capi.h, include/capi/cef_resource_bundle_handler_capi.h:99:3,

///
// Structure used to implement a custom resource bundle structure. See
// CefSettings for additional options related to resource bundle loading. The
// functions of this structure may be called on multiple threads.
///

type cCResourceBundleHandlerT C.cef_resource_bundle_handler_t

// Go type for cef_resource_bundle_handler_t
type CResourceBundleHandlerT struct {
	noCopy                     noCopy
	pc_resource_bundle_handler *cCResourceBundleHandlerT
	beUnrefed                  unrefedBy
}

func (p *CResourceBundleHandlerT) Pass() (ret *CResourceBundleHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResourceBundleHandlerT((*C.cef_resource_bundle_handler_t)(p.pc_resource_bundle_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResourceBundleHandlerT) NewRef() (newP *CResourceBundleHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_resource_bundle_handler
	BaseAddRef(gop)
	newP = newCResourceBundleHandlerT((*C.cef_resource_bundle_handler_t)(gop), byApp)
	return newP
}

// Go type CResourceBundleHandlerT wraps cef type *C.cef_resource_bundle_handler_t
func newCResourceBundleHandlerT(p *C.cef_resource_bundle_handler_t, unrefedBy unrefedBy) *CResourceBundleHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T188.1:")
	pc := (*cCResourceBundleHandlerT)(p)
	go_resource_bundle_handler := &CResourceBundleHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_resource_bundle_handler, func(g *CResourceBundleHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_resource_bundle_handler != nil {
			Tracef(unsafe.Pointer(g.pc_resource_bundle_handler), "T188.2:")
			BaseRelease(g.pc_resource_bundle_handler)
		}
	})

	return go_resource_bundle_handler
}

// *C.cef_resource_bundle_handler_t has refCounted interface
func (resource_bundle_handler *CResourceBundleHandlerT) HasOneRef() bool {
	return BaseHasOneRef(resource_bundle_handler.pc_resource_bundle_handler)
}

func (p *cCResourceBundleHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (resource_bundle_handler *CResourceBundleHandlerT) Unref() (ret bool) {
	if resource_bundle_handler == nil {
		return
	}
	if resource_bundle_handler.beUnrefed == byApp {
		ret = BaseRelease(resource_bundle_handler.pc_resource_bundle_handler)
		resource_bundle_handler.beUnrefed = unrefed
	}
	resource_bundle_handler.pc_resource_bundle_handler = nil
	return ret
}

///
// Called to retrieve a localized translation for the specified |string_id|.
// To provide the translation set |string| to the translation string and
// return true (1). To use the default translation return false (0). Include
// cef_pack_strings.h for a listing of valid string ID values.
///
type GetLocalizedStringHandler interface {
	GetLocalizedString(
		self *CResourceBundleHandlerT,
		string_id int,
	) (ret bool, cstring string)
}

///
// Called to retrieve data for the specified scale independent |resource_id|.
// To provide the resource data set |data| and |data_size| to the data pointer
// and size respectively and return true (1). To use the default resource data
// return false (0). The resource data will not be copied and must remain
// resident in memory. Include cef_pack_resources.h for a listing of valid
// resource ID values.
///
type GetDataResourceHandler interface {
	GetDataResource(
		self *CResourceBundleHandlerT,
		resource_id int,
	) (ret bool, data []byte)
}

///
// Called to retrieve data for the specified |resource_id| nearest the scale
// factor |scale_factor|. To provide the resource data set |data| and
// |data_size| to the data pointer and size respectively and return true (1).
// To use the default resource data return false (0). The resource data will
// not be copied and must remain resident in memory. Include
// cef_pack_resources.h for a listing of valid resource ID values.
///
type GetDataResourceForScaleHandler interface {
	GetDataResourceForScale(
		self *CResourceBundleHandlerT,
		resource_id int,
		scale_factor CScaleFactorT,
	) (ret bool, data []byte)
}

var resource_bundle_handler_handlers = struct {
	handler                             map[*cCResourceBundleHandlerT]interface{}
	get_localized_string_handler        map[*cCResourceBundleHandlerT]GetLocalizedStringHandler
	get_data_resource_handler           map[*cCResourceBundleHandlerT]GetDataResourceHandler
	get_data_resource_for_scale_handler map[*cCResourceBundleHandlerT]GetDataResourceForScaleHandler
}{
	map[*cCResourceBundleHandlerT]interface{}{},
	map[*cCResourceBundleHandlerT]GetLocalizedStringHandler{},
	map[*cCResourceBundleHandlerT]GetDataResourceHandler{},
	map[*cCResourceBundleHandlerT]GetDataResourceForScaleHandler{},
}

// allocCResourceBundleHandlerT allocates CResourceBundleHandlerT and construct it
func allocCResourceBundleHandlerT() *CResourceBundleHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_resource_bundle_handler_wrapper_t, "T188.3:")
	cefp := C.cefingo_construct_resource_bundle_handler((*C.cefingo_resource_bundle_handler_wrapper_t)(up))
	cgop := (*cCResourceBundleHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_resource_bundle_handler_t itself in DeassocFunc,
		// or cef_resource_bundle_handler_t is never GCed.
		Tracef(up, "T188.4:")
		unbindAllCResourceBundleHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCResourceBundleHandlerT(cefp, byApp)
}

// NewCResourceBundleHandlerT allocates CResourceBundleHandlerT, construct and bind it
func NewCResourceBundleHandlerT(a interface{}) *CResourceBundleHandlerT {
	return allocCResourceBundleHandlerT().bind(a)
}

func (resource_bundle_handler *CResourceBundleHandlerT) bind(a interface{}) *CResourceBundleHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := resource_bundle_handler.pc_resource_bundle_handler
	resource_bundle_handler_handlers.handler[cp] = a

	if h, ok := a.(GetLocalizedStringHandler); ok {
		resource_bundle_handler_handlers.get_localized_string_handler[cp] = h
		noBind = false
	} else {
		delete(resource_bundle_handler_handlers.get_localized_string_handler, cp)
	}

	if h, ok := a.(GetDataResourceHandler); ok {
		resource_bundle_handler_handlers.get_data_resource_handler[cp] = h
		noBind = false
	} else {
		delete(resource_bundle_handler_handlers.get_data_resource_handler, cp)
	}

	if h, ok := a.(GetDataResourceForScaleHandler); ok {
		resource_bundle_handler_handlers.get_data_resource_for_scale_handler[cp] = h
		noBind = false
	} else {
		delete(resource_bundle_handler_handlers.get_data_resource_for_scale_handler, cp)
	}

	if noBind {
		Panicln("F229: *CResourceBundleHandlerT No bind")
	}
	return resource_bundle_handler
}

func unbindAllCResourceBundleHandlerT(cp *cCResourceBundleHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := resource_bundle_handler.pc_resource_bundle_handler
	delete(resource_bundle_handler_handlers.handler, cp)

	delete(resource_bundle_handler_handlers.get_localized_string_handler, cp)
	delete(resource_bundle_handler_handlers.get_data_resource_handler, cp)
	delete(resource_bundle_handler_handlers.get_data_resource_for_scale_handler, cp)
}

func (resource_bundle_handler *CResourceBundleHandlerT) UnbindAll() {
	unbindAllCResourceBundleHandlerT(resource_bundle_handler.pc_resource_bundle_handler)
	resource_bundle_handler.Unref()
}

func (resource_bundle_handler *CResourceBundleHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := resource_bundle_handler.pc_resource_bundle_handler
	return resource_bundle_handler_handlers.handler[cp]
}

// cef_resource_handler_capi.h, include/capi/cef_resource_handler_capi.h:71:3,

///
// Callback for asynchronous continuation of cef_resource_handler_t::skip().
///

type cCResourceSkipCallbackT C.cef_resource_skip_callback_t

// Go type for cef_resource_skip_callback_t
type CResourceSkipCallbackT struct {
	noCopy                    noCopy
	pc_resource_skip_callback *cCResourceSkipCallbackT
	beUnrefed                 unrefedBy
}

func (p *CResourceSkipCallbackT) Pass() (ret *CResourceSkipCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResourceSkipCallbackT((*C.cef_resource_skip_callback_t)(p.pc_resource_skip_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResourceSkipCallbackT) NewRef() (newP *CResourceSkipCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_resource_skip_callback
	BaseAddRef(gop)
	newP = newCResourceSkipCallbackT((*C.cef_resource_skip_callback_t)(gop), byApp)
	return newP
}

// Go type CResourceSkipCallbackT wraps cef type *C.cef_resource_skip_callback_t
func newCResourceSkipCallbackT(p *C.cef_resource_skip_callback_t, unrefedBy unrefedBy) *CResourceSkipCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T189.1:")
	pc := (*cCResourceSkipCallbackT)(p)
	go_resource_skip_callback := &CResourceSkipCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_resource_skip_callback, func(g *CResourceSkipCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_resource_skip_callback != nil {
			Tracef(unsafe.Pointer(g.pc_resource_skip_callback), "T189.2:")
			BaseRelease(g.pc_resource_skip_callback)
		}
	})

	return go_resource_skip_callback
}

// *C.cef_resource_skip_callback_t has refCounted interface
func (resource_skip_callback *CResourceSkipCallbackT) HasOneRef() bool {
	return BaseHasOneRef(resource_skip_callback.pc_resource_skip_callback)
}

func (p *cCResourceSkipCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (resource_skip_callback *CResourceSkipCallbackT) Unref() (ret bool) {
	if resource_skip_callback == nil {
		return
	}
	if resource_skip_callback.beUnrefed == byApp {
		ret = BaseRelease(resource_skip_callback.pc_resource_skip_callback)
		resource_skip_callback.beUnrefed = unrefed
	}
	resource_skip_callback.pc_resource_skip_callback = nil
	return ret
}

///
// Callback for asynchronous continuation of skip(). If |bytes_skipped| &gt; 0
// then either skip() will be called again until the requested number of bytes
// have been skipped or the request will proceed. If |bytes_skipped| &lt;= 0 the
// request will fail with ERR_REQUEST_RANGE_NOT_SATISFIABLE.
///
func (self *CResourceSkipCallbackT) Cont(
	bytes_skipped int64,
) {

	C.cefingo_resource_skip_callback_cont((*C.cef_resource_skip_callback_t)(self.pc_resource_skip_callback), (C.int64)(bytes_skipped))

}

///
// Callback for asynchronous continuation of cef_resource_handler_t::read().
///

type cCResourceReadCallbackT C.cef_resource_read_callback_t

// Go type for cef_resource_read_callback_t
type CResourceReadCallbackT struct {
	noCopy                    noCopy
	pc_resource_read_callback *cCResourceReadCallbackT
	beUnrefed                 unrefedBy
}

func (p *CResourceReadCallbackT) Pass() (ret *CResourceReadCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResourceReadCallbackT((*C.cef_resource_read_callback_t)(p.pc_resource_read_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResourceReadCallbackT) NewRef() (newP *CResourceReadCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_resource_read_callback
	BaseAddRef(gop)
	newP = newCResourceReadCallbackT((*C.cef_resource_read_callback_t)(gop), byApp)
	return newP
}

// Go type CResourceReadCallbackT wraps cef type *C.cef_resource_read_callback_t
func newCResourceReadCallbackT(p *C.cef_resource_read_callback_t, unrefedBy unrefedBy) *CResourceReadCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T190.1:")
	pc := (*cCResourceReadCallbackT)(p)
	go_resource_read_callback := &CResourceReadCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_resource_read_callback, func(g *CResourceReadCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_resource_read_callback != nil {
			Tracef(unsafe.Pointer(g.pc_resource_read_callback), "T190.2:")
			BaseRelease(g.pc_resource_read_callback)
		}
	})

	return go_resource_read_callback
}

// *C.cef_resource_read_callback_t has refCounted interface
func (resource_read_callback *CResourceReadCallbackT) HasOneRef() bool {
	return BaseHasOneRef(resource_read_callback.pc_resource_read_callback)
}

func (p *cCResourceReadCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (resource_read_callback *CResourceReadCallbackT) Unref() (ret bool) {
	if resource_read_callback == nil {
		return
	}
	if resource_read_callback.beUnrefed == byApp {
		ret = BaseRelease(resource_read_callback.pc_resource_read_callback)
		resource_read_callback.beUnrefed = unrefed
	}
	resource_read_callback.pc_resource_read_callback = nil
	return ret
}

///
// Callback for asynchronous continuation of read(). If |bytes_read| == 0 the
// response will be considered complete. If |bytes_read| &gt; 0 then read() will
// be called again until the request is complete (based on either the result
// or the expected content length). If |bytes_read| &lt; 0 then the request will
// fail and the |bytes_read| value will be treated as the error code.
///
func (self *CResourceReadCallbackT) Cont(
	bytes_read int,
) {

	C.cefingo_resource_read_callback_cont((*C.cef_resource_read_callback_t)(self.pc_resource_read_callback), (C.int)(bytes_read))

}

///
// Structure used to implement a custom request handler structure. The functions
// of this structure will be called on the IO thread unless otherwise indicated.
///

type cCResourceHandlerT C.cef_resource_handler_t

// Go type for cef_resource_handler_t
type CResourceHandlerT struct {
	noCopy              noCopy
	pc_resource_handler *cCResourceHandlerT
	beUnrefed           unrefedBy
}

func (p *CResourceHandlerT) Pass() (ret *CResourceHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResourceHandlerT((*C.cef_resource_handler_t)(p.pc_resource_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResourceHandlerT) NewRef() (newP *CResourceHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_resource_handler
	BaseAddRef(gop)
	newP = newCResourceHandlerT((*C.cef_resource_handler_t)(gop), byApp)
	return newP
}

// Go type CResourceHandlerT wraps cef type *C.cef_resource_handler_t
func newCResourceHandlerT(p *C.cef_resource_handler_t, unrefedBy unrefedBy) *CResourceHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T191.1:")
	pc := (*cCResourceHandlerT)(p)
	go_resource_handler := &CResourceHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_resource_handler, func(g *CResourceHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_resource_handler != nil {
			Tracef(unsafe.Pointer(g.pc_resource_handler), "T191.2:")
			BaseRelease(g.pc_resource_handler)
		}
	})

	return go_resource_handler
}

// *C.cef_resource_handler_t has refCounted interface
func (resource_handler *CResourceHandlerT) HasOneRef() bool {
	return BaseHasOneRef(resource_handler.pc_resource_handler)
}

func (p *cCResourceHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (resource_handler *CResourceHandlerT) Unref() (ret bool) {
	if resource_handler == nil {
		return
	}
	if resource_handler.beUnrefed == byApp {
		ret = BaseRelease(resource_handler.pc_resource_handler)
		resource_handler.beUnrefed = unrefed
	}
	resource_handler.pc_resource_handler = nil
	return ret
}

///
// Open the response stream. To handle the request immediately set
// |handle_request| to true (1) and return true (1). To decide at a later time
// set |handle_request| to false (0), return true (1), and execute |callback|
// to continue or cancel the request. To cancel the request immediately set
// |handle_request| to true (1) and return false (0). This function will be
// called in sequence but not from a dedicated thread. For backwards
// compatibility set |handle_request| to false (0) and return false (0) and
// the ProcessRequest function will be called.
///
type OpenHandler interface {
	Open(
		self *CResourceHandlerT,
		request *CRequestT,
		callback *CCallbackT,
	) (ret bool, handle_request bool)
}

///
// Begin processing the request. To handle the request return true (1) and
// call cef_callback_t::cont() once the response header information is
// available (cef_callback_t::cont() can also be called from inside this
// function if header information is available immediately). To cancel the
// request return false (0).
//
// WARNING: This function is deprecated. Use Open instead.
///
type ProcessRequestHandler interface {
	ProcessRequest(
		self *CResourceHandlerT,
		request *CRequestT,
		callback *CCallbackT,
	) (ret bool)
}

///
// Retrieve response header information. If the response length is not known
// set |response_length| to -1 and read_response() will be called until it
// returns false (0). If the response length is known set |response_length| to
// a positive value and read_response() will be called until it returns false
// (0) or the specified number of bytes have been read. Use the |response|
// object to set the mime type, http status code and other optional header
// values. To redirect the request to a new URL set |redirectUrl| to the new
// URL. |redirectUrl| can be either a relative or fully qualified URL. It is
// also possible to set |response| to a redirect http status code and pass the
// new URL via a Location header. Likewise with |redirectUrl| it is valid to
// set a relative or fully qualified URL as the Location header value. If an
// error occured while setting up the request you can call set_error() on
// |response| to indicate the error condition.
///
type GetResponseHeadersHandler interface {
	GetResponseHeaders(
		self *CResourceHandlerT,
		response *CResponseT,
	) (response_length int64, redirectUrl string)
}

///
// Skip response data when requested by a Range header. Skip over and discard
// |bytes_to_skip| bytes of response data. If data is available immediately
// set |bytes_skipped| to the number of bytes skipped and return true (1). To
// read the data at a later time set |bytes_skipped| to 0, return true (1) and
// execute |callback| when the data is available. To indicate failure set
// |bytes_skipped| to &lt; 0 (e.g. -2 for ERR_FAILED) and return false (0). This
// function will be called in sequence but not from a dedicated thread.
///
type SkipHandler interface {
	Skip(
		self *CResourceHandlerT,
		bytes_to_skip int64,
		callback *CResourceSkipCallbackT,
	) (ret bool, bytes_skipped int64)
}

///
// Read response data. If data is available immediately copy up to
// |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of
// bytes copied, and return true (1). To read the data at a later time keep a
// pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute
// |callback| when the data is available (|data_out| will remain valid until
// the callback is executed). To indicate response completion set |bytes_read|
// to 0 and return false (0). To indicate failure set |bytes_read| to &lt; 0
// (e.g. -2 for ERR_FAILED) and return false (0). This function will be called
// in sequence but not from a dedicated thread. For backwards compatibility
// set |bytes_read| to -1 and return false (0) and the ReadResponse function
// will be called.
///
type CResourceHandlerTReadHandler interface {
	Read(
		self *CResourceHandlerT,
		data_out []byte,
		callback *CResourceReadCallbackT,
	) (ret bool, bytes_read int)
}

///
// Request processing has been canceled.
///
type CancelHandler interface {
	Cancel(
		self *CResourceHandlerT,
	)
}

var resource_handler_handlers = struct {
	handler                      map[*cCResourceHandlerT]interface{}
	open_handler                 map[*cCResourceHandlerT]OpenHandler
	process_request_handler      map[*cCResourceHandlerT]ProcessRequestHandler
	get_response_headers_handler map[*cCResourceHandlerT]GetResponseHeadersHandler
	skip_handler                 map[*cCResourceHandlerT]SkipHandler
	read_handler                 map[*cCResourceHandlerT]CResourceHandlerTReadHandler
	cancel_handler               map[*cCResourceHandlerT]CancelHandler
}{
	map[*cCResourceHandlerT]interface{}{},
	map[*cCResourceHandlerT]OpenHandler{},
	map[*cCResourceHandlerT]ProcessRequestHandler{},
	map[*cCResourceHandlerT]GetResponseHeadersHandler{},
	map[*cCResourceHandlerT]SkipHandler{},
	map[*cCResourceHandlerT]CResourceHandlerTReadHandler{},
	map[*cCResourceHandlerT]CancelHandler{},
}

// allocCResourceHandlerT allocates CResourceHandlerT and construct it
func allocCResourceHandlerT() *CResourceHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_resource_handler_wrapper_t, "T191.3:")
	cefp := C.cefingo_construct_resource_handler((*C.cefingo_resource_handler_wrapper_t)(up))
	cgop := (*cCResourceHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_resource_handler_t itself in DeassocFunc,
		// or cef_resource_handler_t is never GCed.
		Tracef(up, "T191.4:")
		unbindAllCResourceHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCResourceHandlerT(cefp, byApp)
}

// NewCResourceHandlerT allocates CResourceHandlerT, construct and bind it
func NewCResourceHandlerT(a interface{}) *CResourceHandlerT {
	return allocCResourceHandlerT().bind(a)
}

func (resource_handler *CResourceHandlerT) bind(a interface{}) *CResourceHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := resource_handler.pc_resource_handler
	resource_handler_handlers.handler[cp] = a

	if h, ok := a.(OpenHandler); ok {
		resource_handler_handlers.open_handler[cp] = h
		noBind = false
	} else {
		delete(resource_handler_handlers.open_handler, cp)
	}

	if h, ok := a.(ProcessRequestHandler); ok {
		resource_handler_handlers.process_request_handler[cp] = h
		noBind = false
	} else {
		delete(resource_handler_handlers.process_request_handler, cp)
	}

	if h, ok := a.(GetResponseHeadersHandler); ok {
		resource_handler_handlers.get_response_headers_handler[cp] = h
		noBind = false
	} else {
		delete(resource_handler_handlers.get_response_headers_handler, cp)
	}

	if h, ok := a.(SkipHandler); ok {
		resource_handler_handlers.skip_handler[cp] = h
		noBind = false
	} else {
		delete(resource_handler_handlers.skip_handler, cp)
	}

	if h, ok := a.(CResourceHandlerTReadHandler); ok {
		resource_handler_handlers.read_handler[cp] = h
		noBind = false
	} else {
		delete(resource_handler_handlers.read_handler, cp)
	}

	if h, ok := a.(CancelHandler); ok {
		resource_handler_handlers.cancel_handler[cp] = h
		noBind = false
	} else {
		delete(resource_handler_handlers.cancel_handler, cp)
	}

	if noBind {
		Panicln("F229: *CResourceHandlerT No bind")
	}
	return resource_handler
}

func unbindAllCResourceHandlerT(cp *cCResourceHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := resource_handler.pc_resource_handler
	delete(resource_handler_handlers.handler, cp)

	delete(resource_handler_handlers.open_handler, cp)
	delete(resource_handler_handlers.process_request_handler, cp)
	delete(resource_handler_handlers.get_response_headers_handler, cp)
	delete(resource_handler_handlers.skip_handler, cp)
	delete(resource_handler_handlers.read_handler, cp)
	delete(resource_handler_handlers.cancel_handler, cp)
}

func (resource_handler *CResourceHandlerT) UnbindAll() {
	unbindAllCResourceHandlerT(resource_handler.pc_resource_handler)
	resource_handler.Unref()
}

func (resource_handler *CResourceHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := resource_handler.pc_resource_handler
	return resource_handler_handlers.handler[cp]
}

// cef_resource_request_handler_capi.h, include/capi/cef_resource_request_handler_capi.h:208:3,

///
// Implement this structure to handle events related to browser requests. The
// functions of this structure will be called on the IO thread unless otherwise
// indicated.
///

type cCResourceRequestHandlerT C.cef_resource_request_handler_t

// Go type for cef_resource_request_handler_t
type CResourceRequestHandlerT struct {
	noCopy                      noCopy
	pc_resource_request_handler *cCResourceRequestHandlerT
	beUnrefed                   unrefedBy
}

func (p *CResourceRequestHandlerT) Pass() (ret *CResourceRequestHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResourceRequestHandlerT((*C.cef_resource_request_handler_t)(p.pc_resource_request_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResourceRequestHandlerT) NewRef() (newP *CResourceRequestHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_resource_request_handler
	BaseAddRef(gop)
	newP = newCResourceRequestHandlerT((*C.cef_resource_request_handler_t)(gop), byApp)
	return newP
}

// Go type CResourceRequestHandlerT wraps cef type *C.cef_resource_request_handler_t
func newCResourceRequestHandlerT(p *C.cef_resource_request_handler_t, unrefedBy unrefedBy) *CResourceRequestHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T192.1:")
	pc := (*cCResourceRequestHandlerT)(p)
	go_resource_request_handler := &CResourceRequestHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_resource_request_handler, func(g *CResourceRequestHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_resource_request_handler != nil {
			Tracef(unsafe.Pointer(g.pc_resource_request_handler), "T192.2:")
			BaseRelease(g.pc_resource_request_handler)
		}
	})

	return go_resource_request_handler
}

// *C.cef_resource_request_handler_t has refCounted interface
func (resource_request_handler *CResourceRequestHandlerT) HasOneRef() bool {
	return BaseHasOneRef(resource_request_handler.pc_resource_request_handler)
}

func (p *cCResourceRequestHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (resource_request_handler *CResourceRequestHandlerT) Unref() (ret bool) {
	if resource_request_handler == nil {
		return
	}
	if resource_request_handler.beUnrefed == byApp {
		ret = BaseRelease(resource_request_handler.pc_resource_request_handler)
		resource_request_handler.beUnrefed = unrefed
	}
	resource_request_handler.pc_resource_request_handler = nil
	return ret
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To
// optionally filter cookies for the request return a
// cef_cookie_access_filter_t object. The |request| object cannot not be
// modified in this callback.
///
type GetCookieAccessFilterHandler interface {
	GetCookieAccessFilter(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
	) (ret *CCookieAccessFilterT)
}

///
// Called on the IO thread before a resource request is loaded. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To redirect
// or change the resource load optionally modify |request|. Modification of
// the request URL will be treated as a redirect. Return RV_CONTINUE to
// continue the request immediately. Return RV_CONTINUE_ASYNC and call
// cef_callback_t functions at a later time to continue or cancel the request
// asynchronously. Return RV_CANCEL to cancel the request immediately.
//
///
type OnBeforeResourceLoadHandler interface {
	OnBeforeResourceLoad(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		callback *CCallbackT,
	) (ret CReturnValueT)
}

///
// Called on the IO thread before a resource is loaded. The |browser| and
// |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource to load using the default network loader return NULL. To specify a
// handler for the resource return a cef_resource_handler_t object. The
// |request| object cannot not be modified in this callback.
///
type GetResourceHandlerHandler interface {
	GetResourceHandler(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
	) (ret *CResourceHandlerT)
}

///
// Called on the IO thread when a resource load is redirected. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. The
// |request| parameter will contain the old URL and other request-related
// information. The |response| parameter will contain the response that
// resulted in the redirect. The |new_url| parameter will contain the new URL
// and can be changed if desired. The |request| and |response| objects cannot
// be modified in this callback.
///
type OnResourceRedirectHandler interface {
	OnResourceRedirect(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
	) (new_url string)
}

///
// Called on the IO thread when a resource response is received. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. To allow the
// resource load to proceed without modification return false (0). To redirect
// or retry the resource load optionally modify |request| and return true (1).
// Modification of the request URL will be treated as a redirect. Requests
// handled using the default network loader cannot be redirected in this
// callback. The |response| object cannot be modified in this callback.
//
// WARNING: Redirecting using this function is deprecated. Use
// OnBeforeResourceLoad or GetResourceHandler to perform redirects.
///
type OnResourceResponseHandler interface {
	OnResourceResponse(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
	) (ret bool)
}

///
// Called on the IO thread to optionally filter resource response content. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| and |response| represent the request and response respectively
// and cannot be modified in this callback.
///
type GetResourceResponseFilterHandler interface {
	GetResourceResponseFilter(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
	) (ret *CResponseFilterT)
}

///
// Called on the IO thread when a resource load has completed. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// and |response| represent the request and response respectively and cannot
// be modified in this callback. |status| indicates the load completion
// status. |received_content_length| is the number of response bytes actually
// read. This function will be called for all requests, including requests
// that are aborted due to CEF shutdown or destruction of the associated
// browser. In cases where the associated browser is destroyed this callback
// may arrive after the cef_life_span_handler_t::OnBeforeClose callback for
// that browser. The cef_frame_t::IsValid function can be used to test for
// this situation, and care should be taken not to call |browser| or |frame|
// functions that modify state (like LoadURL, SendProcessMessage, etc.) if the
// frame is invalid.
///
type OnResourceLoadCompleteHandler interface {
	OnResourceLoadComplete(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
		status CUrlrequestStatusT,
		received_content_length int64,
	)
}

///
// Called on the IO thread to handle requests for URLs with an unknown
// protocol component. The |browser| and |frame| values represent the source
// of the request, and may be NULL for requests originating from service
// workers or cef_urlrequest_t. |request| cannot be modified in this callback.
// Set |allow_os_execution| to true (1) to attempt execution via the
// registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD USE
// THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL
// ANALYSIS BEFORE ALLOWING OS EXECUTION.
///
type OnProtocolExecutionHandler interface {
	OnProtocolExecution(
		self *CResourceRequestHandlerT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
	) (allow_os_execution int)
}

var resource_request_handler_handlers = struct {
	handler                              map[*cCResourceRequestHandlerT]interface{}
	get_cookie_access_filter_handler     map[*cCResourceRequestHandlerT]GetCookieAccessFilterHandler
	on_before_resource_load_handler      map[*cCResourceRequestHandlerT]OnBeforeResourceLoadHandler
	get_resource_handler_handler         map[*cCResourceRequestHandlerT]GetResourceHandlerHandler
	on_resource_redirect_handler         map[*cCResourceRequestHandlerT]OnResourceRedirectHandler
	on_resource_response_handler         map[*cCResourceRequestHandlerT]OnResourceResponseHandler
	get_resource_response_filter_handler map[*cCResourceRequestHandlerT]GetResourceResponseFilterHandler
	on_resource_load_complete_handler    map[*cCResourceRequestHandlerT]OnResourceLoadCompleteHandler
	on_protocol_execution_handler        map[*cCResourceRequestHandlerT]OnProtocolExecutionHandler
}{
	map[*cCResourceRequestHandlerT]interface{}{},
	map[*cCResourceRequestHandlerT]GetCookieAccessFilterHandler{},
	map[*cCResourceRequestHandlerT]OnBeforeResourceLoadHandler{},
	map[*cCResourceRequestHandlerT]GetResourceHandlerHandler{},
	map[*cCResourceRequestHandlerT]OnResourceRedirectHandler{},
	map[*cCResourceRequestHandlerT]OnResourceResponseHandler{},
	map[*cCResourceRequestHandlerT]GetResourceResponseFilterHandler{},
	map[*cCResourceRequestHandlerT]OnResourceLoadCompleteHandler{},
	map[*cCResourceRequestHandlerT]OnProtocolExecutionHandler{},
}

// allocCResourceRequestHandlerT allocates CResourceRequestHandlerT and construct it
func allocCResourceRequestHandlerT() *CResourceRequestHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_resource_request_handler_wrapper_t, "T192.3:")
	cefp := C.cefingo_construct_resource_request_handler((*C.cefingo_resource_request_handler_wrapper_t)(up))
	cgop := (*cCResourceRequestHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_resource_request_handler_t itself in DeassocFunc,
		// or cef_resource_request_handler_t is never GCed.
		Tracef(up, "T192.4:")
		unbindAllCResourceRequestHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCResourceRequestHandlerT(cefp, byApp)
}

// NewCResourceRequestHandlerT allocates CResourceRequestHandlerT, construct and bind it
func NewCResourceRequestHandlerT(a interface{}) *CResourceRequestHandlerT {
	return allocCResourceRequestHandlerT().bind(a)
}

func (resource_request_handler *CResourceRequestHandlerT) bind(a interface{}) *CResourceRequestHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := resource_request_handler.pc_resource_request_handler
	resource_request_handler_handlers.handler[cp] = a

	if h, ok := a.(GetCookieAccessFilterHandler); ok {
		resource_request_handler_handlers.get_cookie_access_filter_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.get_cookie_access_filter_handler, cp)
	}

	if h, ok := a.(OnBeforeResourceLoadHandler); ok {
		resource_request_handler_handlers.on_before_resource_load_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.on_before_resource_load_handler, cp)
	}

	if h, ok := a.(GetResourceHandlerHandler); ok {
		resource_request_handler_handlers.get_resource_handler_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.get_resource_handler_handler, cp)
	}

	if h, ok := a.(OnResourceRedirectHandler); ok {
		resource_request_handler_handlers.on_resource_redirect_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.on_resource_redirect_handler, cp)
	}

	if h, ok := a.(OnResourceResponseHandler); ok {
		resource_request_handler_handlers.on_resource_response_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.on_resource_response_handler, cp)
	}

	if h, ok := a.(GetResourceResponseFilterHandler); ok {
		resource_request_handler_handlers.get_resource_response_filter_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.get_resource_response_filter_handler, cp)
	}

	if h, ok := a.(OnResourceLoadCompleteHandler); ok {
		resource_request_handler_handlers.on_resource_load_complete_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.on_resource_load_complete_handler, cp)
	}

	if h, ok := a.(OnProtocolExecutionHandler); ok {
		resource_request_handler_handlers.on_protocol_execution_handler[cp] = h
		noBind = false
	} else {
		delete(resource_request_handler_handlers.on_protocol_execution_handler, cp)
	}

	if noBind {
		Panicln("F229: *CResourceRequestHandlerT No bind")
	}
	return resource_request_handler
}

func unbindAllCResourceRequestHandlerT(cp *cCResourceRequestHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := resource_request_handler.pc_resource_request_handler
	delete(resource_request_handler_handlers.handler, cp)

	delete(resource_request_handler_handlers.get_cookie_access_filter_handler, cp)
	delete(resource_request_handler_handlers.on_before_resource_load_handler, cp)
	delete(resource_request_handler_handlers.get_resource_handler_handler, cp)
	delete(resource_request_handler_handlers.on_resource_redirect_handler, cp)
	delete(resource_request_handler_handlers.on_resource_response_handler, cp)
	delete(resource_request_handler_handlers.get_resource_response_filter_handler, cp)
	delete(resource_request_handler_handlers.on_resource_load_complete_handler, cp)
	delete(resource_request_handler_handlers.on_protocol_execution_handler, cp)
}

func (resource_request_handler *CResourceRequestHandlerT) UnbindAll() {
	unbindAllCResourceRequestHandlerT(resource_request_handler.pc_resource_request_handler)
	resource_request_handler.Unref()
}

func (resource_request_handler *CResourceRequestHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := resource_request_handler.pc_resource_request_handler
	return resource_request_handler_handlers.handler[cp]
}

///
// Implement this structure to filter cookies that may be sent or received from
// resource requests. The functions of this structure will be called on the IO
// thread unless otherwise indicated.
///

type cCCookieAccessFilterT C.cef_cookie_access_filter_t

// Go type for cef_cookie_access_filter_t
type CCookieAccessFilterT struct {
	noCopy                  noCopy
	pc_cookie_access_filter *cCCookieAccessFilterT
	beUnrefed               unrefedBy
}

func (p *CCookieAccessFilterT) Pass() (ret *CCookieAccessFilterT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCCookieAccessFilterT((*C.cef_cookie_access_filter_t)(p.pc_cookie_access_filter), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CCookieAccessFilterT) NewRef() (newP *CCookieAccessFilterT) {
	if self == nil {
		return newP
	}
	gop := self.pc_cookie_access_filter
	BaseAddRef(gop)
	newP = newCCookieAccessFilterT((*C.cef_cookie_access_filter_t)(gop), byApp)
	return newP
}

// Go type CCookieAccessFilterT wraps cef type *C.cef_cookie_access_filter_t
func newCCookieAccessFilterT(p *C.cef_cookie_access_filter_t, unrefedBy unrefedBy) *CCookieAccessFilterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T193.1:")
	pc := (*cCCookieAccessFilterT)(p)
	go_cookie_access_filter := &CCookieAccessFilterT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_cookie_access_filter, func(g *CCookieAccessFilterT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_cookie_access_filter != nil {
			Tracef(unsafe.Pointer(g.pc_cookie_access_filter), "T193.2:")
			BaseRelease(g.pc_cookie_access_filter)
		}
	})

	return go_cookie_access_filter
}

// *C.cef_cookie_access_filter_t has refCounted interface
func (cookie_access_filter *CCookieAccessFilterT) HasOneRef() bool {
	return BaseHasOneRef(cookie_access_filter.pc_cookie_access_filter)
}

func (p *cCCookieAccessFilterT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (cookie_access_filter *CCookieAccessFilterT) Unref() (ret bool) {
	if cookie_access_filter == nil {
		return
	}
	if cookie_access_filter.beUnrefed == byApp {
		ret = BaseRelease(cookie_access_filter.pc_cookie_access_filter)
		cookie_access_filter.beUnrefed = unrefed
	}
	cookie_access_filter.pc_cookie_access_filter = nil
	return ret
}

///
// Called on the IO thread before a resource request is sent. The |browser|
// and |frame| values represent the source of the request, and may be NULL for
// requests originating from service workers or cef_urlrequest_t. |request|
// cannot be modified in this callback. Return true (1) if the specified
// cookie can be sent with the request or false (0) otherwise.
///
type CanSendCookieHandler interface {
	CanSendCookie(
		self *CCookieAccessFilterT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		cookie *CCookieT,
	) (ret bool)
}

///
// Called on the IO thread after a resource response is received. The
// |browser| and |frame| values represent the source of the request, and may
// be NULL for requests originating from service workers or cef_urlrequest_t.
// |request| cannot be modified in this callback. Return true (1) if the
// specified cookie returned with the response can be saved or false (0)
// otherwise.
///
type CanSaveCookieHandler interface {
	CanSaveCookie(
		self *CCookieAccessFilterT,
		browser *CBrowserT,
		frame *CFrameT,
		request *CRequestT,
		response *CResponseT,
		cookie *CCookieT,
	) (ret bool)
}

var cookie_access_filter_handlers = struct {
	handler                 map[*cCCookieAccessFilterT]interface{}
	can_send_cookie_handler map[*cCCookieAccessFilterT]CanSendCookieHandler
	can_save_cookie_handler map[*cCCookieAccessFilterT]CanSaveCookieHandler
}{
	map[*cCCookieAccessFilterT]interface{}{},
	map[*cCCookieAccessFilterT]CanSendCookieHandler{},
	map[*cCCookieAccessFilterT]CanSaveCookieHandler{},
}

// allocCCookieAccessFilterT allocates CCookieAccessFilterT and construct it
func allocCCookieAccessFilterT() *CCookieAccessFilterT {
	up := c_calloc(1, C.sizeof_cefingo_cookie_access_filter_wrapper_t, "T193.3:")
	cefp := C.cefingo_construct_cookie_access_filter((*C.cefingo_cookie_access_filter_wrapper_t)(up))
	cgop := (*cCCookieAccessFilterT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_cookie_access_filter_t itself in DeassocFunc,
		// or cef_cookie_access_filter_t is never GCed.
		Tracef(up, "T193.4:")
		unbindAllCCookieAccessFilterT(cgop)
	}))

	BaseAddRef(cgop)
	return newCCookieAccessFilterT(cefp, byApp)
}

// NewCCookieAccessFilterT allocates CCookieAccessFilterT, construct and bind it
func NewCCookieAccessFilterT(a interface{}) *CCookieAccessFilterT {
	return allocCCookieAccessFilterT().bind(a)
}

func (cookie_access_filter *CCookieAccessFilterT) bind(a interface{}) *CCookieAccessFilterT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := cookie_access_filter.pc_cookie_access_filter
	cookie_access_filter_handlers.handler[cp] = a

	if h, ok := a.(CanSendCookieHandler); ok {
		cookie_access_filter_handlers.can_send_cookie_handler[cp] = h
		noBind = false
	} else {
		delete(cookie_access_filter_handlers.can_send_cookie_handler, cp)
	}

	if h, ok := a.(CanSaveCookieHandler); ok {
		cookie_access_filter_handlers.can_save_cookie_handler[cp] = h
		noBind = false
	} else {
		delete(cookie_access_filter_handlers.can_save_cookie_handler, cp)
	}

	if noBind {
		Panicln("F229: *CCookieAccessFilterT No bind")
	}
	return cookie_access_filter
}

func unbindAllCCookieAccessFilterT(cp *cCCookieAccessFilterT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := cookie_access_filter.pc_cookie_access_filter
	delete(cookie_access_filter_handlers.handler, cp)

	delete(cookie_access_filter_handlers.can_send_cookie_handler, cp)
	delete(cookie_access_filter_handlers.can_save_cookie_handler, cp)
}

func (cookie_access_filter *CCookieAccessFilterT) UnbindAll() {
	unbindAllCCookieAccessFilterT(cookie_access_filter.pc_cookie_access_filter)
	cookie_access_filter.Unref()
}

func (cookie_access_filter *CCookieAccessFilterT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := cookie_access_filter.pc_cookie_access_filter
	return cookie_access_filter_handlers.handler[cp]
}

// cef_response_capi.h, include/capi/cef_response_capi.h:166:3,

///
// Structure used to represent a web response. The functions of this structure
// may be called on any thread.
///

type cCResponseT C.cef_response_t

// Go type for cef_response_t
type CResponseT struct {
	noCopy      noCopy
	pc_response *cCResponseT
	beUnrefed   unrefedBy
}

func (p *CResponseT) Pass() (ret *CResponseT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResponseT((*C.cef_response_t)(p.pc_response), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResponseT) NewRef() (newP *CResponseT) {
	if self == nil {
		return newP
	}
	gop := self.pc_response
	BaseAddRef(gop)
	newP = newCResponseT((*C.cef_response_t)(gop), byApp)
	return newP
}

// Go type CResponseT wraps cef type *C.cef_response_t
func newCResponseT(p *C.cef_response_t, unrefedBy unrefedBy) *CResponseT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T194.1:")
	pc := (*cCResponseT)(p)
	go_response := &CResponseT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_response, func(g *CResponseT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_response != nil {
			Tracef(unsafe.Pointer(g.pc_response), "T194.2:")
			BaseRelease(g.pc_response)
		}
	})

	return go_response
}

// *C.cef_response_t has refCounted interface
func (response *CResponseT) HasOneRef() bool {
	return BaseHasOneRef(response.pc_response)
}

func (p *cCResponseT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (response *CResponseT) Unref() (ret bool) {
	if response == nil {
		return
	}
	if response.beUnrefed == byApp {
		ret = BaseRelease(response.pc_response)
		response.beUnrefed = unrefed
	}
	response.pc_response = nil
	return ret
}

///
// Returns true (1) if this object is read-only.
///
func (self *CResponseT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_response_is_read_only((*C.cef_response_t)(self.pc_response))

	ret = cRet == 1
	return ret
}

///
// Get the response error code. Returns ERR_NONE if there was no error.
///
func (self *CResponseT) GetError() (ret CErrorcodeT) {

	cRet := C.cefingo_response_get_error((*C.cef_response_t)(self.pc_response))

	ret = CErrorcodeT(cRet) // return GoObj
	return ret
}

///
// Set the response error code. This can be used by custom scheme handlers to
// return errors during initial request processing.
///
func (self *CResponseT) SetError(
	error CErrorcodeT,
) {

	C.cefingo_response_set_error((*C.cef_response_t)(self.pc_response), (C.cef_errorcode_t)(error))

}

///
// Get the response status code.
///
func (self *CResponseT) GetStatus() (ret bool) {

	cRet := C.cefingo_response_get_status((*C.cef_response_t)(self.pc_response))

	ret = cRet == 1
	return ret
}

///
// Set the response status code.
///
func (self *CResponseT) SetStatus(
	status int,
) {

	C.cefingo_response_set_status((*C.cef_response_t)(self.pc_response), (C.int)(status))

}

///
// Get the response status text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetStatusText() (ret string) {

	cRet := C.cefingo_response_get_status_text((*C.cef_response_t)(self.pc_response))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the response status text.
///
func (self *CResponseT) SetStatusText(
	statusText string,
) {
	c_statusText := create_cef_string(statusText)

	C.cefingo_response_set_status_text((*C.cef_response_t)(self.pc_response), c_statusText.p_cef_string_t)

}

///
// Get the response mime type.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetMimeType() (ret string) {

	cRet := C.cefingo_response_get_mime_type((*C.cef_response_t)(self.pc_response))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the response mime type.
///
func (self *CResponseT) SetMimeType(
	mimeType string,
) {
	c_mimeType := create_cef_string(mimeType)

	C.cefingo_response_set_mime_type((*C.cef_response_t)(self.pc_response), c_mimeType.p_cef_string_t)

}

///
// Get the response charset.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetCharset() (ret string) {

	cRet := C.cefingo_response_get_charset((*C.cef_response_t)(self.pc_response))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the response charset.
///
func (self *CResponseT) SetCharset(
	charset string,
) {
	c_charset := create_cef_string(charset)

	C.cefingo_response_set_charset((*C.cef_response_t)(self.pc_response), c_charset.p_cef_string_t)

}

///
// Get the value for the specified response header field.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetHeaderByName(
	name string,
) (ret string) {
	c_name := create_cef_string(name)

	cRet := C.cefingo_response_get_header_by_name((*C.cef_response_t)(self.pc_response), c_name.p_cef_string_t)

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the header |name| to |value|. If |overwrite| is true (1) any existing
// values will be replaced with the new value. If |overwrite| is false (0) any
// existing values will not be overwritten.
///
func (self *CResponseT) SetHeaderByName(
	name string,
	value string,
	overwrite int,
) {
	c_name := create_cef_string(name)
	c_value := create_cef_string(value)

	C.cefingo_response_set_header_by_name((*C.cef_response_t)(self.pc_response), c_name.p_cef_string_t, c_value.p_cef_string_t, (C.int)(overwrite))

}

///
// Get all response header fields.
///
func (self *CResponseT) GetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_response_get_header_map((*C.cef_response_t)(self.pc_response), (C.cef_string_multimap_t)(headerMap))

}

///
// Set all response header fields.
///
func (self *CResponseT) SetHeaderMap(
	headerMap CStringMultimapT,
) {

	C.cefingo_response_set_header_map((*C.cef_response_t)(self.pc_response), (C.cef_string_multimap_t)(headerMap))

}

///
// Get the resolved URL after redirects or changed as a result of HSTS.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CResponseT) GetUrl() (ret string) {

	cRet := C.cefingo_response_get_url((*C.cef_response_t)(self.pc_response))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the resolved URL after redirects or changed as a result of HSTS.
///
func (self *CResponseT) SetUrl(
	url string,
) {
	c_url := create_cef_string(url)

	C.cefingo_response_set_url((*C.cef_response_t)(self.pc_response), c_url.p_cef_string_t)

}

///
// Create a new cef_response_t object.
///
func ResponseCreate() (ret *CResponseT) {

	cRet := C.cef_response_create()

	ret = newCResponseT(cRet, byApp) // return GoObj
	return ret
}

// cef_response_filter_capi.h, include/capi/cef_response_filter_capi.h:104:3,

///
// Implement this structure to filter resource response content. The functions
// of this structure will be called on the browser process IO thread.
///

type cCResponseFilterT C.cef_response_filter_t

// Go type for cef_response_filter_t
type CResponseFilterT struct {
	noCopy             noCopy
	pc_response_filter *cCResponseFilterT
	beUnrefed          unrefedBy
}

func (p *CResponseFilterT) Pass() (ret *CResponseFilterT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCResponseFilterT((*C.cef_response_filter_t)(p.pc_response_filter), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CResponseFilterT) NewRef() (newP *CResponseFilterT) {
	if self == nil {
		return newP
	}
	gop := self.pc_response_filter
	BaseAddRef(gop)
	newP = newCResponseFilterT((*C.cef_response_filter_t)(gop), byApp)
	return newP
}

// Go type CResponseFilterT wraps cef type *C.cef_response_filter_t
func newCResponseFilterT(p *C.cef_response_filter_t, unrefedBy unrefedBy) *CResponseFilterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T195.1:")
	pc := (*cCResponseFilterT)(p)
	go_response_filter := &CResponseFilterT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_response_filter, func(g *CResponseFilterT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_response_filter != nil {
			Tracef(unsafe.Pointer(g.pc_response_filter), "T195.2:")
			BaseRelease(g.pc_response_filter)
		}
	})

	return go_response_filter
}

// *C.cef_response_filter_t has refCounted interface
func (response_filter *CResponseFilterT) HasOneRef() bool {
	return BaseHasOneRef(response_filter.pc_response_filter)
}

func (p *cCResponseFilterT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (response_filter *CResponseFilterT) Unref() (ret bool) {
	if response_filter == nil {
		return
	}
	if response_filter.beUnrefed == byApp {
		ret = BaseRelease(response_filter.pc_response_filter)
		response_filter.beUnrefed = unrefed
	}
	response_filter.pc_response_filter = nil
	return ret
}

///
// Initialize the response filter. Will only be called a single time. The
// filter will not be installed if this function returns false (0).
///
type InitFilterHandler interface {
	InitFilter(
		self *CResponseFilterT,
	) (ret bool)
}

///
// Called to filter a chunk of data. Expected usage is as follows:
//
//  A. Read input data from |data_in| and set |data_in_read| to the number of
//     bytes that were read up to a maximum of |data_in_size|. |data_in| will
//     be NULL if |data_in_size| is zero.
//  B. Write filtered output data to |data_out| and set |data_out_written| to
//     the number of bytes that were written up to a maximum of
//     |data_out_size|. If no output data was written then all data must be
//     read from |data_in| (user must set |data_in_read| = |data_in_size|).
//  C. Return RESPONSE_FILTER_DONE if all output data was written or
//     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.
//
// This function will be called repeatedly until the input buffer has been
// fully read (user sets |data_in_read| = |data_in_size|) and there is no more
// input data to filter (the resource response is complete). This function may
// then be called an additional time with an NULL input buffer if the user
// filled the output buffer (set |data_out_written| = |data_out_size|) and
// returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is
// still pending.
//
// Calls to this function will stop when one of the following conditions is
// met:
//
//  A. There is no more input data to filter (the resource response is
//     complete) and the user sets |data_out_written| = 0 or returns
//     RESPONSE_FILTER_DONE to indicate that all data has been written, or;
//  B. The user returns RESPONSE_FILTER_ERROR to indicate an error.
//
// Do not keep a reference to the buffers passed to this function.
///
type FilterHandler interface {
	Filter(
		self *CResponseFilterT,
		data_in []byte,
		data_out []byte,
	) (ret CResponseFilterStatusT, data_in_read int64, data_out_written int64)
}

var response_filter_handlers = struct {
	handler             map[*cCResponseFilterT]interface{}
	init_filter_handler map[*cCResponseFilterT]InitFilterHandler
	filter_handler      map[*cCResponseFilterT]FilterHandler
}{
	map[*cCResponseFilterT]interface{}{},
	map[*cCResponseFilterT]InitFilterHandler{},
	map[*cCResponseFilterT]FilterHandler{},
}

// allocCResponseFilterT allocates CResponseFilterT and construct it
func allocCResponseFilterT() *CResponseFilterT {
	up := c_calloc(1, C.sizeof_cefingo_response_filter_wrapper_t, "T195.3:")
	cefp := C.cefingo_construct_response_filter((*C.cefingo_response_filter_wrapper_t)(up))
	cgop := (*cCResponseFilterT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_response_filter_t itself in DeassocFunc,
		// or cef_response_filter_t is never GCed.
		Tracef(up, "T195.4:")
		unbindAllCResponseFilterT(cgop)
	}))

	BaseAddRef(cgop)
	return newCResponseFilterT(cefp, byApp)
}

// NewCResponseFilterT allocates CResponseFilterT, construct and bind it
func NewCResponseFilterT(a interface{}) *CResponseFilterT {
	return allocCResponseFilterT().bind(a)
}

func (response_filter *CResponseFilterT) bind(a interface{}) *CResponseFilterT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := response_filter.pc_response_filter
	response_filter_handlers.handler[cp] = a

	if h, ok := a.(InitFilterHandler); ok {
		response_filter_handlers.init_filter_handler[cp] = h
		noBind = false
	} else {
		delete(response_filter_handlers.init_filter_handler, cp)
	}

	if h, ok := a.(FilterHandler); ok {
		response_filter_handlers.filter_handler[cp] = h
		noBind = false
	} else {
		delete(response_filter_handlers.filter_handler, cp)
	}

	if noBind {
		Panicln("F229: *CResponseFilterT No bind")
	}
	return response_filter
}

func unbindAllCResponseFilterT(cp *cCResponseFilterT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := response_filter.pc_response_filter
	delete(response_filter_handlers.handler, cp)

	delete(response_filter_handlers.init_filter_handler, cp)
	delete(response_filter_handlers.filter_handler, cp)
}

func (response_filter *CResponseFilterT) UnbindAll() {
	unbindAllCResponseFilterT(response_filter.pc_response_filter)
	response_filter.Unref()
}

func (response_filter *CResponseFilterT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := response_filter.pc_response_filter
	return response_filter_handlers.handler[cp]
}

// cef_scheme_capi.h, include/capi/cef_scheme_capi.h:78:3,

///
// Structure that manages custom scheme registrations.
///

type cCSchemeRegistrarT C.cef_scheme_registrar_t

// Go type for cef_scheme_registrar_t
type CSchemeRegistrarT struct {
	noCopy              noCopy
	pc_scheme_registrar *cCSchemeRegistrarT
}

func (p *CSchemeRegistrarT) Pass() (ret *CSchemeRegistrarT) {
	ret = p

	return ret
}

func (self *CSchemeRegistrarT) NewRef() (newP *CSchemeRegistrarT) {
	if self == nil {
		return newP
	}
	newP = self
	return newP
}

// Go type CSchemeRegistrarT wraps cef type *C.cef_scheme_registrar_t
func newCSchemeRegistrarT(p *C.cef_scheme_registrar_t) *CSchemeRegistrarT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T196.1:")
	pc := (*cCSchemeRegistrarT)(p)
	go_scheme_registrar := &CSchemeRegistrarT{noCopy{}, pc}
	return go_scheme_registrar
}

///
// Register a custom scheme. This function should not be called for the built-
// in HTTP, HTTPS, FILE, FTP, ABOUT and DATA schemes.
//
// See cef_scheme_options_t for possible values for |options|.
//
// This function may be called on any thread. It should only be called once
// per unique |scheme_name| value. If |scheme_name| is already registered or
// if an error occurs this function will return false (0).
///
func (self *CSchemeRegistrarT) AddCustomScheme(
	scheme_name string,
	options int,
) (ret bool) {
	c_scheme_name := create_cef_string(scheme_name)

	cRet := C.cefingo_scheme_registrar_add_custom_scheme((*C.cef_scheme_registrar_t)(self.pc_scheme_registrar), c_scheme_name.p_cef_string_t, (C.int)(options))

	ret = cRet == 1
	return ret
}

///
// Structure that creates cef_resource_handler_t instances for handling scheme
// requests. The functions of this structure will always be called on the IO
// thread.
///

type cCSchemeHandlerFactoryT C.cef_scheme_handler_factory_t

// Go type for cef_scheme_handler_factory_t
type CSchemeHandlerFactoryT struct {
	noCopy                    noCopy
	pc_scheme_handler_factory *cCSchemeHandlerFactoryT
	beUnrefed                 unrefedBy
}

func (p *CSchemeHandlerFactoryT) Pass() (ret *CSchemeHandlerFactoryT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCSchemeHandlerFactoryT((*C.cef_scheme_handler_factory_t)(p.pc_scheme_handler_factory), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CSchemeHandlerFactoryT) NewRef() (newP *CSchemeHandlerFactoryT) {
	if self == nil {
		return newP
	}
	gop := self.pc_scheme_handler_factory
	BaseAddRef(gop)
	newP = newCSchemeHandlerFactoryT((*C.cef_scheme_handler_factory_t)(gop), byApp)
	return newP
}

// Go type CSchemeHandlerFactoryT wraps cef type *C.cef_scheme_handler_factory_t
func newCSchemeHandlerFactoryT(p *C.cef_scheme_handler_factory_t, unrefedBy unrefedBy) *CSchemeHandlerFactoryT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T197.1:")
	pc := (*cCSchemeHandlerFactoryT)(p)
	go_scheme_handler_factory := &CSchemeHandlerFactoryT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_scheme_handler_factory, func(g *CSchemeHandlerFactoryT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_scheme_handler_factory != nil {
			Tracef(unsafe.Pointer(g.pc_scheme_handler_factory), "T197.2:")
			BaseRelease(g.pc_scheme_handler_factory)
		}
	})

	return go_scheme_handler_factory
}

// *C.cef_scheme_handler_factory_t has refCounted interface
func (scheme_handler_factory *CSchemeHandlerFactoryT) HasOneRef() bool {
	return BaseHasOneRef(scheme_handler_factory.pc_scheme_handler_factory)
}

func (p *cCSchemeHandlerFactoryT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (scheme_handler_factory *CSchemeHandlerFactoryT) Unref() (ret bool) {
	if scheme_handler_factory == nil {
		return
	}
	if scheme_handler_factory.beUnrefed == byApp {
		ret = BaseRelease(scheme_handler_factory.pc_scheme_handler_factory)
		scheme_handler_factory.beUnrefed = unrefed
	}
	scheme_handler_factory.pc_scheme_handler_factory = nil
	return ret
}

///
// Return a new resource handler instance to handle the request or an NULL
// reference to allow default handling of the request. |browser| and |frame|
// will be the browser window and frame respectively that originated the
// request or NULL if the request did not originate from a browser window (for
// example, if the request came from cef_urlrequest_t). The |request| object
// passed to this function cannot be modified.
///
type CreateHandler interface {
	Create(
		self *CSchemeHandlerFactoryT,
		browser *CBrowserT,
		frame *CFrameT,
		scheme_name string,
		request *CRequestT,
	) (ret *CResourceHandlerT)
}

var scheme_handler_factory_handlers = struct {
	handler        map[*cCSchemeHandlerFactoryT]interface{}
	create_handler map[*cCSchemeHandlerFactoryT]CreateHandler
}{
	map[*cCSchemeHandlerFactoryT]interface{}{},
	map[*cCSchemeHandlerFactoryT]CreateHandler{},
}

// allocCSchemeHandlerFactoryT allocates CSchemeHandlerFactoryT and construct it
func allocCSchemeHandlerFactoryT() *CSchemeHandlerFactoryT {
	up := c_calloc(1, C.sizeof_cefingo_scheme_handler_factory_wrapper_t, "T197.3:")
	cefp := C.cefingo_construct_scheme_handler_factory((*C.cefingo_scheme_handler_factory_wrapper_t)(up))
	cgop := (*cCSchemeHandlerFactoryT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_scheme_handler_factory_t itself in DeassocFunc,
		// or cef_scheme_handler_factory_t is never GCed.
		Tracef(up, "T197.4:")
		unbindAllCSchemeHandlerFactoryT(cgop)
	}))

	BaseAddRef(cgop)
	return newCSchemeHandlerFactoryT(cefp, byApp)
}

// NewCSchemeHandlerFactoryT allocates CSchemeHandlerFactoryT, construct and bind it
func NewCSchemeHandlerFactoryT(a interface{}) *CSchemeHandlerFactoryT {
	return allocCSchemeHandlerFactoryT().bind(a)
}

func (scheme_handler_factory *CSchemeHandlerFactoryT) bind(a interface{}) *CSchemeHandlerFactoryT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := scheme_handler_factory.pc_scheme_handler_factory
	scheme_handler_factory_handlers.handler[cp] = a

	if h, ok := a.(CreateHandler); ok {
		scheme_handler_factory_handlers.create_handler[cp] = h
		noBind = false
	} else {
		delete(scheme_handler_factory_handlers.create_handler, cp)
	}

	if noBind {
		Panicln("F229: *CSchemeHandlerFactoryT No bind")
	}
	return scheme_handler_factory
}

func unbindAllCSchemeHandlerFactoryT(cp *cCSchemeHandlerFactoryT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := scheme_handler_factory.pc_scheme_handler_factory
	delete(scheme_handler_factory_handlers.handler, cp)

	delete(scheme_handler_factory_handlers.create_handler, cp)
}

func (scheme_handler_factory *CSchemeHandlerFactoryT) UnbindAll() {
	unbindAllCSchemeHandlerFactoryT(scheme_handler_factory.pc_scheme_handler_factory)
	scheme_handler_factory.Unref()
}

func (scheme_handler_factory *CSchemeHandlerFactoryT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := scheme_handler_factory.pc_scheme_handler_factory
	return scheme_handler_factory_handlers.handler[cp]
}

///
// Register a scheme handler factory with the global request context. An NULL
// |domain_name| value for a standard scheme will cause the factory to match all
// domain names. The |domain_name| value will be ignored for non-standard
// schemes. If |scheme_name| is a built-in scheme and no handler is returned by
// |factory| then the built-in scheme handler factory will be called. If
// |scheme_name| is a custom scheme then you must also implement the
// cef_app_t::on_register_custom_schemes() function in all processes. This
// function may be called multiple times to change or remove the factory that
// matches the specified |scheme_name| and optional |domain_name|. Returns false
// (0) if an error occurs. This function may be called on any thread in the
// browser process. Using this function is equivalent to calling cef_request_con
// text_t::cef_request_context_get_global_context()->register_scheme_handler_fac
// tory().
///
func RegisterSchemeHandlerFactory(
	scheme_name string,
	domain_name string,
	factory *CSchemeHandlerFactoryT,
) (ret bool) {
	c_scheme_name := create_cef_string(scheme_name)
	c_domain_name := create_cef_string(domain_name)
	var goTmpfactory *C.cef_scheme_handler_factory_t
	if factory != nil {
		BaseAddRef(factory.pc_scheme_handler_factory)
		goTmpfactory = (*C.cef_scheme_handler_factory_t)(factory.pc_scheme_handler_factory)
	}

	cRet := C.cef_register_scheme_handler_factory(c_scheme_name.p_cef_string_t, c_domain_name.p_cef_string_t, goTmpfactory)

	ret = cRet == 1
	return ret
}

///
// Clear all scheme handler factories registered with the global request
// context. Returns false (0) on error. This function may be called on any
// thread in the browser process. Using this function is equivalent to calling c
// ef_request_context_t::cef_request_context_get_global_context()->clear_scheme_
// handler_factories().
///
func ClearSchemeHandlerFactories() (ret bool) {

	cRet := C.cef_clear_scheme_handler_factories()

	ret = cRet == 1
	return ret
}

// cef_scroll_view_capi.h, include/capi/views/cef_scroll_view_capi.h:100:3,

///
// A ScrollView will show horizontal and/or vertical scrollbars when necessary
// based on the size of the attached content view. Methods must be called on the
// browser process UI thread unless otherwise indicated.
///

type cCScrollViewT C.cef_scroll_view_t

// Go type for cef_scroll_view_t
type CScrollViewT struct {
	noCopy         noCopy
	pc_scroll_view *cCScrollViewT
	beUnrefed      unrefedBy
}

func (p *CScrollViewT) Pass() (ret *CScrollViewT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCScrollViewT((*C.cef_scroll_view_t)(p.pc_scroll_view), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CScrollViewT) NewRef() (newP *CScrollViewT) {
	if self == nil {
		return newP
	}
	gop := self.pc_scroll_view
	BaseAddRef(gop)
	newP = newCScrollViewT((*C.cef_scroll_view_t)(gop), byApp)
	return newP
}

// Go type CScrollViewT wraps cef type *C.cef_scroll_view_t
func newCScrollViewT(p *C.cef_scroll_view_t, unrefedBy unrefedBy) *CScrollViewT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T198.1:")
	pc := (*cCScrollViewT)(p)
	go_scroll_view := &CScrollViewT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_scroll_view, func(g *CScrollViewT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_scroll_view != nil {
			Tracef(unsafe.Pointer(g.pc_scroll_view), "T198.2:")
			BaseRelease(g.pc_scroll_view)
		}
	})

	return go_scroll_view
}

// *C.cef_scroll_view_t has refCounted interface
func (scroll_view *CScrollViewT) HasOneRef() bool {
	return BaseHasOneRef(scroll_view.pc_scroll_view)
}

func (p *cCScrollViewT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (scroll_view *CScrollViewT) Unref() (ret bool) {
	if scroll_view == nil {
		return
	}
	if scroll_view.beUnrefed == byApp {
		ret = BaseRelease(scroll_view.pc_scroll_view)
		scroll_view.beUnrefed = unrefed
	}
	scroll_view.pc_scroll_view = nil
	return ret
}

// Convert to Base Class Pointer *CViewT
func (scroll_view *CScrollViewT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(scroll_view.pc_scroll_view))
	BaseAddRef(scroll_view.pc_scroll_view)
	return newCViewT(p, byApp)
}

///
// Set the content View. The content View must have a specified size (e.g. via
// cef_view_t::SetBounds or cef_view_delegate_t::GetPreferredSize).
///
func (self *CScrollViewT) SetContentView(
	view *CViewT,
) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	C.cefingo_scroll_view_set_content_view((*C.cef_scroll_view_t)(self.pc_scroll_view), goTmpview)

}

///
// Returns the content View.
///
func (self *CScrollViewT) GetContentView() (ret *CViewT) {

	cRet := C.cefingo_scroll_view_get_content_view((*C.cef_scroll_view_t)(self.pc_scroll_view))

	ret = newCViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the visible region of the content View.
///
func (self *CScrollViewT) GetVisibleContentRect() (ret CRectT) {

	cRet := C.cefingo_scroll_view_get_visible_content_rect((*C.cef_scroll_view_t)(self.pc_scroll_view))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Returns true (1) if the horizontal scrollbar is currently showing.
///
func (self *CScrollViewT) HasHorizontalScrollbar() (ret bool) {

	cRet := C.cefingo_scroll_view_has_horizontal_scrollbar((*C.cef_scroll_view_t)(self.pc_scroll_view))

	ret = cRet == 1
	return ret
}

///
// Returns the height of the horizontal scrollbar.
///
func (self *CScrollViewT) GetHorizontalScrollbarHeight() (ret bool) {

	cRet := C.cefingo_scroll_view_get_horizontal_scrollbar_height((*C.cef_scroll_view_t)(self.pc_scroll_view))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the vertical scrollbar is currently showing.
///
func (self *CScrollViewT) HasVerticalScrollbar() (ret bool) {

	cRet := C.cefingo_scroll_view_has_vertical_scrollbar((*C.cef_scroll_view_t)(self.pc_scroll_view))

	ret = cRet == 1
	return ret
}

///
// Returns the width of the vertical scrollbar.
///
func (self *CScrollViewT) GetVerticalScrollbarWidth() (ret bool) {

	cRet := C.cefingo_scroll_view_get_vertical_scrollbar_width((*C.cef_scroll_view_t)(self.pc_scroll_view))

	ret = cRet == 1
	return ret
}

///
// Create a new ScrollView.
///
func ScrollViewCreate(
	delegate *CViewDelegateT,
) (ret *CScrollViewT) {
	var goTmpdelegate *C.cef_view_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_view_delegate)
		goTmpdelegate = (*C.cef_view_delegate_t)(delegate.pc_view_delegate)
	}

	cRet := C.cef_scroll_view_create(goTmpdelegate)

	ret = newCScrollViewT(cRet, byApp) // return GoObj
	return ret
}

// cef_ssl_info_capi.h, include/capi/cef_ssl_info_capi.h:71:3,

///
// Structure representing SSL information.
///

type cCSslinfoT C.cef_sslinfo_t

// Go type for cef_sslinfo_t
type CSslinfoT struct {
	noCopy     noCopy
	pc_sslinfo *cCSslinfoT
	beUnrefed  unrefedBy
}

func (p *CSslinfoT) Pass() (ret *CSslinfoT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCSslinfoT((*C.cef_sslinfo_t)(p.pc_sslinfo), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CSslinfoT) NewRef() (newP *CSslinfoT) {
	if self == nil {
		return newP
	}
	gop := self.pc_sslinfo
	BaseAddRef(gop)
	newP = newCSslinfoT((*C.cef_sslinfo_t)(gop), byApp)
	return newP
}

// Go type CSslinfoT wraps cef type *C.cef_sslinfo_t
func newCSslinfoT(p *C.cef_sslinfo_t, unrefedBy unrefedBy) *CSslinfoT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T199.1:")
	pc := (*cCSslinfoT)(p)
	go_sslinfo := &CSslinfoT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_sslinfo, func(g *CSslinfoT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_sslinfo != nil {
			Tracef(unsafe.Pointer(g.pc_sslinfo), "T199.2:")
			BaseRelease(g.pc_sslinfo)
		}
	})

	return go_sslinfo
}

// *C.cef_sslinfo_t has refCounted interface
func (sslinfo *CSslinfoT) HasOneRef() bool {
	return BaseHasOneRef(sslinfo.pc_sslinfo)
}

func (p *cCSslinfoT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (sslinfo *CSslinfoT) Unref() (ret bool) {
	if sslinfo == nil {
		return
	}
	if sslinfo.beUnrefed == byApp {
		ret = BaseRelease(sslinfo.pc_sslinfo)
		sslinfo.beUnrefed = unrefed
	}
	sslinfo.pc_sslinfo = nil
	return ret
}

///
// Returns a bitmask containing any and all problems verifying the server
// certificate.
///
func (self *CSslinfoT) GetCertStatus() (ret CCertStatusT) {

	cRet := C.cefingo_sslinfo_get_cert_status((*C.cef_sslinfo_t)(self.pc_sslinfo))

	ret = CCertStatusT(cRet) // return GoObj
	return ret
}

///
// Returns the X.509 certificate.
///
func (self *CSslinfoT) GetX509certificate() (ret *CX509certificateT) {

	cRet := C.cefingo_sslinfo_get_x509certificate((*C.cef_sslinfo_t)(self.pc_sslinfo))

	ret = newCX509certificateT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if the certificate status represents an error.
///
func IsCertStatusError(
	status CCertStatusT,
) (ret bool) {

	cRet := C.cef_is_cert_status_error((C.cef_cert_status_t)(status))

	ret = cRet == 1
	return ret
}

// cef_ssl_status_capi.h, include/capi/cef_ssl_status_capi.h:89:3,

///
// Structure representing the SSL information for a navigation entry.
///

type cCSslstatusT C.cef_sslstatus_t

// Go type for cef_sslstatus_t
type CSslstatusT struct {
	noCopy       noCopy
	pc_sslstatus *cCSslstatusT
	beUnrefed    unrefedBy
}

func (p *CSslstatusT) Pass() (ret *CSslstatusT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCSslstatusT((*C.cef_sslstatus_t)(p.pc_sslstatus), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CSslstatusT) NewRef() (newP *CSslstatusT) {
	if self == nil {
		return newP
	}
	gop := self.pc_sslstatus
	BaseAddRef(gop)
	newP = newCSslstatusT((*C.cef_sslstatus_t)(gop), byApp)
	return newP
}

// Go type CSslstatusT wraps cef type *C.cef_sslstatus_t
func newCSslstatusT(p *C.cef_sslstatus_t, unrefedBy unrefedBy) *CSslstatusT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T200.1:")
	pc := (*cCSslstatusT)(p)
	go_sslstatus := &CSslstatusT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_sslstatus, func(g *CSslstatusT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_sslstatus != nil {
			Tracef(unsafe.Pointer(g.pc_sslstatus), "T200.2:")
			BaseRelease(g.pc_sslstatus)
		}
	})

	return go_sslstatus
}

// *C.cef_sslstatus_t has refCounted interface
func (sslstatus *CSslstatusT) HasOneRef() bool {
	return BaseHasOneRef(sslstatus.pc_sslstatus)
}

func (p *cCSslstatusT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (sslstatus *CSslstatusT) Unref() (ret bool) {
	if sslstatus == nil {
		return
	}
	if sslstatus.beUnrefed == byApp {
		ret = BaseRelease(sslstatus.pc_sslstatus)
		sslstatus.beUnrefed = unrefed
	}
	sslstatus.pc_sslstatus = nil
	return ret
}

///
// Returns true (1) if the status is related to a secure SSL/TLS connection.
///
func (self *CSslstatusT) IsSecureConnection() (ret bool) {

	cRet := C.cefingo_sslstatus_is_secure_connection((*C.cef_sslstatus_t)(self.pc_sslstatus))

	ret = cRet == 1
	return ret
}

///
// Returns a bitmask containing any and all problems verifying the server
// certificate.
///
func (self *CSslstatusT) GetCertStatus() (ret CCertStatusT) {

	cRet := C.cefingo_sslstatus_get_cert_status((*C.cef_sslstatus_t)(self.pc_sslstatus))

	ret = CCertStatusT(cRet) // return GoObj
	return ret
}

///
// Returns the SSL version used for the SSL connection.
///
func (self *CSslstatusT) GetSslversion() (ret CSslVersionT) {

	cRet := C.cefingo_sslstatus_get_sslversion((*C.cef_sslstatus_t)(self.pc_sslstatus))

	ret = CSslVersionT(cRet) // return GoObj
	return ret
}

///
// Returns a bitmask containing the page security content status.
///
func (self *CSslstatusT) GetContentStatus() (ret CSslContentStatusT) {

	cRet := C.cefingo_sslstatus_get_content_status((*C.cef_sslstatus_t)(self.pc_sslstatus))

	ret = CSslContentStatusT(cRet) // return GoObj
	return ret
}

///
// Returns the X.509 certificate.
///
func (self *CSslstatusT) GetX509certificate() (ret *CX509certificateT) {

	cRet := C.cefingo_sslstatus_get_x509certificate((*C.cef_sslstatus_t)(self.pc_sslstatus))

	ret = newCX509certificateT(cRet, byApp) // return GoObj
	return ret
}

// cef_stream_capi.h, include/capi/cef_stream_capi.h:91:3,

///
// Structure the client can implement to provide a custom stream reader. The
// functions of this structure may be called on any thread.
///

type cCReadHandlerT C.cef_read_handler_t

// Go type for cef_read_handler_t
type CReadHandlerT struct {
	noCopy          noCopy
	pc_read_handler *cCReadHandlerT
	beUnrefed       unrefedBy
}

func (p *CReadHandlerT) Pass() (ret *CReadHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCReadHandlerT((*C.cef_read_handler_t)(p.pc_read_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CReadHandlerT) NewRef() (newP *CReadHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_read_handler
	BaseAddRef(gop)
	newP = newCReadHandlerT((*C.cef_read_handler_t)(gop), byApp)
	return newP
}

// Go type CReadHandlerT wraps cef type *C.cef_read_handler_t
func newCReadHandlerT(p *C.cef_read_handler_t, unrefedBy unrefedBy) *CReadHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T201.1:")
	pc := (*cCReadHandlerT)(p)
	go_read_handler := &CReadHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_read_handler, func(g *CReadHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_read_handler != nil {
			Tracef(unsafe.Pointer(g.pc_read_handler), "T201.2:")
			BaseRelease(g.pc_read_handler)
		}
	})

	return go_read_handler
}

// *C.cef_read_handler_t has refCounted interface
func (read_handler *CReadHandlerT) HasOneRef() bool {
	return BaseHasOneRef(read_handler.pc_read_handler)
}

func (p *cCReadHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (read_handler *CReadHandlerT) Unref() (ret bool) {
	if read_handler == nil {
		return
	}
	if read_handler.beUnrefed == byApp {
		ret = BaseRelease(read_handler.pc_read_handler)
		read_handler.beUnrefed = unrefed
	}
	read_handler.pc_read_handler = nil
	return ret
}

///
// Read raw binary data.
///
type CReadHandlerTReadHandler interface {
	Read(
		self *CReadHandlerT,
		ptr []byte,
		size int64,
		n int64,
	) (ret int64)
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
type CReadHandlerTSeekHandler interface {
	Seek(
		self *CReadHandlerT,
		offset int64,
		whence int,
	) (ret bool)
}

///
// Return the current offset position.
///
type CReadHandlerTTellHandler interface {
	Tell(
		self *CReadHandlerT,
	) (ret int64)
}

///
// Return non-zero if at end of file.
///
type EofHandler interface {
	Eof(
		self *CReadHandlerT,
	) (ret bool)
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
type CReadHandlerTMayBlockHandler interface {
	MayBlock(
		self *CReadHandlerT,
	) (ret bool)
}

var read_handler_handlers = struct {
	handler           map[*cCReadHandlerT]interface{}
	read_handler      map[*cCReadHandlerT]CReadHandlerTReadHandler
	seek_handler      map[*cCReadHandlerT]CReadHandlerTSeekHandler
	tell_handler      map[*cCReadHandlerT]CReadHandlerTTellHandler
	eof_handler       map[*cCReadHandlerT]EofHandler
	may_block_handler map[*cCReadHandlerT]CReadHandlerTMayBlockHandler
}{
	map[*cCReadHandlerT]interface{}{},
	map[*cCReadHandlerT]CReadHandlerTReadHandler{},
	map[*cCReadHandlerT]CReadHandlerTSeekHandler{},
	map[*cCReadHandlerT]CReadHandlerTTellHandler{},
	map[*cCReadHandlerT]EofHandler{},
	map[*cCReadHandlerT]CReadHandlerTMayBlockHandler{},
}

// allocCReadHandlerT allocates CReadHandlerT and construct it
func allocCReadHandlerT() *CReadHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_read_handler_wrapper_t, "T201.3:")
	cefp := C.cefingo_construct_read_handler((*C.cefingo_read_handler_wrapper_t)(up))
	cgop := (*cCReadHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_read_handler_t itself in DeassocFunc,
		// or cef_read_handler_t is never GCed.
		Tracef(up, "T201.4:")
		unbindAllCReadHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCReadHandlerT(cefp, byApp)
}

// NewCReadHandlerT allocates CReadHandlerT, construct and bind it
func NewCReadHandlerT(a interface{}) *CReadHandlerT {
	return allocCReadHandlerT().bind(a)
}

func (read_handler *CReadHandlerT) bind(a interface{}) *CReadHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := read_handler.pc_read_handler
	read_handler_handlers.handler[cp] = a

	if h, ok := a.(CReadHandlerTReadHandler); ok {
		read_handler_handlers.read_handler[cp] = h
		noBind = false
	} else {
		delete(read_handler_handlers.read_handler, cp)
	}

	if h, ok := a.(CReadHandlerTSeekHandler); ok {
		read_handler_handlers.seek_handler[cp] = h
		noBind = false
	} else {
		delete(read_handler_handlers.seek_handler, cp)
	}

	if h, ok := a.(CReadHandlerTTellHandler); ok {
		read_handler_handlers.tell_handler[cp] = h
		noBind = false
	} else {
		delete(read_handler_handlers.tell_handler, cp)
	}

	if h, ok := a.(EofHandler); ok {
		read_handler_handlers.eof_handler[cp] = h
		noBind = false
	} else {
		delete(read_handler_handlers.eof_handler, cp)
	}

	if h, ok := a.(CReadHandlerTMayBlockHandler); ok {
		read_handler_handlers.may_block_handler[cp] = h
		noBind = false
	} else {
		delete(read_handler_handlers.may_block_handler, cp)
	}

	if noBind {
		Panicln("F229: *CReadHandlerT No bind")
	}
	return read_handler
}

func unbindAllCReadHandlerT(cp *cCReadHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := read_handler.pc_read_handler
	delete(read_handler_handlers.handler, cp)

	delete(read_handler_handlers.read_handler, cp)
	delete(read_handler_handlers.seek_handler, cp)
	delete(read_handler_handlers.tell_handler, cp)
	delete(read_handler_handlers.eof_handler, cp)
	delete(read_handler_handlers.may_block_handler, cp)
}

func (read_handler *CReadHandlerT) UnbindAll() {
	unbindAllCReadHandlerT(read_handler.pc_read_handler)
	read_handler.Unref()
}

func (read_handler *CReadHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := read_handler.pc_read_handler
	return read_handler_handlers.handler[cp]
}

///
// Structure used to read data from a stream. The functions of this structure
// may be called on any thread.
///

type cCStreamReaderT C.cef_stream_reader_t

// Go type for cef_stream_reader_t
type CStreamReaderT struct {
	noCopy           noCopy
	pc_stream_reader *cCStreamReaderT
	beUnrefed        unrefedBy
}

func (p *CStreamReaderT) Pass() (ret *CStreamReaderT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCStreamReaderT((*C.cef_stream_reader_t)(p.pc_stream_reader), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CStreamReaderT) NewRef() (newP *CStreamReaderT) {
	if self == nil {
		return newP
	}
	gop := self.pc_stream_reader
	BaseAddRef(gop)
	newP = newCStreamReaderT((*C.cef_stream_reader_t)(gop), byApp)
	return newP
}

// Go type CStreamReaderT wraps cef type *C.cef_stream_reader_t
func newCStreamReaderT(p *C.cef_stream_reader_t, unrefedBy unrefedBy) *CStreamReaderT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T202.1:")
	pc := (*cCStreamReaderT)(p)
	go_stream_reader := &CStreamReaderT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_stream_reader, func(g *CStreamReaderT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_stream_reader != nil {
			Tracef(unsafe.Pointer(g.pc_stream_reader), "T202.2:")
			BaseRelease(g.pc_stream_reader)
		}
	})

	return go_stream_reader
}

// *C.cef_stream_reader_t has refCounted interface
func (stream_reader *CStreamReaderT) HasOneRef() bool {
	return BaseHasOneRef(stream_reader.pc_stream_reader)
}

func (p *cCStreamReaderT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (stream_reader *CStreamReaderT) Unref() (ret bool) {
	if stream_reader == nil {
		return
	}
	if stream_reader.beUnrefed == byApp {
		ret = BaseRelease(stream_reader.pc_stream_reader)
		stream_reader.beUnrefed = unrefed
	}
	stream_reader.pc_stream_reader = nil
	return ret
}

///
// Read raw binary data.
///
func (self *CStreamReaderT) Read(
	ptr unsafe.Pointer,
	size int64,
	n int64,
) (ret int64) {

	cRet := C.cefingo_stream_reader_read((*C.cef_stream_reader_t)(self.pc_stream_reader), ptr, (C.size_t)(size), (C.size_t)(n))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure.
///
func (self *CStreamReaderT) Seek(
	offset int64,
	whence int,
) (ret bool) {

	cRet := C.cefingo_stream_reader_seek((*C.cef_stream_reader_t)(self.pc_stream_reader), (C.int64)(offset), (C.int)(whence))

	ret = cRet == 1
	return ret
}

///
// Return the current offset position.
///
func (self *CStreamReaderT) Tell() (ret int64) {

	cRet := C.cefingo_stream_reader_tell((*C.cef_stream_reader_t)(self.pc_stream_reader))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Return non-zero if at end of file.
///
func (self *CStreamReaderT) Eof() (ret bool) {

	cRet := C.cefingo_stream_reader_eof((*C.cef_stream_reader_t)(self.pc_stream_reader))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this reader performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the reader from.
///
func (self *CStreamReaderT) MayBlock() (ret bool) {

	cRet := C.cefingo_stream_reader_may_block((*C.cef_stream_reader_t)(self.pc_stream_reader))

	ret = cRet == 1
	return ret
}

///
// Create a new cef_stream_reader_t object from a file.
///
func StreamReaderCreateForFile(
	fileName string,
) (ret *CStreamReaderT) {
	c_fileName := create_cef_string(fileName)

	cRet := C.cef_stream_reader_create_for_file(c_fileName.p_cef_string_t)

	ret = newCStreamReaderT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_stream_reader_t object from data.
///
func StreamReaderCreateForData(
	data []byte,
) (ret *CStreamReaderT) {
	size := len(data)
	tmpdata := C.CBytes(data)
	defer C.free(tmpdata)

	cRet := C.cef_stream_reader_create_for_data(tmpdata, (C.size_t)(size))

	ret = newCStreamReaderT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_stream_reader_t object from a custom handler.
///
func StreamReaderCreateForHandler(
	handler *CReadHandlerT,
) (ret *CStreamReaderT) {
	var goTmphandler *C.cef_read_handler_t
	if handler != nil {
		BaseAddRef(handler.pc_read_handler)
		goTmphandler = (*C.cef_read_handler_t)(handler.pc_read_handler)
	}

	cRet := C.cef_stream_reader_create_for_handler(goTmphandler)

	ret = newCStreamReaderT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure the client can implement to provide a custom stream writer. The
// functions of this structure may be called on any thread.
///

type cCWriteHandlerT C.cef_write_handler_t

// Go type for cef_write_handler_t
type CWriteHandlerT struct {
	noCopy           noCopy
	pc_write_handler *cCWriteHandlerT
	beUnrefed        unrefedBy
}

func (p *CWriteHandlerT) Pass() (ret *CWriteHandlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCWriteHandlerT((*C.cef_write_handler_t)(p.pc_write_handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CWriteHandlerT) NewRef() (newP *CWriteHandlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_write_handler
	BaseAddRef(gop)
	newP = newCWriteHandlerT((*C.cef_write_handler_t)(gop), byApp)
	return newP
}

// Go type CWriteHandlerT wraps cef type *C.cef_write_handler_t
func newCWriteHandlerT(p *C.cef_write_handler_t, unrefedBy unrefedBy) *CWriteHandlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T203.1:")
	pc := (*cCWriteHandlerT)(p)
	go_write_handler := &CWriteHandlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_write_handler, func(g *CWriteHandlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_write_handler != nil {
			Tracef(unsafe.Pointer(g.pc_write_handler), "T203.2:")
			BaseRelease(g.pc_write_handler)
		}
	})

	return go_write_handler
}

// *C.cef_write_handler_t has refCounted interface
func (write_handler *CWriteHandlerT) HasOneRef() bool {
	return BaseHasOneRef(write_handler.pc_write_handler)
}

func (p *cCWriteHandlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (write_handler *CWriteHandlerT) Unref() (ret bool) {
	if write_handler == nil {
		return
	}
	if write_handler.beUnrefed == byApp {
		ret = BaseRelease(write_handler.pc_write_handler)
		write_handler.beUnrefed = unrefed
	}
	write_handler.pc_write_handler = nil
	return ret
}

///
// Write raw binary data.
///
type WriteHandler interface {
	Write(
		self *CWriteHandlerT,
		ptr []byte,
		size int64,
		n int64,
	) (ret int64)
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.
///
type CWriteHandlerTSeekHandler interface {
	Seek(
		self *CWriteHandlerT,
		offset int64,
		whence int,
	) (ret bool)
}

///
// Return the current offset position.
///
type CWriteHandlerTTellHandler interface {
	Tell(
		self *CWriteHandlerT,
	) (ret int64)
}

///
// Flush the stream.
///
type FlushHandler interface {
	Flush(
		self *CWriteHandlerT,
	) (ret bool)
}

///
// Return true (1) if this handler performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the handler from.
///
type CWriteHandlerTMayBlockHandler interface {
	MayBlock(
		self *CWriteHandlerT,
	) (ret bool)
}

var write_handler_handlers = struct {
	handler           map[*cCWriteHandlerT]interface{}
	write_handler     map[*cCWriteHandlerT]WriteHandler
	seek_handler      map[*cCWriteHandlerT]CWriteHandlerTSeekHandler
	tell_handler      map[*cCWriteHandlerT]CWriteHandlerTTellHandler
	flush_handler     map[*cCWriteHandlerT]FlushHandler
	may_block_handler map[*cCWriteHandlerT]CWriteHandlerTMayBlockHandler
}{
	map[*cCWriteHandlerT]interface{}{},
	map[*cCWriteHandlerT]WriteHandler{},
	map[*cCWriteHandlerT]CWriteHandlerTSeekHandler{},
	map[*cCWriteHandlerT]CWriteHandlerTTellHandler{},
	map[*cCWriteHandlerT]FlushHandler{},
	map[*cCWriteHandlerT]CWriteHandlerTMayBlockHandler{},
}

// allocCWriteHandlerT allocates CWriteHandlerT and construct it
func allocCWriteHandlerT() *CWriteHandlerT {
	up := c_calloc(1, C.sizeof_cefingo_write_handler_wrapper_t, "T203.3:")
	cefp := C.cefingo_construct_write_handler((*C.cefingo_write_handler_wrapper_t)(up))
	cgop := (*cCWriteHandlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_write_handler_t itself in DeassocFunc,
		// or cef_write_handler_t is never GCed.
		Tracef(up, "T203.4:")
		unbindAllCWriteHandlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCWriteHandlerT(cefp, byApp)
}

// NewCWriteHandlerT allocates CWriteHandlerT, construct and bind it
func NewCWriteHandlerT(a interface{}) *CWriteHandlerT {
	return allocCWriteHandlerT().bind(a)
}

func (write_handler *CWriteHandlerT) bind(a interface{}) *CWriteHandlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := write_handler.pc_write_handler
	write_handler_handlers.handler[cp] = a

	if h, ok := a.(WriteHandler); ok {
		write_handler_handlers.write_handler[cp] = h
		noBind = false
	} else {
		delete(write_handler_handlers.write_handler, cp)
	}

	if h, ok := a.(CWriteHandlerTSeekHandler); ok {
		write_handler_handlers.seek_handler[cp] = h
		noBind = false
	} else {
		delete(write_handler_handlers.seek_handler, cp)
	}

	if h, ok := a.(CWriteHandlerTTellHandler); ok {
		write_handler_handlers.tell_handler[cp] = h
		noBind = false
	} else {
		delete(write_handler_handlers.tell_handler, cp)
	}

	if h, ok := a.(FlushHandler); ok {
		write_handler_handlers.flush_handler[cp] = h
		noBind = false
	} else {
		delete(write_handler_handlers.flush_handler, cp)
	}

	if h, ok := a.(CWriteHandlerTMayBlockHandler); ok {
		write_handler_handlers.may_block_handler[cp] = h
		noBind = false
	} else {
		delete(write_handler_handlers.may_block_handler, cp)
	}

	if noBind {
		Panicln("F229: *CWriteHandlerT No bind")
	}
	return write_handler
}

func unbindAllCWriteHandlerT(cp *cCWriteHandlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := write_handler.pc_write_handler
	delete(write_handler_handlers.handler, cp)

	delete(write_handler_handlers.write_handler, cp)
	delete(write_handler_handlers.seek_handler, cp)
	delete(write_handler_handlers.tell_handler, cp)
	delete(write_handler_handlers.flush_handler, cp)
	delete(write_handler_handlers.may_block_handler, cp)
}

func (write_handler *CWriteHandlerT) UnbindAll() {
	unbindAllCWriteHandlerT(write_handler.pc_write_handler)
	write_handler.Unref()
}

func (write_handler *CWriteHandlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := write_handler.pc_write_handler
	return write_handler_handlers.handler[cp]
}

///
// Structure used to write data to a stream. The functions of this structure may
// be called on any thread.
///

type cCStreamWriterT C.cef_stream_writer_t

// Go type for cef_stream_writer_t
type CStreamWriterT struct {
	noCopy           noCopy
	pc_stream_writer *cCStreamWriterT
	beUnrefed        unrefedBy
}

func (p *CStreamWriterT) Pass() (ret *CStreamWriterT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCStreamWriterT((*C.cef_stream_writer_t)(p.pc_stream_writer), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CStreamWriterT) NewRef() (newP *CStreamWriterT) {
	if self == nil {
		return newP
	}
	gop := self.pc_stream_writer
	BaseAddRef(gop)
	newP = newCStreamWriterT((*C.cef_stream_writer_t)(gop), byApp)
	return newP
}

// Go type CStreamWriterT wraps cef type *C.cef_stream_writer_t
func newCStreamWriterT(p *C.cef_stream_writer_t, unrefedBy unrefedBy) *CStreamWriterT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T204.1:")
	pc := (*cCStreamWriterT)(p)
	go_stream_writer := &CStreamWriterT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_stream_writer, func(g *CStreamWriterT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_stream_writer != nil {
			Tracef(unsafe.Pointer(g.pc_stream_writer), "T204.2:")
			BaseRelease(g.pc_stream_writer)
		}
	})

	return go_stream_writer
}

// *C.cef_stream_writer_t has refCounted interface
func (stream_writer *CStreamWriterT) HasOneRef() bool {
	return BaseHasOneRef(stream_writer.pc_stream_writer)
}

func (p *cCStreamWriterT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (stream_writer *CStreamWriterT) Unref() (ret bool) {
	if stream_writer == nil {
		return
	}
	if stream_writer.beUnrefed == byApp {
		ret = BaseRelease(stream_writer.pc_stream_writer)
		stream_writer.beUnrefed = unrefed
	}
	stream_writer.pc_stream_writer = nil
	return ret
}

///
// Write raw binary data.
///
func (self *CStreamWriterT) Write(
	ptr unsafe.Pointer,
	size int64,
	n int64,
) (ret int64) {

	cRet := C.cefingo_stream_writer_write((*C.cef_stream_writer_t)(self.pc_stream_writer), ptr, (C.size_t)(size), (C.size_t)(n))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Seek to the specified offset position. |whence| may be any one of SEEK_CUR,
// SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure.
///
func (self *CStreamWriterT) Seek(
	offset int64,
	whence int,
) (ret bool) {

	cRet := C.cefingo_stream_writer_seek((*C.cef_stream_writer_t)(self.pc_stream_writer), (C.int64)(offset), (C.int)(whence))

	ret = cRet == 1
	return ret
}

///
// Return the current offset position.
///
func (self *CStreamWriterT) Tell() (ret int64) {

	cRet := C.cefingo_stream_writer_tell((*C.cef_stream_writer_t)(self.pc_stream_writer))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Flush the stream.
///
func (self *CStreamWriterT) Flush() (ret bool) {

	cRet := C.cefingo_stream_writer_flush((*C.cef_stream_writer_t)(self.pc_stream_writer))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this writer performs work like accessing the file
// system which may block. Used as a hint for determining the thread to access
// the writer from.
///
func (self *CStreamWriterT) MayBlock() (ret bool) {

	cRet := C.cefingo_stream_writer_may_block((*C.cef_stream_writer_t)(self.pc_stream_writer))

	ret = cRet == 1
	return ret
}

///
// Create a new cef_stream_writer_t object for a file.
///
func StreamWriterCreateForFile(
	fileName string,
) (ret *CStreamWriterT) {
	c_fileName := create_cef_string(fileName)

	cRet := C.cef_stream_writer_create_for_file(c_fileName.p_cef_string_t)

	ret = newCStreamWriterT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_stream_writer_t object for a custom handler.
///
func StreamWriterCreateForHandler(
	handler *CWriteHandlerT,
) (ret *CStreamWriterT) {
	var goTmphandler *C.cef_write_handler_t
	if handler != nil {
		BaseAddRef(handler.pc_write_handler)
		goTmphandler = (*C.cef_write_handler_t)(handler.pc_write_handler)
	}

	cRet := C.cef_stream_writer_create_for_handler(goTmphandler)

	ret = newCStreamWriterT(cRet, byApp) // return GoObj
	return ret
}

// cef_string_visitor_capi.h, include/capi/cef_string_visitor_capi.h:63:3,

///
// Implement this structure to receive string values asynchronously.
///

type cCStringVisitorT C.cef_string_visitor_t

// Go type for cef_string_visitor_t
type CStringVisitorT struct {
	noCopy            noCopy
	pc_string_visitor *cCStringVisitorT
	beUnrefed         unrefedBy
}

func (p *CStringVisitorT) Pass() (ret *CStringVisitorT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCStringVisitorT((*C.cef_string_visitor_t)(p.pc_string_visitor), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CStringVisitorT) NewRef() (newP *CStringVisitorT) {
	if self == nil {
		return newP
	}
	gop := self.pc_string_visitor
	BaseAddRef(gop)
	newP = newCStringVisitorT((*C.cef_string_visitor_t)(gop), byApp)
	return newP
}

// Go type CStringVisitorT wraps cef type *C.cef_string_visitor_t
func newCStringVisitorT(p *C.cef_string_visitor_t, unrefedBy unrefedBy) *CStringVisitorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T205.1:")
	pc := (*cCStringVisitorT)(p)
	go_string_visitor := &CStringVisitorT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_string_visitor, func(g *CStringVisitorT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_string_visitor != nil {
			Tracef(unsafe.Pointer(g.pc_string_visitor), "T205.2:")
			BaseRelease(g.pc_string_visitor)
		}
	})

	return go_string_visitor
}

// *C.cef_string_visitor_t has refCounted interface
func (string_visitor *CStringVisitorT) HasOneRef() bool {
	return BaseHasOneRef(string_visitor.pc_string_visitor)
}

func (p *cCStringVisitorT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (string_visitor *CStringVisitorT) Unref() (ret bool) {
	if string_visitor == nil {
		return
	}
	if string_visitor.beUnrefed == byApp {
		ret = BaseRelease(string_visitor.pc_string_visitor)
		string_visitor.beUnrefed = unrefed
	}
	string_visitor.pc_string_visitor = nil
	return ret
}

///
// Method that will be executed.
///
type CStringVisitorTVisitHandler interface {
	Visit(
		self *CStringVisitorT,
		cstring string,
	)
}

var string_visitor_handlers = struct {
	handler       map[*cCStringVisitorT]interface{}
	visit_handler map[*cCStringVisitorT]CStringVisitorTVisitHandler
}{
	map[*cCStringVisitorT]interface{}{},
	map[*cCStringVisitorT]CStringVisitorTVisitHandler{},
}

// allocCStringVisitorT allocates CStringVisitorT and construct it
func allocCStringVisitorT() *CStringVisitorT {
	up := c_calloc(1, C.sizeof_cefingo_string_visitor_wrapper_t, "T205.3:")
	cefp := C.cefingo_construct_string_visitor((*C.cefingo_string_visitor_wrapper_t)(up))
	cgop := (*cCStringVisitorT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_string_visitor_t itself in DeassocFunc,
		// or cef_string_visitor_t is never GCed.
		Tracef(up, "T205.4:")
		unbindAllCStringVisitorT(cgop)
	}))

	BaseAddRef(cgop)
	return newCStringVisitorT(cefp, byApp)
}

// NewCStringVisitorT allocates CStringVisitorT, construct and bind it
func NewCStringVisitorT(a interface{}) *CStringVisitorT {
	return allocCStringVisitorT().bind(a)
}

func (string_visitor *CStringVisitorT) bind(a interface{}) *CStringVisitorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := string_visitor.pc_string_visitor
	string_visitor_handlers.handler[cp] = a

	if h, ok := a.(CStringVisitorTVisitHandler); ok {
		string_visitor_handlers.visit_handler[cp] = h
		noBind = false
	} else {
		delete(string_visitor_handlers.visit_handler, cp)
	}

	if noBind {
		Panicln("F229: *CStringVisitorT No bind")
	}
	return string_visitor
}

func unbindAllCStringVisitorT(cp *cCStringVisitorT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := string_visitor.pc_string_visitor
	delete(string_visitor_handlers.handler, cp)

	delete(string_visitor_handlers.visit_handler, cp)
}

func (string_visitor *CStringVisitorT) UnbindAll() {
	unbindAllCStringVisitorT(string_visitor.pc_string_visitor)
	string_visitor.Unref()
}

func (string_visitor *CStringVisitorT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := string_visitor.pc_string_visitor
	return string_visitor_handlers.handler[cp]
}

// cef_task_capi.h, include/capi/cef_task_capi.h:67:3,

///
// Implement this structure for asynchronous task execution. If the task is
// posted successfully and if the associated message loop is still running then
// the execute() function will be called on the target thread. If the task fails
// to post then the task object may be destroyed on the source thread instead of
// the target thread. For this reason be cautious when performing work in the
// task object destructor.
///

type cCTaskT C.cef_task_t

// Go type for cef_task_t
type CTaskT struct {
	noCopy    noCopy
	pc_task   *cCTaskT
	beUnrefed unrefedBy
}

func (p *CTaskT) Pass() (ret *CTaskT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCTaskT((*C.cef_task_t)(p.pc_task), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CTaskT) NewRef() (newP *CTaskT) {
	if self == nil {
		return newP
	}
	gop := self.pc_task
	BaseAddRef(gop)
	newP = newCTaskT((*C.cef_task_t)(gop), byApp)
	return newP
}

// Go type CTaskT wraps cef type *C.cef_task_t
func newCTaskT(p *C.cef_task_t, unrefedBy unrefedBy) *CTaskT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T206.1:")
	pc := (*cCTaskT)(p)
	go_task := &CTaskT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_task, func(g *CTaskT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_task != nil {
			Tracef(unsafe.Pointer(g.pc_task), "T206.2:")
			BaseRelease(g.pc_task)
		}
	})

	return go_task
}

// *C.cef_task_t has refCounted interface
func (task *CTaskT) HasOneRef() bool {
	return BaseHasOneRef(task.pc_task)
}

func (p *cCTaskT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (task *CTaskT) Unref() (ret bool) {
	if task == nil {
		return
	}
	if task.beUnrefed == byApp {
		ret = BaseRelease(task.pc_task)
		task.beUnrefed = unrefed
	}
	task.pc_task = nil
	return ret
}

///
// Method that will be executed on the target thread.
///
type CTaskTExecuteHandler interface {
	Execute(
		self *CTaskT,
	)
}

var task_handlers = struct {
	handler         map[*cCTaskT]interface{}
	execute_handler map[*cCTaskT]CTaskTExecuteHandler
}{
	map[*cCTaskT]interface{}{},
	map[*cCTaskT]CTaskTExecuteHandler{},
}

// allocCTaskT allocates CTaskT and construct it
func allocCTaskT() *CTaskT {
	up := c_calloc(1, C.sizeof_cefingo_task_wrapper_t, "T206.3:")
	cefp := C.cefingo_construct_task((*C.cefingo_task_wrapper_t)(up))
	cgop := (*cCTaskT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_task_t itself in DeassocFunc,
		// or cef_task_t is never GCed.
		Tracef(up, "T206.4:")
		unbindAllCTaskT(cgop)
	}))

	BaseAddRef(cgop)
	return newCTaskT(cefp, byApp)
}

// NewCTaskT allocates CTaskT, construct and bind it
func NewCTaskT(a interface{}) *CTaskT {
	return allocCTaskT().bind(a)
}

func (task *CTaskT) bind(a interface{}) *CTaskT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := task.pc_task
	task_handlers.handler[cp] = a

	if h, ok := a.(CTaskTExecuteHandler); ok {
		task_handlers.execute_handler[cp] = h
		noBind = false
	} else {
		delete(task_handlers.execute_handler, cp)
	}

	if noBind {
		Panicln("F229: *CTaskT No bind")
	}
	return task
}

func unbindAllCTaskT(cp *cCTaskT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := task.pc_task
	delete(task_handlers.handler, cp)

	delete(task_handlers.execute_handler, cp)
}

func (task *CTaskT) UnbindAll() {
	unbindAllCTaskT(task.pc_task)
	task.Unref()
}

func (task *CTaskT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := task.pc_task
	return task_handlers.handler[cp]
}

///
// Structure that asynchronously executes tasks on the associated thread. It is
// safe to call the functions of this structure on any thread.
//
// CEF maintains multiple internal threads that are used for handling different
// types of tasks in different processes. The cef_thread_id_t definitions in
// cef_types.h list the common CEF threads. Task runners are also available for
// other CEF threads as appropriate (for example, V8 WebWorker threads).
///

type cCTaskRunnerT C.cef_task_runner_t

// Go type for cef_task_runner_t
type CTaskRunnerT struct {
	noCopy         noCopy
	pc_task_runner *cCTaskRunnerT
	beUnrefed      unrefedBy
}

func (p *CTaskRunnerT) Pass() (ret *CTaskRunnerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCTaskRunnerT((*C.cef_task_runner_t)(p.pc_task_runner), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CTaskRunnerT) NewRef() (newP *CTaskRunnerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_task_runner
	BaseAddRef(gop)
	newP = newCTaskRunnerT((*C.cef_task_runner_t)(gop), byApp)
	return newP
}

// Go type CTaskRunnerT wraps cef type *C.cef_task_runner_t
func newCTaskRunnerT(p *C.cef_task_runner_t, unrefedBy unrefedBy) *CTaskRunnerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T207.1:")
	pc := (*cCTaskRunnerT)(p)
	go_task_runner := &CTaskRunnerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_task_runner, func(g *CTaskRunnerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_task_runner != nil {
			Tracef(unsafe.Pointer(g.pc_task_runner), "T207.2:")
			BaseRelease(g.pc_task_runner)
		}
	})

	return go_task_runner
}

// *C.cef_task_runner_t has refCounted interface
func (task_runner *CTaskRunnerT) HasOneRef() bool {
	return BaseHasOneRef(task_runner.pc_task_runner)
}

func (p *cCTaskRunnerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (task_runner *CTaskRunnerT) Unref() (ret bool) {
	if task_runner == nil {
		return
	}
	if task_runner.beUnrefed == byApp {
		ret = BaseRelease(task_runner.pc_task_runner)
		task_runner.beUnrefed = unrefed
	}
	task_runner.pc_task_runner = nil
	return ret
}

///
// Returns true (1) if this object is pointing to the same task runner as
// |that| object.
///
func (self *CTaskRunnerT) IsSame(
	that *CTaskRunnerT,
) (ret bool) {
	var goTmpthat *C.cef_task_runner_t
	if that != nil {
		BaseAddRef(that.pc_task_runner)
		goTmpthat = (*C.cef_task_runner_t)(that.pc_task_runner)
	}

	cRet := C.cefingo_task_runner_is_same((*C.cef_task_runner_t)(self.pc_task_runner), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this task runner belongs to the current thread.
///
func (self *CTaskRunnerT) BelongsToCurrentThread() (ret bool) {

	cRet := C.cefingo_task_runner_belongs_to_current_thread((*C.cef_task_runner_t)(self.pc_task_runner))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this task runner is for the specified CEF thread.
///
func (self *CTaskRunnerT) BelongsToThread(
	threadId CThreadIdT,
) (ret bool) {

	cRet := C.cefingo_task_runner_belongs_to_thread((*C.cef_task_runner_t)(self.pc_task_runner), (C.cef_thread_id_t)(threadId))

	ret = cRet == 1
	return ret
}

///
// Post a task for execution on the thread associated with this task runner.
// Execution will occur asynchronously.
///
func (self *CTaskRunnerT) PostTask(
	task *CTaskT,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		BaseAddRef(task.pc_task)
		goTmptask = (*C.cef_task_t)(task.pc_task)
	}

	cRet := C.cefingo_task_runner_post_task((*C.cef_task_runner_t)(self.pc_task_runner), goTmptask)

	ret = cRet == 1
	return ret
}

///
// Post a task for delayed execution on the thread associated with this task
// runner. Execution will occur asynchronously. Delayed tasks are not
// supported on V8 WebWorker threads and will be executed without the
// specified delay.
///
func (self *CTaskRunnerT) PostDelayedTask(
	task *CTaskT,
	delay_ms int64,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		BaseAddRef(task.pc_task)
		goTmptask = (*C.cef_task_t)(task.pc_task)
	}

	cRet := C.cefingo_task_runner_post_delayed_task((*C.cef_task_runner_t)(self.pc_task_runner), goTmptask, (C.int64)(delay_ms))

	ret = cRet == 1
	return ret
}

///
// Returns the task runner for the current thread. Only CEF threads will have
// task runners. An NULL reference will be returned if this function is called
// on an invalid thread.
///
func TaskRunnerGetForCurrentThread() (ret *CTaskRunnerT) {

	cRet := C.cef_task_runner_get_for_current_thread()

	ret = newCTaskRunnerT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the task runner for the specified CEF thread.
///
func TaskRunnerGetForThread(
	threadId CThreadIdT,
) (ret *CTaskRunnerT) {

	cRet := C.cef_task_runner_get_for_thread((C.cef_thread_id_t)(threadId))

	ret = newCTaskRunnerT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if called on the specified thread. Equivalent to using
// cef_task_runner_t::GetForThread(threadId)->belongs_to_current_thread().
///
func CurrentlyOn(
	threadId CThreadIdT,
) (ret bool) {

	cRet := C.cef_currently_on((C.cef_thread_id_t)(threadId))

	ret = cRet == 1
	return ret
}

///
// Post a task for execution on the specified thread. Equivalent to using
// cef_task_runner_t::GetForThread(threadId)->PostTask(task).
///
func PostTask(
	threadId CThreadIdT,
	task *CTaskT,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		BaseAddRef(task.pc_task)
		goTmptask = (*C.cef_task_t)(task.pc_task)
	}

	cRet := C.cef_post_task((C.cef_thread_id_t)(threadId), goTmptask)

	ret = cRet == 1
	return ret
}

///
// Post a task for delayed execution on the specified thread. Equivalent to
// using cef_task_runner_t::GetForThread(threadId)->PostDelayedTask(task,
// delay_ms).
///
func PostDelayedTask(
	threadId CThreadIdT,
	task *CTaskT,
	delay_ms int64,
) (ret bool) {
	var goTmptask *C.cef_task_t
	if task != nil {
		BaseAddRef(task.pc_task)
		goTmptask = (*C.cef_task_t)(task.pc_task)
	}

	cRet := C.cef_post_delayed_task((C.cef_thread_id_t)(threadId), goTmptask, (C.int64)(delay_ms))

	ret = cRet == 1
	return ret
}

// cef_textfield_capi.h, include/capi/views/cef_textfield_capi.h:261:3,

///
// A Textfield supports editing of text. This control is custom rendered with no
// platform-specific code. Methods must be called on the browser process UI
// thread unless otherwise indicated.
///

type cCTextfieldT C.cef_textfield_t

// Go type for cef_textfield_t
type CTextfieldT struct {
	noCopy       noCopy
	pc_textfield *cCTextfieldT
	beUnrefed    unrefedBy
}

func (p *CTextfieldT) Pass() (ret *CTextfieldT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCTextfieldT((*C.cef_textfield_t)(p.pc_textfield), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CTextfieldT) NewRef() (newP *CTextfieldT) {
	if self == nil {
		return newP
	}
	gop := self.pc_textfield
	BaseAddRef(gop)
	newP = newCTextfieldT((*C.cef_textfield_t)(gop), byApp)
	return newP
}

// Go type CTextfieldT wraps cef type *C.cef_textfield_t
func newCTextfieldT(p *C.cef_textfield_t, unrefedBy unrefedBy) *CTextfieldT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T208.1:")
	pc := (*cCTextfieldT)(p)
	go_textfield := &CTextfieldT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_textfield, func(g *CTextfieldT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_textfield != nil {
			Tracef(unsafe.Pointer(g.pc_textfield), "T208.2:")
			BaseRelease(g.pc_textfield)
		}
	})

	return go_textfield
}

// *C.cef_textfield_t has refCounted interface
func (textfield *CTextfieldT) HasOneRef() bool {
	return BaseHasOneRef(textfield.pc_textfield)
}

func (p *cCTextfieldT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (textfield *CTextfieldT) Unref() (ret bool) {
	if textfield == nil {
		return
	}
	if textfield.beUnrefed == byApp {
		ret = BaseRelease(textfield.pc_textfield)
		textfield.beUnrefed = unrefed
	}
	textfield.pc_textfield = nil
	return ret
}

// Convert to Base Class Pointer *CViewT
func (textfield *CTextfieldT) ToCViewT() *CViewT {
	p := (*C.cef_view_t)(unsafe.Pointer(textfield.pc_textfield))
	BaseAddRef(textfield.pc_textfield)
	return newCViewT(p, byApp)
}

///
// Sets whether the text will be displayed as asterisks.
///
func (self *CTextfieldT) SetPasswordInput(
	password_input int,
) {

	C.cefingo_textfield_set_password_input((*C.cef_textfield_t)(self.pc_textfield), (C.int)(password_input))

}

///
// Returns true (1) if the text will be displayed as asterisks.
///
func (self *CTextfieldT) IsPasswordInput() (ret bool) {

	cRet := C.cefingo_textfield_is_password_input((*C.cef_textfield_t)(self.pc_textfield))

	ret = cRet == 1
	return ret
}

///
// Sets whether the text will read-only.
///
func (self *CTextfieldT) SetReadOnly(
	read_only int,
) {

	C.cefingo_textfield_set_read_only((*C.cef_textfield_t)(self.pc_textfield), (C.int)(read_only))

}

///
// Returns true (1) if the text is read-only.
///
func (self *CTextfieldT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_textfield_is_read_only((*C.cef_textfield_t)(self.pc_textfield))

	ret = cRet == 1
	return ret
}

///
// Returns the currently displayed text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CTextfieldT) GetText() (ret string) {

	cRet := C.cefingo_textfield_get_text((*C.cef_textfield_t)(self.pc_textfield))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the contents to |text|. The cursor will be moved to end of the text if
// the current position is outside of the text range.
///
func (self *CTextfieldT) SetText(
	text string,
) {
	c_text := create_cef_string(text)

	C.cefingo_textfield_set_text((*C.cef_textfield_t)(self.pc_textfield), c_text.p_cef_string_t)

}

///
// Appends |text| to the previously-existing text.
///
func (self *CTextfieldT) AppendText(
	text string,
) {
	c_text := create_cef_string(text)

	C.cefingo_textfield_append_text((*C.cef_textfield_t)(self.pc_textfield), c_text.p_cef_string_t)

}

///
// Inserts |text| at the current cursor position replacing any selected text.
///
func (self *CTextfieldT) InsertOrReplaceText(
	text string,
) {
	c_text := create_cef_string(text)

	C.cefingo_textfield_insert_or_replace_text((*C.cef_textfield_t)(self.pc_textfield), c_text.p_cef_string_t)

}

///
// Returns true (1) if there is any selected text.
///
func (self *CTextfieldT) HasSelection() (ret bool) {

	cRet := C.cefingo_textfield_has_selection((*C.cef_textfield_t)(self.pc_textfield))

	ret = cRet == 1
	return ret
}

///
// Returns the currently selected text.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CTextfieldT) GetSelectedText() (ret string) {

	cRet := C.cefingo_textfield_get_selected_text((*C.cef_textfield_t)(self.pc_textfield))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Selects all text. If |reversed| is true (1) the range will end at the
// logical beginning of the text; this generally shows the leading portion of
// text that overflows its display area.
///
func (self *CTextfieldT) SelectAll(
	reversed int,
) {

	C.cefingo_textfield_select_all((*C.cef_textfield_t)(self.pc_textfield), (C.int)(reversed))

}

///
// Clears the text selection and sets the caret to the end.
///
func (self *CTextfieldT) ClearSelection() {

	C.cefingo_textfield_clear_selection((*C.cef_textfield_t)(self.pc_textfield))

}

///
// Returns the selected logical text range.
///
func (self *CTextfieldT) GetSelectedRange() (ret CRangeT) {

	cRet := C.cefingo_textfield_get_selected_range((*C.cef_textfield_t)(self.pc_textfield))

	ret = (CRangeT)(cRet) // return GoObj
	return ret
}

///
// Selects the specified logical text range.
///
func (self *CTextfieldT) SelectRange(
	crange *CRangeT,
) {

	C.cefingo_textfield_select_range((*C.cef_textfield_t)(self.pc_textfield), (*C.cef_range_t)(crange))

}

///
// Returns the current cursor position.
///
func (self *CTextfieldT) GetCursorPosition() (ret int64) {

	cRet := C.cefingo_textfield_get_cursor_position((*C.cef_textfield_t)(self.pc_textfield))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Sets the text color.
///
func (self *CTextfieldT) SetTextColor(
	color CColorT,
) {

	C.cefingo_textfield_set_text_color((*C.cef_textfield_t)(self.pc_textfield), (C.cef_color_t)(color))

}

///
// Returns the text color.
///
func (self *CTextfieldT) GetTextColor() (ret CColorT) {

	cRet := C.cefingo_textfield_get_text_color((*C.cef_textfield_t)(self.pc_textfield))

	ret = (CColorT)(cRet) // return GoObj
	return ret
}

///
// Sets the selection text color.
///
func (self *CTextfieldT) SetSelectionTextColor(
	color CColorT,
) {

	C.cefingo_textfield_set_selection_text_color((*C.cef_textfield_t)(self.pc_textfield), (C.cef_color_t)(color))

}

///
// Returns the selection text color.
///
func (self *CTextfieldT) GetSelectionTextColor() (ret CColorT) {

	cRet := C.cefingo_textfield_get_selection_text_color((*C.cef_textfield_t)(self.pc_textfield))

	ret = (CColorT)(cRet) // return GoObj
	return ret
}

///
// Sets the selection background color.
///
func (self *CTextfieldT) SetSelectionBackgroundColor(
	color CColorT,
) {

	C.cefingo_textfield_set_selection_background_color((*C.cef_textfield_t)(self.pc_textfield), (C.cef_color_t)(color))

}

///
// Returns the selection background color.
///
func (self *CTextfieldT) GetSelectionBackgroundColor() (ret CColorT) {

	cRet := C.cefingo_textfield_get_selection_background_color((*C.cef_textfield_t)(self.pc_textfield))

	ret = (CColorT)(cRet) // return GoObj
	return ret
}

///
// Sets the font list. The format is &quot;&lt;FONT_FAMILY_LIST&gt;,[STYLES] &lt;SIZE&gt;&quot;,
// where: - FONT_FAMILY_LIST is a comma-separated list of font family names, -
// STYLES is an optional space-separated list of style names (case-sensitive
//   &quot;Bold&quot; and &quot;Italic&quot; are supported), and
// - SIZE is an integer font size in pixels with the suffix &quot;px&quot;.
//
// Here are examples of valid font description strings: - &quot;Arial, Helvetica,
// Bold Italic 14px&quot; - &quot;Arial, 14px&quot;
///
func (self *CTextfieldT) SetFontList(
	font_list string,
) {
	c_font_list := create_cef_string(font_list)

	C.cefingo_textfield_set_font_list((*C.cef_textfield_t)(self.pc_textfield), c_font_list.p_cef_string_t)

}

///
// Applies |color| to the specified |range| without changing the default
// color. If |range| is NULL the color will be set on the complete text
// contents.
///
func (self *CTextfieldT) ApplyTextColor(
	color CColorT,
	crange *CRangeT,
) {

	C.cefingo_textfield_apply_text_color((*C.cef_textfield_t)(self.pc_textfield), (C.cef_color_t)(color), (*C.cef_range_t)(crange))

}

///
// Applies |style| to the specified |range| without changing the default
// style. If |add| is true (1) the style will be added, otherwise the style
// will be removed. If |range| is NULL the style will be set on the complete
// text contents.
///
func (self *CTextfieldT) ApplyTextStyle(
	style CTextStyleT,
	add int,
	crange *CRangeT,
) {

	C.cefingo_textfield_apply_text_style((*C.cef_textfield_t)(self.pc_textfield), (C.cef_text_style_t)(style), (C.int)(add), (*C.cef_range_t)(crange))

}

///
// Returns true (1) if the action associated with the specified command id is
// enabled. See additional comments on execute_command().
///
func (self *CTextfieldT) IsCommandEnabled(
	command_id CTextFieldCommandsT,
) (ret bool) {

	cRet := C.cefingo_textfield_is_command_enabled((*C.cef_textfield_t)(self.pc_textfield), (C.cef_text_field_commands_t)(command_id))

	ret = cRet == 1
	return ret
}

///
// Performs the action associated with the specified command id.
///
func (self *CTextfieldT) ExecuteCommand(
	command_id CTextFieldCommandsT,
) {

	C.cefingo_textfield_execute_command((*C.cef_textfield_t)(self.pc_textfield), (C.cef_text_field_commands_t)(command_id))

}

///
// Clears Edit history.
///
func (self *CTextfieldT) ClearEditHistory() {

	C.cefingo_textfield_clear_edit_history((*C.cef_textfield_t)(self.pc_textfield))

}

///
// Sets the placeholder text that will be displayed when the Textfield is
// NULL.
///
func (self *CTextfieldT) SetPlaceholderText(
	text string,
) {
	c_text := create_cef_string(text)

	C.cefingo_textfield_set_placeholder_text((*C.cef_textfield_t)(self.pc_textfield), c_text.p_cef_string_t)

}

///
// Returns the placeholder text that will be displayed when the Textfield is
// NULL.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CTextfieldT) GetPlaceholderText() (ret string) {

	cRet := C.cefingo_textfield_get_placeholder_text((*C.cef_textfield_t)(self.pc_textfield))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Sets the placeholder text color.
///
func (self *CTextfieldT) SetPlaceholderTextColor(
	color CColorT,
) {

	C.cefingo_textfield_set_placeholder_text_color((*C.cef_textfield_t)(self.pc_textfield), (C.cef_color_t)(color))

}

///
// Set the accessible name that will be exposed to assistive technology (AT).
///
func (self *CTextfieldT) SetAccessibleName(
	name string,
) {
	c_name := create_cef_string(name)

	C.cefingo_textfield_set_accessible_name((*C.cef_textfield_t)(self.pc_textfield), c_name.p_cef_string_t)

}

///
// Create a new Textfield.
///
func TextfieldCreate(
	delegate *CTextfieldDelegateT,
) (ret *CTextfieldT) {
	var goTmpdelegate *C.cef_textfield_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_textfield_delegate)
		goTmpdelegate = (*C.cef_textfield_delegate_t)(delegate.pc_textfield_delegate)
	}

	cRet := C.cef_textfield_create(goTmpdelegate)

	ret = newCTextfieldT(cRet, byApp) // return GoObj
	return ret
}

// cef_textfield_delegate_capi.h, include/capi/views/cef_textfield_delegate_capi.h:77:3,

///
// Implement this structure to handle Textfield events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCTextfieldDelegateT C.cef_textfield_delegate_t

// Go type for cef_textfield_delegate_t
type CTextfieldDelegateT struct {
	noCopy                noCopy
	pc_textfield_delegate *cCTextfieldDelegateT
	beUnrefed             unrefedBy
}

func (p *CTextfieldDelegateT) Pass() (ret *CTextfieldDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCTextfieldDelegateT((*C.cef_textfield_delegate_t)(p.pc_textfield_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CTextfieldDelegateT) NewRef() (newP *CTextfieldDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_textfield_delegate
	BaseAddRef(gop)
	newP = newCTextfieldDelegateT((*C.cef_textfield_delegate_t)(gop), byApp)
	return newP
}

// Go type CTextfieldDelegateT wraps cef type *C.cef_textfield_delegate_t
func newCTextfieldDelegateT(p *C.cef_textfield_delegate_t, unrefedBy unrefedBy) *CTextfieldDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T209.1:")
	pc := (*cCTextfieldDelegateT)(p)
	go_textfield_delegate := &CTextfieldDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_textfield_delegate, func(g *CTextfieldDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_textfield_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_textfield_delegate), "T209.2:")
			BaseRelease(g.pc_textfield_delegate)
		}
	})

	return go_textfield_delegate
}

// *C.cef_textfield_delegate_t has refCounted interface
func (textfield_delegate *CTextfieldDelegateT) HasOneRef() bool {
	return BaseHasOneRef(textfield_delegate.pc_textfield_delegate)
}

func (p *cCTextfieldDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (textfield_delegate *CTextfieldDelegateT) Unref() (ret bool) {
	if textfield_delegate == nil {
		return
	}
	if textfield_delegate.beUnrefed == byApp {
		ret = BaseRelease(textfield_delegate.pc_textfield_delegate)
		textfield_delegate.beUnrefed = unrefed
	}
	textfield_delegate.pc_textfield_delegate = nil
	return ret
}

// Convert to Base Class Pointer *CViewDelegateT
func (textfield_delegate *CTextfieldDelegateT) ToCViewDelegateT() *CViewDelegateT {
	p := (*C.cef_view_delegate_t)(unsafe.Pointer(textfield_delegate.pc_textfield_delegate))
	BaseAddRef(textfield_delegate.pc_textfield_delegate)
	return newCViewDelegateT(p, byApp)
}

///
// Called when |textfield| recieves a keyboard event. |event| contains
// information about the keyboard event. Return true (1) if the keyboard event
// was handled or false (0) otherwise for default handling.
///
type CTextfieldDelegateTOnKeyEventHandler interface {
	OnKeyEvent(
		self *CTextfieldDelegateT,
		textfield *CTextfieldT,
		event *CKeyEventT,
	) (ret bool)
}

///
// Called after performing a user action that may change |textfield|.
///
type OnAfterUserActionHandler interface {
	OnAfterUserAction(
		self *CTextfieldDelegateT,
		textfield *CTextfieldT,
	)
}

var textfield_delegate_handlers = struct {
	handler                        map[*cCTextfieldDelegateT]interface{}
	on_key_event_handler           map[*cCTextfieldDelegateT]CTextfieldDelegateTOnKeyEventHandler
	on_after_user_action_handler   map[*cCTextfieldDelegateT]OnAfterUserActionHandler
	get_preferred_size_handler     map[*cCTextfieldDelegateT]GetPreferredSizeHandler
	get_minimum_size_handler       map[*cCTextfieldDelegateT]GetMinimumSizeHandler
	get_maximum_size_handler       map[*cCTextfieldDelegateT]GetMaximumSizeHandler
	get_height_for_width_handler   map[*cCTextfieldDelegateT]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*cCTextfieldDelegateT]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*cCTextfieldDelegateT]OnChildViewChangedHandler
	on_window_changed_handler      map[*cCTextfieldDelegateT]OnWindowChangedHandler
	on_layout_changed_handler      map[*cCTextfieldDelegateT]OnLayoutChangedHandler
	on_focus_handler               map[*cCTextfieldDelegateT]OnFocusHandler
	on_blur_handler                map[*cCTextfieldDelegateT]OnBlurHandler
}{
	map[*cCTextfieldDelegateT]interface{}{},
	map[*cCTextfieldDelegateT]CTextfieldDelegateTOnKeyEventHandler{},
	map[*cCTextfieldDelegateT]OnAfterUserActionHandler{},
	map[*cCTextfieldDelegateT]GetPreferredSizeHandler{},
	map[*cCTextfieldDelegateT]GetMinimumSizeHandler{},
	map[*cCTextfieldDelegateT]GetMaximumSizeHandler{},
	map[*cCTextfieldDelegateT]GetHeightForWidthHandler{},
	map[*cCTextfieldDelegateT]OnParentViewChangedHandler{},
	map[*cCTextfieldDelegateT]OnChildViewChangedHandler{},
	map[*cCTextfieldDelegateT]OnWindowChangedHandler{},
	map[*cCTextfieldDelegateT]OnLayoutChangedHandler{},
	map[*cCTextfieldDelegateT]OnFocusHandler{},
	map[*cCTextfieldDelegateT]OnBlurHandler{},
}

// allocCTextfieldDelegateT allocates CTextfieldDelegateT and construct it
func allocCTextfieldDelegateT() *CTextfieldDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_textfield_delegate_wrapper_t, "T209.3:")
	cefp := C.cefingo_construct_textfield_delegate((*C.cefingo_textfield_delegate_wrapper_t)(up))
	cgop := (*cCTextfieldDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_textfield_delegate_t itself in DeassocFunc,
		// or cef_textfield_delegate_t is never GCed.
		Tracef(up, "T209.4:")
		unbindAllCTextfieldDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCTextfieldDelegateT(cefp, byApp)
}

// NewCTextfieldDelegateT allocates CTextfieldDelegateT, construct and bind it
func NewCTextfieldDelegateT(a interface{}) *CTextfieldDelegateT {
	return allocCTextfieldDelegateT().bind(a)
}

func (textfield_delegate *CTextfieldDelegateT) bind(a interface{}) *CTextfieldDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := textfield_delegate.pc_textfield_delegate
	textfield_delegate_handlers.handler[cp] = a

	if h, ok := a.(CTextfieldDelegateTOnKeyEventHandler); ok {
		textfield_delegate_handlers.on_key_event_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_key_event_handler, cp)
	}

	if h, ok := a.(OnAfterUserActionHandler); ok {
		textfield_delegate_handlers.on_after_user_action_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_after_user_action_handler, cp)
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		textfield_delegate_handlers.get_preferred_size_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.get_preferred_size_handler, cp)
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		textfield_delegate_handlers.get_minimum_size_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.get_minimum_size_handler, cp)
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		textfield_delegate_handlers.get_maximum_size_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.get_maximum_size_handler, cp)
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		textfield_delegate_handlers.get_height_for_width_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.get_height_for_width_handler, cp)
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		textfield_delegate_handlers.on_parent_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_parent_view_changed_handler, cp)
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		textfield_delegate_handlers.on_child_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_child_view_changed_handler, cp)
	}

	if h, ok := a.(OnWindowChangedHandler); ok {
		textfield_delegate_handlers.on_window_changed_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_window_changed_handler, cp)
	}

	if h, ok := a.(OnLayoutChangedHandler); ok {
		textfield_delegate_handlers.on_layout_changed_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_layout_changed_handler, cp)
	}

	if h, ok := a.(OnFocusHandler); ok {
		textfield_delegate_handlers.on_focus_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_focus_handler, cp)
	}

	if h, ok := a.(OnBlurHandler); ok {
		textfield_delegate_handlers.on_blur_handler[cp] = h
		noBind = false
	} else {
		delete(textfield_delegate_handlers.on_blur_handler, cp)
	}

	if noBind {
		Panicln("F229: *CTextfieldDelegateT No bind")
	}
	return textfield_delegate
}

func unbindAllCTextfieldDelegateT(cp *cCTextfieldDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := textfield_delegate.pc_textfield_delegate
	delete(textfield_delegate_handlers.handler, cp)

	delete(textfield_delegate_handlers.on_key_event_handler, cp)
	delete(textfield_delegate_handlers.on_after_user_action_handler, cp)
	delete(textfield_delegate_handlers.get_preferred_size_handler, cp)
	delete(textfield_delegate_handlers.get_minimum_size_handler, cp)
	delete(textfield_delegate_handlers.get_maximum_size_handler, cp)
	delete(textfield_delegate_handlers.get_height_for_width_handler, cp)
	delete(textfield_delegate_handlers.on_parent_view_changed_handler, cp)
	delete(textfield_delegate_handlers.on_child_view_changed_handler, cp)
	delete(textfield_delegate_handlers.on_window_changed_handler, cp)
	delete(textfield_delegate_handlers.on_layout_changed_handler, cp)
	delete(textfield_delegate_handlers.on_focus_handler, cp)
	delete(textfield_delegate_handlers.on_blur_handler, cp)
}

func (textfield_delegate *CTextfieldDelegateT) UnbindAll() {
	unbindAllCTextfieldDelegateT(textfield_delegate.pc_textfield_delegate)
	textfield_delegate.Unref()
}

func (textfield_delegate *CTextfieldDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := textfield_delegate.pc_textfield_delegate
	return textfield_delegate_handlers.handler[cp]
}

// cef_trace_capi.h, include/capi/cef_trace_capi.h:69:3,

///
// Implement this structure to receive notification when tracing has completed.
// The functions of this structure will be called on the browser process UI
// thread.
///

type cCEndTracingCallbackT C.cef_end_tracing_callback_t

// Go type for cef_end_tracing_callback_t
type CEndTracingCallbackT struct {
	noCopy                  noCopy
	pc_end_tracing_callback *cCEndTracingCallbackT
	beUnrefed               unrefedBy
}

func (p *CEndTracingCallbackT) Pass() (ret *CEndTracingCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCEndTracingCallbackT((*C.cef_end_tracing_callback_t)(p.pc_end_tracing_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CEndTracingCallbackT) NewRef() (newP *CEndTracingCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_end_tracing_callback
	BaseAddRef(gop)
	newP = newCEndTracingCallbackT((*C.cef_end_tracing_callback_t)(gop), byApp)
	return newP
}

// Go type CEndTracingCallbackT wraps cef type *C.cef_end_tracing_callback_t
func newCEndTracingCallbackT(p *C.cef_end_tracing_callback_t, unrefedBy unrefedBy) *CEndTracingCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T381.1:")
	pc := (*cCEndTracingCallbackT)(p)
	go_end_tracing_callback := &CEndTracingCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_end_tracing_callback, func(g *CEndTracingCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_end_tracing_callback != nil {
			Tracef(unsafe.Pointer(g.pc_end_tracing_callback), "T381.2:")
			BaseRelease(g.pc_end_tracing_callback)
		}
	})

	return go_end_tracing_callback
}

// *C.cef_end_tracing_callback_t has refCounted interface
func (end_tracing_callback *CEndTracingCallbackT) HasOneRef() bool {
	return BaseHasOneRef(end_tracing_callback.pc_end_tracing_callback)
}

func (p *cCEndTracingCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (end_tracing_callback *CEndTracingCallbackT) Unref() (ret bool) {
	if end_tracing_callback == nil {
		return
	}
	if end_tracing_callback.beUnrefed == byApp {
		ret = BaseRelease(end_tracing_callback.pc_end_tracing_callback)
		end_tracing_callback.beUnrefed = unrefed
	}
	end_tracing_callback.pc_end_tracing_callback = nil
	return ret
}

///
// Called after all processes have sent their trace data. |tracing_file| is
// the path at which tracing data was written. The client is responsible for
// deleting |tracing_file|.
///
type OnEndTracingCompleteHandler interface {
	OnEndTracingComplete(
		self *CEndTracingCallbackT,
		tracing_file string,
	)
}

var end_tracing_callback_handlers = struct {
	handler                         map[*cCEndTracingCallbackT]interface{}
	on_end_tracing_complete_handler map[*cCEndTracingCallbackT]OnEndTracingCompleteHandler
}{
	map[*cCEndTracingCallbackT]interface{}{},
	map[*cCEndTracingCallbackT]OnEndTracingCompleteHandler{},
}

// allocCEndTracingCallbackT allocates CEndTracingCallbackT and construct it
func allocCEndTracingCallbackT() *CEndTracingCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_end_tracing_callback_wrapper_t, "T381.3:")
	cefp := C.cefingo_construct_end_tracing_callback((*C.cefingo_end_tracing_callback_wrapper_t)(up))
	cgop := (*cCEndTracingCallbackT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_end_tracing_callback_t itself in DeassocFunc,
		// or cef_end_tracing_callback_t is never GCed.
		Tracef(up, "T381.4:")
		unbindAllCEndTracingCallbackT(cgop)
	}))

	BaseAddRef(cgop)
	return newCEndTracingCallbackT(cefp, byApp)
}

// NewCEndTracingCallbackT allocates CEndTracingCallbackT, construct and bind it
func NewCEndTracingCallbackT(a interface{}) *CEndTracingCallbackT {
	return allocCEndTracingCallbackT().bind(a)
}

func (end_tracing_callback *CEndTracingCallbackT) bind(a interface{}) *CEndTracingCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := end_tracing_callback.pc_end_tracing_callback
	end_tracing_callback_handlers.handler[cp] = a

	if h, ok := a.(OnEndTracingCompleteHandler); ok {
		end_tracing_callback_handlers.on_end_tracing_complete_handler[cp] = h
		noBind = false
	} else {
		delete(end_tracing_callback_handlers.on_end_tracing_complete_handler, cp)
	}

	if noBind {
		Panicln("F229: *CEndTracingCallbackT No bind")
	}
	return end_tracing_callback
}

func unbindAllCEndTracingCallbackT(cp *cCEndTracingCallbackT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := end_tracing_callback.pc_end_tracing_callback
	delete(end_tracing_callback_handlers.handler, cp)

	delete(end_tracing_callback_handlers.on_end_tracing_complete_handler, cp)
}

func (end_tracing_callback *CEndTracingCallbackT) UnbindAll() {
	unbindAllCEndTracingCallbackT(end_tracing_callback.pc_end_tracing_callback)
	end_tracing_callback.Unref()
}

func (end_tracing_callback *CEndTracingCallbackT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := end_tracing_callback.pc_end_tracing_callback
	return end_tracing_callback_handlers.handler[cp]
}

///
// Start tracing events on all processes. Tracing is initialized asynchronously
// and |callback| will be executed on the UI thread after initialization is
// complete.
//
// If CefBeginTracing was called previously, or if a CefEndTracingAsync call is
// pending, CefBeginTracing will fail and return false (0).
//
// |categories| is a comma-delimited list of category wildcards. A category can
// have an optional '-' prefix to make it an excluded category. Having both
// included and excluded categories in the same list is not supported.
//
// Example: "test_MyTest*" Example: "test_MyTest*,test_OtherStuff" Example:
// "-excluded_category1,-excluded_category2"
//
// This function must be called on the browser process UI thread.
///
func BeginTracing(
	categories string,
	callback *CCompletionCallbackT,
) (ret bool) {
	c_categories := create_cef_string(categories)
	var goTmpcallback *C.cef_completion_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_completion_callback)
		goTmpcallback = (*C.cef_completion_callback_t)(callback.pc_completion_callback)
	}

	cRet := C.cef_begin_tracing(c_categories.p_cef_string_t, goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Stop tracing events on all processes.
//
// This function will fail and return false (0) if a previous call to
// CefEndTracingAsync is already pending or if CefBeginTracing was not called.
//
// |tracing_file| is the path at which tracing data will be written and
// |callback| is the callback that will be executed once all processes have sent
// their trace data. If |tracing_file| is NULL a new temporary file path will be
// used. If |callback| is NULL no trace data will be written.
//
// This function must be called on the browser process UI thread.
///
func EndTracing(
	tracing_file string,
	callback *CEndTracingCallbackT,
) (ret bool) {
	c_tracing_file := create_cef_string(tracing_file)
	var goTmpcallback *C.cef_end_tracing_callback_t
	if callback != nil {
		BaseAddRef(callback.pc_end_tracing_callback)
		goTmpcallback = (*C.cef_end_tracing_callback_t)(callback.pc_end_tracing_callback)
	}

	cRet := C.cef_end_tracing(c_tracing_file.p_cef_string_t, goTmpcallback)

	ret = cRet == 1
	return ret
}

///
// Returns the current system trace time or, if none is defined, the current
// high-res time. Can be used by clients to synchronize with the time
// information in trace events.
///
func NowFromSystemTraceTime() (ret int64) {

	cRet := C.cef_now_from_system_trace_time()

	ret = (int64)(cRet) // return GoObj
	return ret
}

// cef_urlrequest_capi.h, include/capi/cef_urlrequest_capi.h:112:3,

///
// Structure used to make a URL request. URL requests are not associated with a
// browser instance so no cef_client_t callbacks will be executed. URL requests
// can be created on any valid CEF thread in either the browser or render
// process. Once created the functions of the URL request object must be
// accessed on the same thread that created it.
///

type cCUrlrequestT C.cef_urlrequest_t

// Go type for cef_urlrequest_t
type CUrlrequestT struct {
	noCopy        noCopy
	pc_urlrequest *cCUrlrequestT
	beUnrefed     unrefedBy
}

func (p *CUrlrequestT) Pass() (ret *CUrlrequestT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCUrlrequestT((*C.cef_urlrequest_t)(p.pc_urlrequest), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CUrlrequestT) NewRef() (newP *CUrlrequestT) {
	if self == nil {
		return newP
	}
	gop := self.pc_urlrequest
	BaseAddRef(gop)
	newP = newCUrlrequestT((*C.cef_urlrequest_t)(gop), byApp)
	return newP
}

// Go type CUrlrequestT wraps cef type *C.cef_urlrequest_t
func newCUrlrequestT(p *C.cef_urlrequest_t, unrefedBy unrefedBy) *CUrlrequestT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T210.1:")
	pc := (*cCUrlrequestT)(p)
	go_urlrequest := &CUrlrequestT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_urlrequest, func(g *CUrlrequestT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_urlrequest != nil {
			Tracef(unsafe.Pointer(g.pc_urlrequest), "T210.2:")
			BaseRelease(g.pc_urlrequest)
		}
	})

	return go_urlrequest
}

// *C.cef_urlrequest_t has refCounted interface
func (urlrequest *CUrlrequestT) HasOneRef() bool {
	return BaseHasOneRef(urlrequest.pc_urlrequest)
}

func (p *cCUrlrequestT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (urlrequest *CUrlrequestT) Unref() (ret bool) {
	if urlrequest == nil {
		return
	}
	if urlrequest.beUnrefed == byApp {
		ret = BaseRelease(urlrequest.pc_urlrequest)
		urlrequest.beUnrefed = unrefed
	}
	urlrequest.pc_urlrequest = nil
	return ret
}

///
// Returns the request object used to create this URL request. The returned
// object is read-only and should not be modified.
///
func (self *CUrlrequestT) GetRequest() (ret *CRequestT) {

	cRet := C.cefingo_urlrequest_get_request((*C.cef_urlrequest_t)(self.pc_urlrequest))

	ret = newCRequestT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the client.
///
func (self *CUrlrequestT) GetClient() (ret *CUrlrequestClientT) {

	cRet := C.cefingo_urlrequest_get_client((*C.cef_urlrequest_t)(self.pc_urlrequest))

	ret = newCUrlrequestClientT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the request status.
///
func (self *CUrlrequestT) GetRequestStatus() (ret CUrlrequestStatusT) {

	cRet := C.cefingo_urlrequest_get_request_status((*C.cef_urlrequest_t)(self.pc_urlrequest))

	ret = CUrlrequestStatusT(cRet) // return GoObj
	return ret
}

///
// Returns the request error if status is UR_CANCELED or UR_FAILED, or 0
// otherwise.
///
func (self *CUrlrequestT) GetRequestError() (ret CErrorcodeT) {

	cRet := C.cefingo_urlrequest_get_request_error((*C.cef_urlrequest_t)(self.pc_urlrequest))

	ret = CErrorcodeT(cRet) // return GoObj
	return ret
}

///
// Returns the response, or NULL if no response information is available.
// Response information will only be available after the upload has completed.
// The returned object is read-only and should not be modified.
///
func (self *CUrlrequestT) GetResponse() (ret *CResponseT) {

	cRet := C.cefingo_urlrequest_get_response((*C.cef_urlrequest_t)(self.pc_urlrequest))

	ret = newCResponseT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if the response body was served from the cache. This
// includes responses for which revalidation was required.
///
func (self *CUrlrequestT) ResponseWasCached() (ret bool) {

	cRet := C.cefingo_urlrequest_response_was_cached((*C.cef_urlrequest_t)(self.pc_urlrequest))

	ret = cRet == 1
	return ret
}

///
// Cancel the request.
///
func (self *CUrlrequestT) Cancel() {

	C.cefingo_urlrequest_cancel((*C.cef_urlrequest_t)(self.pc_urlrequest))

}

///
// Create a new URL request that is not associated with a specific browser or
// frame. Use cef_frame_t::CreateURLRequest instead if you want the request to
// have this association, in which case it may be handled differently (see
// documentation on that function). A request created with this function may
// only originate from the browser process, and will behave as follows:
//   - It may be intercepted by the client via CefResourceRequestHandler or
//     CefSchemeHandlerFactory.
//   - POST data may only contain only a single element of type PDE_TYPE_FILE
//     or PDE_TYPE_BYTES.
//   - If |request_context| is empty the global request context will be used.
//
// The |request| object will be marked as read-only after calling this function.
///
func UrlrequestCreate(
	request *CRequestT,
	client *CUrlrequestClientT,
	request_context *CRequestContextT,
) (ret *CUrlrequestT) {
	var goTmprequest *C.cef_request_t
	if request != nil {
		BaseAddRef(request.pc_request)
		goTmprequest = (*C.cef_request_t)(request.pc_request)
	}
	var goTmpclient *C.cef_urlrequest_client_t
	if client != nil {
		BaseAddRef(client.pc_urlrequest_client)
		goTmpclient = (*C.cef_urlrequest_client_t)(client.pc_urlrequest_client)
	}
	var goTmprequest_context *C.cef_request_context_t
	if request_context != nil {
		BaseAddRef(request_context.pc_request_context)
		goTmprequest_context = (*C.cef_request_context_t)(request_context.pc_request_context)
	}

	cRet := C.cef_urlrequest_create(goTmprequest, goTmpclient, goTmprequest_context)

	ret = newCUrlrequestT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure that should be implemented by the cef_urlrequest_t client. The
// functions of this structure will be called on the same thread that created
// the request unless otherwise documented.
///

type cCUrlrequestClientT C.cef_urlrequest_client_t

// Go type for cef_urlrequest_client_t
type CUrlrequestClientT struct {
	noCopy               noCopy
	pc_urlrequest_client *cCUrlrequestClientT
	beUnrefed            unrefedBy
}

func (p *CUrlrequestClientT) Pass() (ret *CUrlrequestClientT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCUrlrequestClientT((*C.cef_urlrequest_client_t)(p.pc_urlrequest_client), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CUrlrequestClientT) NewRef() (newP *CUrlrequestClientT) {
	if self == nil {
		return newP
	}
	gop := self.pc_urlrequest_client
	BaseAddRef(gop)
	newP = newCUrlrequestClientT((*C.cef_urlrequest_client_t)(gop), byApp)
	return newP
}

// Go type CUrlrequestClientT wraps cef type *C.cef_urlrequest_client_t
func newCUrlrequestClientT(p *C.cef_urlrequest_client_t, unrefedBy unrefedBy) *CUrlrequestClientT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T211.1:")
	pc := (*cCUrlrequestClientT)(p)
	go_urlrequest_client := &CUrlrequestClientT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_urlrequest_client, func(g *CUrlrequestClientT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_urlrequest_client != nil {
			Tracef(unsafe.Pointer(g.pc_urlrequest_client), "T211.2:")
			BaseRelease(g.pc_urlrequest_client)
		}
	})

	return go_urlrequest_client
}

// *C.cef_urlrequest_client_t has refCounted interface
func (urlrequest_client *CUrlrequestClientT) HasOneRef() bool {
	return BaseHasOneRef(urlrequest_client.pc_urlrequest_client)
}

func (p *cCUrlrequestClientT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (urlrequest_client *CUrlrequestClientT) Unref() (ret bool) {
	if urlrequest_client == nil {
		return
	}
	if urlrequest_client.beUnrefed == byApp {
		ret = BaseRelease(urlrequest_client.pc_urlrequest_client)
		urlrequest_client.beUnrefed = unrefed
	}
	urlrequest_client.pc_urlrequest_client = nil
	return ret
}

///
// Notifies the client that the request has completed. Use the
// cef_urlrequest_t::GetRequestStatus function to determine if the request was
// successful or not.
///
type OnRequestCompleteHandler interface {
	OnRequestComplete(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
	)
}

///
// Notifies the client of upload progress. |current| denotes the number of
// bytes sent so far and |total| is the total size of uploading data (or -1 if
// chunked upload is enabled). This function will only be called if the
// UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request.
///
type OnUploadProgressHandler interface {
	OnUploadProgress(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
		current int64,
		total int64,
	)
}

///
// Notifies the client of download progress. |current| denotes the number of
// bytes received up to the call and |total| is the expected total size of the
// response (or -1 if not determined).
///
type OnDownloadProgressHandler interface {
	OnDownloadProgress(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
		current int64,
		total int64,
	)
}

///
// Called when some part of the response is read. |data| contains the current
// bytes received since the last call. This function will not be called if the
// UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request.
///
type OnDownloadDataHandler interface {
	OnDownloadData(
		self *CUrlrequestClientT,
		request *CUrlrequestT,
		data []byte,
	)
}

///
// Called on the IO thread when the browser needs credentials from the user.
// |isProxy| indicates whether the host is a proxy server. |host| contains the
// hostname and |port| contains the port number. Return true (1) to continue
// the request and call cef_auth_callback_t::cont() when the authentication
// information is available. If the request has an associated browser/frame
// then returning false (0) will result in a call to GetAuthCredentials on the
// cef_request_handler_t associated with that browser, if any. Otherwise,
// returning false (0) will cancel the request immediately. This function will
// only be called for requests initiated from the browser process.
///
type CUrlrequestClientTGetAuthCredentialsHandler interface {
	GetAuthCredentials(
		self *CUrlrequestClientT,
		isProxy int,
		host string,
		port int,
		realm string,
		scheme string,
		callback *CAuthCallbackT,
	) (ret bool)
}

var urlrequest_client_handlers = struct {
	handler                      map[*cCUrlrequestClientT]interface{}
	on_request_complete_handler  map[*cCUrlrequestClientT]OnRequestCompleteHandler
	on_upload_progress_handler   map[*cCUrlrequestClientT]OnUploadProgressHandler
	on_download_progress_handler map[*cCUrlrequestClientT]OnDownloadProgressHandler
	on_download_data_handler     map[*cCUrlrequestClientT]OnDownloadDataHandler
	get_auth_credentials_handler map[*cCUrlrequestClientT]CUrlrequestClientTGetAuthCredentialsHandler
}{
	map[*cCUrlrequestClientT]interface{}{},
	map[*cCUrlrequestClientT]OnRequestCompleteHandler{},
	map[*cCUrlrequestClientT]OnUploadProgressHandler{},
	map[*cCUrlrequestClientT]OnDownloadProgressHandler{},
	map[*cCUrlrequestClientT]OnDownloadDataHandler{},
	map[*cCUrlrequestClientT]CUrlrequestClientTGetAuthCredentialsHandler{},
}

// allocCUrlrequestClientT allocates CUrlrequestClientT and construct it
func allocCUrlrequestClientT() *CUrlrequestClientT {
	up := c_calloc(1, C.sizeof_cefingo_urlrequest_client_wrapper_t, "T211.3:")
	cefp := C.cefingo_construct_urlrequest_client((*C.cefingo_urlrequest_client_wrapper_t)(up))
	cgop := (*cCUrlrequestClientT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_urlrequest_client_t itself in DeassocFunc,
		// or cef_urlrequest_client_t is never GCed.
		Tracef(up, "T211.4:")
		unbindAllCUrlrequestClientT(cgop)
	}))

	BaseAddRef(cgop)
	return newCUrlrequestClientT(cefp, byApp)
}

// NewCUrlrequestClientT allocates CUrlrequestClientT, construct and bind it
func NewCUrlrequestClientT(a interface{}) *CUrlrequestClientT {
	return allocCUrlrequestClientT().bind(a)
}

func (urlrequest_client *CUrlrequestClientT) bind(a interface{}) *CUrlrequestClientT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := urlrequest_client.pc_urlrequest_client
	urlrequest_client_handlers.handler[cp] = a

	if h, ok := a.(OnRequestCompleteHandler); ok {
		urlrequest_client_handlers.on_request_complete_handler[cp] = h
		noBind = false
	} else {
		delete(urlrequest_client_handlers.on_request_complete_handler, cp)
	}

	if h, ok := a.(OnUploadProgressHandler); ok {
		urlrequest_client_handlers.on_upload_progress_handler[cp] = h
		noBind = false
	} else {
		delete(urlrequest_client_handlers.on_upload_progress_handler, cp)
	}

	if h, ok := a.(OnDownloadProgressHandler); ok {
		urlrequest_client_handlers.on_download_progress_handler[cp] = h
		noBind = false
	} else {
		delete(urlrequest_client_handlers.on_download_progress_handler, cp)
	}

	if h, ok := a.(OnDownloadDataHandler); ok {
		urlrequest_client_handlers.on_download_data_handler[cp] = h
		noBind = false
	} else {
		delete(urlrequest_client_handlers.on_download_data_handler, cp)
	}

	if h, ok := a.(CUrlrequestClientTGetAuthCredentialsHandler); ok {
		urlrequest_client_handlers.get_auth_credentials_handler[cp] = h
		noBind = false
	} else {
		delete(urlrequest_client_handlers.get_auth_credentials_handler, cp)
	}

	if noBind {
		Panicln("F229: *CUrlrequestClientT No bind")
	}
	return urlrequest_client
}

func unbindAllCUrlrequestClientT(cp *cCUrlrequestClientT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := urlrequest_client.pc_urlrequest_client
	delete(urlrequest_client_handlers.handler, cp)

	delete(urlrequest_client_handlers.on_request_complete_handler, cp)
	delete(urlrequest_client_handlers.on_upload_progress_handler, cp)
	delete(urlrequest_client_handlers.on_download_progress_handler, cp)
	delete(urlrequest_client_handlers.on_download_data_handler, cp)
	delete(urlrequest_client_handlers.get_auth_credentials_handler, cp)
}

func (urlrequest_client *CUrlrequestClientT) UnbindAll() {
	unbindAllCUrlrequestClientT(urlrequest_client.pc_urlrequest_client)
	urlrequest_client.Unref()
}

func (urlrequest_client *CUrlrequestClientT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := urlrequest_client.pc_urlrequest_client
	return urlrequest_client_handlers.handler[cp]
}

// cef_v8_capi.h, include/capi/cef_v8_capi.h:141:3,

///
// Structure representing a V8 context handle. V8 handles can only be accessed
// from the thread on which they are created. Valid threads for creating a V8
// handle include the render process main thread (TID_RENDERER) and WebWorker
// threads. A task runner for posting tasks on the associated thread can be
// retrieved via the cef_v8context_t::get_task_runner() function.
///

type cCV8contextT C.cef_v8context_t

// Go type for cef_v8context_t
type CV8contextT struct {
	noCopy       noCopy
	pc_v8context *cCV8contextT
	beUnrefed    unrefedBy
}

func (p *CV8contextT) Pass() (ret *CV8contextT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8contextT((*C.cef_v8context_t)(p.pc_v8context), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8contextT) NewRef() (newP *CV8contextT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8context
	BaseAddRef(gop)
	newP = newCV8contextT((*C.cef_v8context_t)(gop), byApp)
	return newP
}

// Go type CV8contextT wraps cef type *C.cef_v8context_t
func newCV8contextT(p *C.cef_v8context_t, unrefedBy unrefedBy) *CV8contextT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T212.1:")
	pc := (*cCV8contextT)(p)
	go_v8context := &CV8contextT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8context, func(g *CV8contextT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8context != nil {
			Tracef(unsafe.Pointer(g.pc_v8context), "T212.2:")
			BaseRelease(g.pc_v8context)
		}
	})

	return go_v8context
}

// *C.cef_v8context_t has refCounted interface
func (v8context *CV8contextT) HasOneRef() bool {
	return BaseHasOneRef(v8context.pc_v8context)
}

func (p *cCV8contextT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8context *CV8contextT) Unref() (ret bool) {
	if v8context == nil {
		return
	}
	if v8context.beUnrefed == byApp {
		ret = BaseRelease(v8context.pc_v8context)
		v8context.beUnrefed = unrefed
	}
	v8context.pc_v8context = nil
	return ret
}

///
// Returns the task runner associated with this context. V8 handles can only
// be accessed from the thread on which they are created. This function can be
// called on any render process thread.
///
func (self *CV8contextT) GetTaskRunner() (ret *CTaskRunnerT) {

	cRet := C.cefingo_v8context_get_task_runner((*C.cef_v8context_t)(self.pc_v8context))

	ret = newCTaskRunnerT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8contextT) IsValid() (ret bool) {

	cRet := C.cefingo_v8context_is_valid((*C.cef_v8context_t)(self.pc_v8context))

	ret = cRet == 1
	return ret
}

///
// Returns the browser for this context. This function will return an NULL
// reference for WebWorker contexts.
///
func (self *CV8contextT) GetBrowser() (ret *CBrowserT) {

	cRet := C.cefingo_v8context_get_browser((*C.cef_v8context_t)(self.pc_v8context))

	ret = newCBrowserT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the frame for this context. This function will return an NULL
// reference for WebWorker contexts.
///
func (self *CV8contextT) GetFrame() (ret *CFrameT) {

	cRet := C.cefingo_v8context_get_frame((*C.cef_v8context_t)(self.pc_v8context))

	ret = newCFrameT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the global object for this context. The context must be entered
// before calling this function.
///
func (self *CV8contextT) GetGlobal() (ret *CV8valueT) {

	cRet := C.cefingo_v8context_get_global((*C.cef_v8context_t)(self.pc_v8context))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Enter this context. A context must be explicitly entered before creating a
// V8 Object, Array, Function or Date asynchronously. exit() must be called
// the same number of times as enter() before releasing this context. V8
// objects belong to the context in which they are created. Returns true (1)
// if the scope was entered successfully.
///
func (self *CV8contextT) Enter() (ret bool) {

	cRet := C.cefingo_v8context_enter((*C.cef_v8context_t)(self.pc_v8context))

	ret = cRet == 1
	return ret
}

///
// Exit this context. Call this function only after calling enter(). Returns
// true (1) if the scope was exited successfully.
///
func (self *CV8contextT) Exit() (ret bool) {

	cRet := C.cefingo_v8context_exit((*C.cef_v8context_t)(self.pc_v8context))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CV8contextT) IsSame(
	that *CV8contextT,
) (ret bool) {
	var goTmpthat *C.cef_v8context_t
	if that != nil {
		BaseAddRef(that.pc_v8context)
		goTmpthat = (*C.cef_v8context_t)(that.pc_v8context)
	}

	cRet := C.cefingo_v8context_is_same((*C.cef_v8context_t)(self.pc_v8context), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Execute a string of JavaScript code in this V8 context. The |script_url|
// parameter is the URL where the script in question can be found, if any. The
// |start_line| parameter is the base line number to use for error reporting.
// On success |retval| will be set to the return value, if any, and the
// function will return true (1). On failure |exception| will be set to the
// exception, if any, and the function will return false (0).
///
func (self *CV8contextT) Eval(
	code string,
	script_url string,
	start_line int,
) (ret bool, retval *CV8valueT, exception *CV8exceptionT) {
	c_code := create_cef_string(code)
	c_script_url := create_cef_string(script_url)
	var tmpretval *C.cef_v8value_t
	var tmpexception *C.cef_v8exception_t

	cRet := C.cefingo_v8context_eval((*C.cef_v8context_t)(self.pc_v8context), c_code.p_cef_string_t, c_script_url.p_cef_string_t, (C.int)(start_line), &tmpretval, &tmpexception)

	retval = newCV8valueT(tmpretval, byApp)           // Out Param
	exception = newCV8exceptionT(tmpexception, byApp) // Out Param

	ret = cRet == 1
	return ret, retval, exception
}

///
// Returns the current (top) context object in the V8 context stack.
///
func V8contextGetCurrentContext() (ret *CV8contextT) {

	cRet := C.cef_v8context_get_current_context()

	ret = newCV8contextT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the entered (bottom) context object in the V8 context stack.
///
func V8contextGetEnteredContext() (ret *CV8contextT) {

	cRet := C.cef_v8context_get_entered_context()

	ret = newCV8contextT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns true (1) if V8 is currently inside a context.
///
func V8contextInContext() (ret bool) {

	cRet := C.cef_v8context_in_context()

	ret = cRet == 1
	return ret
}

///
// Structure that should be implemented to handle V8 function calls. The
// functions of this structure will be called on the thread associated with the
// V8 function.
///

type cCV8handlerT C.cef_v8handler_t

// Go type for cef_v8handler_t
type CV8handlerT struct {
	noCopy       noCopy
	pc_v8handler *cCV8handlerT
	beUnrefed    unrefedBy
}

func (p *CV8handlerT) Pass() (ret *CV8handlerT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8handlerT((*C.cef_v8handler_t)(p.pc_v8handler), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8handlerT) NewRef() (newP *CV8handlerT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8handler
	BaseAddRef(gop)
	newP = newCV8handlerT((*C.cef_v8handler_t)(gop), byApp)
	return newP
}

// Go type CV8handlerT wraps cef type *C.cef_v8handler_t
func newCV8handlerT(p *C.cef_v8handler_t, unrefedBy unrefedBy) *CV8handlerT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T213.1:")
	pc := (*cCV8handlerT)(p)
	go_v8handler := &CV8handlerT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8handler, func(g *CV8handlerT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8handler != nil {
			Tracef(unsafe.Pointer(g.pc_v8handler), "T213.2:")
			BaseRelease(g.pc_v8handler)
		}
	})

	return go_v8handler
}

// *C.cef_v8handler_t has refCounted interface
func (v8handler *CV8handlerT) HasOneRef() bool {
	return BaseHasOneRef(v8handler.pc_v8handler)
}

func (p *cCV8handlerT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8handler *CV8handlerT) Unref() (ret bool) {
	if v8handler == nil {
		return
	}
	if v8handler.beUnrefed == byApp {
		ret = BaseRelease(v8handler.pc_v8handler)
		v8handler.beUnrefed = unrefed
	}
	v8handler.pc_v8handler = nil
	return ret
}

///
// Handle execution of the function identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the function. |arguments| is the list of
// arguments passed to the function. If execution succeeds set |retval| to the
// function return value. If execution fails set |exception| to the exception
// that will be thrown. Return true (1) if execution was handled.
///
type CV8handlerTExecuteHandler interface {
	Execute(
		self *CV8handlerT,
		name string,
		object *CV8valueT,
		arguments []*CV8valueT,
	) (ret bool, retval *CV8valueT, exception string)
}

var v8handler_handlers = struct {
	handler         map[*cCV8handlerT]interface{}
	execute_handler map[*cCV8handlerT]CV8handlerTExecuteHandler
}{
	map[*cCV8handlerT]interface{}{},
	map[*cCV8handlerT]CV8handlerTExecuteHandler{},
}

// allocCV8handlerT allocates CV8handlerT and construct it
func allocCV8handlerT() *CV8handlerT {
	up := c_calloc(1, C.sizeof_cefingo_v8handler_wrapper_t, "T213.3:")
	cefp := C.cefingo_construct_v8handler((*C.cefingo_v8handler_wrapper_t)(up))
	cgop := (*cCV8handlerT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_v8handler_t itself in DeassocFunc,
		// or cef_v8handler_t is never GCed.
		Tracef(up, "T213.4:")
		unbindAllCV8handlerT(cgop)
	}))

	BaseAddRef(cgop)
	return newCV8handlerT(cefp, byApp)
}

// NewCV8handlerT allocates CV8handlerT, construct and bind it
func NewCV8handlerT(a interface{}) *CV8handlerT {
	return allocCV8handlerT().bind(a)
}

func (v8handler *CV8handlerT) bind(a interface{}) *CV8handlerT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := v8handler.pc_v8handler
	v8handler_handlers.handler[cp] = a

	if h, ok := a.(CV8handlerTExecuteHandler); ok {
		v8handler_handlers.execute_handler[cp] = h
		noBind = false
	} else {
		delete(v8handler_handlers.execute_handler, cp)
	}

	if noBind {
		Panicln("F229: *CV8handlerT No bind")
	}
	return v8handler
}

func unbindAllCV8handlerT(cp *cCV8handlerT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := v8handler.pc_v8handler
	delete(v8handler_handlers.handler, cp)

	delete(v8handler_handlers.execute_handler, cp)
}

func (v8handler *CV8handlerT) UnbindAll() {
	unbindAllCV8handlerT(v8handler.pc_v8handler)
	v8handler.Unref()
}

func (v8handler *CV8handlerT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := v8handler.pc_v8handler
	return v8handler_handlers.handler[cp]
}

///
// Structure that should be implemented to handle V8 accessor calls. Accessor
// identifiers are registered by calling cef_v8value_t::set_value(). The
// functions of this structure will be called on the thread associated with the
// V8 accessor.
///

type cCV8accessorT C.cef_v8accessor_t

// Go type for cef_v8accessor_t
type CV8accessorT struct {
	noCopy        noCopy
	pc_v8accessor *cCV8accessorT
	beUnrefed     unrefedBy
}

func (p *CV8accessorT) Pass() (ret *CV8accessorT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8accessorT((*C.cef_v8accessor_t)(p.pc_v8accessor), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8accessorT) NewRef() (newP *CV8accessorT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8accessor
	BaseAddRef(gop)
	newP = newCV8accessorT((*C.cef_v8accessor_t)(gop), byApp)
	return newP
}

// Go type CV8accessorT wraps cef type *C.cef_v8accessor_t
func newCV8accessorT(p *C.cef_v8accessor_t, unrefedBy unrefedBy) *CV8accessorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T214.1:")
	pc := (*cCV8accessorT)(p)
	go_v8accessor := &CV8accessorT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8accessor, func(g *CV8accessorT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8accessor != nil {
			Tracef(unsafe.Pointer(g.pc_v8accessor), "T214.2:")
			BaseRelease(g.pc_v8accessor)
		}
	})

	return go_v8accessor
}

// *C.cef_v8accessor_t has refCounted interface
func (v8accessor *CV8accessorT) HasOneRef() bool {
	return BaseHasOneRef(v8accessor.pc_v8accessor)
}

func (p *cCV8accessorT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8accessor *CV8accessorT) Unref() (ret bool) {
	if v8accessor == nil {
		return
	}
	if v8accessor.beUnrefed == byApp {
		ret = BaseRelease(v8accessor.pc_v8accessor)
		v8accessor.beUnrefed = unrefed
	}
	v8accessor.pc_v8accessor = nil
	return ret
}

///
// Handle retrieval the accessor value identified by |name|. |object| is the
// receiver (&#39;this&#39; object) of the accessor. If retrieval succeeds set
// |retval| to the return value. If retrieval fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor retrieval was
// handled.
///
type GetHandler interface {
	Get(
		self *CV8accessorT,
		name string,
		object *CV8valueT,
	) (ret bool, retval *CV8valueT, exception string)
}

///
// Handle assignment of the accessor value identified by |name|. |object| is
// the receiver (&#39;this&#39; object) of the accessor. |value| is the new value
// being assigned to the accessor. If assignment fails set |exception| to the
// exception that will be thrown. Return true (1) if accessor assignment was
// handled.
///
type SetHandler interface {
	Set(
		self *CV8accessorT,
		name string,
		object *CV8valueT,
		value *CV8valueT,
	) (ret bool, exception string)
}

var v8accessor_handlers = struct {
	handler     map[*cCV8accessorT]interface{}
	get_handler map[*cCV8accessorT]GetHandler
	set_handler map[*cCV8accessorT]SetHandler
}{
	map[*cCV8accessorT]interface{}{},
	map[*cCV8accessorT]GetHandler{},
	map[*cCV8accessorT]SetHandler{},
}

// allocCV8accessorT allocates CV8accessorT and construct it
func allocCV8accessorT() *CV8accessorT {
	up := c_calloc(1, C.sizeof_cefingo_v8accessor_wrapper_t, "T214.3:")
	cefp := C.cefingo_construct_v8accessor((*C.cefingo_v8accessor_wrapper_t)(up))
	cgop := (*cCV8accessorT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_v8accessor_t itself in DeassocFunc,
		// or cef_v8accessor_t is never GCed.
		Tracef(up, "T214.4:")
		unbindAllCV8accessorT(cgop)
	}))

	BaseAddRef(cgop)
	return newCV8accessorT(cefp, byApp)
}

// NewCV8accessorT allocates CV8accessorT, construct and bind it
func NewCV8accessorT(a interface{}) *CV8accessorT {
	return allocCV8accessorT().bind(a)
}

func (v8accessor *CV8accessorT) bind(a interface{}) *CV8accessorT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := v8accessor.pc_v8accessor
	v8accessor_handlers.handler[cp] = a

	if h, ok := a.(GetHandler); ok {
		v8accessor_handlers.get_handler[cp] = h
		noBind = false
	} else {
		delete(v8accessor_handlers.get_handler, cp)
	}

	if h, ok := a.(SetHandler); ok {
		v8accessor_handlers.set_handler[cp] = h
		noBind = false
	} else {
		delete(v8accessor_handlers.set_handler, cp)
	}

	if noBind {
		Panicln("F229: *CV8accessorT No bind")
	}
	return v8accessor
}

func unbindAllCV8accessorT(cp *cCV8accessorT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := v8accessor.pc_v8accessor
	delete(v8accessor_handlers.handler, cp)

	delete(v8accessor_handlers.get_handler, cp)
	delete(v8accessor_handlers.set_handler, cp)
}

func (v8accessor *CV8accessorT) UnbindAll() {
	unbindAllCV8accessorT(v8accessor.pc_v8accessor)
	v8accessor.Unref()
}

func (v8accessor *CV8accessorT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := v8accessor.pc_v8accessor
	return v8accessor_handlers.handler[cp]
}

///
// Structure that should be implemented to handle V8 interceptor calls. The
// functions of this structure will be called on the thread associated with the
// V8 interceptor. Interceptor's named property handlers (with first argument of
// type CefString) are called when object is indexed by string. Indexed property
// handlers (with first argument of type int) are called when object is indexed
// by integer.
///

type cCV8interceptorT C.cef_v8interceptor_t

// Go type for cef_v8interceptor_t
type CV8interceptorT struct {
	noCopy           noCopy
	pc_v8interceptor *cCV8interceptorT
	beUnrefed        unrefedBy
}

func (p *CV8interceptorT) Pass() (ret *CV8interceptorT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8interceptorT((*C.cef_v8interceptor_t)(p.pc_v8interceptor), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8interceptorT) NewRef() (newP *CV8interceptorT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8interceptor
	BaseAddRef(gop)
	newP = newCV8interceptorT((*C.cef_v8interceptor_t)(gop), byApp)
	return newP
}

// Go type CV8interceptorT wraps cef type *C.cef_v8interceptor_t
func newCV8interceptorT(p *C.cef_v8interceptor_t, unrefedBy unrefedBy) *CV8interceptorT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T215.1:")
	pc := (*cCV8interceptorT)(p)
	go_v8interceptor := &CV8interceptorT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8interceptor, func(g *CV8interceptorT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8interceptor != nil {
			Tracef(unsafe.Pointer(g.pc_v8interceptor), "T215.2:")
			BaseRelease(g.pc_v8interceptor)
		}
	})

	return go_v8interceptor
}

// *C.cef_v8interceptor_t has refCounted interface
func (v8interceptor *CV8interceptorT) HasOneRef() bool {
	return BaseHasOneRef(v8interceptor.pc_v8interceptor)
}

func (p *cCV8interceptorT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8interceptor *CV8interceptorT) Unref() (ret bool) {
	if v8interceptor == nil {
		return
	}
	if v8interceptor.beUnrefed == byApp {
		ret = BaseRelease(v8interceptor.pc_v8interceptor)
		v8interceptor.beUnrefed = unrefed
	}
	v8interceptor.pc_v8interceptor = nil
	return ret
}

///
// Handle retrieval of the interceptor value identified by |name|. |object| is
// the receiver (&#39;this&#39; object) of the interceptor. If retrieval succeeds, set
// |retval| to the return value. If the requested value does not exist, don&#39;t
// set either |retval| or |exception|. If retrieval fails, set |exception| to
// the exception that will be thrown. If the property has an associated
// accessor, it will be called only if you don&#39;t set |retval|. Return true (1)
// if interceptor retrieval was handled, false (0) otherwise.
///
func (self *CV8interceptorT) GetByname(
	name string,
	object *CV8valueT,
) (ret bool, retval *CV8valueT, exception string) {
	c_name := create_cef_string(name)
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		BaseAddRef(object.pc_v8value)
		goTmpobject = (*C.cef_v8value_t)(object.pc_v8value)
	}
	var tmpretval *C.cef_v8value_t
	tmpc_exception := create_cef_string("")

	cRet := C.cefingo_v8interceptor_get_byname((*C.cef_v8interceptor_t)(self.pc_v8interceptor), c_name.p_cef_string_t, goTmpobject, &tmpretval, tmpc_exception.p_cef_string_t)

	retval = newCV8valueT(tmpretval, byApp) // Out Param
	exception = string_from_cef_string(tmpc_exception.p_cef_string_t)

	ret = cRet == 1
	return ret, retval, exception
}

///
// Handle retrieval of the interceptor value identified by |index|. |object|
// is the receiver (&#39;this&#39; object) of the interceptor. If retrieval succeeds,
// set |retval| to the return value. If the requested value does not exist,
// don&#39;t set either |retval| or |exception|. If retrieval fails, set
// |exception| to the exception that will be thrown. Return true (1) if
// interceptor retrieval was handled, false (0) otherwise.
///
func (self *CV8interceptorT) GetByindex(
	index int,
	object *CV8valueT,
) (ret bool, retval *CV8valueT, exception string) {
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		BaseAddRef(object.pc_v8value)
		goTmpobject = (*C.cef_v8value_t)(object.pc_v8value)
	}
	var tmpretval *C.cef_v8value_t
	tmpc_exception := create_cef_string("")

	cRet := C.cefingo_v8interceptor_get_byindex((*C.cef_v8interceptor_t)(self.pc_v8interceptor), (C.int)(index), goTmpobject, &tmpretval, tmpc_exception.p_cef_string_t)

	retval = newCV8valueT(tmpretval, byApp) // Out Param
	exception = string_from_cef_string(tmpc_exception.p_cef_string_t)

	ret = cRet == 1
	return ret, retval, exception
}

///
// Handle assignment of the interceptor value identified by |name|. |object|
// is the receiver (&#39;this&#39; object) of the interceptor. |value| is the new
// value being assigned to the interceptor. If assignment fails, set
// |exception| to the exception that will be thrown. This setter will always
// be called, even when the property has an associated accessor. Return true
// (1) if interceptor assignment was handled, false (0) otherwise.
///
func (self *CV8interceptorT) SetByname(
	name string,
	object *CV8valueT,
	value *CV8valueT,
) (ret bool, exception string) {
	c_name := create_cef_string(name)
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		BaseAddRef(object.pc_v8value)
		goTmpobject = (*C.cef_v8value_t)(object.pc_v8value)
	}
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		BaseAddRef(value.pc_v8value)
		goTmpvalue = (*C.cef_v8value_t)(value.pc_v8value)
	}
	tmpc_exception := create_cef_string("")

	cRet := C.cefingo_v8interceptor_set_byname((*C.cef_v8interceptor_t)(self.pc_v8interceptor), c_name.p_cef_string_t, goTmpobject, goTmpvalue, tmpc_exception.p_cef_string_t)

	exception = string_from_cef_string(tmpc_exception.p_cef_string_t)

	ret = cRet == 1
	return ret, exception
}

///
// Handle assignment of the interceptor value identified by |index|. |object|
// is the receiver (&#39;this&#39; object) of the interceptor. |value| is the new
// value being assigned to the interceptor. If assignment fails, set
// |exception| to the exception that will be thrown. Return true (1) if
// interceptor assignment was handled, false (0) otherwise.
///
func (self *CV8interceptorT) SetByindex(
	index int,
	object *CV8valueT,
	value *CV8valueT,
) (ret bool, exception string) {
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		BaseAddRef(object.pc_v8value)
		goTmpobject = (*C.cef_v8value_t)(object.pc_v8value)
	}
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		BaseAddRef(value.pc_v8value)
		goTmpvalue = (*C.cef_v8value_t)(value.pc_v8value)
	}
	tmpc_exception := create_cef_string("")

	cRet := C.cefingo_v8interceptor_set_byindex((*C.cef_v8interceptor_t)(self.pc_v8interceptor), (C.int)(index), goTmpobject, goTmpvalue, tmpc_exception.p_cef_string_t)

	exception = string_from_cef_string(tmpc_exception.p_cef_string_t)

	ret = cRet == 1
	return ret, exception
}

///
// Structure representing a V8 exception. The functions of this structure may be
// called on any render process thread.
///

type cCV8exceptionT C.cef_v8exception_t

// Go type for cef_v8exception_t
type CV8exceptionT struct {
	noCopy         noCopy
	pc_v8exception *cCV8exceptionT
	beUnrefed      unrefedBy
}

func (p *CV8exceptionT) Pass() (ret *CV8exceptionT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8exceptionT((*C.cef_v8exception_t)(p.pc_v8exception), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8exceptionT) NewRef() (newP *CV8exceptionT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8exception
	BaseAddRef(gop)
	newP = newCV8exceptionT((*C.cef_v8exception_t)(gop), byApp)
	return newP
}

// Go type CV8exceptionT wraps cef type *C.cef_v8exception_t
func newCV8exceptionT(p *C.cef_v8exception_t, unrefedBy unrefedBy) *CV8exceptionT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T216.1:")
	pc := (*cCV8exceptionT)(p)
	go_v8exception := &CV8exceptionT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8exception, func(g *CV8exceptionT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8exception != nil {
			Tracef(unsafe.Pointer(g.pc_v8exception), "T216.2:")
			BaseRelease(g.pc_v8exception)
		}
	})

	return go_v8exception
}

// *C.cef_v8exception_t has refCounted interface
func (v8exception *CV8exceptionT) HasOneRef() bool {
	return BaseHasOneRef(v8exception.pc_v8exception)
}

func (p *cCV8exceptionT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8exception *CV8exceptionT) Unref() (ret bool) {
	if v8exception == nil {
		return
	}
	if v8exception.beUnrefed == byApp {
		ret = BaseRelease(v8exception.pc_v8exception)
		v8exception.beUnrefed = unrefed
	}
	v8exception.pc_v8exception = nil
	return ret
}

///
// Returns the exception message.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8exceptionT) GetMessage() (ret string) {

	cRet := C.cefingo_v8exception_get_message((*C.cef_v8exception_t)(self.pc_v8exception))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the line of source code that the exception occurred within.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8exceptionT) GetSourceLine() (ret string) {

	cRet := C.cefingo_v8exception_get_source_line((*C.cef_v8exception_t)(self.pc_v8exception))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the resource name for the script from where the function causing
// the error originates.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8exceptionT) GetScriptResourceName() (ret string) {

	cRet := C.cefingo_v8exception_get_script_resource_name((*C.cef_v8exception_t)(self.pc_v8exception))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the 1-based number of the line where the error occurred or 0 if the
// line number is unknown.
///
func (self *CV8exceptionT) GetLineNumber() (ret bool) {

	cRet := C.cefingo_v8exception_get_line_number((*C.cef_v8exception_t)(self.pc_v8exception))

	ret = cRet == 1
	return ret
}

///
// Returns the index within the script of the first character where the error
// occurred.
///
func (self *CV8exceptionT) GetStartPosition() (ret bool) {

	cRet := C.cefingo_v8exception_get_start_position((*C.cef_v8exception_t)(self.pc_v8exception))

	ret = cRet == 1
	return ret
}

///
// Returns the index within the script of the last character where the error
// occurred.
///
func (self *CV8exceptionT) GetEndPosition() (ret bool) {

	cRet := C.cefingo_v8exception_get_end_position((*C.cef_v8exception_t)(self.pc_v8exception))

	ret = cRet == 1
	return ret
}

///
// Returns the index within the line of the first character where the error
// occurred.
///
func (self *CV8exceptionT) GetStartColumn() (ret bool) {

	cRet := C.cefingo_v8exception_get_start_column((*C.cef_v8exception_t)(self.pc_v8exception))

	ret = cRet == 1
	return ret
}

///
// Returns the index within the line of the last character where the error
// occurred.
///
func (self *CV8exceptionT) GetEndColumn() (ret bool) {

	cRet := C.cefingo_v8exception_get_end_column((*C.cef_v8exception_t)(self.pc_v8exception))

	ret = cRet == 1
	return ret
}

///
// Callback structure that is passed to cef_v8value_t::CreateArrayBuffer.
///

type cCV8arrayBufferReleaseCallbackT C.cef_v8array_buffer_release_callback_t

// Go type for cef_v8array_buffer_release_callback_t
type CV8arrayBufferReleaseCallbackT struct {
	noCopy                             noCopy
	pc_v8array_buffer_release_callback *cCV8arrayBufferReleaseCallbackT
	beUnrefed                          unrefedBy
}

func (p *CV8arrayBufferReleaseCallbackT) Pass() (ret *CV8arrayBufferReleaseCallbackT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8arrayBufferReleaseCallbackT((*C.cef_v8array_buffer_release_callback_t)(p.pc_v8array_buffer_release_callback), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8arrayBufferReleaseCallbackT) NewRef() (newP *CV8arrayBufferReleaseCallbackT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8array_buffer_release_callback
	BaseAddRef(gop)
	newP = newCV8arrayBufferReleaseCallbackT((*C.cef_v8array_buffer_release_callback_t)(gop), byApp)
	return newP
}

// Go type CV8arrayBufferReleaseCallbackT wraps cef type *C.cef_v8array_buffer_release_callback_t
func newCV8arrayBufferReleaseCallbackT(p *C.cef_v8array_buffer_release_callback_t, unrefedBy unrefedBy) *CV8arrayBufferReleaseCallbackT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T217.1:")
	pc := (*cCV8arrayBufferReleaseCallbackT)(p)
	go_v8array_buffer_release_callback := &CV8arrayBufferReleaseCallbackT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8array_buffer_release_callback, func(g *CV8arrayBufferReleaseCallbackT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8array_buffer_release_callback != nil {
			Tracef(unsafe.Pointer(g.pc_v8array_buffer_release_callback), "T217.2:")
			BaseRelease(g.pc_v8array_buffer_release_callback)
		}
	})

	return go_v8array_buffer_release_callback
}

// *C.cef_v8array_buffer_release_callback_t has refCounted interface
func (v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT) HasOneRef() bool {
	return BaseHasOneRef(v8array_buffer_release_callback.pc_v8array_buffer_release_callback)
}

func (p *cCV8arrayBufferReleaseCallbackT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT) Unref() (ret bool) {
	if v8array_buffer_release_callback == nil {
		return
	}
	if v8array_buffer_release_callback.beUnrefed == byApp {
		ret = BaseRelease(v8array_buffer_release_callback.pc_v8array_buffer_release_callback)
		v8array_buffer_release_callback.beUnrefed = unrefed
	}
	v8array_buffer_release_callback.pc_v8array_buffer_release_callback = nil
	return ret
}

///
// Called to release |buffer| when the ArrayBuffer JS object is garbage
// collected. |buffer| is the value that was passed to CreateArrayBuffer along
// with this object.
///
type ReleaseBufferHandler interface {
	ReleaseBuffer(
		self *CV8arrayBufferReleaseCallbackT,
		buffer unsafe.Pointer,
	)
}

var v8array_buffer_release_callback_handlers = struct {
	handler                map[*cCV8arrayBufferReleaseCallbackT]interface{}
	release_buffer_handler map[*cCV8arrayBufferReleaseCallbackT]ReleaseBufferHandler
}{
	map[*cCV8arrayBufferReleaseCallbackT]interface{}{},
	map[*cCV8arrayBufferReleaseCallbackT]ReleaseBufferHandler{},
}

// allocCV8arrayBufferReleaseCallbackT allocates CV8arrayBufferReleaseCallbackT and construct it
func allocCV8arrayBufferReleaseCallbackT() *CV8arrayBufferReleaseCallbackT {
	up := c_calloc(1, C.sizeof_cefingo_v8array_buffer_release_callback_wrapper_t, "T217.3:")
	cefp := C.cefingo_construct_v8array_buffer_release_callback((*C.cefingo_v8array_buffer_release_callback_wrapper_t)(up))
	cgop := (*cCV8arrayBufferReleaseCallbackT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_v8array_buffer_release_callback_t itself in DeassocFunc,
		// or cef_v8array_buffer_release_callback_t is never GCed.
		Tracef(up, "T217.4:")
		unbindAllCV8arrayBufferReleaseCallbackT(cgop)
	}))

	BaseAddRef(cgop)
	return newCV8arrayBufferReleaseCallbackT(cefp, byApp)
}

// NewCV8arrayBufferReleaseCallbackT allocates CV8arrayBufferReleaseCallbackT, construct and bind it
func NewCV8arrayBufferReleaseCallbackT(a interface{}) *CV8arrayBufferReleaseCallbackT {
	return allocCV8arrayBufferReleaseCallbackT().bind(a)
}

func (v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT) bind(a interface{}) *CV8arrayBufferReleaseCallbackT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := v8array_buffer_release_callback.pc_v8array_buffer_release_callback
	v8array_buffer_release_callback_handlers.handler[cp] = a

	if h, ok := a.(ReleaseBufferHandler); ok {
		v8array_buffer_release_callback_handlers.release_buffer_handler[cp] = h
		noBind = false
	} else {
		delete(v8array_buffer_release_callback_handlers.release_buffer_handler, cp)
	}

	if noBind {
		Panicln("F229: *CV8arrayBufferReleaseCallbackT No bind")
	}
	return v8array_buffer_release_callback
}

func unbindAllCV8arrayBufferReleaseCallbackT(cp *cCV8arrayBufferReleaseCallbackT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := v8array_buffer_release_callback.pc_v8array_buffer_release_callback
	delete(v8array_buffer_release_callback_handlers.handler, cp)

	delete(v8array_buffer_release_callback_handlers.release_buffer_handler, cp)
}

func (v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT) UnbindAll() {
	unbindAllCV8arrayBufferReleaseCallbackT(v8array_buffer_release_callback.pc_v8array_buffer_release_callback)
	v8array_buffer_release_callback.Unref()
}

func (v8array_buffer_release_callback *CV8arrayBufferReleaseCallbackT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := v8array_buffer_release_callback.pc_v8array_buffer_release_callback
	return v8array_buffer_release_callback_handlers.handler[cp]
}

///
// Structure representing a V8 value handle. V8 handles can only be accessed
// from the thread on which they are created. Valid threads for creating a V8
// handle include the render process main thread (TID_RENDERER) and WebWorker
// threads. A task runner for posting tasks on the associated thread can be
// retrieved via the cef_v8context_t::get_task_runner() function.
///

type cCV8valueT C.cef_v8value_t

// Go type for cef_v8value_t
type CV8valueT struct {
	noCopy     noCopy
	pc_v8value *cCV8valueT
	beUnrefed  unrefedBy
}

func (p *CV8valueT) Pass() (ret *CV8valueT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8valueT((*C.cef_v8value_t)(p.pc_v8value), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8valueT) NewRef() (newP *CV8valueT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8value
	BaseAddRef(gop)
	newP = newCV8valueT((*C.cef_v8value_t)(gop), byApp)
	return newP
}

// Go type CV8valueT wraps cef type *C.cef_v8value_t
func newCV8valueT(p *C.cef_v8value_t, unrefedBy unrefedBy) *CV8valueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T218.1:")
	pc := (*cCV8valueT)(p)
	go_v8value := &CV8valueT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8value, func(g *CV8valueT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8value != nil {
			Tracef(unsafe.Pointer(g.pc_v8value), "T218.2:")
			BaseRelease(g.pc_v8value)
		}
	})

	return go_v8value
}

// *C.cef_v8value_t has refCounted interface
func (v8value *CV8valueT) HasOneRef() bool {
	return BaseHasOneRef(v8value.pc_v8value)
}

func (p *cCV8valueT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8value *CV8valueT) Unref() (ret bool) {
	if v8value == nil {
		return
	}
	if v8value.beUnrefed == byApp {
		ret = BaseRelease(v8value.pc_v8value)
		v8value.beUnrefed = unrefed
	}
	v8value.pc_v8value = nil
	return ret
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8valueT) IsValid() (ret bool) {

	cRet := C.cefingo_v8value_is_valid((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is undefined.
///
func (self *CV8valueT) IsUndefined() (ret bool) {

	cRet := C.cefingo_v8value_is_undefined((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is null.
///
func (self *CV8valueT) IsNull() (ret bool) {

	cRet := C.cefingo_v8value_is_null((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is bool.
///
func (self *CV8valueT) IsBool() (ret bool) {

	cRet := C.cefingo_v8value_is_bool((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is int.
///
func (self *CV8valueT) IsInt() (ret bool) {

	cRet := C.cefingo_v8value_is_int((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is unsigned int.
///
func (self *CV8valueT) IsUint() (ret bool) {

	cRet := C.cefingo_v8value_is_uint((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is double.
///
func (self *CV8valueT) IsDouble() (ret bool) {

	cRet := C.cefingo_v8value_is_double((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is Date.
///
func (self *CV8valueT) IsDate() (ret bool) {

	cRet := C.cefingo_v8value_is_date((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is string.
///
func (self *CV8valueT) IsString() (ret bool) {

	cRet := C.cefingo_v8value_is_string((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is object.
///
func (self *CV8valueT) IsObject() (ret bool) {

	cRet := C.cefingo_v8value_is_object((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is array.
///
func (self *CV8valueT) IsArray() (ret bool) {

	cRet := C.cefingo_v8value_is_array((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is an ArrayBuffer.
///
func (self *CV8valueT) IsArrayBuffer() (ret bool) {

	cRet := C.cefingo_v8value_is_array_buffer((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// True if the value type is function.
///
func (self *CV8valueT) IsFunction() (ret bool) {

	cRet := C.cefingo_v8value_is_function((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is pointing to the same handle as |that|
// object.
///
func (self *CV8valueT) IsSame(
	that *CV8valueT,
) (ret bool) {
	var goTmpthat *C.cef_v8value_t
	if that != nil {
		BaseAddRef(that.pc_v8value)
		goTmpthat = (*C.cef_v8value_t)(that.pc_v8value)
	}

	cRet := C.cefingo_v8value_is_same((*C.cef_v8value_t)(self.pc_v8value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Return a bool value.
///
func (self *CV8valueT) GetBoolValue() (ret bool) {

	cRet := C.cefingo_v8value_get_bool_value((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Return an int value.
///
func (self *CV8valueT) GetIntValue() (ret int32) {

	cRet := C.cefingo_v8value_get_int_value((*C.cef_v8value_t)(self.pc_v8value))

	ret = (int32)(cRet) // return GoObj
	return ret
}

///
// Return an unsigned int value.
///
func (self *CV8valueT) GetUintValue() (ret uint32) {

	cRet := C.cefingo_v8value_get_uint_value((*C.cef_v8value_t)(self.pc_v8value))

	ret = (uint32)(cRet) // return GoObj
	return ret
}

///
// Return a double value.
///
func (self *CV8valueT) GetDoubleValue() (ret float64) {

	cRet := C.cefingo_v8value_get_double_value((*C.cef_v8value_t)(self.pc_v8value))

	ret = (float64)(cRet) // return GoObj
	return ret
}

///
// Return a Date value.
///
func (self *CV8valueT) GetDateValue() (ret CTimeT) {

	cRet := C.cefingo_v8value_get_date_value((*C.cef_v8value_t)(self.pc_v8value))

	ret = (CTimeT)(cRet) // return GoObj
	return ret
}

///
// Return a string value.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8valueT) GetStringValue() (ret string) {

	cRet := C.cefingo_v8value_get_string_value((*C.cef_v8value_t)(self.pc_v8value))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this is a user created object.
///
func (self *CV8valueT) IsUserCreated() (ret bool) {

	cRet := C.cefingo_v8value_is_user_created((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the last function call resulted in an exception. This
// attribute exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) HasException() (ret bool) {

	cRet := C.cefingo_v8value_has_exception((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Returns the exception resulting from the last function call. This attribute
// exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) GetException() (ret *CV8exceptionT) {

	cRet := C.cefingo_v8value_get_exception((*C.cef_v8value_t)(self.pc_v8value))

	ret = newCV8exceptionT(cRet, byApp) // return GoObj
	return ret
}

///
// Clears the last exception and returns true (1) on success.
///
func (self *CV8valueT) ClearException() (ret bool) {

	cRet := C.cefingo_v8value_clear_exception((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object will re-throw future exceptions. This
// attribute exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) WillRethrowExceptions() (ret bool) {

	cRet := C.cefingo_v8value_will_rethrow_exceptions((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Set whether this object will re-throw future exceptions. By default
// exceptions are not re-thrown. If a exception is re-thrown the current
// context should not be accessed again until after the exception has been
// caught and not re-thrown. Returns true (1) on success. This attribute
// exists only in the scope of the current CEF value object.
///
func (self *CV8valueT) SetRethrowExceptions(
	rethrow int,
) (ret bool) {

	cRet := C.cefingo_v8value_set_rethrow_exceptions((*C.cef_v8value_t)(self.pc_v8value), (C.int)(rethrow))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the object has a value with the specified identifier.
///
func (self *CV8valueT) HasValueBykey(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_v8value_has_value_bykey((*C.cef_v8value_t)(self.pc_v8value), c_key.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the object has a value with the specified identifier.
///
func (self *CV8valueT) HasValueByindex(
	index int,
) (ret bool) {

	cRet := C.cefingo_v8value_has_value_byindex((*C.cef_v8value_t)(self.pc_v8value), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Deletes the value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly or an
// exception is thrown. For read-only and don&#39;t-delete values this function
// will return true (1) even though deletion failed.
///
func (self *CV8valueT) DeleteValueBykey(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_v8value_delete_value_bykey((*C.cef_v8value_t)(self.pc_v8value), c_key.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Deletes the value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly, deletion
// fails or an exception is thrown. For read-only and don&#39;t-delete values this
// function will return true (1) even though deletion failed.
///
func (self *CV8valueT) DeleteValueByindex(
	index int,
) (ret bool) {

	cRet := C.cefingo_v8value_delete_value_byindex((*C.cef_v8value_t)(self.pc_v8value), (C.int)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the value with the specified identifier on success. Returns NULL if
// this function is called incorrectly or an exception is thrown.
///
func (self *CV8valueT) GetValueBykey(
	key string,
) (ret *CV8valueT) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_v8value_get_value_bykey((*C.cef_v8value_t)(self.pc_v8value), c_key.p_cef_string_t)

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the value with the specified identifier on success. Returns NULL if
// this function is called incorrectly or an exception is thrown.
///
func (self *CV8valueT) GetValueByindex(
	index int,
) (ret *CV8valueT) {

	cRet := C.cefingo_v8value_get_value_byindex((*C.cef_v8value_t)(self.pc_v8value), (C.int)(index))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Associates a value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly or an
// exception is thrown. For read-only values this function will return true
// (1) even though assignment failed.
///
func (self *CV8valueT) SetValueBykey(
	key string,
	value *CV8valueT,
	attribute CV8PropertyattributeT,
) (ret bool) {
	c_key := create_cef_string(key)
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		BaseAddRef(value.pc_v8value)
		goTmpvalue = (*C.cef_v8value_t)(value.pc_v8value)
	}

	cRet := C.cefingo_v8value_set_value_bykey((*C.cef_v8value_t)(self.pc_v8value), c_key.p_cef_string_t, goTmpvalue, (C.cef_v8_propertyattribute_t)(attribute))

	ret = cRet == 1
	return ret
}

///
// Associates a value with the specified identifier and returns true (1) on
// success. Returns false (0) if this function is called incorrectly or an
// exception is thrown. For read-only values this function will return true
// (1) even though assignment failed.
///
func (self *CV8valueT) SetValueByindex(
	index int,
	value *CV8valueT,
) (ret bool) {
	var goTmpvalue *C.cef_v8value_t
	if value != nil {
		BaseAddRef(value.pc_v8value)
		goTmpvalue = (*C.cef_v8value_t)(value.pc_v8value)
	}

	cRet := C.cefingo_v8value_set_value_byindex((*C.cef_v8value_t)(self.pc_v8value), (C.int)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Registers an identifier and returns true (1) on success. Access to the
// identifier will be forwarded to the cef_v8accessor_t instance passed to
// cef_v8value_t::cef_v8value_create_object(). Returns false (0) if this
// function is called incorrectly or an exception is thrown. For read-only
// values this function will return true (1) even though assignment failed.
///
func (self *CV8valueT) SetValueByaccessor(
	key string,
	settings CV8AccesscontrolT,
	attribute CV8PropertyattributeT,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_v8value_set_value_byaccessor((*C.cef_v8value_t)(self.pc_v8value), c_key.p_cef_string_t, (C.cef_v8_accesscontrol_t)(settings), (C.cef_v8_propertyattribute_t)(attribute))

	ret = cRet == 1
	return ret
}

///
// Read the keys for the object&#39;s values into the specified vector. Integer-
// based keys will also be returned as strings.
///
func (self *CV8valueT) GetKeys(
	keys CStringListT,
) (ret bool) {

	cRet := C.cefingo_v8value_get_keys((*C.cef_v8value_t)(self.pc_v8value), (C.cef_string_list_t)(keys))

	ret = cRet == 1
	return ret
}

///
// Returns the amount of externally allocated memory registered for the
// object.
///
func (self *CV8valueT) GetExternallyAllocatedMemory() (ret bool) {

	cRet := C.cefingo_v8value_get_externally_allocated_memory((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Adjusts the amount of registered external memory for the object. Used to
// give V8 an indication of the amount of externally allocated memory that is
// kept alive by JavaScript objects. V8 uses this information to decide when
// to perform global garbage collection. Each cef_v8value_t tracks the amount
// of external memory associated with it and automatically decreases the
// global total by the appropriate amount on its destruction.
// |change_in_bytes| specifies the number of bytes to adjust by. This function
// returns the number of bytes associated with the object after the
// adjustment. This function can only be called on user created objects.
///
func (self *CV8valueT) AdjustExternallyAllocatedMemory(
	change_in_bytes int,
) (ret bool) {

	cRet := C.cefingo_v8value_adjust_externally_allocated_memory((*C.cef_v8value_t)(self.pc_v8value), (C.int)(change_in_bytes))

	ret = cRet == 1
	return ret
}

///
// Returns the number of elements in the array.
///
func (self *CV8valueT) GetArrayLength() (ret bool) {

	cRet := C.cefingo_v8value_get_array_length((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Returns the ReleaseCallback object associated with the ArrayBuffer or NULL
// if the ArrayBuffer was not created with CreateArrayBuffer.
///
func (self *CV8valueT) GetArrayBufferReleaseCallback() (ret *CV8arrayBufferReleaseCallbackT) {

	cRet := C.cefingo_v8value_get_array_buffer_release_callback((*C.cef_v8value_t)(self.pc_v8value))

	ret = newCV8arrayBufferReleaseCallbackT(cRet, byApp) // return GoObj
	return ret
}

///
// Prevent the ArrayBuffer from using it&#39;s memory block by setting the length
// to zero. This operation cannot be undone. If the ArrayBuffer was created
// with CreateArrayBuffer then
// cef_v8array_buffer_release_callback_t::ReleaseBuffer will be called to
// release the underlying buffer.
///
func (self *CV8valueT) NeuterArrayBuffer() (ret bool) {

	cRet := C.cefingo_v8value_neuter_array_buffer((*C.cef_v8value_t)(self.pc_v8value))

	ret = cRet == 1
	return ret
}

///
// Returns the function name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8valueT) GetFunctionName() (ret string) {

	cRet := C.cefingo_v8value_get_function_name((*C.cef_v8value_t)(self.pc_v8value))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the function handler or NULL if not a CEF-created function.
///
func (self *CV8valueT) GetFunctionHandler() (ret *CV8handlerT) {

	cRet := C.cefingo_v8value_get_function_handler((*C.cef_v8value_t)(self.pc_v8value))

	ret = newCV8handlerT(cRet, byApp) // return GoObj
	return ret
}

///
// Execute the function using the current V8 context. This function should
// only be called from within the scope of a cef_v8handler_t or
// cef_v8accessor_t callback, or in combination with calling enter() and
// exit() on a stored cef_v8context_t reference. |object| is the receiver
// (&#39;this&#39; object) of the function. If |object| is NULL the current context&#39;s
// global object will be used. |arguments| is the list of arguments that will
// be passed to the function. Returns the function return value on success.
// Returns NULL if this function is called incorrectly or an exception is
// thrown.
///
func (self *CV8valueT) ExecuteFunction(
	object *CV8valueT,
	arguments []*CV8valueT,
) (ret *CV8valueT) {
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		BaseAddRef(object.pc_v8value)
		goTmpobject = (*C.cef_v8value_t)(object.pc_v8value)
	}
	argumentsCount := len(arguments)
	tmparguments := c_calloc(C.size_t(argumentsCount), (C.size_t)(unsafe.Sizeof(arguments[0])), "T218.3:cef_v8value_t::execute_function::arguments")
	slice := (*[1 << 30]*C.cef_v8value_t)(tmparguments)[:argumentsCount:argumentsCount]
	for i, v := range arguments {
		cefp := v.pc_v8value
		if cefp != nil {
			BaseAddRef(cefp)
		}
		slice[i] = (*C.cef_v8value_t)(cefp)
	}

	cRet := C.cefingo_v8value_execute_function((*C.cef_v8value_t)(self.pc_v8value), goTmpobject, (C.size_t)(argumentsCount), (**C.cef_v8value_t)(tmparguments))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Execute the function using the specified V8 context. |object| is the
// receiver (&#39;this&#39; object) of the function. If |object| is NULL the specified
// context&#39;s global object will be used. |arguments| is the list of arguments
// that will be passed to the function. Returns the function return value on
// success. Returns NULL if this function is called incorrectly or an
// exception is thrown.
///
func (self *CV8valueT) ExecuteFunctionWithContext(
	context *CV8contextT,
	object *CV8valueT,
	arguments []*CV8valueT,
) (ret *CV8valueT) {
	var goTmpcontext *C.cef_v8context_t
	if context != nil {
		BaseAddRef(context.pc_v8context)
		goTmpcontext = (*C.cef_v8context_t)(context.pc_v8context)
	}
	var goTmpobject *C.cef_v8value_t
	if object != nil {
		BaseAddRef(object.pc_v8value)
		goTmpobject = (*C.cef_v8value_t)(object.pc_v8value)
	}
	argumentsCount := len(arguments)
	tmparguments := c_calloc(C.size_t(argumentsCount), (C.size_t)(unsafe.Sizeof(arguments[0])), "T218.4:cef_v8value_t::execute_function_with_context::arguments")
	slice := (*[1 << 30]*C.cef_v8value_t)(tmparguments)[:argumentsCount:argumentsCount]
	for i, v := range arguments {
		cefp := v.pc_v8value
		if cefp != nil {
			BaseAddRef(cefp)
		}
		slice[i] = (*C.cef_v8value_t)(cefp)
	}

	cRet := C.cefingo_v8value_execute_function_with_context((*C.cef_v8value_t)(self.pc_v8value), goTmpcontext, goTmpobject, (C.size_t)(argumentsCount), (**C.cef_v8value_t)(tmparguments))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type undefined.
///
func V8valueCreateUndefined() (ret *CV8valueT) {

	cRet := C.cef_v8value_create_undefined()

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type null.
///
func V8valueCreateNull() (ret *CV8valueT) {

	cRet := C.cef_v8value_create_null()

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type bool.
///
func V8valueCreateBool(
	value int,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_bool((C.int)(value))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type int.
///
func V8valueCreateInt(
	value int32,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_int((C.int32)(value))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type unsigned int.
///
func V8valueCreateUint(
	value uint32,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_uint((C.uint32)(value))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type double.
///
func V8valueCreateDouble(
	value float64,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_double((C.double)(value))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type Date. This function should only be
// called from within the scope of a cef_render_process_handler_t,
// cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
// enter() and exit() on a stored cef_v8context_t reference.
///
func V8valueCreateDate(
	date *CTimeT,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_date((*C.cef_time_t)(date))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type string.
///
func V8valueCreateString(
	value string,
) (ret *CV8valueT) {
	c_value := create_cef_string(value)

	cRet := C.cef_v8value_create_string(c_value.p_cef_string_t)

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type object with optional accessor
// and/or interceptor. This function should only be called from within the scope
// of a cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t
// callback, or in combination with calling enter() and exit() on a stored
// cef_v8context_t reference.
///
func V8valueCreateObject(
	accessor *CV8accessorT,
	interceptor *CV8interceptorT,
) (ret *CV8valueT) {
	var goTmpaccessor *C.cef_v8accessor_t
	if accessor != nil {
		BaseAddRef(accessor.pc_v8accessor)
		goTmpaccessor = (*C.cef_v8accessor_t)(accessor.pc_v8accessor)
	}
	var goTmpinterceptor *C.cef_v8interceptor_t
	if interceptor != nil {
		BaseAddRef(interceptor.pc_v8interceptor)
		goTmpinterceptor = (*C.cef_v8interceptor_t)(interceptor.pc_v8interceptor)
	}

	cRet := C.cef_v8value_create_object(goTmpaccessor, goTmpinterceptor)

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type array with the specified |length|.
// If |length| is negative the returned array will have length 0. This function
// should only be called from within the scope of a
// cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,
// or in combination with calling enter() and exit() on a stored cef_v8context_t
// reference.
///
func V8valueCreateArray(
	length int,
) (ret *CV8valueT) {

	cRet := C.cef_v8value_create_array((C.int)(length))

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type ArrayBuffer which wraps the
// provided |buffer| of size |length| bytes. The ArrayBuffer is externalized,
// meaning that it does not own |buffer|. The caller is responsible for freeing
// |buffer| when requested via a call to cef_v8array_buffer_release_callback_t::
// ReleaseBuffer. This function should only be called from within the scope of a
// cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,
// or in combination with calling enter() and exit() on a stored cef_v8context_t
// reference.
///
func V8valueCreateArrayBuffer(
	buffer unsafe.Pointer,
	length int64,
	release_callback *CV8arrayBufferReleaseCallbackT,
) (ret *CV8valueT) {
	var goTmprelease_callback *C.cef_v8array_buffer_release_callback_t
	if release_callback != nil {
		BaseAddRef(release_callback.pc_v8array_buffer_release_callback)
		goTmprelease_callback = (*C.cef_v8array_buffer_release_callback_t)(release_callback.pc_v8array_buffer_release_callback)
	}

	cRet := C.cef_v8value_create_array_buffer(buffer, (C.size_t)(length), goTmprelease_callback)

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Create a new cef_v8value_t object of type function. This function should only
// be called from within the scope of a cef_render_process_handler_t,
// cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling
// enter() and exit() on a stored cef_v8context_t reference.
///
func V8valueCreateFunction(
	name string,
	handler *CV8handlerT,
) (ret *CV8valueT) {
	c_name := create_cef_string(name)
	var goTmphandler *C.cef_v8handler_t
	if handler != nil {
		BaseAddRef(handler.pc_v8handler)
		goTmphandler = (*C.cef_v8handler_t)(handler.pc_v8handler)
	}

	cRet := C.cef_v8value_create_function(c_name.p_cef_string_t, goTmphandler)

	ret = newCV8valueT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure representing a V8 stack trace handle. V8 handles can only be
// accessed from the thread on which they are created. Valid threads for
// creating a V8 handle include the render process main thread (TID_RENDERER)
// and WebWorker threads. A task runner for posting tasks on the associated
// thread can be retrieved via the cef_v8context_t::get_task_runner() function.
///

type cCV8stackTraceT C.cef_v8stack_trace_t

// Go type for cef_v8stack_trace_t
type CV8stackTraceT struct {
	noCopy           noCopy
	pc_v8stack_trace *cCV8stackTraceT
	beUnrefed        unrefedBy
}

func (p *CV8stackTraceT) Pass() (ret *CV8stackTraceT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8stackTraceT((*C.cef_v8stack_trace_t)(p.pc_v8stack_trace), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8stackTraceT) NewRef() (newP *CV8stackTraceT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8stack_trace
	BaseAddRef(gop)
	newP = newCV8stackTraceT((*C.cef_v8stack_trace_t)(gop), byApp)
	return newP
}

// Go type CV8stackTraceT wraps cef type *C.cef_v8stack_trace_t
func newCV8stackTraceT(p *C.cef_v8stack_trace_t, unrefedBy unrefedBy) *CV8stackTraceT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T219.1:")
	pc := (*cCV8stackTraceT)(p)
	go_v8stack_trace := &CV8stackTraceT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8stack_trace, func(g *CV8stackTraceT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8stack_trace != nil {
			Tracef(unsafe.Pointer(g.pc_v8stack_trace), "T219.2:")
			BaseRelease(g.pc_v8stack_trace)
		}
	})

	return go_v8stack_trace
}

// *C.cef_v8stack_trace_t has refCounted interface
func (v8stack_trace *CV8stackTraceT) HasOneRef() bool {
	return BaseHasOneRef(v8stack_trace.pc_v8stack_trace)
}

func (p *cCV8stackTraceT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8stack_trace *CV8stackTraceT) Unref() (ret bool) {
	if v8stack_trace == nil {
		return
	}
	if v8stack_trace.beUnrefed == byApp {
		ret = BaseRelease(v8stack_trace.pc_v8stack_trace)
		v8stack_trace.beUnrefed = unrefed
	}
	v8stack_trace.pc_v8stack_trace = nil
	return ret
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8stackTraceT) IsValid() (ret bool) {

	cRet := C.cefingo_v8stack_trace_is_valid((*C.cef_v8stack_trace_t)(self.pc_v8stack_trace))

	ret = cRet == 1
	return ret
}

///
// Returns the number of stack frames.
///
func (self *CV8stackTraceT) GetFrameCount() (ret bool) {

	cRet := C.cefingo_v8stack_trace_get_frame_count((*C.cef_v8stack_trace_t)(self.pc_v8stack_trace))

	ret = cRet == 1
	return ret
}

///
// Returns the stack frame at the specified 0-based index.
///
func (self *CV8stackTraceT) GetFrame(
	index int,
) (ret *CV8stackFrameT) {

	cRet := C.cefingo_v8stack_trace_get_frame((*C.cef_v8stack_trace_t)(self.pc_v8stack_trace), (C.int)(index))

	ret = newCV8stackFrameT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the stack trace for the currently active context. |frame_limit| is
// the maximum number of frames that will be captured.
///
func V8stackTraceGetCurrent(
	frame_limit int,
) (ret *CV8stackTraceT) {

	cRet := C.cef_v8stack_trace_get_current((C.int)(frame_limit))

	ret = newCV8stackTraceT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure representing a V8 stack frame handle. V8 handles can only be
// accessed from the thread on which they are created. Valid threads for
// creating a V8 handle include the render process main thread (TID_RENDERER)
// and WebWorker threads. A task runner for posting tasks on the associated
// thread can be retrieved via the cef_v8context_t::get_task_runner() function.
///

type cCV8stackFrameT C.cef_v8stack_frame_t

// Go type for cef_v8stack_frame_t
type CV8stackFrameT struct {
	noCopy           noCopy
	pc_v8stack_frame *cCV8stackFrameT
	beUnrefed        unrefedBy
}

func (p *CV8stackFrameT) Pass() (ret *CV8stackFrameT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCV8stackFrameT((*C.cef_v8stack_frame_t)(p.pc_v8stack_frame), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CV8stackFrameT) NewRef() (newP *CV8stackFrameT) {
	if self == nil {
		return newP
	}
	gop := self.pc_v8stack_frame
	BaseAddRef(gop)
	newP = newCV8stackFrameT((*C.cef_v8stack_frame_t)(gop), byApp)
	return newP
}

// Go type CV8stackFrameT wraps cef type *C.cef_v8stack_frame_t
func newCV8stackFrameT(p *C.cef_v8stack_frame_t, unrefedBy unrefedBy) *CV8stackFrameT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T220.1:")
	pc := (*cCV8stackFrameT)(p)
	go_v8stack_frame := &CV8stackFrameT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_v8stack_frame, func(g *CV8stackFrameT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_v8stack_frame != nil {
			Tracef(unsafe.Pointer(g.pc_v8stack_frame), "T220.2:")
			BaseRelease(g.pc_v8stack_frame)
		}
	})

	return go_v8stack_frame
}

// *C.cef_v8stack_frame_t has refCounted interface
func (v8stack_frame *CV8stackFrameT) HasOneRef() bool {
	return BaseHasOneRef(v8stack_frame.pc_v8stack_frame)
}

func (p *cCV8stackFrameT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (v8stack_frame *CV8stackFrameT) Unref() (ret bool) {
	if v8stack_frame == nil {
		return
	}
	if v8stack_frame.beUnrefed == byApp {
		ret = BaseRelease(v8stack_frame.pc_v8stack_frame)
		v8stack_frame.beUnrefed = unrefed
	}
	v8stack_frame.pc_v8stack_frame = nil
	return ret
}

///
// Returns true (1) if the underlying handle is valid and it can be accessed
// on the current thread. Do not call any other functions if this function
// returns false (0).
///
func (self *CV8stackFrameT) IsValid() (ret bool) {

	cRet := C.cefingo_v8stack_frame_is_valid((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	ret = cRet == 1
	return ret
}

///
// Returns the name of the resource script that contains the function.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8stackFrameT) GetScriptName() (ret string) {

	cRet := C.cefingo_v8stack_frame_get_script_name((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the name of the resource script that contains the function or the
// sourceURL value if the script name is undefined and its source ends with a
// &quot;//@ sourceURL=...&quot; string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8stackFrameT) GetScriptNameOrSourceUrl() (ret string) {

	cRet := C.cefingo_v8stack_frame_get_script_name_or_source_url((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the name of the function.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CV8stackFrameT) GetFunctionName() (ret string) {

	cRet := C.cefingo_v8stack_frame_get_function_name((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the 1-based line number for the function call or 0 if unknown.
///
func (self *CV8stackFrameT) GetLineNumber() (ret bool) {

	cRet := C.cefingo_v8stack_frame_get_line_number((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	ret = cRet == 1
	return ret
}

///
// Returns the 1-based column offset on the line for the function call or 0 if
// unknown.
///
func (self *CV8stackFrameT) GetColumn() (ret bool) {

	cRet := C.cefingo_v8stack_frame_get_column((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the function was compiled using eval().
///
func (self *CV8stackFrameT) IsEval() (ret bool) {

	cRet := C.cefingo_v8stack_frame_is_eval((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the function was called as a constructor via &quot;new&quot;.
///
func (self *CV8stackFrameT) IsConstructor() (ret bool) {

	cRet := C.cefingo_v8stack_frame_is_constructor((*C.cef_v8stack_frame_t)(self.pc_v8stack_frame))

	ret = cRet == 1
	return ret
}

///
// Register a new V8 extension with the specified JavaScript extension code and
// handler. Functions implemented by the handler are prototyped using the
// keyword 'native'. The calling of a native function is restricted to the scope
// in which the prototype of the native function is defined. This function may
// only be called on the render process main thread.
//
// Example JavaScript extension code: <pre>
//   // create the 'example' global object if it doesn't already exist.
//   if (!example)
//     example = {};
//   // create the 'example.test' global object if it doesn't already exist.
//   if (!example.test)
//     example.test = {};
//   (function() {
//     // Define the function 'example.test.myfunction'.
//     example.test.myfunction = function() {
//       // Call CefV8Handler::Execute() with the function name 'MyFunction'
//       // and no arguments.
//       native function MyFunction();
//       return MyFunction();
//     };
//     // Define the getter function for parameter 'example.test.myparam'.
//     example.test.__defineGetter__('myparam', function() {
//       // Call CefV8Handler::Execute() with the function name 'GetMyParam'
//       // and no arguments.
//       native function GetMyParam();
//       return GetMyParam();
//     });
//     // Define the setter function for parameter 'example.test.myparam'.
//     example.test.__defineSetter__('myparam', function(b) {
//       // Call CefV8Handler::Execute() with the function name 'SetMyParam'
//       // and a single argument.
//       native function SetMyParam();
//       if(b) SetMyParam(b);
//     });
//
//     // Extension definitions can also contain normal JavaScript variables
//     // and functions.
//     var myint = 0;
//     example.test.increment = function() {
//       myint += 1;
//       return myint;
//     };
//   })();
// </pre> Example usage in the page: <pre>
//   // Call the function.
//   example.test.myfunction();
//   // Set the parameter.
//   example.test.myparam = value;
//   // Get the parameter.
//   value = example.test.myparam;
//   // Call another function.
//   example.test.increment();
// </pre>
///
func RegisterExtension(
	extension_name string,
	javascript_code string,
	handler *CV8handlerT,
) (ret bool) {
	c_extension_name := create_cef_string(extension_name)
	c_javascript_code := create_cef_string(javascript_code)
	var goTmphandler *C.cef_v8handler_t
	if handler != nil {
		BaseAddRef(handler.pc_v8handler)
		goTmphandler = (*C.cef_v8handler_t)(handler.pc_v8handler)
	}

	cRet := C.cef_register_extension(c_extension_name.p_cef_string_t, c_javascript_code.p_cef_string_t, goTmphandler)

	ret = cRet == 1
	return ret
}

// cef_values_capi.h, include/capi/cef_values_capi.h:217:3,

///
// Structure that wraps other data value types. Complex types (binary,
// dictionary and list) will be referenced but not owned by this object. Can be
// used on any process and thread.
///

type cCValueT C.cef_value_t

// Go type for cef_value_t
type CValueT struct {
	noCopy    noCopy
	pc_value  *cCValueT
	beUnrefed unrefedBy
}

func (p *CValueT) Pass() (ret *CValueT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCValueT((*C.cef_value_t)(p.pc_value), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CValueT) NewRef() (newP *CValueT) {
	if self == nil {
		return newP
	}
	gop := self.pc_value
	BaseAddRef(gop)
	newP = newCValueT((*C.cef_value_t)(gop), byApp)
	return newP
}

// Go type CValueT wraps cef type *C.cef_value_t
func newCValueT(p *C.cef_value_t, unrefedBy unrefedBy) *CValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T221.1:")
	pc := (*cCValueT)(p)
	go_value := &CValueT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_value, func(g *CValueT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_value != nil {
			Tracef(unsafe.Pointer(g.pc_value), "T221.2:")
			BaseRelease(g.pc_value)
		}
	})

	return go_value
}

// *C.cef_value_t has refCounted interface
func (value *CValueT) HasOneRef() bool {
	return BaseHasOneRef(value.pc_value)
}

func (p *cCValueT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (value *CValueT) Unref() (ret bool) {
	if value == nil {
		return
	}
	if value.beUnrefed == byApp {
		ret = BaseRelease(value.pc_value)
		value.beUnrefed = unrefed
	}
	value.pc_value = nil
	return ret
}

///
// Returns true (1) if the underlying data is valid. This will always be true
// (1) for simple types. For complex types (binary, dictionary and list) the
// underlying data may become invalid if owned by another object (e.g. list or
// dictionary) and that other object is then modified or destroyed. This value
// object can be re-used by calling Set*() even if the underlying data is
// invalid.
///
func (self *CValueT) IsValid() (ret bool) {

	cRet := C.cefingo_value_is_valid((*C.cef_value_t)(self.pc_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the underlying data is owned by another object.
///
func (self *CValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_value_is_owned((*C.cef_value_t)(self.pc_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the underlying data is read-only. Some APIs may expose
// read-only objects.
///
func (self *CValueT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_value_is_read_only((*C.cef_value_t)(self.pc_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data. If true (1) modifications to this object will also affect |that|
// object and vice-versa.
///
func (self *CValueT) IsSame(
	that *CValueT,
) (ret bool) {
	var goTmpthat *C.cef_value_t
	if that != nil {
		BaseAddRef(that.pc_value)
		goTmpthat = (*C.cef_value_t)(that.pc_value)
	}

	cRet := C.cefingo_value_is_same((*C.cef_value_t)(self.pc_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CValueT) IsEqual(
	that *CValueT,
) (ret bool) {
	var goTmpthat *C.cef_value_t
	if that != nil {
		BaseAddRef(that.pc_value)
		goTmpthat = (*C.cef_value_t)(that.pc_value)
	}

	cRet := C.cefingo_value_is_equal((*C.cef_value_t)(self.pc_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a copy of this object. The underlying data will also be copied.
///
func (self *CValueT) Copy() (ret *CValueT) {

	cRet := C.cefingo_value_copy((*C.cef_value_t)(self.pc_value))

	ret = newCValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the underlying value type.
///
func (self *CValueT) GetType() (ret CValueTypeT) {

	cRet := C.cefingo_value_get_type((*C.cef_value_t)(self.pc_value))

	ret = CValueTypeT(cRet) // return GoObj
	return ret
}

///
// Returns the underlying value as type bool.
///
func (self *CValueT) GetBool() (ret bool) {

	cRet := C.cefingo_value_get_bool((*C.cef_value_t)(self.pc_value))

	ret = cRet == 1
	return ret
}

///
// Returns the underlying value as type int.
///
func (self *CValueT) GetInt() (ret bool) {

	cRet := C.cefingo_value_get_int((*C.cef_value_t)(self.pc_value))

	ret = cRet == 1
	return ret
}

///
// Returns the underlying value as type double.
///
func (self *CValueT) GetDouble() (ret float64) {

	cRet := C.cefingo_value_get_double((*C.cef_value_t)(self.pc_value))

	ret = (float64)(cRet) // return GoObj
	return ret
}

///
// Returns the underlying value as type string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CValueT) GetString() (ret string) {

	cRet := C.cefingo_value_get_string((*C.cef_value_t)(self.pc_value))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the underlying value as type binary. The returned reference may
// become invalid if the value is owned by another object or if ownership is
// transferred to another object in the future. To maintain a reference to the
// value after assigning ownership to a dictionary or list pass this object to
// the set_value() function instead of passing the returned reference to
// set_binary().
///
func (self *CValueT) GetBinary() (ret *CBinaryValueT) {

	cRet := C.cefingo_value_get_binary((*C.cef_value_t)(self.pc_value))

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the underlying value as type dictionary. The returned reference may
// become invalid if the value is owned by another object or if ownership is
// transferred to another object in the future. To maintain a reference to the
// value after assigning ownership to a dictionary or list pass this object to
// the set_value() function instead of passing the returned reference to
// set_dictionary().
///
func (self *CValueT) GetDictionary() (ret *CDictionaryValueT) {

	cRet := C.cefingo_value_get_dictionary((*C.cef_value_t)(self.pc_value))

	ret = newCDictionaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the underlying value as type list. The returned reference may
// become invalid if the value is owned by another object or if ownership is
// transferred to another object in the future. To maintain a reference to the
// value after assigning ownership to a dictionary or list pass this object to
// the set_value() function instead of passing the returned reference to
// set_list().
///
func (self *CValueT) GetList() (ret *CListValueT) {

	cRet := C.cefingo_value_get_list((*C.cef_value_t)(self.pc_value))

	ret = newCListValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the underlying value as type null. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetNull() (ret bool) {

	cRet := C.cefingo_value_set_null((*C.cef_value_t)(self.pc_value))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type bool. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetBool(
	value bool,
) (ret bool) {
	var tmpvalue int
	if value {
		tmpvalue = 1
	}

	cRet := C.cefingo_value_set_bool((*C.cef_value_t)(self.pc_value), C.int(tmpvalue))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type int. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetInt(
	value int,
) (ret bool) {

	cRet := C.cefingo_value_set_int((*C.cef_value_t)(self.pc_value), (C.int)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type double. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetDouble(
	value float64,
) (ret bool) {

	cRet := C.cefingo_value_set_double((*C.cef_value_t)(self.pc_value), (C.double)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type string. Returns true (1) if the value was
// set successfully.
///
func (self *CValueT) SetString(
	value string,
) (ret bool) {
	c_value := create_cef_string(value)

	cRet := C.cefingo_value_set_string((*C.cef_value_t)(self.pc_value), c_value.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type binary. Returns true (1) if the value was
// set successfully. This object keeps a reference to |value| and ownership of
// the underlying data remains unchanged.
///
func (self *CValueT) SetBinary(
	value *CBinaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_binary_value_t
	if value != nil {
		BaseAddRef(value.pc_binary_value)
		goTmpvalue = (*C.cef_binary_value_t)(value.pc_binary_value)
	}

	cRet := C.cefingo_value_set_binary((*C.cef_value_t)(self.pc_value), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type dict. Returns true (1) if the value was
// set successfully. This object keeps a reference to |value| and ownership of
// the underlying data remains unchanged.
///
func (self *CValueT) SetDictionary(
	value *CDictionaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_dictionary_value_t
	if value != nil {
		BaseAddRef(value.pc_dictionary_value)
		goTmpvalue = (*C.cef_dictionary_value_t)(value.pc_dictionary_value)
	}

	cRet := C.cefingo_value_set_dictionary((*C.cef_value_t)(self.pc_value), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the underlying value as type list. Returns true (1) if the value was
// set successfully. This object keeps a reference to |value| and ownership of
// the underlying data remains unchanged.
///
func (self *CValueT) SetList(
	value *CListValueT,
) (ret bool) {
	var goTmpvalue *C.cef_list_value_t
	if value != nil {
		BaseAddRef(value.pc_list_value)
		goTmpvalue = (*C.cef_list_value_t)(value.pc_list_value)
	}

	cRet := C.cefingo_value_set_list((*C.cef_value_t)(self.pc_value), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Creates a new object.
///
func ValueCreate() (ret *CValueT) {

	cRet := C.cef_value_create()

	ret = newCValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure representing a binary value. Can be used on any process and thread.
///

type cCBinaryValueT C.cef_binary_value_t

// Go type for cef_binary_value_t
type CBinaryValueT struct {
	noCopy          noCopy
	pc_binary_value *cCBinaryValueT
	beUnrefed       unrefedBy
}

func (p *CBinaryValueT) Pass() (ret *CBinaryValueT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCBinaryValueT((*C.cef_binary_value_t)(p.pc_binary_value), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CBinaryValueT) NewRef() (newP *CBinaryValueT) {
	if self == nil {
		return newP
	}
	gop := self.pc_binary_value
	BaseAddRef(gop)
	newP = newCBinaryValueT((*C.cef_binary_value_t)(gop), byApp)
	return newP
}

// Go type CBinaryValueT wraps cef type *C.cef_binary_value_t
func newCBinaryValueT(p *C.cef_binary_value_t, unrefedBy unrefedBy) *CBinaryValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T222.1:")
	pc := (*cCBinaryValueT)(p)
	go_binary_value := &CBinaryValueT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_binary_value, func(g *CBinaryValueT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_binary_value != nil {
			Tracef(unsafe.Pointer(g.pc_binary_value), "T222.2:")
			BaseRelease(g.pc_binary_value)
		}
	})

	return go_binary_value
}

// *C.cef_binary_value_t has refCounted interface
func (binary_value *CBinaryValueT) HasOneRef() bool {
	return BaseHasOneRef(binary_value.pc_binary_value)
}

func (p *cCBinaryValueT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (binary_value *CBinaryValueT) Unref() (ret bool) {
	if binary_value == nil {
		return
	}
	if binary_value.beUnrefed == byApp {
		ret = BaseRelease(binary_value.pc_binary_value)
		binary_value.beUnrefed = unrefed
	}
	binary_value.pc_binary_value = nil
	return ret
}

///
// Returns true (1) if this object is valid. This object may become invalid if
// the underlying data is owned by another object (e.g. list or dictionary)
// and that other object is then modified or destroyed. Do not call any other
// functions if this function returns false (0).
///
func (self *CBinaryValueT) IsValid() (ret bool) {

	cRet := C.cefingo_binary_value_is_valid((*C.cef_binary_value_t)(self.pc_binary_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is currently owned by another object.
///
func (self *CBinaryValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_binary_value_is_owned((*C.cef_binary_value_t)(self.pc_binary_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data.
///
func (self *CBinaryValueT) IsSame(
	that *CBinaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_binary_value_t
	if that != nil {
		BaseAddRef(that.pc_binary_value)
		goTmpthat = (*C.cef_binary_value_t)(that.pc_binary_value)
	}

	cRet := C.cefingo_binary_value_is_same((*C.cef_binary_value_t)(self.pc_binary_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CBinaryValueT) IsEqual(
	that *CBinaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_binary_value_t
	if that != nil {
		BaseAddRef(that.pc_binary_value)
		goTmpthat = (*C.cef_binary_value_t)(that.pc_binary_value)
	}

	cRet := C.cefingo_binary_value_is_equal((*C.cef_binary_value_t)(self.pc_binary_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a copy of this object. The data in this object will also be copied.
///
func (self *CBinaryValueT) Copy() (ret *CBinaryValueT) {

	cRet := C.cefingo_binary_value_copy((*C.cef_binary_value_t)(self.pc_binary_value))

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the data size.
///
func (self *CBinaryValueT) GetSize() (ret int64) {

	cRet := C.cefingo_binary_value_get_size((*C.cef_binary_value_t)(self.pc_binary_value))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Read up to |buffer_size| number of bytes into |buffer|. Reading begins at
// the specified byte |data_offset|. Returns the number of bytes read.
///
func (self *CBinaryValueT) GetData(
	buffer unsafe.Pointer,
	buffer_size int64,
	data_offset int64,
) (ret int64) {

	cRet := C.cefingo_binary_value_get_data((*C.cef_binary_value_t)(self.pc_binary_value), buffer, (C.size_t)(buffer_size), (C.size_t)(data_offset))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Creates a new object that is not owned by any other object. The specified
// |data| will be copied.
///
func BinaryValueCreate(
	data []byte,
) (ret *CBinaryValueT) {
	data_size := len(data)
	tmpdata := C.CBytes(data)
	defer C.free(tmpdata)

	cRet := C.cef_binary_value_create(tmpdata, (C.size_t)(data_size))

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure representing a dictionary value. Can be used on any process and
// thread.
///

type cCDictionaryValueT C.cef_dictionary_value_t

// Go type for cef_dictionary_value_t
type CDictionaryValueT struct {
	noCopy              noCopy
	pc_dictionary_value *cCDictionaryValueT
	beUnrefed           unrefedBy
}

func (p *CDictionaryValueT) Pass() (ret *CDictionaryValueT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCDictionaryValueT((*C.cef_dictionary_value_t)(p.pc_dictionary_value), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CDictionaryValueT) NewRef() (newP *CDictionaryValueT) {
	if self == nil {
		return newP
	}
	gop := self.pc_dictionary_value
	BaseAddRef(gop)
	newP = newCDictionaryValueT((*C.cef_dictionary_value_t)(gop), byApp)
	return newP
}

// Go type CDictionaryValueT wraps cef type *C.cef_dictionary_value_t
func newCDictionaryValueT(p *C.cef_dictionary_value_t, unrefedBy unrefedBy) *CDictionaryValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T223.1:")
	pc := (*cCDictionaryValueT)(p)
	go_dictionary_value := &CDictionaryValueT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_dictionary_value, func(g *CDictionaryValueT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_dictionary_value != nil {
			Tracef(unsafe.Pointer(g.pc_dictionary_value), "T223.2:")
			BaseRelease(g.pc_dictionary_value)
		}
	})

	return go_dictionary_value
}

// *C.cef_dictionary_value_t has refCounted interface
func (dictionary_value *CDictionaryValueT) HasOneRef() bool {
	return BaseHasOneRef(dictionary_value.pc_dictionary_value)
}

func (p *cCDictionaryValueT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (dictionary_value *CDictionaryValueT) Unref() (ret bool) {
	if dictionary_value == nil {
		return
	}
	if dictionary_value.beUnrefed == byApp {
		ret = BaseRelease(dictionary_value.pc_dictionary_value)
		dictionary_value.beUnrefed = unrefed
	}
	dictionary_value.pc_dictionary_value = nil
	return ret
}

///
// Returns true (1) if this object is valid. This object may become invalid if
// the underlying data is owned by another object (e.g. list or dictionary)
// and that other object is then modified or destroyed. Do not call any other
// functions if this function returns false (0).
///
func (self *CDictionaryValueT) IsValid() (ret bool) {

	cRet := C.cefingo_dictionary_value_is_valid((*C.cef_dictionary_value_t)(self.pc_dictionary_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is currently owned by another object.
///
func (self *CDictionaryValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_dictionary_value_is_owned((*C.cef_dictionary_value_t)(self.pc_dictionary_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CDictionaryValueT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_dictionary_value_is_read_only((*C.cef_dictionary_value_t)(self.pc_dictionary_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data. If true (1) modifications to this object will also affect |that|
// object and vice-versa.
///
func (self *CDictionaryValueT) IsSame(
	that *CDictionaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_dictionary_value_t
	if that != nil {
		BaseAddRef(that.pc_dictionary_value)
		goTmpthat = (*C.cef_dictionary_value_t)(that.pc_dictionary_value)
	}

	cRet := C.cefingo_dictionary_value_is_same((*C.cef_dictionary_value_t)(self.pc_dictionary_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CDictionaryValueT) IsEqual(
	that *CDictionaryValueT,
) (ret bool) {
	var goTmpthat *C.cef_dictionary_value_t
	if that != nil {
		BaseAddRef(that.pc_dictionary_value)
		goTmpthat = (*C.cef_dictionary_value_t)(that.pc_dictionary_value)
	}

	cRet := C.cefingo_dictionary_value_is_equal((*C.cef_dictionary_value_t)(self.pc_dictionary_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object. If |exclude_NULL_children| is true
// (1) any NULL dictionaries or lists will be excluded from the copy.
///
func (self *CDictionaryValueT) Copy(
	exclude_empty_children int,
) (ret *CDictionaryValueT) {

	cRet := C.cefingo_dictionary_value_copy((*C.cef_dictionary_value_t)(self.pc_dictionary_value), (C.int)(exclude_empty_children))

	ret = newCDictionaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the number of values.
///
func (self *CDictionaryValueT) GetSize() (ret int64) {

	cRet := C.cefingo_dictionary_value_get_size((*C.cef_dictionary_value_t)(self.pc_dictionary_value))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Removes all values. Returns true (1) on success.
///
func (self *CDictionaryValueT) Clear() (ret bool) {

	cRet := C.cefingo_dictionary_value_clear((*C.cef_dictionary_value_t)(self.pc_dictionary_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the current dictionary has a value for the given key.
///
func (self *CDictionaryValueT) HasKey(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_has_key((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Reads all keys for this dictionary into the specified vector.
///
func (self *CDictionaryValueT) GetKeys(
	keys CStringListT,
) (ret bool) {

	cRet := C.cefingo_dictionary_value_get_keys((*C.cef_dictionary_value_t)(self.pc_dictionary_value), (C.cef_string_list_t)(keys))

	ret = cRet == 1
	return ret
}

///
// Removes the value at the specified key. Returns true (1) is the value was
// removed successfully.
///
func (self *CDictionaryValueT) Remove(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_remove((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the value type for the specified key.
///
func (self *CDictionaryValueT) GetType(
	key string,
) (ret CValueTypeT) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_type((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = CValueTypeT(cRet) // return GoObj
	return ret
}

///
// Returns the value at the specified key. For simple types the returned value
// will copy existing data and modifications to the value will not modify this
// object. For complex types (binary, dictionary and list) the returned value
// will reference existing data and modifications to the value will modify
// this object.
///
func (self *CDictionaryValueT) GetValue(
	key string,
) (ret *CValueT) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_value((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = newCValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the value at the specified key as type bool.
///
func (self *CDictionaryValueT) GetBool(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_bool((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the value at the specified key as type int.
///
func (self *CDictionaryValueT) GetInt(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_int((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Returns the value at the specified key as type double.
///
func (self *CDictionaryValueT) GetDouble(
	key string,
) (ret float64) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_double((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = (float64)(cRet) // return GoObj
	return ret
}

///
// Returns the value at the specified key as type string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CDictionaryValueT) GetString(
	key string,
) (ret string) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_string((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the value at the specified key as type binary. The returned value
// will reference existing data.
///
func (self *CDictionaryValueT) GetBinary(
	key string,
) (ret *CBinaryValueT) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_binary((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the value at the specified key as type dictionary. The returned
// value will reference existing data and modifications to the value will
// modify this object.
///
func (self *CDictionaryValueT) GetDictionary(
	key string,
) (ret *CDictionaryValueT) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_dictionary((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = newCDictionaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the value at the specified key as type list. The returned value
// will reference existing data and modifications to the value will modify
// this object.
///
func (self *CDictionaryValueT) GetList(
	key string,
) (ret *CListValueT) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_get_list((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = newCListValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the value at the specified key. Returns true (1) if the value was set
// successfully. If |value| represents simple data then the underlying data
// will be copied and modifications to |value| will not modify this object. If
// |value| represents complex data (binary, dictionary or list) then the
// underlying data will be referenced and modifications to |value| will modify
// this object.
///
func (self *CDictionaryValueT) SetValue(
	key string,
	value *CValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	var goTmpvalue *C.cef_value_t
	if value != nil {
		BaseAddRef(value.pc_value)
		goTmpvalue = (*C.cef_value_t)(value.pc_value)
	}

	cRet := C.cefingo_dictionary_value_set_value((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type null. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetNull(
	key string,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_set_null((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type bool. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetBool(
	key string,
	value bool,
) (ret bool) {
	c_key := create_cef_string(key)
	var tmpvalue int
	if value {
		tmpvalue = 1
	}

	cRet := C.cefingo_dictionary_value_set_bool((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, C.int(tmpvalue))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type int. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetInt(
	key string,
	value int,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_set_int((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, (C.int)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type double. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetDouble(
	key string,
	value float64,
) (ret bool) {
	c_key := create_cef_string(key)

	cRet := C.cefingo_dictionary_value_set_double((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, (C.double)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type string. Returns true (1) if the
// value was set successfully.
///
func (self *CDictionaryValueT) SetString(
	key string,
	value string,
) (ret bool) {
	c_key := create_cef_string(key)
	c_value := create_cef_string(value)

	cRet := C.cefingo_dictionary_value_set_string((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, c_value.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type binary. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CDictionaryValueT) SetBinary(
	key string,
	value *CBinaryValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	var goTmpvalue *C.cef_binary_value_t
	if value != nil {
		BaseAddRef(value.pc_binary_value)
		goTmpvalue = (*C.cef_binary_value_t)(value.pc_binary_value)
	}

	cRet := C.cefingo_dictionary_value_set_binary((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type dict. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CDictionaryValueT) SetDictionary(
	key string,
	value *CDictionaryValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	var goTmpvalue *C.cef_dictionary_value_t
	if value != nil {
		BaseAddRef(value.pc_dictionary_value)
		goTmpvalue = (*C.cef_dictionary_value_t)(value.pc_dictionary_value)
	}

	cRet := C.cefingo_dictionary_value_set_dictionary((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified key as type list. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CDictionaryValueT) SetList(
	key string,
	value *CListValueT,
) (ret bool) {
	c_key := create_cef_string(key)
	var goTmpvalue *C.cef_list_value_t
	if value != nil {
		BaseAddRef(value.pc_list_value)
		goTmpvalue = (*C.cef_list_value_t)(value.pc_list_value)
	}

	cRet := C.cefingo_dictionary_value_set_list((*C.cef_dictionary_value_t)(self.pc_dictionary_value), c_key.p_cef_string_t, goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Creates a new object that is not owned by any other object.
///
func DictionaryValueCreate() (ret *CDictionaryValueT) {

	cRet := C.cef_dictionary_value_create()

	ret = newCDictionaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Structure representing a list value. Can be used on any process and thread.
///

type cCListValueT C.cef_list_value_t

// Go type for cef_list_value_t
type CListValueT struct {
	noCopy        noCopy
	pc_list_value *cCListValueT
	beUnrefed     unrefedBy
}

func (p *CListValueT) Pass() (ret *CListValueT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCListValueT((*C.cef_list_value_t)(p.pc_list_value), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CListValueT) NewRef() (newP *CListValueT) {
	if self == nil {
		return newP
	}
	gop := self.pc_list_value
	BaseAddRef(gop)
	newP = newCListValueT((*C.cef_list_value_t)(gop), byApp)
	return newP
}

// Go type CListValueT wraps cef type *C.cef_list_value_t
func newCListValueT(p *C.cef_list_value_t, unrefedBy unrefedBy) *CListValueT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T224.1:")
	pc := (*cCListValueT)(p)
	go_list_value := &CListValueT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_list_value, func(g *CListValueT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_list_value != nil {
			Tracef(unsafe.Pointer(g.pc_list_value), "T224.2:")
			BaseRelease(g.pc_list_value)
		}
	})

	return go_list_value
}

// *C.cef_list_value_t has refCounted interface
func (list_value *CListValueT) HasOneRef() bool {
	return BaseHasOneRef(list_value.pc_list_value)
}

func (p *cCListValueT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (list_value *CListValueT) Unref() (ret bool) {
	if list_value == nil {
		return
	}
	if list_value.beUnrefed == byApp {
		ret = BaseRelease(list_value.pc_list_value)
		list_value.beUnrefed = unrefed
	}
	list_value.pc_list_value = nil
	return ret
}

///
// Returns true (1) if this object is valid. This object may become invalid if
// the underlying data is owned by another object (e.g. list or dictionary)
// and that other object is then modified or destroyed. Do not call any other
// functions if this function returns false (0).
///
func (self *CListValueT) IsValid() (ret bool) {

	cRet := C.cefingo_list_value_is_valid((*C.cef_list_value_t)(self.pc_list_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object is currently owned by another object.
///
func (self *CListValueT) IsOwned() (ret bool) {

	cRet := C.cefingo_list_value_is_owned((*C.cef_list_value_t)(self.pc_list_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the values of this object are read-only. Some APIs may
// expose read-only objects.
///
func (self *CListValueT) IsReadOnly() (ret bool) {

	cRet := C.cefingo_list_value_is_read_only((*C.cef_list_value_t)(self.pc_list_value))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have the same underlying
// data. If true (1) modifications to this object will also affect |that|
// object and vice-versa.
///
func (self *CListValueT) IsSame(
	that *CListValueT,
) (ret bool) {
	var goTmpthat *C.cef_list_value_t
	if that != nil {
		BaseAddRef(that.pc_list_value)
		goTmpthat = (*C.cef_list_value_t)(that.pc_list_value)
	}

	cRet := C.cefingo_list_value_is_same((*C.cef_list_value_t)(self.pc_list_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this object and |that| object have an equivalent
// underlying value but are not necessarily the same object.
///
func (self *CListValueT) IsEqual(
	that *CListValueT,
) (ret bool) {
	var goTmpthat *C.cef_list_value_t
	if that != nil {
		BaseAddRef(that.pc_list_value)
		goTmpthat = (*C.cef_list_value_t)(that.pc_list_value)
	}

	cRet := C.cefingo_list_value_is_equal((*C.cef_list_value_t)(self.pc_list_value), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns a writable copy of this object.
///
func (self *CListValueT) Copy() (ret *CListValueT) {

	cRet := C.cefingo_list_value_copy((*C.cef_list_value_t)(self.pc_list_value))

	ret = newCListValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the number of values. If the number of values is expanded all new
// value slots will default to type null. Returns true (1) on success.
///
func (self *CListValueT) SetSize(
	size int64,
) (ret bool) {

	cRet := C.cefingo_list_value_set_size((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(size))

	ret = cRet == 1
	return ret
}

///
// Returns the number of values.
///
func (self *CListValueT) GetSize() (ret int64) {

	cRet := C.cefingo_list_value_get_size((*C.cef_list_value_t)(self.pc_list_value))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Removes all values. Returns true (1) on success.
///
func (self *CListValueT) Clear() (ret bool) {

	cRet := C.cefingo_list_value_clear((*C.cef_list_value_t)(self.pc_list_value))

	ret = cRet == 1
	return ret
}

///
// Removes the value at the specified index.
///
func (self *CListValueT) Remove(
	index int64,
) (ret bool) {

	cRet := C.cefingo_list_value_remove((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the value type at the specified index.
///
func (self *CListValueT) GetType(
	index int64,
) (ret CValueTypeT) {

	cRet := C.cefingo_list_value_get_type((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = CValueTypeT(cRet) // return GoObj
	return ret
}

///
// Returns the value at the specified index. For simple types the returned
// value will copy existing data and modifications to the value will not
// modify this object. For complex types (binary, dictionary and list) the
// returned value will reference existing data and modifications to the value
// will modify this object.
///
func (self *CListValueT) GetValue(
	index int64,
) (ret *CValueT) {

	cRet := C.cefingo_list_value_get_value((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = newCValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the value at the specified index as type bool.
///
func (self *CListValueT) GetBool(
	index int64,
) (ret bool) {

	cRet := C.cefingo_list_value_get_bool((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = cRet == 1
	return ret
}

///
// Returns the value at the specified index as type int.
///
func (self *CListValueT) GetInt(
	index int64,
) (ret int) {

	cRet := C.cefingo_list_value_get_int((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = (int)(cRet) // return GoObj
	return ret
}

///
// Returns the value at the specified index as type double.
///
func (self *CListValueT) GetDouble(
	index int64,
) (ret float64) {

	cRet := C.cefingo_list_value_get_double((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = (float64)(cRet) // return GoObj
	return ret
}

///
// Returns the value at the specified index as type string.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CListValueT) GetString(
	index int64,
) (ret string) {

	cRet := C.cefingo_list_value_get_string((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the value at the specified index as type binary. The returned value
// will reference existing data.
///
func (self *CListValueT) GetBinary(
	index int64,
) (ret *CBinaryValueT) {

	cRet := C.cefingo_list_value_get_binary((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the value at the specified index as type dictionary. The returned
// value will reference existing data and modifications to the value will
// modify this object.
///
func (self *CListValueT) GetDictionary(
	index int64,
) (ret *CDictionaryValueT) {

	cRet := C.cefingo_list_value_get_dictionary((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = newCDictionaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the value at the specified index as type list. The returned value
// will reference existing data and modifications to the value will modify
// this object.
///
func (self *CListValueT) GetList(
	index int64,
) (ret *CListValueT) {

	cRet := C.cefingo_list_value_get_list((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = newCListValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the value at the specified index. Returns true (1) if the value was
// set successfully. If |value| represents simple data then the underlying
// data will be copied and modifications to |value| will not modify this
// object. If |value| represents complex data (binary, dictionary or list)
// then the underlying data will be referenced and modifications to |value|
// will modify this object.
///
func (self *CListValueT) SetValue(
	index int64,
	value *CValueT,
) (ret bool) {
	var goTmpvalue *C.cef_value_t
	if value != nil {
		BaseAddRef(value.pc_value)
		goTmpvalue = (*C.cef_value_t)(value.pc_value)
	}

	cRet := C.cefingo_list_value_set_value((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type null. Returns true (1) if the
// value was set successfully.
///
func (self *CListValueT) SetNull(
	index int64,
) (ret bool) {

	cRet := C.cefingo_list_value_set_null((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type bool. Returns true (1) if the
// value was set successfully.
///
func (self *CListValueT) SetBool(
	index int64,
	value bool,
) (ret bool) {
	var tmpvalue int
	if value {
		tmpvalue = 1
	}

	cRet := C.cefingo_list_value_set_bool((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), C.int(tmpvalue))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type int. Returns true (1) if the
// value was set successfully.
///
func (self *CListValueT) SetInt(
	index int64,
	value int,
) (ret bool) {

	cRet := C.cefingo_list_value_set_int((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), (C.int)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type double. Returns true (1) if
// the value was set successfully.
///
func (self *CListValueT) SetDouble(
	index int64,
	value float64,
) (ret bool) {

	cRet := C.cefingo_list_value_set_double((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), (C.double)(value))

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type string. Returns true (1) if
// the value was set successfully.
///
func (self *CListValueT) SetString(
	index int64,
	value string,
) (ret bool) {
	c_value := create_cef_string(value)

	cRet := C.cefingo_list_value_set_string((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), c_value.p_cef_string_t)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type binary. Returns true (1) if
// the value was set successfully. If |value| is currently owned by another
// object then the value will be copied and the |value| reference will not
// change. Otherwise, ownership will be transferred to this object and the
// |value| reference will be invalidated.
///
func (self *CListValueT) SetBinary(
	index int64,
	value *CBinaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_binary_value_t
	if value != nil {
		BaseAddRef(value.pc_binary_value)
		goTmpvalue = (*C.cef_binary_value_t)(value.pc_binary_value)
	}

	cRet := C.cefingo_list_value_set_binary((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type dict. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CListValueT) SetDictionary(
	index int64,
	value *CDictionaryValueT,
) (ret bool) {
	var goTmpvalue *C.cef_dictionary_value_t
	if value != nil {
		BaseAddRef(value.pc_dictionary_value)
		goTmpvalue = (*C.cef_dictionary_value_t)(value.pc_dictionary_value)
	}

	cRet := C.cefingo_list_value_set_dictionary((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Sets the value at the specified index as type list. Returns true (1) if the
// value was set successfully. If |value| is currently owned by another object
// then the value will be copied and the |value| reference will not change.
// Otherwise, ownership will be transferred to this object and the |value|
// reference will be invalidated.
///
func (self *CListValueT) SetList(
	index int64,
	value *CListValueT,
) (ret bool) {
	var goTmpvalue *C.cef_list_value_t
	if value != nil {
		BaseAddRef(value.pc_list_value)
		goTmpvalue = (*C.cef_list_value_t)(value.pc_list_value)
	}

	cRet := C.cefingo_list_value_set_list((*C.cef_list_value_t)(self.pc_list_value), (C.size_t)(index), goTmpvalue)

	ret = cRet == 1
	return ret
}

///
// Creates a new object that is not owned by any other object.
///
func ListValueCreate() (ret *CListValueT) {

	cRet := C.cef_list_value_create()

	ret = newCListValueT(cRet, byApp) // return GoObj
	return ret
}

// cef_view_capi.h, include/capi/views/cef_view_capi.h:404:3,

///
// A View is a rectangle within the views View hierarchy. It is the base
// structure for all Views. All size and position values are in density
// independent pixels (DIP) unless otherwise indicated. Methods must be called
// on the browser process UI thread unless otherwise indicated.
///

type cCViewT C.cef_view_t

// Go type for cef_view_t
type CViewT struct {
	noCopy    noCopy
	pc_view   *cCViewT
	beUnrefed unrefedBy
}

func (p *CViewT) Pass() (ret *CViewT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCViewT((*C.cef_view_t)(p.pc_view), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CViewT) NewRef() (newP *CViewT) {
	if self == nil {
		return newP
	}
	gop := self.pc_view
	BaseAddRef(gop)
	newP = newCViewT((*C.cef_view_t)(gop), byApp)
	return newP
}

// Go type CViewT wraps cef type *C.cef_view_t
func newCViewT(p *C.cef_view_t, unrefedBy unrefedBy) *CViewT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T225.1:")
	pc := (*cCViewT)(p)
	go_view := &CViewT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_view, func(g *CViewT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_view != nil {
			Tracef(unsafe.Pointer(g.pc_view), "T225.2:")
			BaseRelease(g.pc_view)
		}
	})

	return go_view
}

// *C.cef_view_t has refCounted interface
func (view *CViewT) HasOneRef() bool {
	return BaseHasOneRef(view.pc_view)
}

func (p *cCViewT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (view *CViewT) Unref() (ret bool) {
	if view == nil {
		return
	}
	if view.beUnrefed == byApp {
		ret = BaseRelease(view.pc_view)
		view.beUnrefed = unrefed
	}
	view.pc_view = nil
	return ret
}

///
// Returns this View as a BrowserView or NULL if this is not a BrowserView.
///
func (self *CViewT) AsBrowserView() (ret *CBrowserViewT) {

	cRet := C.cefingo_view_as_browser_view((*C.cef_view_t)(self.pc_view))

	ret = newCBrowserViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns this View as a Button or NULL if this is not a Button.
///
func (self *CViewT) AsButton() (ret *CButtonT) {

	cRet := C.cefingo_view_as_button((*C.cef_view_t)(self.pc_view))

	ret = newCButtonT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns this View as a Panel or NULL if this is not a Panel.
///
func (self *CViewT) AsPanel() (ret *CPanelT) {

	cRet := C.cefingo_view_as_panel((*C.cef_view_t)(self.pc_view))

	ret = newCPanelT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns this View as a ScrollView or NULL if this is not a ScrollView.
///
func (self *CViewT) AsScrollView() (ret *CScrollViewT) {

	cRet := C.cefingo_view_as_scroll_view((*C.cef_view_t)(self.pc_view))

	ret = newCScrollViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns this View as a Textfield or NULL if this is not a Textfield.
///
func (self *CViewT) AsTextfield() (ret *CTextfieldT) {

	cRet := C.cefingo_view_as_textfield((*C.cef_view_t)(self.pc_view))

	ret = newCTextfieldT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the type of this View as a string. Used primarily for testing
// purposes.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CViewT) GetTypeString() (ret string) {

	cRet := C.cefingo_view_get_type_string((*C.cef_view_t)(self.pc_view))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns a string representation of this View which includes the type and
// various type-specific identifying attributes. If |include_children| is true
// (1) any child Views will also be included. Used primarily for testing
// purposes.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CViewT) ToString(
	include_children int,
) (ret string) {

	cRet := C.cefingo_view_to_string((*C.cef_view_t)(self.pc_view), (C.int)(include_children))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns true (1) if this View is valid.
///
func (self *CViewT) IsValid() (ret bool) {

	cRet := C.cefingo_view_is_valid((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this View is currently attached to another View. A View
// can only be attached to one View at a time.
///
func (self *CViewT) IsAttached() (ret bool) {

	cRet := C.cefingo_view_is_attached((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if this View is the same as |that| View.
///
func (self *CViewT) IsSame(
	that *CViewT,
) (ret bool) {
	var goTmpthat *C.cef_view_t
	if that != nil {
		BaseAddRef(that.pc_view)
		goTmpthat = (*C.cef_view_t)(that.pc_view)
	}

	cRet := C.cefingo_view_is_same((*C.cef_view_t)(self.pc_view), goTmpthat)

	ret = cRet == 1
	return ret
}

///
// Returns the delegate associated with this View, if any.
///
func (self *CViewT) GetDelegate() (ret *CViewDelegateT) {

	cRet := C.cefingo_view_get_delegate((*C.cef_view_t)(self.pc_view))

	ret = newCViewDelegateT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the top-level Window hosting this View, if any.
///
func (self *CViewT) GetWindow() (ret *CWindowT) {

	cRet := C.cefingo_view_get_window((*C.cef_view_t)(self.pc_view))

	ret = newCWindowT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the ID for this View.
///
func (self *CViewT) GetId() (ret bool) {

	cRet := C.cefingo_view_get_id((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Sets the ID for this View. ID should be unique within the subtree that you
// intend to search for it. 0 is the default ID for views.
///
func (self *CViewT) SetId(
	id int,
) {

	C.cefingo_view_set_id((*C.cef_view_t)(self.pc_view), (C.int)(id))

}

///
// Returns the group id of this View, or -1 if not set.
///
func (self *CViewT) GetGroupId() (ret bool) {

	cRet := C.cefingo_view_get_group_id((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// A group id is used to tag Views which are part of the same logical group.
// Focus can be moved between views with the same group using the arrow keys.
// The group id is immutable once it&#39;s set.
///
func (self *CViewT) SetGroupId(
	group_id int,
) {

	C.cefingo_view_set_group_id((*C.cef_view_t)(self.pc_view), (C.int)(group_id))

}

///
// Returns the View that contains this View, if any.
///
func (self *CViewT) GetParentView() (ret *CViewT) {

	cRet := C.cefingo_view_get_parent_view((*C.cef_view_t)(self.pc_view))

	ret = newCViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Recursively descends the view tree starting at this View, and returns the
// first child that it encounters with the given ID. Returns NULL if no
// matching child view is found.
///
func (self *CViewT) GetViewForId(
	id int,
) (ret *CViewT) {

	cRet := C.cefingo_view_get_view_for_id((*C.cef_view_t)(self.pc_view), (C.int)(id))

	ret = newCViewT(cRet, byApp) // return GoObj
	return ret
}

///
// Sets the bounds (size and position) of this View. |bounds| is in parent
// coordinates, or DIP screen coordinates if there is no parent.
///
func (self *CViewT) SetBounds(
	bounds *CRectT,
) {

	C.cefingo_view_set_bounds((*C.cef_view_t)(self.pc_view), (*C.cef_rect_t)(bounds))

}

///
// Returns the bounds (size and position) of this View in parent coordinates,
// or DIP screen coordinates if there is no parent.
///
func (self *CViewT) GetBounds() (ret CRectT) {

	cRet := C.cefingo_view_get_bounds((*C.cef_view_t)(self.pc_view))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Returns the bounds (size and position) of this View in DIP screen
// coordinates.
///
func (self *CViewT) GetBoundsInScreen() (ret CRectT) {

	cRet := C.cefingo_view_get_bounds_in_screen((*C.cef_view_t)(self.pc_view))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Sets the size of this View without changing the position. |size| in parent
// coordinates, or DIP screen coordinates if there is no parent.
///
func (self *CViewT) SetSize(
	size *CSizeT,
) {

	C.cefingo_view_set_size((*C.cef_view_t)(self.pc_view), (*C.cef_size_t)(size))

}

///
// Returns the size of this View in parent coordinates, or DIP screen
// coordinates if there is no parent.
///
func (self *CViewT) GetSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_size((*C.cef_view_t)(self.pc_view))

	ret = (CSizeT)(cRet) // return GoObj
	return ret
}

///
// Sets the position of this View without changing the size. |position| is in
// parent coordinates, or DIP screen coordinates if there is no parent.
///
func (self *CViewT) SetPosition(
	position *CPointT,
) {

	C.cefingo_view_set_position((*C.cef_view_t)(self.pc_view), (*C.cef_point_t)(position))

}

///
// Returns the position of this View. Position is in parent coordinates, or
// DIP screen coordinates if there is no parent.
///
func (self *CViewT) GetPosition() (ret CPointT) {

	cRet := C.cefingo_view_get_position((*C.cef_view_t)(self.pc_view))

	ret = (CPointT)(cRet) // return GoObj
	return ret
}

///
// Sets the insets for this View. |insets| is in parent coordinates, or DIP
// screen coordinates if there is no parent.
///
func (self *CViewT) SetInsets(
	insets *CInsetsT,
) {

	C.cefingo_view_set_insets((*C.cef_view_t)(self.pc_view), (*C.cef_insets_t)(insets))

}

///
// Returns the insets for this View in parent coordinates, or DIP screen
// coordinates if there is no parent.
///
func (self *CViewT) GetInsets() (ret CInsetsT) {

	cRet := C.cefingo_view_get_insets((*C.cef_view_t)(self.pc_view))

	ret = (CInsetsT)(cRet) // return GoObj
	return ret
}

///
// Returns the size this View would like to be if enough space is available.
// Size is in parent coordinates, or DIP screen coordinates if there is no
// parent.
///
func (self *CViewT) GetPreferredSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_preferred_size((*C.cef_view_t)(self.pc_view))

	ret = (CSizeT)(cRet) // return GoObj
	return ret
}

///
// Size this View to its preferred size. Size is in parent coordinates, or DIP
// screen coordinates if there is no parent.
///
func (self *CViewT) SizeToPreferredSize() {

	C.cefingo_view_size_to_preferred_size((*C.cef_view_t)(self.pc_view))

}

///
// Returns the minimum size for this View. Size is in parent coordinates, or
// DIP screen coordinates if there is no parent.
///
func (self *CViewT) GetMinimumSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_minimum_size((*C.cef_view_t)(self.pc_view))

	ret = (CSizeT)(cRet) // return GoObj
	return ret
}

///
// Returns the maximum size for this View. Size is in parent coordinates, or
// DIP screen coordinates if there is no parent.
///
func (self *CViewT) GetMaximumSize() (ret CSizeT) {

	cRet := C.cefingo_view_get_maximum_size((*C.cef_view_t)(self.pc_view))

	ret = (CSizeT)(cRet) // return GoObj
	return ret
}

///
// Returns the height necessary to display this View with the provided width.
///
func (self *CViewT) GetHeightForWidth(
	width int,
) (ret bool) {

	cRet := C.cefingo_view_get_height_for_width((*C.cef_view_t)(self.pc_view), (C.int)(width))

	ret = cRet == 1
	return ret
}

///
// Indicate that this View and all parent Views require a re-layout. This
// ensures the next call to layout() will propagate to this View even if the
// bounds of parent Views do not change.
///
func (self *CViewT) InvalidateLayout() {

	C.cefingo_view_invalidate_layout((*C.cef_view_t)(self.pc_view))

}

///
// Sets whether this View is visible. Windows are hidden by default and other
// views are visible by default. This View and any parent views must be set as
// visible for this View to be drawn in a Window. If this View is set as
// hidden then it and any child views will not be drawn and, if any of those
// views currently have focus, then focus will also be cleared. Painting is
// scheduled as needed. If this View is a Window then calling this function is
// equivalent to calling the Window show() and hide() functions.
///
func (self *CViewT) SetVisible(
	visible int,
) {

	C.cefingo_view_set_visible((*C.cef_view_t)(self.pc_view), (C.int)(visible))

}

///
// Returns whether this View is visible. A view may be visible but still not
// drawn in a Window if any parent views are hidden. If this View is a Window
// then a return value of true (1) indicates that this Window is currently
// visible to the user on-screen. If this View is not a Window then call
// is_drawn() to determine whether this View and all parent views are visible
// and will be drawn.
///
func (self *CViewT) IsVisible() (ret bool) {

	cRet := C.cefingo_view_is_visible((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Returns whether this View is visible and drawn in a Window. A view is drawn
// if it and all parent views are visible. If this View is a Window then
// calling this function is equivalent to calling is_visible(). Otherwise, to
// determine if the containing Window is visible to the user on-screen call
// is_visible() on the Window.
///
func (self *CViewT) IsDrawn() (ret bool) {

	cRet := C.cefingo_view_is_drawn((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Set whether this View is enabled. A disabled View does not receive keyboard
// or mouse inputs. If |enabled| differs from the current value the View will
// be repainted. Also, clears focus if the focused View is disabled.
///
func (self *CViewT) SetEnabled(
	enabled int,
) {

	C.cefingo_view_set_enabled((*C.cef_view_t)(self.pc_view), (C.int)(enabled))

}

///
// Returns whether this View is enabled.
///
func (self *CViewT) IsEnabled() (ret bool) {

	cRet := C.cefingo_view_is_enabled((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Sets whether this View is capable of taking focus. It will clear focus if
// the focused View is set to be non-focusable. This is false (0) by default
// so that a View used as a container does not get the focus.
///
func (self *CViewT) SetFocusable(
	focusable bool,
) {
	var tmpfocusable int
	if focusable {
		tmpfocusable = 1
	}

	C.cefingo_view_set_focusable((*C.cef_view_t)(self.pc_view), C.int(tmpfocusable))

}

///
// Returns true (1) if this View is focusable, enabled and drawn.
///
func (self *CViewT) IsFocusable() (ret bool) {

	cRet := C.cefingo_view_is_focusable((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Return whether this View is focusable when the user requires full keyboard
// access, even though it may not be normally focusable.
///
func (self *CViewT) IsAccessibilityFocusable() (ret bool) {

	cRet := C.cefingo_view_is_accessibility_focusable((*C.cef_view_t)(self.pc_view))

	ret = cRet == 1
	return ret
}

///
// Request keyboard focus. If this View is focusable it will become the
// focused View.
///
func (self *CViewT) RequestFocus() {

	C.cefingo_view_request_focus((*C.cef_view_t)(self.pc_view))

}

///
// Sets the background color for this View.
///
func (self *CViewT) SetBackgroundColor(
	color CColorT,
) {

	C.cefingo_view_set_background_color((*C.cef_view_t)(self.pc_view), (C.cef_color_t)(color))

}

///
// Returns the background color for this View.
///
func (self *CViewT) GetBackgroundColor() (ret CColorT) {

	cRet := C.cefingo_view_get_background_color((*C.cef_view_t)(self.pc_view))

	ret = (CColorT)(cRet) // return GoObj
	return ret
}

///
// Convert |point| from this View&#39;s coordinate system to DIP screen
// coordinates. This View must belong to a Window when calling this function.
// Returns true (1) if the conversion is successful or false (0) otherwise.
// Use cef_display_t::convert_point_to_pixels() after calling this function if
// further conversion to display-specific pixel coordinates is desired.
///
func (self *CViewT) ConvertPointToScreen(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_to_screen((*C.cef_view_t)(self.pc_view), (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| to this View&#39;s coordinate system from DIP screen
// coordinates. This View must belong to a Window when calling this function.
// Returns true (1) if the conversion is successful or false (0) otherwise.
// Use cef_display_t::convert_point_from_pixels() before calling this function
// if conversion from display-specific pixel coordinates is necessary.
///
func (self *CViewT) ConvertPointFromScreen(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_from_screen((*C.cef_view_t)(self.pc_view), (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| from this View&#39;s coordinate system to that of the Window.
// This View must belong to a Window when calling this function. Returns true
// (1) if the conversion is successful or false (0) otherwise.
///
func (self *CViewT) ConvertPointToWindow(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_to_window((*C.cef_view_t)(self.pc_view), (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| to this View&#39;s coordinate system from that of the Window.
// This View must belong to a Window when calling this function. Returns true
// (1) if the conversion is successful or false (0) otherwise.
///
func (self *CViewT) ConvertPointFromWindow(
	point *CPointT,
) (ret bool) {

	cRet := C.cefingo_view_convert_point_from_window((*C.cef_view_t)(self.pc_view), (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| from this View&#39;s coordinate system to that of |view|.
// |view| needs to be in the same Window but not necessarily the same view
// hierarchy. Returns true (1) if the conversion is successful or false (0)
// otherwise.
///
func (self *CViewT) ConvertPointToView(
	view *CViewT,
	point *CPointT,
) (ret bool) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	cRet := C.cefingo_view_convert_point_to_view((*C.cef_view_t)(self.pc_view), goTmpview, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

///
// Convert |point| to this View&#39;s coordinate system from that |view|. |view|
// needs to be in the same Window but not necessarily the same view hierarchy.
// Returns true (1) if the conversion is successful or false (0) otherwise.
///
func (self *CViewT) ConvertPointFromView(
	view *CViewT,
	point *CPointT,
) (ret bool) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	cRet := C.cefingo_view_convert_point_from_view((*C.cef_view_t)(self.pc_view), goTmpview, (*C.cef_point_t)(point))

	ret = cRet == 1
	return ret
}

// cef_view_delegate_capi.h, include/capi/views/cef_view_delegate_capi.h:142:3,

///
// Implement this structure to handle view events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCViewDelegateT C.cef_view_delegate_t

// Go type for cef_view_delegate_t
type CViewDelegateT struct {
	noCopy           noCopy
	pc_view_delegate *cCViewDelegateT
	beUnrefed        unrefedBy
}

func (p *CViewDelegateT) Pass() (ret *CViewDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCViewDelegateT((*C.cef_view_delegate_t)(p.pc_view_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CViewDelegateT) NewRef() (newP *CViewDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_view_delegate
	BaseAddRef(gop)
	newP = newCViewDelegateT((*C.cef_view_delegate_t)(gop), byApp)
	return newP
}

// Go type CViewDelegateT wraps cef type *C.cef_view_delegate_t
func newCViewDelegateT(p *C.cef_view_delegate_t, unrefedBy unrefedBy) *CViewDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T226.1:")
	pc := (*cCViewDelegateT)(p)
	go_view_delegate := &CViewDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_view_delegate, func(g *CViewDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_view_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_view_delegate), "T226.2:")
			BaseRelease(g.pc_view_delegate)
		}
	})

	return go_view_delegate
}

// *C.cef_view_delegate_t has refCounted interface
func (view_delegate *CViewDelegateT) HasOneRef() bool {
	return BaseHasOneRef(view_delegate.pc_view_delegate)
}

func (p *cCViewDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (view_delegate *CViewDelegateT) Unref() (ret bool) {
	if view_delegate == nil {
		return
	}
	if view_delegate.beUnrefed == byApp {
		ret = BaseRelease(view_delegate.pc_view_delegate)
		view_delegate.beUnrefed = unrefed
	}
	view_delegate.pc_view_delegate = nil
	return ret
}

///
// Return the preferred size for |view|. The Layout will use this information
// to determine the display size.
///
type GetPreferredSizeHandler interface {
	GetPreferredSize(
		self *CViewDelegateT,
		view *CViewT,
	) (ret CSizeT)
}

///
// Return the minimum size for |view|.
///
type GetMinimumSizeHandler interface {
	GetMinimumSize(
		self *CViewDelegateT,
		view *CViewT,
	) (ret CSizeT)
}

///
// Return the maximum size for |view|.
///
type GetMaximumSizeHandler interface {
	GetMaximumSize(
		self *CViewDelegateT,
		view *CViewT,
	) (ret CSizeT)
}

///
// Return the height necessary to display |view| with the provided |width|. If
// not specified the result of get_preferred_size().height will be used by
// default. Override if |view|&#39;s preferred height depends upon the width (for
// example, with Labels).
///
type GetHeightForWidthHandler interface {
	GetHeightForWidth(
		self *CViewDelegateT,
		view *CViewT,
		width int,
	) (ret bool)
}

///
// Called when the parent of |view| has changed. If |view| is being added to
// |parent| then |added| will be true (1). If |view| is being removed from
// |parent| then |added| will be false (0). If |view| is being reparented the
// remove notification will be sent before the add notification. Do not modify
// the view hierarchy in this callback.
///
type OnParentViewChangedHandler interface {
	OnParentViewChanged(
		self *CViewDelegateT,
		view *CViewT,
		added int,
		parent *CViewT,
	)
}

///
// Called when a child of |view| has changed. If |child| is being added to
// |view| then |added| will be true (1). If |child| is being removed from
// |view| then |added| will be false (0). If |child| is being reparented the
// remove notification will be sent to the old parent before the add
// notification is sent to the new parent. Do not modify the view hierarchy in
// this callback.
///
type OnChildViewChangedHandler interface {
	OnChildViewChanged(
		self *CViewDelegateT,
		view *CViewT,
		added int,
		child *CViewT,
	)
}

///
// Called when |view| is added or removed from the cef_window_t.
///
type OnWindowChangedHandler interface {
	OnWindowChanged(
		self *CViewDelegateT,
		view *CViewT,
		added int,
	)
}

///
// Called when the layout of |view| has changed.
///
type OnLayoutChangedHandler interface {
	OnLayoutChanged(
		self *CViewDelegateT,
		view *CViewT,
		new_bounds *CRectT,
	)
}

///
// Called when |view| gains focus.
///
type OnFocusHandler interface {
	OnFocus(
		self *CViewDelegateT,
		view *CViewT,
	)
}

///
// Called when |view| loses focus.
///
type OnBlurHandler interface {
	OnBlur(
		self *CViewDelegateT,
		view *CViewT,
	)
}

var view_delegate_handlers = struct {
	handler                        map[*cCViewDelegateT]interface{}
	get_preferred_size_handler     map[*cCViewDelegateT]GetPreferredSizeHandler
	get_minimum_size_handler       map[*cCViewDelegateT]GetMinimumSizeHandler
	get_maximum_size_handler       map[*cCViewDelegateT]GetMaximumSizeHandler
	get_height_for_width_handler   map[*cCViewDelegateT]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*cCViewDelegateT]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*cCViewDelegateT]OnChildViewChangedHandler
	on_window_changed_handler      map[*cCViewDelegateT]OnWindowChangedHandler
	on_layout_changed_handler      map[*cCViewDelegateT]OnLayoutChangedHandler
	on_focus_handler               map[*cCViewDelegateT]OnFocusHandler
	on_blur_handler                map[*cCViewDelegateT]OnBlurHandler
}{
	map[*cCViewDelegateT]interface{}{},
	map[*cCViewDelegateT]GetPreferredSizeHandler{},
	map[*cCViewDelegateT]GetMinimumSizeHandler{},
	map[*cCViewDelegateT]GetMaximumSizeHandler{},
	map[*cCViewDelegateT]GetHeightForWidthHandler{},
	map[*cCViewDelegateT]OnParentViewChangedHandler{},
	map[*cCViewDelegateT]OnChildViewChangedHandler{},
	map[*cCViewDelegateT]OnWindowChangedHandler{},
	map[*cCViewDelegateT]OnLayoutChangedHandler{},
	map[*cCViewDelegateT]OnFocusHandler{},
	map[*cCViewDelegateT]OnBlurHandler{},
}

// allocCViewDelegateT allocates CViewDelegateT and construct it
func allocCViewDelegateT() *CViewDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_view_delegate_wrapper_t, "T226.3:")
	cefp := C.cefingo_construct_view_delegate((*C.cefingo_view_delegate_wrapper_t)(up))
	cgop := (*cCViewDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_view_delegate_t itself in DeassocFunc,
		// or cef_view_delegate_t is never GCed.
		Tracef(up, "T226.4:")
		unbindAllCViewDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCViewDelegateT(cefp, byApp)
}

// NewCViewDelegateT allocates CViewDelegateT, construct and bind it
func NewCViewDelegateT(a interface{}) *CViewDelegateT {
	return allocCViewDelegateT().bind(a)
}

func (view_delegate *CViewDelegateT) bind(a interface{}) *CViewDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := view_delegate.pc_view_delegate
	view_delegate_handlers.handler[cp] = a

	if h, ok := a.(GetPreferredSizeHandler); ok {
		view_delegate_handlers.get_preferred_size_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.get_preferred_size_handler, cp)
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		view_delegate_handlers.get_minimum_size_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.get_minimum_size_handler, cp)
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		view_delegate_handlers.get_maximum_size_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.get_maximum_size_handler, cp)
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		view_delegate_handlers.get_height_for_width_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.get_height_for_width_handler, cp)
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		view_delegate_handlers.on_parent_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.on_parent_view_changed_handler, cp)
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		view_delegate_handlers.on_child_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.on_child_view_changed_handler, cp)
	}

	if h, ok := a.(OnWindowChangedHandler); ok {
		view_delegate_handlers.on_window_changed_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.on_window_changed_handler, cp)
	}

	if h, ok := a.(OnLayoutChangedHandler); ok {
		view_delegate_handlers.on_layout_changed_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.on_layout_changed_handler, cp)
	}

	if h, ok := a.(OnFocusHandler); ok {
		view_delegate_handlers.on_focus_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.on_focus_handler, cp)
	}

	if h, ok := a.(OnBlurHandler); ok {
		view_delegate_handlers.on_blur_handler[cp] = h
		noBind = false
	} else {
		delete(view_delegate_handlers.on_blur_handler, cp)
	}

	if noBind {
		Panicln("F229: *CViewDelegateT No bind")
	}
	return view_delegate
}

func unbindAllCViewDelegateT(cp *cCViewDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := view_delegate.pc_view_delegate
	delete(view_delegate_handlers.handler, cp)

	delete(view_delegate_handlers.get_preferred_size_handler, cp)
	delete(view_delegate_handlers.get_minimum_size_handler, cp)
	delete(view_delegate_handlers.get_maximum_size_handler, cp)
	delete(view_delegate_handlers.get_height_for_width_handler, cp)
	delete(view_delegate_handlers.on_parent_view_changed_handler, cp)
	delete(view_delegate_handlers.on_child_view_changed_handler, cp)
	delete(view_delegate_handlers.on_window_changed_handler, cp)
	delete(view_delegate_handlers.on_layout_changed_handler, cp)
	delete(view_delegate_handlers.on_focus_handler, cp)
	delete(view_delegate_handlers.on_blur_handler, cp)
}

func (view_delegate *CViewDelegateT) UnbindAll() {
	unbindAllCViewDelegateT(view_delegate.pc_view_delegate)
	view_delegate.Unref()
}

func (view_delegate *CViewDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := view_delegate.pc_view_delegate
	return view_delegate_handlers.handler[cp]
}

// cef_window_capi.h, include/capi/views/cef_window_capi.h:337:3,

///
// A Window is a top-level Window/widget in the Views hierarchy. By default it
// will have a non-client area with title bar, icon and buttons that supports
// moving and resizing. All size and position values are in density independent
// pixels (DIP) unless otherwise indicated. Methods must be called on the
// browser process UI thread unless otherwise indicated.
///

type cCWindowT C.cef_window_t

// Go type for cef_window_t
type CWindowT struct {
	noCopy    noCopy
	pc_window *cCWindowT
	beUnrefed unrefedBy
}

func (p *CWindowT) Pass() (ret *CWindowT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCWindowT((*C.cef_window_t)(p.pc_window), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CWindowT) NewRef() (newP *CWindowT) {
	if self == nil {
		return newP
	}
	gop := self.pc_window
	BaseAddRef(gop)
	newP = newCWindowT((*C.cef_window_t)(gop), byApp)
	return newP
}

// Go type CWindowT wraps cef type *C.cef_window_t
func newCWindowT(p *C.cef_window_t, unrefedBy unrefedBy) *CWindowT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T231.1:")
	pc := (*cCWindowT)(p)
	go_window := &CWindowT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_window, func(g *CWindowT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_window != nil {
			Tracef(unsafe.Pointer(g.pc_window), "T231.2:")
			BaseRelease(g.pc_window)
		}
	})

	return go_window
}

// *C.cef_window_t has refCounted interface
func (window *CWindowT) HasOneRef() bool {
	return BaseHasOneRef(window.pc_window)
}

func (p *cCWindowT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (window *CWindowT) Unref() (ret bool) {
	if window == nil {
		return
	}
	if window.beUnrefed == byApp {
		ret = BaseRelease(window.pc_window)
		window.beUnrefed = unrefed
	}
	window.pc_window = nil
	return ret
}

// Convert to Base Class Pointer *CPanelT
func (window *CWindowT) ToCPanelT() *CPanelT {
	p := (*C.cef_panel_t)(unsafe.Pointer(window.pc_window))
	BaseAddRef(window.pc_window)
	return newCPanelT(p, byApp)
}

///
// Show the Window.
///
func (self *CWindowT) Show() {

	C.cefingo_window_show((*C.cef_window_t)(self.pc_window))

}

///
// Hide the Window.
///
func (self *CWindowT) Hide() {

	C.cefingo_window_hide((*C.cef_window_t)(self.pc_window))

}

///
// Sizes the Window to |size| and centers it in the current display.
///
func (self *CWindowT) CenterWindow(
	size *CSizeT,
) {

	C.cefingo_window_center_window((*C.cef_window_t)(self.pc_window), (*C.cef_size_t)(size))

}

///
// Close the Window.
///
func (self *CWindowT) Close() {

	C.cefingo_window_close((*C.cef_window_t)(self.pc_window))

}

///
// Returns true (1) if the Window has been closed.
///
func (self *CWindowT) IsClosed() (ret bool) {

	cRet := C.cefingo_window_is_closed((*C.cef_window_t)(self.pc_window))

	ret = cRet == 1
	return ret
}

///
// Activate the Window, assuming it already exists and is visible.
///
func (self *CWindowT) Activate() {

	C.cefingo_window_activate((*C.cef_window_t)(self.pc_window))

}

///
// Deactivate the Window, making the next Window in the Z order the active
// Window.
///
func (self *CWindowT) Deactivate() {

	C.cefingo_window_deactivate((*C.cef_window_t)(self.pc_window))

}

///
// Returns whether the Window is the currently active Window.
///
func (self *CWindowT) IsActive() (ret bool) {

	cRet := C.cefingo_window_is_active((*C.cef_window_t)(self.pc_window))

	ret = cRet == 1
	return ret
}

///
// Bring this Window to the top of other Windows in the Windowing system.
///
func (self *CWindowT) BringToTop() {

	C.cefingo_window_bring_to_top((*C.cef_window_t)(self.pc_window))

}

///
// Set the Window to be on top of other Windows in the Windowing system.
///
func (self *CWindowT) SetAlwaysOnTop(
	on_top int,
) {

	C.cefingo_window_set_always_on_top((*C.cef_window_t)(self.pc_window), (C.int)(on_top))

}

///
// Returns whether the Window has been set to be on top of other Windows in
// the Windowing system.
///
func (self *CWindowT) IsAlwaysOnTop() (ret bool) {

	cRet := C.cefingo_window_is_always_on_top((*C.cef_window_t)(self.pc_window))

	ret = cRet == 1
	return ret
}

///
// Maximize the Window.
///
func (self *CWindowT) Maximize() {

	C.cefingo_window_maximize((*C.cef_window_t)(self.pc_window))

}

///
// Minimize the Window.
///
func (self *CWindowT) Minimize() {

	C.cefingo_window_minimize((*C.cef_window_t)(self.pc_window))

}

///
// Restore the Window.
///
func (self *CWindowT) Restore() {

	C.cefingo_window_restore((*C.cef_window_t)(self.pc_window))

}

///
// Set fullscreen Window state.
///
func (self *CWindowT) SetFullscreen(
	fullscreen int,
) {

	C.cefingo_window_set_fullscreen((*C.cef_window_t)(self.pc_window), (C.int)(fullscreen))

}

///
// Returns true (1) if the Window is maximized.
///
func (self *CWindowT) IsMaximized() (ret bool) {

	cRet := C.cefingo_window_is_maximized((*C.cef_window_t)(self.pc_window))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the Window is minimized.
///
func (self *CWindowT) IsMinimized() (ret bool) {

	cRet := C.cefingo_window_is_minimized((*C.cef_window_t)(self.pc_window))

	ret = cRet == 1
	return ret
}

///
// Returns true (1) if the Window is fullscreen.
///
func (self *CWindowT) IsFullscreen() (ret bool) {

	cRet := C.cefingo_window_is_fullscreen((*C.cef_window_t)(self.pc_window))

	ret = cRet == 1
	return ret
}

///
// Set the Window title.
///
func (self *CWindowT) SetTitle(
	title string,
) {
	c_title := create_cef_string(title)

	C.cefingo_window_set_title((*C.cef_window_t)(self.pc_window), c_title.p_cef_string_t)

}

///
// Get the Window title.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CWindowT) GetTitle() (ret string) {

	cRet := C.cefingo_window_get_title((*C.cef_window_t)(self.pc_window))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Set the Window icon. This should be a 16x16 icon suitable for use in the
// Windows&#39;s title bar.
///
func (self *CWindowT) SetWindowIcon(
	image *CImageT,
) {
	var goTmpimage *C.cef_image_t
	if image != nil {
		BaseAddRef(image.pc_image)
		goTmpimage = (*C.cef_image_t)(image.pc_image)
	}

	C.cefingo_window_set_window_icon((*C.cef_window_t)(self.pc_window), goTmpimage)

}

///
// Get the Window icon.
///
func (self *CWindowT) GetWindowIcon() (ret *CImageT) {

	cRet := C.cefingo_window_get_window_icon((*C.cef_window_t)(self.pc_window))

	ret = newCImageT(cRet, byApp) // return GoObj
	return ret
}

///
// Set the Window App icon. This should be a larger icon for use in the host
// environment app switching UI. On Windows, this is the ICON_BIG used in Alt-
// Tab list and Windows taskbar. The Window icon will be used by default if no
// Window App icon is specified.
///
func (self *CWindowT) SetWindowAppIcon(
	image *CImageT,
) {
	var goTmpimage *C.cef_image_t
	if image != nil {
		BaseAddRef(image.pc_image)
		goTmpimage = (*C.cef_image_t)(image.pc_image)
	}

	C.cefingo_window_set_window_app_icon((*C.cef_window_t)(self.pc_window), goTmpimage)

}

///
// Get the Window App icon.
///
func (self *CWindowT) GetWindowAppIcon() (ret *CImageT) {

	cRet := C.cefingo_window_get_window_app_icon((*C.cef_window_t)(self.pc_window))

	ret = newCImageT(cRet, byApp) // return GoObj
	return ret
}

///
// Add a View that will be overlayed on the Window contents with absolute
// positioning and high z-order. Positioning is controlled by |docking_mode|
// as described below. The returned cef_overlay_controller_t object is used to
// control the overlay. Overlays are hidden by default.
//
// With CEF_DOCKING_MODE_CUSTOM:
//   1. The overlay is initially hidden, sized to |view|&#39;s preferred size, and
//      positioned in the top-left corner.
//   2. Optionally change the overlay position and/or size by calling
//      CefOverlayController methods.
//   3. Call CefOverlayController::SetVisible(true) to show the overlay.
//   4. The overlay will be automatically re-sized if |view|&#39;s layout changes.
//      Optionally change the overlay position and/or size when
//      OnLayoutChanged is called on the Window&#39;s delegate to indicate a
//      change in Window bounds.
//
// With other docking modes:
//   1. The overlay is initially hidden, sized to |view|&#39;s preferred size, and
//      positioned based on |docking_mode|.
//   2. Call CefOverlayController::SetVisible(true) to show the overlay.
//   3. The overlay will be automatically re-sized if |view|&#39;s layout changes
//      and re-positioned as appropriate when the Window resizes.
//
// Overlays created by this function will receive a higher z-order then any
// child Views added previously. It is therefore recommended to call this
// function last after all other child Views have been added so that the
// overlay displays as the top-most child of the Window.
///
func (self *CWindowT) AddOverlayView(
	view *CViewT,
	docking_mode CDockingModeT,
) (ret *COverlayControllerT) {
	var goTmpview *C.cef_view_t
	if view != nil {
		BaseAddRef(view.pc_view)
		goTmpview = (*C.cef_view_t)(view.pc_view)
	}

	cRet := C.cefingo_window_add_overlay_view((*C.cef_window_t)(self.pc_window), goTmpview, (C.cef_docking_mode_t)(docking_mode))

	ret = newCOverlayControllerT(cRet, byApp) // return GoObj
	return ret
}

///
// Show a menu with contents |menu_model|. |screen_point| specifies the menu
// position in screen coordinates. |anchor_position| specifies how the menu
// will be anchored relative to |screen_point|.
///
func (self *CWindowT) ShowMenu(
	menu_model *CMenuModelT,
	screen_point *CPointT,
	anchor_position CMenuAnchorPositionT,
) {
	var goTmpmenu_model *C.cef_menu_model_t
	if menu_model != nil {
		BaseAddRef(menu_model.pc_menu_model)
		goTmpmenu_model = (*C.cef_menu_model_t)(menu_model.pc_menu_model)
	}

	C.cefingo_window_show_menu((*C.cef_window_t)(self.pc_window), goTmpmenu_model, (*C.cef_point_t)(screen_point), (C.cef_menu_anchor_position_t)(anchor_position))

}

///
// Cancel the menu that is currently showing, if any.
///
func (self *CWindowT) CancelMenu() {

	C.cefingo_window_cancel_menu((*C.cef_window_t)(self.pc_window))

}

///
// Returns the Display that most closely intersects the bounds of this Window.
// May return NULL if this Window is not currently displayed.
///
func (self *CWindowT) GetDisplay() (ret *CDisplayT) {

	cRet := C.cefingo_window_get_display((*C.cef_window_t)(self.pc_window))

	ret = newCDisplayT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the bounds (size and position) of this Window&#39;s client area.
// Position is in screen coordinates.
///
func (self *CWindowT) GetClientAreaBoundsInScreen() (ret CRectT) {

	cRet := C.cefingo_window_get_client_area_bounds_in_screen((*C.cef_window_t)(self.pc_window))

	ret = (CRectT)(cRet) // return GoObj
	return ret
}

///
// Set the regions where mouse events will be intercepted by this Window to
// support drag operations. Call this function with an NULL vector to clear
// the draggable regions. The draggable region bounds should be in window
// coordinates.
///
func (self *CWindowT) SetDraggableRegions(
	regionsCount int64,
	regions *CDraggableRegionT,
) {

	C.cefingo_window_set_draggable_regions((*C.cef_window_t)(self.pc_window), (C.size_t)(regionsCount), (*C.cef_draggable_region_t)(regions))

}

///
// Retrieve the platform window handle for this Window.
///
func (self *CWindowT) GetWindowHandle() (ret CWindowHandleT) {

	cRet := C.cefingo_window_get_window_handle((*C.cef_window_t)(self.pc_window))

	ret = (CWindowHandleT)(cRet) // return GoObj
	return ret
}

///
// Simulate a key press. |key_code| is the VKEY_* value from Chromium&#39;s
// ui/events/keycodes/keyboard_codes.h header (VK_* values on Windows).
// |event_flags| is some combination of EVENTFLAG_SHIFT_DOWN,
// EVENTFLAG_CONTROL_DOWN and/or EVENTFLAG_ALT_DOWN. This function is exposed
// primarily for testing purposes.
///
func (self *CWindowT) SendKeyPress(
	key_code int,
	event_flags uint32,
) {

	C.cefingo_window_send_key_press((*C.cef_window_t)(self.pc_window), (C.int)(key_code), (C.uint32)(event_flags))

}

///
// Simulate a mouse move. The mouse cursor will be moved to the specified
// (screen_x, screen_y) position. This function is exposed primarily for
// testing purposes.
///
func (self *CWindowT) SendMouseMove(
	screen_x int,
	screen_y int,
) {

	C.cefingo_window_send_mouse_move((*C.cef_window_t)(self.pc_window), (C.int)(screen_x), (C.int)(screen_y))

}

///
// Simulate mouse down and/or mouse up events. |button| is the mouse button
// type. If |mouse_down| is true (1) a mouse down event will be sent. If
// |mouse_up| is true (1) a mouse up event will be sent. If both are true (1)
// a mouse down event will be sent followed by a mouse up event (equivalent to
// clicking the mouse button). The events will be sent using the current
// cursor position so make sure to call send_mouse_move() first to position
// the mouse. This function is exposed primarily for testing purposes.
///
func (self *CWindowT) SendMouseEvents(
	button CMouseButtonTypeT,
	mouse_down int,
	mouse_up int,
) {

	C.cefingo_window_send_mouse_events((*C.cef_window_t)(self.pc_window), (C.cef_mouse_button_type_t)(button), (C.int)(mouse_down), (C.int)(mouse_up))

}

///
// Set the keyboard accelerator for the specified |command_id|. |key_code| can
// be any virtual key or character value. cef_window_delegate_t::OnAccelerator
// will be called if the keyboard combination is triggered while this window
// has focus.
///
func (self *CWindowT) SetAccelerator(
	command_id int,
	key_code int,
	shift_pressed int,
	ctrl_pressed int,
	alt_pressed int,
) {

	C.cefingo_window_set_accelerator((*C.cef_window_t)(self.pc_window), (C.int)(command_id), (C.int)(key_code), (C.int)(shift_pressed), (C.int)(ctrl_pressed), (C.int)(alt_pressed))

}

///
// Remove the keyboard accelerator for the specified |command_id|.
///
func (self *CWindowT) RemoveAccelerator(
	command_id int,
) {

	C.cefingo_window_remove_accelerator((*C.cef_window_t)(self.pc_window), (C.int)(command_id))

}

///
// Remove all keyboard accelerators.
///
func (self *CWindowT) RemoveAllAccelerators() {

	C.cefingo_window_remove_all_accelerators((*C.cef_window_t)(self.pc_window))

}

///
// Create a new Window.
///
func WindowCreateTopLevel(
	delegate *CWindowDelegateT,
) (ret *CWindowT) {
	var goTmpdelegate *C.cef_window_delegate_t
	if delegate != nil {
		BaseAddRef(delegate.pc_window_delegate)
		goTmpdelegate = (*C.cef_window_delegate_t)(delegate.pc_window_delegate)
	}

	cRet := C.cef_window_create_top_level(goTmpdelegate)

	ret = newCWindowT(cRet, byApp) // return GoObj
	return ret
}

// cef_window_delegate_capi.h, include/capi/views/cef_window_delegate_capi.h:159:3,

///
// Implement this structure to handle window events. The functions of this
// structure will be called on the browser process UI thread unless otherwise
// indicated.
///

type cCWindowDelegateT C.cef_window_delegate_t

// Go type for cef_window_delegate_t
type CWindowDelegateT struct {
	noCopy             noCopy
	pc_window_delegate *cCWindowDelegateT
	beUnrefed          unrefedBy
}

func (p *CWindowDelegateT) Pass() (ret *CWindowDelegateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCWindowDelegateT((*C.cef_window_delegate_t)(p.pc_window_delegate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CWindowDelegateT) NewRef() (newP *CWindowDelegateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_window_delegate
	BaseAddRef(gop)
	newP = newCWindowDelegateT((*C.cef_window_delegate_t)(gop), byApp)
	return newP
}

// Go type CWindowDelegateT wraps cef type *C.cef_window_delegate_t
func newCWindowDelegateT(p *C.cef_window_delegate_t, unrefedBy unrefedBy) *CWindowDelegateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T232.1:")
	pc := (*cCWindowDelegateT)(p)
	go_window_delegate := &CWindowDelegateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_window_delegate, func(g *CWindowDelegateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_window_delegate != nil {
			Tracef(unsafe.Pointer(g.pc_window_delegate), "T232.2:")
			BaseRelease(g.pc_window_delegate)
		}
	})

	return go_window_delegate
}

// *C.cef_window_delegate_t has refCounted interface
func (window_delegate *CWindowDelegateT) HasOneRef() bool {
	return BaseHasOneRef(window_delegate.pc_window_delegate)
}

func (p *cCWindowDelegateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (window_delegate *CWindowDelegateT) Unref() (ret bool) {
	if window_delegate == nil {
		return
	}
	if window_delegate.beUnrefed == byApp {
		ret = BaseRelease(window_delegate.pc_window_delegate)
		window_delegate.beUnrefed = unrefed
	}
	window_delegate.pc_window_delegate = nil
	return ret
}

// Convert to Base Class Pointer *CPanelDelegateT
func (window_delegate *CWindowDelegateT) ToCPanelDelegateT() *CPanelDelegateT {
	p := (*C.cef_panel_delegate_t)(unsafe.Pointer(window_delegate.pc_window_delegate))
	BaseAddRef(window_delegate.pc_window_delegate)
	return newCPanelDelegateT(p, byApp)
}

///
// Called when |window| is created.
///
type OnWindowCreatedHandler interface {
	OnWindowCreated(
		self *CWindowDelegateT,
		window *CWindowT,
	)
}

///
// Called when |window| is destroyed. Release all references to |window| and
// do not attempt to execute any functions on |window| after this callback
// returns.
///
type OnWindowDestroyedHandler interface {
	OnWindowDestroyed(
		self *CWindowDelegateT,
		window *CWindowT,
	)
}

///
// Return the parent for |window| or NULL if the |window| does not have a
// parent. Windows with parents will not get a taskbar button. Set |is_menu|
// to true (1) if |window| will be displayed as a menu, in which case it will
// not be clipped to the parent window bounds. Set |can_activate_menu| to
// false (0) if |is_menu| is true (1) and |window| should not be activated
// (given keyboard focus) when displayed.
///
type GetParentWindowHandler interface {
	GetParentWindow(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret *CWindowT, is_menu bool, can_activate_menu bool)
}

///
// Return the initial bounds for |window| in density independent pixel (DIP)
// coordinates. If this function returns an NULL CefRect then
// get_preferred_size() will be called to retrieve the size, and the window
// will be placed on the screen with origin (0,0). This function can be used
// in combination with cef_view_t::get_bounds_in_screen() to restore the
// previous window bounds.
///
type GetInitialBoundsHandler interface {
	GetInitialBounds(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret CRectT)
}

///
// Return the initial show state for |window|.
///
type GetInitialShowStateHandler interface {
	GetInitialShowState(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret CShowStateT)
}

///
// Return true (1) if |window| should be created without a frame or title bar.
// The window will be resizable if can_resize() returns true (1). Use
// cef_window_t::set_draggable_regions() to specify draggable regions.
///
type IsFramelessHandler interface {
	IsFrameless(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be resized.
///
type CanResizeHandler interface {
	CanResize(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be maximized.
///
type CanMaximizeHandler interface {
	CanMaximize(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be minimized.
///
type CanMinimizeHandler interface {
	CanMinimize(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Return true (1) if |window| can be closed. This will be called for user-
// initiated window close actions and when cef_window_t::close() is called.
///
type CanCloseHandler interface {
	CanClose(
		self *CWindowDelegateT,
		window *CWindowT,
	) (ret bool)
}

///
// Called when a keyboard accelerator registered with
// cef_window_t::SetAccelerator is triggered. Return true (1) if the
// accelerator was handled or false (0) otherwise.
///
type OnAcceleratorHandler interface {
	OnAccelerator(
		self *CWindowDelegateT,
		window *CWindowT,
		command_id int,
	) (ret bool)
}

///
// Called after all other controls in the window have had a chance to handle
// the event. |event| contains information about the keyboard event. Return
// true (1) if the keyboard event was handled or false (0) otherwise.
///
type CWindowDelegateTOnKeyEventHandler interface {
	OnKeyEvent(
		self *CWindowDelegateT,
		window *CWindowT,
		event *CKeyEventT,
	) (ret bool)
}

var window_delegate_handlers = struct {
	handler                        map[*cCWindowDelegateT]interface{}
	on_window_created_handler      map[*cCWindowDelegateT]OnWindowCreatedHandler
	on_window_destroyed_handler    map[*cCWindowDelegateT]OnWindowDestroyedHandler
	get_parent_window_handler      map[*cCWindowDelegateT]GetParentWindowHandler
	get_initial_bounds_handler     map[*cCWindowDelegateT]GetInitialBoundsHandler
	get_initial_show_state_handler map[*cCWindowDelegateT]GetInitialShowStateHandler
	is_frameless_handler           map[*cCWindowDelegateT]IsFramelessHandler
	can_resize_handler             map[*cCWindowDelegateT]CanResizeHandler
	can_maximize_handler           map[*cCWindowDelegateT]CanMaximizeHandler
	can_minimize_handler           map[*cCWindowDelegateT]CanMinimizeHandler
	can_close_handler              map[*cCWindowDelegateT]CanCloseHandler
	on_accelerator_handler         map[*cCWindowDelegateT]OnAcceleratorHandler
	on_key_event_handler           map[*cCWindowDelegateT]CWindowDelegateTOnKeyEventHandler
	get_preferred_size_handler     map[*cCWindowDelegateT]GetPreferredSizeHandler
	get_minimum_size_handler       map[*cCWindowDelegateT]GetMinimumSizeHandler
	get_maximum_size_handler       map[*cCWindowDelegateT]GetMaximumSizeHandler
	get_height_for_width_handler   map[*cCWindowDelegateT]GetHeightForWidthHandler
	on_parent_view_changed_handler map[*cCWindowDelegateT]OnParentViewChangedHandler
	on_child_view_changed_handler  map[*cCWindowDelegateT]OnChildViewChangedHandler
	on_window_changed_handler      map[*cCWindowDelegateT]OnWindowChangedHandler
	on_layout_changed_handler      map[*cCWindowDelegateT]OnLayoutChangedHandler
	on_focus_handler               map[*cCWindowDelegateT]OnFocusHandler
	on_blur_handler                map[*cCWindowDelegateT]OnBlurHandler
}{
	map[*cCWindowDelegateT]interface{}{},
	map[*cCWindowDelegateT]OnWindowCreatedHandler{},
	map[*cCWindowDelegateT]OnWindowDestroyedHandler{},
	map[*cCWindowDelegateT]GetParentWindowHandler{},
	map[*cCWindowDelegateT]GetInitialBoundsHandler{},
	map[*cCWindowDelegateT]GetInitialShowStateHandler{},
	map[*cCWindowDelegateT]IsFramelessHandler{},
	map[*cCWindowDelegateT]CanResizeHandler{},
	map[*cCWindowDelegateT]CanMaximizeHandler{},
	map[*cCWindowDelegateT]CanMinimizeHandler{},
	map[*cCWindowDelegateT]CanCloseHandler{},
	map[*cCWindowDelegateT]OnAcceleratorHandler{},
	map[*cCWindowDelegateT]CWindowDelegateTOnKeyEventHandler{},
	map[*cCWindowDelegateT]GetPreferredSizeHandler{},
	map[*cCWindowDelegateT]GetMinimumSizeHandler{},
	map[*cCWindowDelegateT]GetMaximumSizeHandler{},
	map[*cCWindowDelegateT]GetHeightForWidthHandler{},
	map[*cCWindowDelegateT]OnParentViewChangedHandler{},
	map[*cCWindowDelegateT]OnChildViewChangedHandler{},
	map[*cCWindowDelegateT]OnWindowChangedHandler{},
	map[*cCWindowDelegateT]OnLayoutChangedHandler{},
	map[*cCWindowDelegateT]OnFocusHandler{},
	map[*cCWindowDelegateT]OnBlurHandler{},
}

// allocCWindowDelegateT allocates CWindowDelegateT and construct it
func allocCWindowDelegateT() *CWindowDelegateT {
	up := c_calloc(1, C.sizeof_cefingo_window_delegate_wrapper_t, "T232.3:")
	cefp := C.cefingo_construct_window_delegate((*C.cefingo_window_delegate_wrapper_t)(up))
	cgop := (*cCWindowDelegateT)(cefp)

	registerDeassocer(up, DeassocFunc(func() {
		// Do not have reference to cef_window_delegate_t itself in DeassocFunc,
		// or cef_window_delegate_t is never GCed.
		Tracef(up, "T232.4:")
		unbindAllCWindowDelegateT(cgop)
	}))

	BaseAddRef(cgop)
	return newCWindowDelegateT(cefp, byApp)
}

// NewCWindowDelegateT allocates CWindowDelegateT, construct and bind it
func NewCWindowDelegateT(a interface{}) *CWindowDelegateT {
	return allocCWindowDelegateT().bind(a)
}

func (window_delegate *CWindowDelegateT) bind(a interface{}) *CWindowDelegateT {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()
	noBind := true

	cp := window_delegate.pc_window_delegate
	window_delegate_handlers.handler[cp] = a

	if h, ok := a.(OnWindowCreatedHandler); ok {
		window_delegate_handlers.on_window_created_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_window_created_handler, cp)
	}

	if h, ok := a.(OnWindowDestroyedHandler); ok {
		window_delegate_handlers.on_window_destroyed_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_window_destroyed_handler, cp)
	}

	if h, ok := a.(GetParentWindowHandler); ok {
		window_delegate_handlers.get_parent_window_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.get_parent_window_handler, cp)
	}

	if h, ok := a.(GetInitialBoundsHandler); ok {
		window_delegate_handlers.get_initial_bounds_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.get_initial_bounds_handler, cp)
	}

	if h, ok := a.(GetInitialShowStateHandler); ok {
		window_delegate_handlers.get_initial_show_state_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.get_initial_show_state_handler, cp)
	}

	if h, ok := a.(IsFramelessHandler); ok {
		window_delegate_handlers.is_frameless_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.is_frameless_handler, cp)
	}

	if h, ok := a.(CanResizeHandler); ok {
		window_delegate_handlers.can_resize_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.can_resize_handler, cp)
	}

	if h, ok := a.(CanMaximizeHandler); ok {
		window_delegate_handlers.can_maximize_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.can_maximize_handler, cp)
	}

	if h, ok := a.(CanMinimizeHandler); ok {
		window_delegate_handlers.can_minimize_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.can_minimize_handler, cp)
	}

	if h, ok := a.(CanCloseHandler); ok {
		window_delegate_handlers.can_close_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.can_close_handler, cp)
	}

	if h, ok := a.(OnAcceleratorHandler); ok {
		window_delegate_handlers.on_accelerator_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_accelerator_handler, cp)
	}

	if h, ok := a.(CWindowDelegateTOnKeyEventHandler); ok {
		window_delegate_handlers.on_key_event_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_key_event_handler, cp)
	}

	if h, ok := a.(GetPreferredSizeHandler); ok {
		window_delegate_handlers.get_preferred_size_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.get_preferred_size_handler, cp)
	}

	if h, ok := a.(GetMinimumSizeHandler); ok {
		window_delegate_handlers.get_minimum_size_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.get_minimum_size_handler, cp)
	}

	if h, ok := a.(GetMaximumSizeHandler); ok {
		window_delegate_handlers.get_maximum_size_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.get_maximum_size_handler, cp)
	}

	if h, ok := a.(GetHeightForWidthHandler); ok {
		window_delegate_handlers.get_height_for_width_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.get_height_for_width_handler, cp)
	}

	if h, ok := a.(OnParentViewChangedHandler); ok {
		window_delegate_handlers.on_parent_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_parent_view_changed_handler, cp)
	}

	if h, ok := a.(OnChildViewChangedHandler); ok {
		window_delegate_handlers.on_child_view_changed_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_child_view_changed_handler, cp)
	}

	if h, ok := a.(OnWindowChangedHandler); ok {
		window_delegate_handlers.on_window_changed_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_window_changed_handler, cp)
	}

	if h, ok := a.(OnLayoutChangedHandler); ok {
		window_delegate_handlers.on_layout_changed_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_layout_changed_handler, cp)
	}

	if h, ok := a.(OnFocusHandler); ok {
		window_delegate_handlers.on_focus_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_focus_handler, cp)
	}

	if h, ok := a.(OnBlurHandler); ok {
		window_delegate_handlers.on_blur_handler[cp] = h
		noBind = false
	} else {
		delete(window_delegate_handlers.on_blur_handler, cp)
	}

	if noBind {
		Panicln("F229: *CWindowDelegateT No bind")
	}
	return window_delegate
}

func unbindAllCWindowDelegateT(cp *cCWindowDelegateT) {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	// cp := window_delegate.pc_window_delegate
	delete(window_delegate_handlers.handler, cp)

	delete(window_delegate_handlers.on_window_created_handler, cp)
	delete(window_delegate_handlers.on_window_destroyed_handler, cp)
	delete(window_delegate_handlers.get_parent_window_handler, cp)
	delete(window_delegate_handlers.get_initial_bounds_handler, cp)
	delete(window_delegate_handlers.get_initial_show_state_handler, cp)
	delete(window_delegate_handlers.is_frameless_handler, cp)
	delete(window_delegate_handlers.can_resize_handler, cp)
	delete(window_delegate_handlers.can_maximize_handler, cp)
	delete(window_delegate_handlers.can_minimize_handler, cp)
	delete(window_delegate_handlers.can_close_handler, cp)
	delete(window_delegate_handlers.on_accelerator_handler, cp)
	delete(window_delegate_handlers.on_key_event_handler, cp)
	delete(window_delegate_handlers.get_preferred_size_handler, cp)
	delete(window_delegate_handlers.get_minimum_size_handler, cp)
	delete(window_delegate_handlers.get_maximum_size_handler, cp)
	delete(window_delegate_handlers.get_height_for_width_handler, cp)
	delete(window_delegate_handlers.on_parent_view_changed_handler, cp)
	delete(window_delegate_handlers.on_child_view_changed_handler, cp)
	delete(window_delegate_handlers.on_window_changed_handler, cp)
	delete(window_delegate_handlers.on_layout_changed_handler, cp)
	delete(window_delegate_handlers.on_focus_handler, cp)
	delete(window_delegate_handlers.on_blur_handler, cp)
}

func (window_delegate *CWindowDelegateT) UnbindAll() {
	unbindAllCWindowDelegateT(window_delegate.pc_window_delegate)
	window_delegate.Unref()
}

func (window_delegate *CWindowDelegateT) Handler() interface{} {
	cefingoIfaceAccess.Lock()
	defer cefingoIfaceAccess.Unlock()

	cp := window_delegate.pc_window_delegate
	return window_delegate_handlers.handler[cp]
}

// cef_x509_certificate_capi.h, include/capi/cef_x509_certificate_capi.h:123:3,

///
// Structure representing the issuer or subject field of an X.509 certificate.
///

type cCX509certPrincipalT C.cef_x509cert_principal_t

// Go type for cef_x509cert_principal_t
type CX509certPrincipalT struct {
	noCopy                noCopy
	pc_x509cert_principal *cCX509certPrincipalT
	beUnrefed             unrefedBy
}

func (p *CX509certPrincipalT) Pass() (ret *CX509certPrincipalT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCX509certPrincipalT((*C.cef_x509cert_principal_t)(p.pc_x509cert_principal), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CX509certPrincipalT) NewRef() (newP *CX509certPrincipalT) {
	if self == nil {
		return newP
	}
	gop := self.pc_x509cert_principal
	BaseAddRef(gop)
	newP = newCX509certPrincipalT((*C.cef_x509cert_principal_t)(gop), byApp)
	return newP
}

// Go type CX509certPrincipalT wraps cef type *C.cef_x509cert_principal_t
func newCX509certPrincipalT(p *C.cef_x509cert_principal_t, unrefedBy unrefedBy) *CX509certPrincipalT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T233.1:")
	pc := (*cCX509certPrincipalT)(p)
	go_x509cert_principal := &CX509certPrincipalT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_x509cert_principal, func(g *CX509certPrincipalT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_x509cert_principal != nil {
			Tracef(unsafe.Pointer(g.pc_x509cert_principal), "T233.2:")
			BaseRelease(g.pc_x509cert_principal)
		}
	})

	return go_x509cert_principal
}

// *C.cef_x509cert_principal_t has refCounted interface
func (x509cert_principal *CX509certPrincipalT) HasOneRef() bool {
	return BaseHasOneRef(x509cert_principal.pc_x509cert_principal)
}

func (p *cCX509certPrincipalT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (x509cert_principal *CX509certPrincipalT) Unref() (ret bool) {
	if x509cert_principal == nil {
		return
	}
	if x509cert_principal.beUnrefed == byApp {
		ret = BaseRelease(x509cert_principal.pc_x509cert_principal)
		x509cert_principal.beUnrefed = unrefed
	}
	x509cert_principal.pc_x509cert_principal = nil
	return ret
}

///
// Returns a name that can be used to represent the issuer. It tries in this
// order: Common Name (CN), Organization Name (O) and Organizational Unit Name
// (OU) and returns the first non-NULL one found.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetDisplayName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_display_name((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the common name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetCommonName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_common_name((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the locality name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetLocalityName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_locality_name((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the state or province name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetStateOrProvinceName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_state_or_province_name((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Returns the country name.
///
// The resulting string must be freed by calling cef_string_userfree_free().
func (self *CX509certPrincipalT) GetCountryName() (ret string) {

	cRet := C.cefingo_x509cert_principal_get_country_name((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal))

	s := string_from_cef_string(cRet)
	if cRet != nil {
		C.cef_string_userfree_free(cRet)
	}
	ret = s
	return ret
}

///
// Retrieve the list of street addresses.
///
func (self *CX509certPrincipalT) GetStreetAddresses(
	addresses CStringListT,
) {

	C.cefingo_x509cert_principal_get_street_addresses((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal), (C.cef_string_list_t)(addresses))

}

///
// Retrieve the list of organization names.
///
func (self *CX509certPrincipalT) GetOrganizationNames(
	names CStringListT,
) {

	C.cefingo_x509cert_principal_get_organization_names((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal), (C.cef_string_list_t)(names))

}

///
// Retrieve the list of organization unit names.
///
func (self *CX509certPrincipalT) GetOrganizationUnitNames(
	names CStringListT,
) {

	C.cefingo_x509cert_principal_get_organization_unit_names((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal), (C.cef_string_list_t)(names))

}

///
// Retrieve the list of domain components.
///
func (self *CX509certPrincipalT) GetDomainComponents(
	components CStringListT,
) {

	C.cefingo_x509cert_principal_get_domain_components((*C.cef_x509cert_principal_t)(self.pc_x509cert_principal), (C.cef_string_list_t)(components))

}

///
// Structure representing a X.509 certificate.
///

type cCX509certificateT C.cef_x509certificate_t

// Go type for cef_x509certificate_t
type CX509certificateT struct {
	noCopy             noCopy
	pc_x509certificate *cCX509certificateT
	beUnrefed          unrefedBy
}

func (p *CX509certificateT) Pass() (ret *CX509certificateT) {
	switch p.beUnrefed {
	case byApp:
		p.beUnrefed = unrefed
		ret = newCX509certificateT((*C.cef_x509certificate_t)(p.pc_x509certificate), byCef)
	case byApi, byCef:
		ret = p
	default:
		Panicln("F725: Unsupported Ref Passed", p.beUnrefed)
	}

	return ret
}

func (self *CX509certificateT) NewRef() (newP *CX509certificateT) {
	if self == nil {
		return newP
	}
	gop := self.pc_x509certificate
	BaseAddRef(gop)
	newP = newCX509certificateT((*C.cef_x509certificate_t)(gop), byApp)
	return newP
}

// Go type CX509certificateT wraps cef type *C.cef_x509certificate_t
func newCX509certificateT(p *C.cef_x509certificate_t, unrefedBy unrefedBy) *CX509certificateT {
	if p == nil {
		return nil
	}
	Tracef(unsafe.Pointer(p), "T234.1:")
	pc := (*cCX509certificateT)(p)
	go_x509certificate := &CX509certificateT{noCopy{}, pc, unrefedBy}
	// BaseAddRef(pc)
	runtime.SetFinalizer(go_x509certificate, func(g *CX509certificateT) {
		// same as g.Unref()
		if g.beUnrefed == byApp && g.pc_x509certificate != nil {
			Tracef(unsafe.Pointer(g.pc_x509certificate), "T234.2:")
			BaseRelease(g.pc_x509certificate)
		}
	})

	return go_x509certificate
}

// *C.cef_x509certificate_t has refCounted interface
func (x509certificate *CX509certificateT) HasOneRef() bool {
	return BaseHasOneRef(x509certificate.pc_x509certificate)
}

func (p *cCX509certificateT) cast_to_p_base_ref_counted_t() *C.cef_base_ref_counted_t {
	return (*C.cef_base_ref_counted_t)(unsafe.Pointer(p))
}

func (x509certificate *CX509certificateT) Unref() (ret bool) {
	if x509certificate == nil {
		return
	}
	if x509certificate.beUnrefed == byApp {
		ret = BaseRelease(x509certificate.pc_x509certificate)
		x509certificate.beUnrefed = unrefed
	}
	x509certificate.pc_x509certificate = nil
	return ret
}

///
// Returns the subject of the X.509 certificate. For HTTPS server certificates
// this represents the web server.  The common name of the subject should
// match the host name of the web server.
///
func (self *CX509certificateT) GetSubject() (ret *CX509certPrincipalT) {

	cRet := C.cefingo_x509certificate_get_subject((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = newCX509certPrincipalT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the issuer of the X.509 certificate.
///
func (self *CX509certificateT) GetIssuer() (ret *CX509certPrincipalT) {

	cRet := C.cefingo_x509certificate_get_issuer((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = newCX509certPrincipalT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the DER encoded serial number for the X.509 certificate. The value
// possibly includes a leading 00 byte.
///
func (self *CX509certificateT) GetSerialNumber() (ret *CBinaryValueT) {

	cRet := C.cefingo_x509certificate_get_serial_number((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the date before which the X.509 certificate is invalid.
// CefTime.GetTimeT() will return 0 if no date was specified.
///
func (self *CX509certificateT) GetValidStart() (ret CTimeT) {

	cRet := C.cefingo_x509certificate_get_valid_start((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = (CTimeT)(cRet) // return GoObj
	return ret
}

///
// Returns the date after which the X.509 certificate is invalid.
// CefTime.GetTimeT() will return 0 if no date was specified.
///
func (self *CX509certificateT) GetValidExpiry() (ret CTimeT) {

	cRet := C.cefingo_x509certificate_get_valid_expiry((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = (CTimeT)(cRet) // return GoObj
	return ret
}

///
// Returns the DER encoded data for the X.509 certificate.
///
func (self *CX509certificateT) GetDerencoded() (ret *CBinaryValueT) {

	cRet := C.cefingo_x509certificate_get_derencoded((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the PEM encoded data for the X.509 certificate.
///
func (self *CX509certificateT) GetPemencoded() (ret *CBinaryValueT) {

	cRet := C.cefingo_x509certificate_get_pemencoded((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = newCBinaryValueT(cRet, byApp) // return GoObj
	return ret
}

///
// Returns the number of certificates in the issuer chain. If 0, the
// certificate is self-signed.
///
func (self *CX509certificateT) GetIssuerChainSize() (ret int64) {

	cRet := C.cefingo_x509certificate_get_issuer_chain_size((*C.cef_x509certificate_t)(self.pc_x509certificate))

	ret = (int64)(cRet) // return GoObj
	return ret
}

///
// Returns the DER encoded data for the certificate issuer chain. If we failed
// to encode a certificate in the chain it is still present in the array but
// is an NULL string.
///
func (self *CX509certificateT) GetDerencodedIssuerChain() (chain []*CBinaryValueT) {
	_chainCount := C.size_t(self.GetIssuerChainSize()) // =SizeFunc cef_x509certificate_t::get_derencoded_issuer_chain:chain
	if _chainCount == 0 {
		return
	}
	chainCount := &_chainCount
	tmpchain := unsafe.Pointer(c_calloc(_chainCount, 8, "T234.3"))
	defer C.free(tmpchain)

	C.cefingo_x509certificate_get_derencoded_issuer_chain((*C.cef_x509certificate_t)(self.pc_x509certificate), (*C.size_t)(chainCount), (**C.cef_binary_value_t)(tmpchain))

	chain = make([]*CBinaryValueT, *chainCount)
	_tmpchain := (*[1 << 30](*C.cef_binary_value_t))(unsafe.Pointer(tmpchain))[:*chainCount:*chainCount]
	for i := C.size_t(0); i < *chainCount; i++ {
		chain[i] = newCBinaryValueT(_tmpchain[i], byApp) // Out Slice Param
	}
	return chain
}

///
// Returns the PEM encoded data for the certificate issuer chain. If we failed
// to encode a certificate in the chain it is still present in the array but
// is an NULL string.
///
func (self *CX509certificateT) GetPemencodedIssuerChain() (chain []*CBinaryValueT) {
	_chainCount := C.size_t(self.GetIssuerChainSize()) // =SizeFunc cef_x509certificate_t::get_pemencoded_issuer_chain:chain
	if _chainCount == 0 {
		return
	}
	chainCount := &_chainCount
	tmpchain := unsafe.Pointer(c_calloc(_chainCount, 8, "T234.4"))
	defer C.free(tmpchain)

	C.cefingo_x509certificate_get_pemencoded_issuer_chain((*C.cef_x509certificate_t)(self.pc_x509certificate), (*C.size_t)(chainCount), (**C.cef_binary_value_t)(tmpchain))

	chain = make([]*CBinaryValueT, *chainCount)
	_tmpchain := (*[1 << 30](*C.cef_binary_value_t))(unsafe.Pointer(tmpchain))[:*chainCount:*chainCount]
	for i := C.size_t(0); i < *chainCount; i++ {
		chain[i] = newCBinaryValueT(_tmpchain[i], byApp) // Out Slice Param
	}
	return chain
}
