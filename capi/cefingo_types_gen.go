// Code generated by "gen-cefingo.go" DO NOT EDIT.

package capi

import (
	"sync"
	"time"
	"unsafe"
)

// #include "cefingo.h"
import "C"

var cefingoIfaceAccess sync.Mutex

// cef_string_list.h, include/internal/cef_string_list.h:44:36,

// /
// / CEF string maps are a set of key/value string pairs.
// /
type CStringListT C.cef_string_list_t

// /
// / Allocate a new string map.
// /
func StringListAlloc() (ret CStringListT) {

	cRet := C.cef_string_list_alloc()

	ret = (CStringListT)(cRet) // return GoObj
	return ret
}

// /
// / Return the number of elements in the string list.
// /
func StringListSize(
	list CStringListT,
) (ret int64) {

	cRet := C.cef_string_list_size((C.cef_string_list_t)(list))

	ret = (int64)(cRet) // return GoObj
	return ret
}

// /
// / Retrieve the value at the specified zero-based string list index. Returns
// / true (1) if the value was successfully retrieved.
// /
func StringListValue(
	list CStringListT,
	index int64,
) (ret bool, value string) {
	// IsOutParam
	tmpc_value := create_cef_string("")

	cRet := C.cef_string_list_value((C.cef_string_list_t)(list), (C.size_t)(index), tmpc_value.p_cef_string_t /* IsOutParam */)

	// IsOutParam
	value = string_from_cef_string(tmpc_value.p_cef_string_t)

	ret = cRet == 1
	return ret, value
}

// /
// / Append a new value at the end of the string list.
// /
func StringListAppend(
	list CStringListT,
	value string,
) {
	c_value := create_cef_string(value)

	C.cef_string_list_append((C.cef_string_list_t)(list), c_value.p_cef_string_t)

}

// /
// / Clear the string list.
// /
func StringListClear(
	list CStringListT,
) {

	C.cef_string_list_clear((C.cef_string_list_t)(list))

}

// /
// / Free the string list.
// /
func StringListFree(
	list CStringListT,
) {

	C.cef_string_list_free((C.cef_string_list_t)(list))

}

// /
// / Creates a copy of an existing string list.
// /
func StringListCopy(
	list CStringListT,
) (ret CStringListT) {

	cRet := C.cef_string_list_copy((C.cef_string_list_t)(list))

	ret = (CStringListT)(cRet) // return GoObj
	return ret
}

// cef_string_map.h, include/internal/cef_string_map.h:44:35,

// /
// / CEF string maps are a set of key/value string pairs.
// /
type CStringMapT C.cef_string_map_t

// /
// / Allocate a new string map.
// /
func StringMapAlloc() (ret CStringMapT) {

	cRet := C.cef_string_map_alloc()

	ret = (CStringMapT)(cRet) // return GoObj
	return ret
}

// /
// / Return the number of elements in the string map.
// /
func StringMapSize(
	cmap CStringMapT,
) (ret int64) {

	cRet := C.cef_string_map_size((C.cef_string_map_t)(cmap))

	ret = (int64)(cRet) // return GoObj
	return ret
}

// /
// / Return the value assigned to the specified key.
// /
func StringMapFind(
	cmap CStringMapT,
	key string,
) (ret bool, value string) {
	c_key := create_cef_string(key)
	// IsOutParam
	tmpc_value := create_cef_string("")

	cRet := C.cef_string_map_find((C.cef_string_map_t)(cmap), c_key.p_cef_string_t, tmpc_value.p_cef_string_t /* IsOutParam */)

	// IsOutParam
	value = string_from_cef_string(tmpc_value.p_cef_string_t)

	ret = cRet == 1
	return ret, value
}

// /
// / Return the key at the specified zero-based string map index.
// /
func StringMapKey(
	cmap CStringMapT,
	index int64,
) (ret bool, key string) {
	// IsOutParam
	tmpc_key := create_cef_string("")

	cRet := C.cef_string_map_key((C.cef_string_map_t)(cmap), (C.size_t)(index), tmpc_key.p_cef_string_t /* IsOutParam */)

	// IsOutParam
	key = string_from_cef_string(tmpc_key.p_cef_string_t)

	ret = cRet == 1
	return ret, key
}

// /
// / Return the value at the specified zero-based string map index.
// /
func StringMapValue(
	cmap CStringMapT,
	index int64,
) (ret bool, value string) {
	// IsOutParam
	tmpc_value := create_cef_string("")

	cRet := C.cef_string_map_value((C.cef_string_map_t)(cmap), (C.size_t)(index), tmpc_value.p_cef_string_t /* IsOutParam */)

	// IsOutParam
	value = string_from_cef_string(tmpc_value.p_cef_string_t)

	ret = cRet == 1
	return ret, value
}

// /
// / Append a new key/value pair at the end of the string map. If the key exists,
// / overwrite the existing value with a new value w/o changing the pair order.
// /
func StringMapAppend(
	cmap CStringMapT,
	key string,
	value string,
) (ret bool) {
	c_key := create_cef_string(key)
	c_value := create_cef_string(value)

	cRet := C.cef_string_map_append((C.cef_string_map_t)(cmap), c_key.p_cef_string_t, c_value.p_cef_string_t)

	ret = cRet == 1
	return ret
}

// /
// / Clear the string map.
// /
func StringMapClear(
	cmap CStringMapT,
) {

	C.cef_string_map_clear((C.cef_string_map_t)(cmap))

}

// /
// / Free the string map.
// /
func StringMapFree(
	cmap CStringMapT,
) {

	C.cef_string_map_free((C.cef_string_map_t)(cmap))

}

// cef_string_multimap.h, include/internal/cef_string_multimap.h:45:40,

// /
// / CEF string multimaps are a set of key/value string pairs.
// / More than one value can be assigned to a single key.
// /
type CStringMultimapT C.cef_string_multimap_t

// /
// / Allocate a new string multimap.
// /
func StringMultimapAlloc() (ret CStringMultimapT) {

	cRet := C.cef_string_multimap_alloc()

	ret = (CStringMultimapT)(cRet) // return GoObj
	return ret
}

// /
// / Return the number of elements in the string multimap.
// /
func StringMultimapSize(
	cmap CStringMultimapT,
) (ret int64) {

	cRet := C.cef_string_multimap_size((C.cef_string_multimap_t)(cmap))

	ret = (int64)(cRet) // return GoObj
	return ret
}

// /
// / Return the number of values with the specified key.
// /
func StringMultimapFindCount(
	cmap CStringMultimapT,
	key string,
) (ret int64) {
	c_key := create_cef_string(key)

	cRet := C.cef_string_multimap_find_count((C.cef_string_multimap_t)(cmap), c_key.p_cef_string_t)

	ret = (int64)(cRet) // return GoObj
	return ret
}

// /
// / Return the value_index-th value with the specified key.
// /
func StringMultimapEnumerate(
	cmap CStringMultimapT,
	key string,
	value_index int64,
) (ret bool, value string) {
	c_key := create_cef_string(key)
	// IsOutParam
	tmpc_value := create_cef_string("")

	cRet := C.cef_string_multimap_enumerate((C.cef_string_multimap_t)(cmap), c_key.p_cef_string_t, (C.size_t)(value_index), tmpc_value.p_cef_string_t /* IsOutParam */)

	// IsOutParam
	value = string_from_cef_string(tmpc_value.p_cef_string_t)

	ret = cRet == 1
	return ret, value
}

// /
// / Return the key at the specified zero-based string multimap index.
// /
func StringMultimapKey(
	cmap CStringMultimapT,
	index int64,
) (ret bool, key string) {
	// IsOutParam
	tmpc_key := create_cef_string("")

	cRet := C.cef_string_multimap_key((C.cef_string_multimap_t)(cmap), (C.size_t)(index), tmpc_key.p_cef_string_t /* IsOutParam */)

	// IsOutParam
	key = string_from_cef_string(tmpc_key.p_cef_string_t)

	ret = cRet == 1
	return ret, key
}

// /
// / Return the value at the specified zero-based string multimap index.
// /
func StringMultimapValue(
	cmap CStringMultimapT,
	index int64,
) (ret bool, value string) {
	// IsOutParam
	tmpc_value := create_cef_string("")

	cRet := C.cef_string_multimap_value((C.cef_string_multimap_t)(cmap), (C.size_t)(index), tmpc_value.p_cef_string_t /* IsOutParam */)

	// IsOutParam
	value = string_from_cef_string(tmpc_value.p_cef_string_t)

	ret = cRet == 1
	return ret, value
}

// /
// / Append a new key/value pair at the end of the string multimap.
// /
func StringMultimapAppend(
	cmap CStringMultimapT,
	key string,
	value string,
) (ret bool) {
	c_key := create_cef_string(key)
	c_value := create_cef_string(value)

	cRet := C.cef_string_multimap_append((C.cef_string_multimap_t)(cmap), c_key.p_cef_string_t, c_value.p_cef_string_t)

	ret = cRet == 1
	return ret
}

// /
// / Clear the string multimap.
// /
func StringMultimapClear(
	cmap CStringMultimapT,
) {

	C.cef_string_multimap_clear((C.cef_string_multimap_t)(cmap))

}

// /
// / Free the string multimap.
// /
func StringMultimapFree(
	cmap CStringMultimapT,
) {

	C.cef_string_multimap_free((C.cef_string_multimap_t)(cmap))

}

// cef_time.h, include/internal/cef_time.h:52:3,

// /
// / Represents a wall clock time in UTC. Values are not guaranteed to be
// / monotonically non-decreasing and are subject to large amounts of skew.
// / Time is stored internally as microseconds since the Windows epoch (1601).
// /
// / This is equivalent of Chromium `base::Time` (see base/time/time.h).
// /
type CBasetimeT C.cef_basetime_t

func NewCBasetimeT() *CBasetimeT {
	s := &CBasetimeT{}
	return s
}

func (st *CBasetimeT) Val() int64 {
	return int64(st.val)
}

func (st *CBasetimeT) SetVal(v int64) {
	st.val = (C.int64_t)(v)
}

// /
// / Time information. Values should always be in UTC.
// /
type CTimeT C.cef_time_t

func NewCTimeT() *CTimeT {
	s := &CTimeT{}
	return s
}

func (st *CTimeT) Year() int {
	return int(st.year)
}

func (st *CTimeT) SetYear(v int) {
	st.year = (C.int)(v)
}

func (st *CTimeT) Month() int {
	return int(st.month)
}

func (st *CTimeT) SetMonth(v int) {
	st.month = (C.int)(v)
}

func (st *CTimeT) DayOfWeek() int {
	return int(st.day_of_week)
}

func (st *CTimeT) SetDayOfWeek(v int) {
	st.day_of_week = (C.int)(v)
}

func (st *CTimeT) DayOfMonth() int {
	return int(st.day_of_month)
}

func (st *CTimeT) SetDayOfMonth(v int) {
	st.day_of_month = (C.int)(v)
}

func (st *CTimeT) Hour() int {
	return int(st.hour)
}

func (st *CTimeT) SetHour(v int) {
	st.hour = (C.int)(v)
}

func (st *CTimeT) Minute() int {
	return int(st.minute)
}

func (st *CTimeT) SetMinute(v int) {
	st.minute = (C.int)(v)
}

func (st *CTimeT) Second() int {
	return int(st.second)
}

func (st *CTimeT) SetSecond(v int) {
	st.second = (C.int)(v)
}

func (st *CTimeT) Millisecond() int {
	return int(st.millisecond)
}

func (st *CTimeT) SetMillisecond(v int) {
	st.millisecond = (C.int)(v)
}

// /
// / Converts cef_time_t to/from time_t. Returns true (1) on success and false
// / (0) on failure.
// /
func TimeToTimet(
	cef_time *CTimeT,
) (ret bool, ctime time.Time) {
	// IsOutParam
	var tmpc_ctime C.time_t

	cRet := C.cef_time_to_timet((*C.cef_time_t)(cef_time), &tmpc_ctime /* IsOutParam */)

	// IsOutParam

	ctime = time.Unix(int64(tmpc_ctime), 0)

	ret = cRet == 1
	return ret, ctime
}
func TimeFromTimet(
	ctime time.Time,
	cef_time *CTimeT,
) (ret bool) {
	c_ctime := ctime.Unix()

	cRet := C.cef_time_from_timet(C.time_t(c_ctime), (*C.cef_time_t)(cef_time))

	ret = cRet == 1
	return ret
}

// /
// / Converts cef_time_t to/from a double which is the number of seconds since
// / epoch (Jan 1, 1970). Webkit uses this format to represent time. A value of 0
// / means "not initialized". Returns true (1) on success and false (0) on
// / failure.
// /
func TimeToDoublet(
	cef_time *CTimeT,
	ctime *float64,
) (ret bool) {

	cRet := C.cef_time_to_doublet((*C.cef_time_t)(cef_time), (*C.double)(ctime))

	ret = cRet == 1
	return ret
}
func TimeFromDoublet(
	ctime float64,
	cef_time *CTimeT,
) (ret bool) {

	cRet := C.cef_time_from_doublet((C.double)(ctime), (*C.cef_time_t)(cef_time))

	ret = cRet == 1
	return ret
}

// /
// / Retrieve the current system time. Returns true (1) on success and false (0)
// / on failure.
// /
func TimeNow(
	cef_time *CTimeT,
) (ret bool) {

	cRet := C.cef_time_now((*C.cef_time_t)(cef_time))

	ret = cRet == 1
	return ret
}

// /
// / Retrieve the current system time.
// /
func BasetimeNow() (ret CBasetimeT) {

	cRet := C.cef_basetime_now()

	ret = (CBasetimeT)(cRet) // return GoObj
	return ret
}

// /
// / Retrieve the delta in milliseconds between two time values. Returns true (1)
// / on success and false (0) on failure.
func TimeDelta(
	cef_time1 *CTimeT,
	cef_time2 *CTimeT,
	delta *int64,
) (ret bool) {

	cRet := C.cef_time_delta((*C.cef_time_t)(cef_time1), (*C.cef_time_t)(cef_time2), (*C.LONGLONG)(delta))

	ret = cRet == 1
	return ret
}

// /
// / Converts cef_time_t to cef_basetime_t. Returns true (1) on success and
// / false (0) on failure.
// /
func TimeToBasetime(
	from *CTimeT,
	to *CBasetimeT,
) (ret bool) {

	cRet := C.cef_time_to_basetime((*C.cef_time_t)(from), (*C.cef_basetime_t)(to))

	ret = cRet == 1
	return ret
}

// /
// / Converts cef_basetime_t to cef_time_t. Returns true (1) on success and
// / false (0) on failure.
// /
func TimeFromBasetime(
	from CBasetimeT,
	to *CTimeT,
) (ret bool) {

	cRet := C.cef_time_from_basetime((C.cef_basetime_t)(from), (*C.cef_time_t)(to))

	ret = cRet == 1
	return ret
}

// cef_types.h, include/internal/cef_types.h:55:18,

// 32-bit ARGB color value, not premultiplied. The color components are always
// in a known order. Equivalent to the SkColor type.
type CColorT C.cef_color_t

// /
// / Log severity levels.
// /
type CLogSeverityT C.cef_log_severity_t

const (

	///
	/// Default logging (currently INFO logging).
	///
	LogseverityDefault CLogSeverityT = C.LOGSEVERITY_DEFAULT

	///
	/// Verbose logging.
	///
	LogseverityVerbose CLogSeverityT = C.LOGSEVERITY_VERBOSE

	///
	/// DEBUG logging.
	///
	LogseverityDebug CLogSeverityT = C.LOGSEVERITY_DEBUG

	///
	/// INFO logging.
	///
	LogseverityInfo CLogSeverityT = C.LOGSEVERITY_INFO

	///
	/// WARNING logging.
	///
	LogseverityWarning CLogSeverityT = C.LOGSEVERITY_WARNING

	///
	/// ERROR logging.
	///
	LogseverityError CLogSeverityT = C.LOGSEVERITY_ERROR

	///
	/// FATAL logging.
	///
	LogseverityFatal CLogSeverityT = C.LOGSEVERITY_FATAL

	///
	/// Disable logging to file for all messages, and to stderr for messages with
	/// severity less than FATAL.
	///
	LogseverityDisable CLogSeverityT = C.LOGSEVERITY_DISABLE
)

// /
// / Represents the state of a setting.
// /
type CStateT C.cef_state_t

const (

	///
	/// Use the default state for the setting.
	///
	StateDefault CStateT = C.STATE_DEFAULT

	///
	/// Enable or allow the setting.
	///
	StateEnabled CStateT = C.STATE_ENABLED

	///
	/// Disable or disallow the setting.
	///
	StateDisabled CStateT = C.STATE_DISABLED
)

// /
// / Initialization settings. Specify NULL or 0 to get the recommended default
// / values. Many of these and other settings can also configured using command-
// / line switches.
// /
type CSettingsT C.cef_settings_t

func NewCSettingsT() *CSettingsT {
	s := &CSettingsT{}
	s.size = C.sizeof_cef_settings_t
	return s
}

func (st *CSettingsT) NoSandbox() bool {
	return st.no_sandbox != 0
}

func (st *CSettingsT) SetNoSandbox(v bool) {
	if v {
		st.no_sandbox = 1
	} else {
		st.no_sandbox = 0
	}
}

func (st *CSettingsT) BrowserSubprocessPath() string {
	return string_from_cef_string(&st.browser_subprocess_path)
}

func (st *CSettingsT) SetBrowserSubprocessPath(v string) {
	set_cef_string(&st.browser_subprocess_path, v)
}

func (st *CSettingsT) FrameworkDirPath() string {
	return string_from_cef_string(&st.framework_dir_path)
}

func (st *CSettingsT) SetFrameworkDirPath(v string) {
	set_cef_string(&st.framework_dir_path, v)
}

func (st *CSettingsT) MainBundlePath() string {
	return string_from_cef_string(&st.main_bundle_path)
}

func (st *CSettingsT) SetMainBundlePath(v string) {
	set_cef_string(&st.main_bundle_path, v)
}

func (st *CSettingsT) ChromeRuntime() int {
	return int(st.chrome_runtime)
}

func (st *CSettingsT) SetChromeRuntime(v int) {
	st.chrome_runtime = (C.int)(v)
}

func (st *CSettingsT) MultiThreadedMessageLoop() bool {
	return st.multi_threaded_message_loop != 0
}

func (st *CSettingsT) SetMultiThreadedMessageLoop(v bool) {
	if v {
		st.multi_threaded_message_loop = 1
	} else {
		st.multi_threaded_message_loop = 0
	}
}

func (st *CSettingsT) ExternalMessagePump() bool {
	return st.external_message_pump != 0
}

func (st *CSettingsT) SetExternalMessagePump(v bool) {
	if v {
		st.external_message_pump = 1
	} else {
		st.external_message_pump = 0
	}
}

func (st *CSettingsT) WindowlessRenderingEnabled() bool {
	return st.windowless_rendering_enabled != 0
}

func (st *CSettingsT) SetWindowlessRenderingEnabled(v bool) {
	if v {
		st.windowless_rendering_enabled = 1
	} else {
		st.windowless_rendering_enabled = 0
	}
}

func (st *CSettingsT) CommandLineArgsDisabled() bool {
	return st.command_line_args_disabled != 0
}

func (st *CSettingsT) SetCommandLineArgsDisabled(v bool) {
	if v {
		st.command_line_args_disabled = 1
	} else {
		st.command_line_args_disabled = 0
	}
}

func (st *CSettingsT) CachePath() string {
	return string_from_cef_string(&st.cache_path)
}

func (st *CSettingsT) SetCachePath(v string) {
	set_cef_string(&st.cache_path, v)
}

func (st *CSettingsT) RootCachePath() string {
	return string_from_cef_string(&st.root_cache_path)
}

func (st *CSettingsT) SetRootCachePath(v string) {
	set_cef_string(&st.root_cache_path, v)
}

func (st *CSettingsT) PersistSessionCookies() bool {
	return st.persist_session_cookies != 0
}

func (st *CSettingsT) SetPersistSessionCookies(v bool) {
	if v {
		st.persist_session_cookies = 1
	} else {
		st.persist_session_cookies = 0
	}
}

func (st *CSettingsT) PersistUserPreferences() bool {
	return st.persist_user_preferences != 0
}

func (st *CSettingsT) SetPersistUserPreferences(v bool) {
	if v {
		st.persist_user_preferences = 1
	} else {
		st.persist_user_preferences = 0
	}
}

func (st *CSettingsT) UserAgent() string {
	return string_from_cef_string(&st.user_agent)
}

func (st *CSettingsT) SetUserAgent(v string) {
	set_cef_string(&st.user_agent, v)
}

func (st *CSettingsT) UserAgentProduct() string {
	return string_from_cef_string(&st.user_agent_product)
}

func (st *CSettingsT) SetUserAgentProduct(v string) {
	set_cef_string(&st.user_agent_product, v)
}

func (st *CSettingsT) Locale() string {
	return string_from_cef_string(&st.locale)
}

func (st *CSettingsT) SetLocale(v string) {
	set_cef_string(&st.locale, v)
}

func (st *CSettingsT) LogFile() string {
	return string_from_cef_string(&st.log_file)
}

func (st *CSettingsT) SetLogFile(v string) {
	set_cef_string(&st.log_file, v)
}

func (st *CSettingsT) LogSeverity() CLogSeverityT {
	return CLogSeverityT(st.log_severity)
}

func (st *CSettingsT) SetLogSeverity(v CLogSeverityT) {
	st.log_severity = (C.cef_log_severity_t)(v)
}

func (st *CSettingsT) JavascriptFlags() string {
	return string_from_cef_string(&st.javascript_flags)
}

func (st *CSettingsT) SetJavascriptFlags(v string) {
	set_cef_string(&st.javascript_flags, v)
}

func (st *CSettingsT) ResourcesDirPath() string {
	return string_from_cef_string(&st.resources_dir_path)
}

func (st *CSettingsT) SetResourcesDirPath(v string) {
	set_cef_string(&st.resources_dir_path, v)
}

func (st *CSettingsT) LocalesDirPath() string {
	return string_from_cef_string(&st.locales_dir_path)
}

func (st *CSettingsT) SetLocalesDirPath(v string) {
	set_cef_string(&st.locales_dir_path, v)
}

func (st *CSettingsT) PackLoadingDisabled() bool {
	return st.pack_loading_disabled != 0
}

func (st *CSettingsT) SetPackLoadingDisabled(v bool) {
	if v {
		st.pack_loading_disabled = 1
	} else {
		st.pack_loading_disabled = 0
	}
}

func (st *CSettingsT) RemoteDebuggingPort() int {
	return int(st.remote_debugging_port)
}

func (st *CSettingsT) SetRemoteDebuggingPort(v int) {
	st.remote_debugging_port = (C.int)(v)
}

func (st *CSettingsT) UncaughtExceptionStackSize() int {
	return int(st.uncaught_exception_stack_size)
}

func (st *CSettingsT) SetUncaughtExceptionStackSize(v int) {
	st.uncaught_exception_stack_size = (C.int)(v)
}

func (st *CSettingsT) BackgroundColor() CColorT {
	return CColorT(st.background_color)
}

func (st *CSettingsT) SetBackgroundColor(v CColorT) {
	st.background_color = (C.cef_color_t)(v)
}

func (st *CSettingsT) AcceptLanguageList() string {
	return string_from_cef_string(&st.accept_language_list)
}

func (st *CSettingsT) SetAcceptLanguageList(v string) {
	set_cef_string(&st.accept_language_list, v)
}

func (st *CSettingsT) CookieableSchemesList() string {
	return string_from_cef_string(&st.cookieable_schemes_list)
}

func (st *CSettingsT) SetCookieableSchemesList(v string) {
	set_cef_string(&st.cookieable_schemes_list, v)
}

func (st *CSettingsT) CookieableSchemesExcludeDefaults() int {
	return int(st.cookieable_schemes_exclude_defaults)
}

func (st *CSettingsT) SetCookieableSchemesExcludeDefaults(v int) {
	st.cookieable_schemes_exclude_defaults = (C.int)(v)
}

// /
// / Request context initialization settings. Specify NULL or 0 to get the
// / recommended default values.
// /
type CRequestContextSettingsT C.cef_request_context_settings_t

func NewCRequestContextSettingsT() *CRequestContextSettingsT {
	s := &CRequestContextSettingsT{}
	s.size = C.sizeof_cef_request_context_settings_t
	return s
}

func (st *CRequestContextSettingsT) CachePath() string {
	return string_from_cef_string(&st.cache_path)
}

func (st *CRequestContextSettingsT) SetCachePath(v string) {
	set_cef_string(&st.cache_path, v)
}

func (st *CRequestContextSettingsT) PersistSessionCookies() bool {
	return st.persist_session_cookies != 0
}

func (st *CRequestContextSettingsT) SetPersistSessionCookies(v bool) {
	if v {
		st.persist_session_cookies = 1
	} else {
		st.persist_session_cookies = 0
	}
}

func (st *CRequestContextSettingsT) PersistUserPreferences() bool {
	return st.persist_user_preferences != 0
}

func (st *CRequestContextSettingsT) SetPersistUserPreferences(v bool) {
	if v {
		st.persist_user_preferences = 1
	} else {
		st.persist_user_preferences = 0
	}
}

func (st *CRequestContextSettingsT) AcceptLanguageList() string {
	return string_from_cef_string(&st.accept_language_list)
}

func (st *CRequestContextSettingsT) SetAcceptLanguageList(v string) {
	set_cef_string(&st.accept_language_list, v)
}

func (st *CRequestContextSettingsT) CookieableSchemesList() string {
	return string_from_cef_string(&st.cookieable_schemes_list)
}

func (st *CRequestContextSettingsT) SetCookieableSchemesList(v string) {
	set_cef_string(&st.cookieable_schemes_list, v)
}

func (st *CRequestContextSettingsT) CookieableSchemesExcludeDefaults() int {
	return int(st.cookieable_schemes_exclude_defaults)
}

func (st *CRequestContextSettingsT) SetCookieableSchemesExcludeDefaults(v int) {
	st.cookieable_schemes_exclude_defaults = (C.int)(v)
}

// /
// / Browser initialization settings. Specify NULL or 0 to get the recommended
// / default values. The consequences of using custom values may not be well
// / tested. Many of these and other settings can also configured using command-
// / line switches.
// /
type CBrowserSettingsT C.cef_browser_settings_t

func NewCBrowserSettingsT() *CBrowserSettingsT {
	s := &CBrowserSettingsT{}
	s.size = C.sizeof_cef_browser_settings_t
	return s
}

func (st *CBrowserSettingsT) WindowlessFrameRate() int {
	return int(st.windowless_frame_rate)
}

func (st *CBrowserSettingsT) SetWindowlessFrameRate(v int) {
	st.windowless_frame_rate = (C.int)(v)
}

func (st *CBrowserSettingsT) StandardFontFamily() string {
	return string_from_cef_string(&st.standard_font_family)
}

func (st *CBrowserSettingsT) SetStandardFontFamily(v string) {
	set_cef_string(&st.standard_font_family, v)
}

func (st *CBrowserSettingsT) FixedFontFamily() string {
	return string_from_cef_string(&st.fixed_font_family)
}

func (st *CBrowserSettingsT) SetFixedFontFamily(v string) {
	set_cef_string(&st.fixed_font_family, v)
}

func (st *CBrowserSettingsT) SerifFontFamily() string {
	return string_from_cef_string(&st.serif_font_family)
}

func (st *CBrowserSettingsT) SetSerifFontFamily(v string) {
	set_cef_string(&st.serif_font_family, v)
}

func (st *CBrowserSettingsT) SansSerifFontFamily() string {
	return string_from_cef_string(&st.sans_serif_font_family)
}

func (st *CBrowserSettingsT) SetSansSerifFontFamily(v string) {
	set_cef_string(&st.sans_serif_font_family, v)
}

func (st *CBrowserSettingsT) CursiveFontFamily() string {
	return string_from_cef_string(&st.cursive_font_family)
}

func (st *CBrowserSettingsT) SetCursiveFontFamily(v string) {
	set_cef_string(&st.cursive_font_family, v)
}

func (st *CBrowserSettingsT) FantasyFontFamily() string {
	return string_from_cef_string(&st.fantasy_font_family)
}

func (st *CBrowserSettingsT) SetFantasyFontFamily(v string) {
	set_cef_string(&st.fantasy_font_family, v)
}

func (st *CBrowserSettingsT) DefaultFontSize() int {
	return int(st.default_font_size)
}

func (st *CBrowserSettingsT) SetDefaultFontSize(v int) {
	st.default_font_size = (C.int)(v)
}

func (st *CBrowserSettingsT) DefaultFixedFontSize() int {
	return int(st.default_fixed_font_size)
}

func (st *CBrowserSettingsT) SetDefaultFixedFontSize(v int) {
	st.default_fixed_font_size = (C.int)(v)
}

func (st *CBrowserSettingsT) MinimumFontSize() int {
	return int(st.minimum_font_size)
}

func (st *CBrowserSettingsT) SetMinimumFontSize(v int) {
	st.minimum_font_size = (C.int)(v)
}

func (st *CBrowserSettingsT) MinimumLogicalFontSize() int {
	return int(st.minimum_logical_font_size)
}

func (st *CBrowserSettingsT) SetMinimumLogicalFontSize(v int) {
	st.minimum_logical_font_size = (C.int)(v)
}

func (st *CBrowserSettingsT) DefaultEncoding() string {
	return string_from_cef_string(&st.default_encoding)
}

func (st *CBrowserSettingsT) SetDefaultEncoding(v string) {
	set_cef_string(&st.default_encoding, v)
}

func (st *CBrowserSettingsT) RemoteFonts() CStateT {
	return CStateT(st.remote_fonts)
}

func (st *CBrowserSettingsT) SetRemoteFonts(v CStateT) {
	st.remote_fonts = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) Javascript() CStateT {
	return CStateT(st.javascript)
}

func (st *CBrowserSettingsT) SetJavascript(v CStateT) {
	st.javascript = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) JavascriptCloseWindows() CStateT {
	return CStateT(st.javascript_close_windows)
}

func (st *CBrowserSettingsT) SetJavascriptCloseWindows(v CStateT) {
	st.javascript_close_windows = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) JavascriptAccessClipboard() CStateT {
	return CStateT(st.javascript_access_clipboard)
}

func (st *CBrowserSettingsT) SetJavascriptAccessClipboard(v CStateT) {
	st.javascript_access_clipboard = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) JavascriptDomPaste() CStateT {
	return CStateT(st.javascript_dom_paste)
}

func (st *CBrowserSettingsT) SetJavascriptDomPaste(v CStateT) {
	st.javascript_dom_paste = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) ImageLoading() CStateT {
	return CStateT(st.image_loading)
}

func (st *CBrowserSettingsT) SetImageLoading(v CStateT) {
	st.image_loading = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) ImageShrinkStandaloneToFit() CStateT {
	return CStateT(st.image_shrink_standalone_to_fit)
}

func (st *CBrowserSettingsT) SetImageShrinkStandaloneToFit(v CStateT) {
	st.image_shrink_standalone_to_fit = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) TextAreaResize() CStateT {
	return CStateT(st.text_area_resize)
}

func (st *CBrowserSettingsT) SetTextAreaResize(v CStateT) {
	st.text_area_resize = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) TabToLinks() CStateT {
	return CStateT(st.tab_to_links)
}

func (st *CBrowserSettingsT) SetTabToLinks(v CStateT) {
	st.tab_to_links = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) LocalStorage() CStateT {
	return CStateT(st.local_storage)
}

func (st *CBrowserSettingsT) SetLocalStorage(v CStateT) {
	st.local_storage = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) Databases() CStateT {
	return CStateT(st.databases)
}

func (st *CBrowserSettingsT) SetDatabases(v CStateT) {
	st.databases = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) Webgl() CStateT {
	return CStateT(st.webgl)
}

func (st *CBrowserSettingsT) SetWebgl(v CStateT) {
	st.webgl = (C.cef_state_t)(v)
}

func (st *CBrowserSettingsT) BackgroundColor() CColorT {
	return CColorT(st.background_color)
}

func (st *CBrowserSettingsT) SetBackgroundColor(v CColorT) {
	st.background_color = (C.cef_color_t)(v)
}

func (st *CBrowserSettingsT) AcceptLanguageList() string {
	return string_from_cef_string(&st.accept_language_list)
}

func (st *CBrowserSettingsT) SetAcceptLanguageList(v string) {
	set_cef_string(&st.accept_language_list, v)
}

func (st *CBrowserSettingsT) ChromeStatusBubble() CStateT {
	return CStateT(st.chrome_status_bubble)
}

func (st *CBrowserSettingsT) SetChromeStatusBubble(v CStateT) {
	st.chrome_status_bubble = (C.cef_state_t)(v)
}

// /
// / Return value types.
// /
type CReturnValueT C.cef_return_value_t

const (

	///
	/// Cancel immediately.
	///
	RvCancel CReturnValueT = C.RV_CANCEL

	///
	/// Continue immediately.
	///
	RvContinue CReturnValueT = C.RV_CONTINUE

	///
	/// Continue asynchronously (usually via a callback).
	///
	RvContinueAsync CReturnValueT = C.RV_CONTINUE_ASYNC
)

// /
// / URL component parts.
// /
type CUrlpartsT C.cef_urlparts_t

func NewCUrlpartsT() *CUrlpartsT {
	s := &CUrlpartsT{}
	return s
}

func (st *CUrlpartsT) Spec() string {
	return string_from_cef_string(&st.spec)
}

func (st *CUrlpartsT) SetSpec(v string) {
	set_cef_string(&st.spec, v)
}

func (st *CUrlpartsT) Scheme() string {
	return string_from_cef_string(&st.scheme)
}

func (st *CUrlpartsT) SetScheme(v string) {
	set_cef_string(&st.scheme, v)
}

func (st *CUrlpartsT) Username() string {
	return string_from_cef_string(&st.username)
}

func (st *CUrlpartsT) SetUsername(v string) {
	set_cef_string(&st.username, v)
}

func (st *CUrlpartsT) Password() string {
	return string_from_cef_string(&st.password)
}

func (st *CUrlpartsT) SetPassword(v string) {
	set_cef_string(&st.password, v)
}

func (st *CUrlpartsT) Host() string {
	return string_from_cef_string(&st.host)
}

func (st *CUrlpartsT) SetHost(v string) {
	set_cef_string(&st.host, v)
}

func (st *CUrlpartsT) Port() string {
	return string_from_cef_string(&st.port)
}

func (st *CUrlpartsT) SetPort(v string) {
	set_cef_string(&st.port, v)
}

func (st *CUrlpartsT) Origin() string {
	return string_from_cef_string(&st.origin)
}

func (st *CUrlpartsT) SetOrigin(v string) {
	set_cef_string(&st.origin, v)
}

func (st *CUrlpartsT) Path() string {
	return string_from_cef_string(&st.path)
}

func (st *CUrlpartsT) SetPath(v string) {
	set_cef_string(&st.path, v)
}

func (st *CUrlpartsT) Query() string {
	return string_from_cef_string(&st.query)
}

func (st *CUrlpartsT) SetQuery(v string) {
	set_cef_string(&st.query, v)
}

func (st *CUrlpartsT) Fragment() string {
	return string_from_cef_string(&st.fragment)
}

func (st *CUrlpartsT) SetFragment(v string) {
	set_cef_string(&st.fragment, v)
}

// /
// / Cookie priority values.
// /
type CCookiePriorityT C.cef_cookie_priority_t

const (
	CefCookiePriorityLow    CCookiePriorityT = C.CEF_COOKIE_PRIORITY_LOW
	CefCookiePriorityMedium CCookiePriorityT = C.CEF_COOKIE_PRIORITY_MEDIUM
	CefCookiePriorityHigh   CCookiePriorityT = C.CEF_COOKIE_PRIORITY_HIGH
)

// /
// / Cookie same site values.
// /
type CCookieSameSiteT C.cef_cookie_same_site_t

const (
	CefCookieSameSiteUnspecified   CCookieSameSiteT = C.CEF_COOKIE_SAME_SITE_UNSPECIFIED
	CefCookieSameSiteNoRestriction CCookieSameSiteT = C.CEF_COOKIE_SAME_SITE_NO_RESTRICTION
	CefCookieSameSiteLaxMode       CCookieSameSiteT = C.CEF_COOKIE_SAME_SITE_LAX_MODE
	CefCookieSameSiteStrictMode    CCookieSameSiteT = C.CEF_COOKIE_SAME_SITE_STRICT_MODE
)

// /
// / Cookie information.
// /
type CCookieT C.cef_cookie_t

func NewCCookieT() *CCookieT {
	s := &CCookieT{}
	return s
}

func (st *CCookieT) Name() string {
	return string_from_cef_string(&st.name)
}

func (st *CCookieT) SetName(v string) {
	set_cef_string(&st.name, v)
}

func (st *CCookieT) Value() string {
	return string_from_cef_string(&st.value)
}

func (st *CCookieT) SetValue(v string) {
	set_cef_string(&st.value, v)
}

func (st *CCookieT) Domain() string {
	return string_from_cef_string(&st.domain)
}

func (st *CCookieT) SetDomain(v string) {
	set_cef_string(&st.domain, v)
}

func (st *CCookieT) Path() string {
	return string_from_cef_string(&st.path)
}

func (st *CCookieT) SetPath(v string) {
	set_cef_string(&st.path, v)
}

func (st *CCookieT) Secure() int {
	return int(st.secure)
}

func (st *CCookieT) SetSecure(v int) {
	st.secure = (C.int)(v)
}

func (st *CCookieT) Httponly() int {
	return int(st.httponly)
}

func (st *CCookieT) SetHttponly(v int) {
	st.httponly = (C.int)(v)
}

func (st *CCookieT) Creation() CBasetimeT {
	return CBasetimeT(st.creation)
}

func (st *CCookieT) SetCreation(v CBasetimeT) {
	st.creation = (C.cef_basetime_t)(v)
}

func (st *CCookieT) LastAccess() CBasetimeT {
	return CBasetimeT(st.last_access)
}

func (st *CCookieT) SetLastAccess(v CBasetimeT) {
	st.last_access = (C.cef_basetime_t)(v)
}

func (st *CCookieT) HasExpires() int {
	return int(st.has_expires)
}

func (st *CCookieT) SetHasExpires(v int) {
	st.has_expires = (C.int)(v)
}

func (st *CCookieT) Expires() CBasetimeT {
	return CBasetimeT(st.expires)
}

func (st *CCookieT) SetExpires(v CBasetimeT) {
	st.expires = (C.cef_basetime_t)(v)
}

func (st *CCookieT) SameSite() CCookieSameSiteT {
	return CCookieSameSiteT(st.same_site)
}

func (st *CCookieT) SetSameSite(v CCookieSameSiteT) {
	st.same_site = (C.cef_cookie_same_site_t)(v)
}

func (st *CCookieT) Priority() CCookiePriorityT {
	return CCookiePriorityT(st.priority)
}

func (st *CCookieT) SetPriority(v CCookiePriorityT) {
	st.priority = (C.cef_cookie_priority_t)(v)
}

// /
// / Process termination status values.
// /
type CTerminationStatusT C.cef_termination_status_t

const (

	///
	/// Non-zero exit status.
	///
	TsAbnormalTermination CTerminationStatusT = C.TS_ABNORMAL_TERMINATION

	///
	/// SIGKILL or task manager kill.
	///
	TsProcessWasKilled CTerminationStatusT = C.TS_PROCESS_WAS_KILLED

	///
	/// Segmentation fault.
	///
	TsProcessCrashed CTerminationStatusT = C.TS_PROCESS_CRASHED

	///
	/// Out of memory. Some platforms may use TS_PROCESS_CRASHED instead.
	///
	TsProcessOom CTerminationStatusT = C.TS_PROCESS_OOM
)

// /
// / Path key values.
// /
type CPathKeyT C.cef_path_key_t

const (

	///
	/// Current directory.
	///
	PkDirCurrent CPathKeyT = C.PK_DIR_CURRENT

	///
	/// Directory containing PK_FILE_EXE.
	///
	PkDirExe CPathKeyT = C.PK_DIR_EXE

	///
	/// Directory containing PK_FILE_MODULE.
	///
	PkDirModule CPathKeyT = C.PK_DIR_MODULE

	///
	/// Temporary directory.
	///
	PkDirTemp CPathKeyT = C.PK_DIR_TEMP

	///
	/// Path and filename of the current executable.
	///
	PkFileExe CPathKeyT = C.PK_FILE_EXE

	///
	/// Path and filename of the module containing the CEF code (usually the
	/// libcef module).
	///
	PkFileModule CPathKeyT = C.PK_FILE_MODULE

	///
	/// "Local Settings\Application Data" directory under the user profile
	/// directory on Windows.
	///
	PkLocalAppData CPathKeyT = C.PK_LOCAL_APP_DATA

	///
	/// "Application Data" directory under the user profile directory on Windows
	/// and "~/Library/Application Support" directory on MacOS.
	///
	PkUserData CPathKeyT = C.PK_USER_DATA

	///
	/// Directory containing application resources. Can be configured via
	/// CefSettings.resources_dir_path.
	///
	PkDirResources CPathKeyT = C.PK_DIR_RESOURCES
)

// /
// / Storage types.
// /
type CStorageTypeT C.cef_storage_type_t

const (
	StLocalstorage   CStorageTypeT = C.ST_LOCALSTORAGE
	StSessionstorage CStorageTypeT = C.ST_SESSIONSTORAGE
)

// /
// / Supported error code values. For the complete list of error values see
// / "include/base/internal/cef_net_error_list.h".
// /
type CErrorcodeT C.cef_errorcode_t

const (

	// No error.
	ErrNone CErrorcodeT = C.ERR_NONE

	// Copyright (c) 2014 Marshall A. Greenblatt. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions are
	// met:
	//
	//    * Redistributions of source code must retain the above copyright
	// notice, this list of conditions and the following disclaimer.
	//    * Redistributions in binary form must reproduce the above
	// copyright notice, this list of conditions and the following disclaimer
	// in the documentation and/or other materials provided with the
	// distribution.
	//    * Neither the name of Google Inc. nor the name Chromium Embedded
	// Framework nor the names of its contributors may be used to endorse
	// or promote products derived from this software without specific prior
	// written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	ErrIoPending       CErrorcodeT = C.ERR_IO_PENDING
	ErrFailed          CErrorcodeT = C.ERR_FAILED
	ErrAborted         CErrorcodeT = C.ERR_ABORTED
	ErrInvalidArgument CErrorcodeT = C.ERR_INVALID_ARGUMENT
	ErrInvalidHandle   CErrorcodeT = C.ERR_INVALID_HANDLE
	ErrFileNotFound    CErrorcodeT = C.ERR_FILE_NOT_FOUND
	ErrTimedOut        CErrorcodeT = C.ERR_TIMED_OUT
	ErrFileTooBig      CErrorcodeT = C.ERR_FILE_TOO_BIG
	ErrUnexpected      CErrorcodeT = C.ERR_UNEXPECTED
	ErrAccessDenied    CErrorcodeT = C.ERR_ACCESS_DENIED

	// Return the red byte from a cef_color_t value.
	ErrNotImplemented        CErrorcodeT = C.ERR_NOT_IMPLEMENTED
	ErrInsufficientResources CErrorcodeT = C.ERR_INSUFFICIENT_RESOURCES
	ErrOutOfMemory           CErrorcodeT = C.ERR_OUT_OF_MEMORY
	ErrUploadFileChanged     CErrorcodeT = C.ERR_UPLOAD_FILE_CHANGED
	ErrSocketNotConnected    CErrorcodeT = C.ERR_SOCKET_NOT_CONNECTED
	ErrFileExists            CErrorcodeT = C.ERR_FILE_EXISTS
	ErrFilePathTooLong       CErrorcodeT = C.ERR_FILE_PATH_TOO_LONG

	// Return the high int32_t value from an int64_t value.
	ErrFileNoSpace                    CErrorcodeT = C.ERR_FILE_NO_SPACE
	ErrFileVirusInfected              CErrorcodeT = C.ERR_FILE_VIRUS_INFECTED
	ErrBlockedByClient                CErrorcodeT = C.ERR_BLOCKED_BY_CLIENT
	ErrNetworkChanged                 CErrorcodeT = C.ERR_NETWORK_CHANGED
	ErrBlockedByAdministrator         CErrorcodeT = C.ERR_BLOCKED_BY_ADMINISTRATOR
	ErrSocketIsConnected              CErrorcodeT = C.ERR_SOCKET_IS_CONNECTED
	ErrUploadStreamRewindNotSupported CErrorcodeT = C.ERR_UPLOAD_STREAM_REWIND_NOT_SUPPORTED
	ErrContextShutDown                CErrorcodeT = C.ERR_CONTEXT_SHUT_DOWN
	ErrBlockedByResponse              CErrorcodeT = C.ERR_BLOCKED_BY_RESPONSE
	ErrCleartextNotPermitted          CErrorcodeT = C.ERR_CLEARTEXT_NOT_PERMITTED
	ErrBlockedByCsp                   CErrorcodeT = C.ERR_BLOCKED_BY_CSP
	ErrH2OrQuicRequired               CErrorcodeT = C.ERR_H2_OR_QUIC_REQUIRED
	ErrBlockedByOrb                   CErrorcodeT = C.ERR_BLOCKED_BY_ORB
	ErrConnectionClosed               CErrorcodeT = C.ERR_CONNECTION_CLOSED
	ErrConnectionReset                CErrorcodeT = C.ERR_CONNECTION_RESET
	ErrConnectionRefused              CErrorcodeT = C.ERR_CONNECTION_REFUSED
	ErrConnectionAborted              CErrorcodeT = C.ERR_CONNECTION_ABORTED
	ErrConnectionFailed               CErrorcodeT = C.ERR_CONNECTION_FAILED

	///
	/// Enable or allow the setting.
	///
	ErrNameNotResolved      CErrorcodeT = C.ERR_NAME_NOT_RESOLVED
	ErrInternetDisconnected CErrorcodeT = C.ERR_INTERNET_DISCONNECTED
	ErrSslProtocolError     CErrorcodeT = C.ERR_SSL_PROTOCOL_ERROR
	ErrAddressInvalid       CErrorcodeT = C.ERR_ADDRESS_INVALID
	ErrAddressUnreachable   CErrorcodeT = C.ERR_ADDRESS_UNREACHABLE

	///
	/// Size of this structure.
	///
	ErrSslClientAuthCertNeeded    CErrorcodeT = C.ERR_SSL_CLIENT_AUTH_CERT_NEEDED
	ErrTunnelConnectionFailed     CErrorcodeT = C.ERR_TUNNEL_CONNECTION_FAILED
	ErrNoSslVersionsEnabled       CErrorcodeT = C.ERR_NO_SSL_VERSIONS_ENABLED
	ErrSslVersionOrCipherMismatch CErrorcodeT = C.ERR_SSL_VERSION_OR_CIPHER_MISMATCH
	ErrSslRenegotiationRequested  CErrorcodeT = C.ERR_SSL_RENEGOTIATION_REQUESTED
	ErrProxyAuthUnsupported       CErrorcodeT = C.ERR_PROXY_AUTH_UNSUPPORTED
	ErrBadSslClientAuthCert       CErrorcodeT = C.ERR_BAD_SSL_CLIENT_AUTH_CERT
	ErrConnectionTimedOut         CErrorcodeT = C.ERR_CONNECTION_TIMED_OUT
	ErrHostResolverQueueTooLarge  CErrorcodeT = C.ERR_HOST_RESOLVER_QUEUE_TOO_LARGE
	ErrSocksConnectionFailed      CErrorcodeT = C.ERR_SOCKS_CONNECTION_FAILED

	///
	/// The path to the main bundle on macOS. If this value is empty then it
	/// defaults to the top-level app bundle. If this value is non-empty then it
	/// must be an absolute path. Also configurable using the "main-bundle-path"
	/// command-line switch.
	///
	ErrSocksConnectionHostUnreachable CErrorcodeT = C.ERR_SOCKS_CONNECTION_HOST_UNREACHABLE
	ErrAlpnNegotiationFailed          CErrorcodeT = C.ERR_ALPN_NEGOTIATION_FAILED
	ErrSslNoRenegotiation             CErrorcodeT = C.ERR_SSL_NO_RENEGOTIATION
	ErrWinsockUnexpectedWrittenBytes  CErrorcodeT = C.ERR_WINSOCK_UNEXPECTED_WRITTEN_BYTES

	///
	/// Set to true (1) to have the browser process message loop run in a separate
	/// thread. If false (0) then the CefDoMessageLoopWork() function must be
	/// called from your application message loop. This option is only supported
	/// on Windows and Linux.
	///
	ErrSslDecompressionFailureAlert      CErrorcodeT = C.ERR_SSL_DECOMPRESSION_FAILURE_ALERT
	ErrSslBadRecordMacAlert              CErrorcodeT = C.ERR_SSL_BAD_RECORD_MAC_ALERT
	ErrProxyAuthRequested                CErrorcodeT = C.ERR_PROXY_AUTH_REQUESTED
	ErrProxyConnectionFailed             CErrorcodeT = C.ERR_PROXY_CONNECTION_FAILED
	ErrMandatoryProxyConfigurationFailed CErrorcodeT = C.ERR_MANDATORY_PROXY_CONFIGURATION_FAILED
	ErrPreconnectMaxSocketLimit          CErrorcodeT = C.ERR_PRECONNECT_MAX_SOCKET_LIMIT

	///
	/// Set to true (1) to disable configuration of browser process features using
	/// standard CEF and Chromium command-line arguments. Configuration can still
	/// be specified using CEF data structures or via the
	/// CefApp::OnBeforeCommandLineProcessing() method.
	///
	ErrSslClientAuthPrivateKeyAccessDenied CErrorcodeT = C.ERR_SSL_CLIENT_AUTH_PRIVATE_KEY_ACCESS_DENIED
	ErrSslClientAuthCertNoPrivateKey       CErrorcodeT = C.ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY
	ErrProxyCertificateInvalid             CErrorcodeT = C.ERR_PROXY_CERTIFICATE_INVALID
	ErrNameResolutionFailed                CErrorcodeT = C.ERR_NAME_RESOLUTION_FAILED

	///
	/// The location where data for the global browser cache will be stored on
	/// disk. If this value is non-empty then it must be an absolute path that is
	/// either equal to or a child directory of CefSettings.root_cache_path. If
	/// this value is empty then browsers will be created in "incognito mode"
	/// where in-memory caches are used for storage and no data is persisted to
	/// disk. HTML5 databases such as localStorage will only persist across
	/// sessions if a cache path is specified. Can be overridden for individual
	/// CefRequestContext instances via the CefRequestContextSettings.cache_path
	/// value. When using the Chrome runtime the "default" profile will be used if
	/// |cache_path| and |root_cache_path| have the same value.
	///
	ErrNetworkAccessDenied              CErrorcodeT = C.ERR_NETWORK_ACCESS_DENIED
	ErrTemporarilyThrottled             CErrorcodeT = C.ERR_TEMPORARILY_THROTTLED
	ErrHttpsProxyTunnelResponseRedirect CErrorcodeT = C.ERR_HTTPS_PROXY_TUNNEL_RESPONSE_REDIRECT
	ErrSslClientAuthSignatureFailed     CErrorcodeT = C.ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED
	ErrMsgTooBig                        CErrorcodeT = C.ERR_MSG_TOO_BIG
	ErrWsProtocolError                  CErrorcodeT = C.ERR_WS_PROTOCOL_ERROR

	///
	/// To persist user preferences as a JSON file in the cache path directory set
	/// this value to true (1). A |cache_path| value must also be specified
	/// to enable this feature. Also configurable using the
	/// "persist-user-preferences" command-line switch. Can be overridden for
	/// individual CefRequestContext instances via the
	/// CefRequestContextSettings.persist_user_preferences value.
	///
	ErrAddressInUse                    CErrorcodeT = C.ERR_ADDRESS_IN_USE
	ErrSslHandshakeNotCompleted        CErrorcodeT = C.ERR_SSL_HANDSHAKE_NOT_COMPLETED
	ErrSslBadPeerPublicKey             CErrorcodeT = C.ERR_SSL_BAD_PEER_PUBLIC_KEY
	ErrSslPinnedKeyNotInCertChain      CErrorcodeT = C.ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN
	ErrClientAuthCertTypeUnsupported   CErrorcodeT = C.ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED
	ErrSslDecryptErrorAlert            CErrorcodeT = C.ERR_SSL_DECRYPT_ERROR_ALERT
	ErrWsThrottleQueueTooLarge         CErrorcodeT = C.ERR_WS_THROTTLE_QUEUE_TOO_LARGE
	ErrSslServerCertChanged            CErrorcodeT = C.ERR_SSL_SERVER_CERT_CHANGED
	ErrSslUnrecognizedNameAlert        CErrorcodeT = C.ERR_SSL_UNRECOGNIZED_NAME_ALERT
	ErrSocketSetReceiveBufferSizeError CErrorcodeT = C.ERR_SOCKET_SET_RECEIVE_BUFFER_SIZE_ERROR

	///
	/// The log severity. Only messages of this severity level or higher will be
	/// logged. When set to DISABLE no messages will be written to the log file,
	/// but FATAL messages will still be output to stderr. Also configurable using
	/// the "log-severity" command-line switch with a value of "verbose", "info",
	/// "warning", "error", "fatal" or "disable".
	///
	ErrSocketSetSendBufferSizeError        CErrorcodeT = C.ERR_SOCKET_SET_SEND_BUFFER_SIZE_ERROR
	ErrSocketReceiveBufferSizeUnchangeable CErrorcodeT = C.ERR_SOCKET_RECEIVE_BUFFER_SIZE_UNCHANGEABLE
	ErrSocketSendBufferSizeUnchangeable    CErrorcodeT = C.ERR_SOCKET_SEND_BUFFER_SIZE_UNCHANGEABLE
	ErrSslClientAuthCertBadFormat          CErrorcodeT = C.ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT
	ErrIcannNameCollision                  CErrorcodeT = C.ERR_ICANN_NAME_COLLISION
	ErrSslServerCertBadFormat              CErrorcodeT = C.ERR_SSL_SERVER_CERT_BAD_FORMAT
	ErrCtSthParsingFailed                  CErrorcodeT = C.ERR_CT_STH_PARSING_FAILED
	ErrCtSthIncomplete                     CErrorcodeT = C.ERR_CT_STH_INCOMPLETE
	ErrUnableToReuseConnectionForProxyAuth CErrorcodeT = C.ERR_UNABLE_TO_REUSE_CONNECTION_FOR_PROXY_AUTH
	ErrCtConsistencyProofParsingFailed     CErrorcodeT = C.ERR_CT_CONSISTENCY_PROOF_PARSING_FAILED
	ErrSslObsoleteCipher                   CErrorcodeT = C.ERR_SSL_OBSOLETE_CIPHER
	ErrWsUpgrade                           CErrorcodeT = C.ERR_WS_UPGRADE

	///
	/// The number of stack trace frames to capture for uncaught exceptions.
	/// Specify a positive value to enable the
	/// CefRenderProcessHandler::OnUncaughtException() callback. Specify 0
	/// (default value) and OnUncaughtException() will not be called. Also
	/// configurable using the "uncaught-exception-stack-size" command-line
	/// switch.
	///
	ErrReadIfReadyNotImplemented       CErrorcodeT = C.ERR_READ_IF_READY_NOT_IMPLEMENTED
	ErrNoBufferSpace                   CErrorcodeT = C.ERR_NO_BUFFER_SPACE
	ErrSslClientAuthNoCommonAlgorithms CErrorcodeT = C.ERR_SSL_CLIENT_AUTH_NO_COMMON_ALGORITHMS
	ErrEarlyDataRejected               CErrorcodeT = C.ERR_EARLY_DATA_REJECTED
	ErrWrongVersionOnEarlyData         CErrorcodeT = C.ERR_WRONG_VERSION_ON_EARLY_DATA
	ErrTls13DowngradeDetected          CErrorcodeT = C.ERR_TLS13_DOWNGRADE_DETECTED
	ErrSslKeyUsageIncompatible         CErrorcodeT = C.ERR_SSL_KEY_USAGE_INCOMPATIBLE
	ErrInvalidEchConfigList            CErrorcodeT = C.ERR_INVALID_ECH_CONFIG_LIST
	ErrEchNotNegotiated                CErrorcodeT = C.ERR_ECH_NOT_NEGOTIATED
	ErrEchFallbackCertificateInvalid   CErrorcodeT = C.ERR_ECH_FALLBACK_CERTIFICATE_INVALID
	ErrCertCommonNameInvalid           CErrorcodeT = C.ERR_CERT_COMMON_NAME_INVALID
	ErrCertDateInvalid                 CErrorcodeT = C.ERR_CERT_DATE_INVALID
	ErrCertAuthorityInvalid            CErrorcodeT = C.ERR_CERT_AUTHORITY_INVALID
	ErrCertContainsErrors              CErrorcodeT = C.ERR_CERT_CONTAINS_ERRORS
	ErrCertNoRevocationMechanism       CErrorcodeT = C.ERR_CERT_NO_REVOCATION_MECHANISM
	ErrCertUnableToCheckRevocation     CErrorcodeT = C.ERR_CERT_UNABLE_TO_CHECK_REVOCATION
	ErrCertRevoked                     CErrorcodeT = C.ERR_CERT_REVOKED

	///
	/// Font settings.
	///
	ErrCertInvalid                     CErrorcodeT = C.ERR_CERT_INVALID
	ErrCertWeakSignatureAlgorithm      CErrorcodeT = C.ERR_CERT_WEAK_SIGNATURE_ALGORITHM
	ErrCertNonUniqueName               CErrorcodeT = C.ERR_CERT_NON_UNIQUE_NAME
	ErrCertWeakKey                     CErrorcodeT = C.ERR_CERT_WEAK_KEY
	ErrCertNameConstraintViolation     CErrorcodeT = C.ERR_CERT_NAME_CONSTRAINT_VIOLATION
	ErrCertValidityTooLong             CErrorcodeT = C.ERR_CERT_VALIDITY_TOO_LONG
	ErrCertificateTransparencyRequired CErrorcodeT = C.ERR_CERTIFICATE_TRANSPARENCY_REQUIRED

	///
	/// Controls whether JavaScript can be executed. Also configurable using the
	/// "disable-javascript" command-line switch.
	///
	ErrCertSymantecLegacy           CErrorcodeT = C.ERR_CERT_SYMANTEC_LEGACY
	ErrCertKnownInterceptionBlocked CErrorcodeT = C.ERR_CERT_KNOWN_INTERCEPTION_BLOCKED
	ErrCertEnd                      CErrorcodeT = C.ERR_CERT_END
	ErrInvalidUrl                   CErrorcodeT = C.ERR_INVALID_URL
	ErrDisallowedUrlScheme          CErrorcodeT = C.ERR_DISALLOWED_URL_SCHEME
	ErrUnknownUrlScheme             CErrorcodeT = C.ERR_UNKNOWN_URL_SCHEME

	///
	/// Controls whether image URLs will be loaded from the network. A cached
	/// image will still be rendered if requested. Also configurable using the
	/// "disable-image-loading" command-line switch.
	///
	ErrInvalidRedirect  CErrorcodeT = C.ERR_INVALID_REDIRECT
	ErrTooManyRedirects CErrorcodeT = C.ERR_TOO_MANY_REDIRECTS

	///
	/// Controls whether standalone images will be shrunk to fit the page. Also
	/// configurable using the "image-shrink-standalone-to-fit" command-line
	/// switch.
	///
	ErrUnsafeRedirect CErrorcodeT = C.ERR_UNSAFE_REDIRECT

	///
	/// Controls whether text areas can be resized. Also configurable using the
	/// "disable-text-area-resize" command-line switch.
	///
	ErrUnsafePort      CErrorcodeT = C.ERR_UNSAFE_PORT
	ErrInvalidResponse CErrorcodeT = C.ERR_INVALID_RESPONSE

	///
	/// Controls whether the tab key can advance focus to links. Also configurable
	/// using the "disable-tab-to-links" command-line switch.
	///
	ErrInvalidChunkedEncoding CErrorcodeT = C.ERR_INVALID_CHUNKED_ENCODING
	ErrMethodNotSupported     CErrorcodeT = C.ERR_METHOD_NOT_SUPPORTED
	ErrUnexpectedProxyAuth    CErrorcodeT = C.ERR_UNEXPECTED_PROXY_AUTH
	ErrEmptyResponse          CErrorcodeT = C.ERR_EMPTY_RESPONSE
	ErrResponseHeadersTooBig  CErrorcodeT = C.ERR_RESPONSE_HEADERS_TOO_BIG
	ErrPacScriptFailed        CErrorcodeT = C.ERR_PAC_SCRIPT_FAILED

	/// END values that map to WebPreferences settings.
	ErrRequestRangeNotSatisfiable CErrorcodeT = C.ERR_REQUEST_RANGE_NOT_SATISFIABLE
	ErrMalformedIdentity          CErrorcodeT = C.ERR_MALFORMED_IDENTITY
	ErrContentDecodingFailed      CErrorcodeT = C.ERR_CONTENT_DECODING_FAILED
	ErrNetworkIoSuspended         CErrorcodeT = C.ERR_NETWORK_IO_SUSPENDED
	ErrSynReplyNotReceived        CErrorcodeT = C.ERR_SYN_REPLY_NOT_RECEIVED
	ErrEncodingConversionFailed   CErrorcodeT = C.ERR_ENCODING_CONVERSION_FAILED

	///
	/// Comma delimited ordered list of language codes without any whitespace that
	/// will be used in the "Accept-Language" HTTP header. May be set globally
	/// using the CefSettings.accept_language_list value. If both values are
	/// empty then "en-US,en" will be used.
	///
	ErrUnrecognizedFtpDirectoryListingFormat CErrorcodeT = C.ERR_UNRECOGNIZED_FTP_DIRECTORY_LISTING_FORMAT
	ErrNoSupportedProxies                    CErrorcodeT = C.ERR_NO_SUPPORTED_PROXIES
	ErrHttp2ProtocolError                    CErrorcodeT = C.ERR_HTTP2_PROTOCOL_ERROR
	ErrInvalidAuthCredentials                CErrorcodeT = C.ERR_INVALID_AUTH_CREDENTIALS
	ErrUnsupportedAuthScheme                 CErrorcodeT = C.ERR_UNSUPPORTED_AUTH_SCHEME
	ErrEncodingDetectionFailed               CErrorcodeT = C.ERR_ENCODING_DETECTION_FAILED

	///
	/// Continue immediately.
	///
	ErrMissingAuthCredentials               CErrorcodeT = C.ERR_MISSING_AUTH_CREDENTIALS
	ErrUnexpectedSecurityLibraryStatus      CErrorcodeT = C.ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS
	ErrMisconfiguredAuthEnvironment         CErrorcodeT = C.ERR_MISCONFIGURED_AUTH_ENVIRONMENT
	ErrUndocumentedSecurityLibraryStatus    CErrorcodeT = C.ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS
	ErrResponseBodyTooBigToDrain            CErrorcodeT = C.ERR_RESPONSE_BODY_TOO_BIG_TO_DRAIN
	ErrResponseHeadersMultipleContentLength CErrorcodeT = C.ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH

	///
	/// Scheme component not including the colon (e.g., "http").
	///
	ErrIncompleteHttp2Headers CErrorcodeT = C.ERR_INCOMPLETE_HTTP2_HEADERS

	///
	/// User name component.
	///
	ErrPacNotInDhcp                              CErrorcodeT = C.ERR_PAC_NOT_IN_DHCP
	ErrResponseHeadersMultipleContentDisposition CErrorcodeT = C.ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION
	ErrResponseHeadersMultipleLocation           CErrorcodeT = C.ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION
	ErrHttp2ServerRefusedStream                  CErrorcodeT = C.ERR_HTTP2_SERVER_REFUSED_STREAM

	///
	/// Port number component.
	///
	ErrHttp2PingFailed CErrorcodeT = C.ERR_HTTP2_PING_FAILED

	///
	/// Origin contains just the scheme, host, and port from a URL. Equivalent to
	/// clearing any username and password, replacing the path with a slash, and
	/// clearing everything after that. This value will be empty for non-standard
	/// URLs.
	///
	ErrContentLengthMismatch     CErrorcodeT = C.ERR_CONTENT_LENGTH_MISMATCH
	ErrIncompleteChunkedEncoding CErrorcodeT = C.ERR_INCOMPLETE_CHUNKED_ENCODING
	ErrQuicProtocolError         CErrorcodeT = C.ERR_QUIC_PROTOCOL_ERROR

	///
	/// Query string component (i.e., everything following the '?').
	///
	ErrResponseHeadersTruncated CErrorcodeT = C.ERR_RESPONSE_HEADERS_TRUNCATED
	ErrQuicHandshakeFailed      CErrorcodeT = C.ERR_QUIC_HANDSHAKE_FAILED

	///
	/// Cookie priority values.
	///
	ErrHttp2InadequateTransportSecurity CErrorcodeT = C.ERR_HTTP2_INADEQUATE_TRANSPORT_SECURITY
	ErrHttp2FlowControlError            CErrorcodeT = C.ERR_HTTP2_FLOW_CONTROL_ERROR
	ErrHttp2FrameSizeError              CErrorcodeT = C.ERR_HTTP2_FRAME_SIZE_ERROR

	///
	/// Cookie same site values.
	///
	ErrHttp2CompressionError                                 CErrorcodeT = C.ERR_HTTP2_COMPRESSION_ERROR
	ErrProxyAuthRequestedWithNoConnection                    CErrorcodeT = C.ERR_PROXY_AUTH_REQUESTED_WITH_NO_CONNECTION
	ErrHttp11Required                                        CErrorcodeT = C.ERR_HTTP_1_1_REQUIRED
	ErrProxyHttp11Required                                   CErrorcodeT = C.ERR_PROXY_HTTP_1_1_REQUIRED
	ErrPacScriptTerminated                                   CErrorcodeT = C.ERR_PAC_SCRIPT_TERMINATED
	ErrInvalidHttpResponse                                   CErrorcodeT = C.ERR_INVALID_HTTP_RESPONSE
	ErrContentDecodingInitFailed                             CErrorcodeT = C.ERR_CONTENT_DECODING_INIT_FAILED
	ErrHttp2RstStreamNoErrorReceived                         CErrorcodeT = C.ERR_HTTP2_RST_STREAM_NO_ERROR_RECEIVED
	ErrHttp2PushedStreamNotAvailable                         CErrorcodeT = C.ERR_HTTP2_PUSHED_STREAM_NOT_AVAILABLE
	ErrHttp2ClaimedPushedStreamResetByServer                 CErrorcodeT = C.ERR_HTTP2_CLAIMED_PUSHED_STREAM_RESET_BY_SERVER
	ErrTooManyRetries                                        CErrorcodeT = C.ERR_TOO_MANY_RETRIES
	ErrHttp2StreamClosed                                     CErrorcodeT = C.ERR_HTTP2_STREAM_CLOSED
	ErrHttp2ClientRefusedStream                              CErrorcodeT = C.ERR_HTTP2_CLIENT_REFUSED_STREAM
	ErrHttp2PushedResponseDoesNotMatch                       CErrorcodeT = C.ERR_HTTP2_PUSHED_RESPONSE_DOES_NOT_MATCH
	ErrHttpResponseCodeFailure                               CErrorcodeT = C.ERR_HTTP_RESPONSE_CODE_FAILURE
	ErrQuicCertRootNotKnown                                  CErrorcodeT = C.ERR_QUIC_CERT_ROOT_NOT_KNOWN
	ErrQuicGoawayRequestCanBeRetried                         CErrorcodeT = C.ERR_QUIC_GOAWAY_REQUEST_CAN_BE_RETRIED
	ErrTooManyAcceptChRestarts                               CErrorcodeT = C.ERR_TOO_MANY_ACCEPT_CH_RESTARTS
	ErrInconsistentIpAddressSpace                            CErrorcodeT = C.ERR_INCONSISTENT_IP_ADDRESS_SPACE
	ErrCachedIpAddressSpaceBlockedByLocalNetworkAccessPolicy CErrorcodeT = C.ERR_CACHED_IP_ADDRESS_SPACE_BLOCKED_BY_LOCAL_NETWORK_ACCESS_POLICY
	ErrCacheMiss                                             CErrorcodeT = C.ERR_CACHE_MISS
	ErrCacheReadFailure                                      CErrorcodeT = C.ERR_CACHE_READ_FAILURE
	ErrCacheWriteFailure                                     CErrorcodeT = C.ERR_CACHE_WRITE_FAILURE

	///
	/// Out of memory. Some platforms may use TS_PROCESS_CRASHED instead.
	///
	ErrCacheOperationNotSupported CErrorcodeT = C.ERR_CACHE_OPERATION_NOT_SUPPORTED
	ErrCacheOpenFailure           CErrorcodeT = C.ERR_CACHE_OPEN_FAILURE

	///
	/// Path key values.
	///
	ErrCacheCreateFailure       CErrorcodeT = C.ERR_CACHE_CREATE_FAILURE
	ErrCacheRace                CErrorcodeT = C.ERR_CACHE_RACE
	ErrCacheChecksumReadFailure CErrorcodeT = C.ERR_CACHE_CHECKSUM_READ_FAILURE
	ErrCacheChecksumMismatch    CErrorcodeT = C.ERR_CACHE_CHECKSUM_MISMATCH
	ErrCacheLockTimeout         CErrorcodeT = C.ERR_CACHE_LOCK_TIMEOUT

	///
	/// Path and filename of the current executable.
	///
	ErrCacheAuthFailureAfterRead CErrorcodeT = C.ERR_CACHE_AUTH_FAILURE_AFTER_READ
	ErrCacheEntryNotSuitable     CErrorcodeT = C.ERR_CACHE_ENTRY_NOT_SUITABLE
	ErrCacheDoomFailure          CErrorcodeT = C.ERR_CACHE_DOOM_FAILURE
	ErrCacheOpenOrCreateFailure  CErrorcodeT = C.ERR_CACHE_OPEN_OR_CREATE_FAILURE
	ErrInsecureResponse          CErrorcodeT = C.ERR_INSECURE_RESPONSE

	///
	/// "Application Data" directory under the user profile directory on Windows
	/// and "~/Library/Application Support" directory on MacOS.
	///
	ErrNoPrivateKeyForCert CErrorcodeT = C.ERR_NO_PRIVATE_KEY_FOR_CERT
	ErrAddUserCertFailed   CErrorcodeT = C.ERR_ADD_USER_CERT_FAILED

	///
	/// Directory containing application resources. Can be configured via
	/// CefSettings.resources_dir_path.
	///
	ErrInvalidSignedExchange                           CErrorcodeT = C.ERR_INVALID_SIGNED_EXCHANGE
	ErrInvalidWebBundle                                CErrorcodeT = C.ERR_INVALID_WEB_BUNDLE
	ErrTrustTokenOperationFailed                       CErrorcodeT = C.ERR_TRUST_TOKEN_OPERATION_FAILED
	ErrTrustTokenOperationSuccessWithoutSendingRequest CErrorcodeT = C.ERR_TRUST_TOKEN_OPERATION_SUCCESS_WITHOUT_SENDING_REQUEST
	ErrFtpFailed                                       CErrorcodeT = C.ERR_FTP_FAILED
	ErrFtpServiceUnavailable                           CErrorcodeT = C.ERR_FTP_SERVICE_UNAVAILABLE
	ErrFtpTransferAborted                              CErrorcodeT = C.ERR_FTP_TRANSFER_ABORTED
	ErrFtpFileBusy                                     CErrorcodeT = C.ERR_FTP_FILE_BUSY
	ErrFtpSyntaxError                                  CErrorcodeT = C.ERR_FTP_SYNTAX_ERROR

	// 1 << 9 was used for CERT_STATUS_NOT_IN_DNS
	ErrFtpCommandNotSupported CErrorcodeT = C.ERR_FTP_COMMAND_NOT_SUPPORTED
	ErrFtpBadCommandSequence  CErrorcodeT = C.ERR_FTP_BAD_COMMAND_SEQUENCE

	// Bits 16 to 31 are for non-error statuses.
	ErrPkcs12ImportBadPassword CErrorcodeT = C.ERR_PKCS12_IMPORT_BAD_PASSWORD

	// Bit 18 was CERT_STATUS_IS_DNSSEC
	ErrPkcs12ImportFailed      CErrorcodeT = C.ERR_PKCS12_IMPORT_FAILED
	ErrImportCaCertNotCa       CErrorcodeT = C.ERR_IMPORT_CA_CERT_NOT_CA
	ErrImportCertAlreadyExists CErrorcodeT = C.ERR_IMPORT_CERT_ALREADY_EXISTS
	ErrImportCaCertFailed      CErrorcodeT = C.ERR_IMPORT_CA_CERT_FAILED
	ErrImportServerCertFailed  CErrorcodeT = C.ERR_IMPORT_SERVER_CERT_FAILED
	ErrPkcs12ImportInvalidMac  CErrorcodeT = C.ERR_PKCS12_IMPORT_INVALID_MAC

	///
	/// Indicates that only one tab with the url should exist in the same window.
	///
	ErrPkcs12ImportInvalidFile        CErrorcodeT = C.ERR_PKCS12_IMPORT_INVALID_FILE
	ErrPkcs12ImportUnsupported        CErrorcodeT = C.ERR_PKCS12_IMPORT_UNSUPPORTED
	ErrKeyGenerationFailed            CErrorcodeT = C.ERR_KEY_GENERATION_FAILED
	ErrPrivateKeyExportFailed         CErrorcodeT = C.ERR_PRIVATE_KEY_EXPORT_FAILED
	ErrSelfSignedCertGenerationFailed CErrorcodeT = C.ERR_SELF_SIGNED_CERT_GENERATION_FAILED
	ErrCertDatabaseChanged            CErrorcodeT = C.ERR_CERT_DATABASE_CHANGED
	ErrCertVerifierChanged            CErrorcodeT = C.ERR_CERT_VERIFIER_CHANGED
	ErrDnsMalformedResponse           CErrorcodeT = C.ERR_DNS_MALFORMED_RESPONSE

	///
	/// New off-the-record (incognito) window.
	///
	ErrDnsServerRequiresTcp CErrorcodeT = C.ERR_DNS_SERVER_REQUIRES_TCP
	ErrDnsServerFailed      CErrorcodeT = C.ERR_DNS_SERVER_FAILED
	ErrDnsTimedOut          CErrorcodeT = C.ERR_DNS_TIMED_OUT

	///
	/// Creates a new document picture-in-picture window showing a child WebView.
	///
	ErrDnsCacheMiss                              CErrorcodeT = C.ERR_DNS_CACHE_MISS
	ErrDnsSearchEmpty                            CErrorcodeT = C.ERR_DNS_SEARCH_EMPTY
	ErrDnsSortError                              CErrorcodeT = C.ERR_DNS_SORT_ERROR
	ErrDnsSecureResolverHostnameResolutionFailed CErrorcodeT = C.ERR_DNS_SECURE_RESOLVER_HOSTNAME_RESOLUTION_FAILED
	ErrDnsNameHttpsOnly                          CErrorcodeT = C.ERR_DNS_NAME_HTTPS_ONLY
	ErrDnsRequestCancelled                       CErrorcodeT = C.ERR_DNS_REQUEST_CANCELLED
	ErrDnsNoMatchingSupportedAlpn                CErrorcodeT = C.ERR_DNS_NO_MATCHING_SUPPORTED_ALPN
)

// /
// / Supported certificate status code values. See net\cert\cert_status_flags.h
// / for more information. CERT_STATUS_NONE is new in CEF because we use an
// / enum while cert_status_flags.h uses a typedef and static const variables.
// /
type CCertStatusT C.cef_cert_status_t

const (
	CertStatusNone              CCertStatusT = C.CERT_STATUS_NONE
	CertStatusCommonNameInvalid CCertStatusT = C.CERT_STATUS_COMMON_NAME_INVALID
	CertStatusDateInvalid       CCertStatusT = C.CERT_STATUS_DATE_INVALID
	CertStatusAuthorityInvalid  CCertStatusT = C.CERT_STATUS_AUTHORITY_INVALID

	// 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP).
	CertStatusNoRevocationMechanism   CCertStatusT = C.CERT_STATUS_NO_REVOCATION_MECHANISM
	CertStatusUnableToCheckRevocation CCertStatusT = C.CERT_STATUS_UNABLE_TO_CHECK_REVOCATION
	CertStatusRevoked                 CCertStatusT = C.CERT_STATUS_REVOKED
	CertStatusInvalid                 CCertStatusT = C.CERT_STATUS_INVALID
	CertStatusWeakSignatureAlgorithm  CCertStatusT = C.CERT_STATUS_WEAK_SIGNATURE_ALGORITHM

	// 1 << 9 was used for CERT_STATUS_NOT_IN_DNS
	CertStatusNonUniqueName CCertStatusT = C.CERT_STATUS_NON_UNIQUE_NAME
	CertStatusWeakKey       CCertStatusT = C.CERT_STATUS_WEAK_KEY

	// 1 << 12 was used for CERT_STATUS_WEAK_DH_KEY
	CertStatusPinnedKeyMissing        CCertStatusT = C.CERT_STATUS_PINNED_KEY_MISSING
	CertStatusNameConstraintViolation CCertStatusT = C.CERT_STATUS_NAME_CONSTRAINT_VIOLATION
	CertStatusValidityTooLong         CCertStatusT = C.CERT_STATUS_VALIDITY_TOO_LONG

	// Bits 16 to 31 are for non-error statuses.
	CertStatusIsEv               CCertStatusT = C.CERT_STATUS_IS_EV
	CertStatusRevCheckingEnabled CCertStatusT = C.CERT_STATUS_REV_CHECKING_ENABLED

	// Bit 18 was CERT_STATUS_IS_DNSSEC
	CertStatusSha1SignaturePresent CCertStatusT = C.CERT_STATUS_SHA1_SIGNATURE_PRESENT
	CertStatusCtComplianceFailed   CCertStatusT = C.CERT_STATUS_CT_COMPLIANCE_FAILED
)

// /
// / The manner in which a link click should be opened. These constants match
// / their equivalents in Chromium's window_open_disposition.h and should not be
// / renumbered.
// /
type CWindowOpenDispositionT C.cef_window_open_disposition_t

const (
	WodUnknown CWindowOpenDispositionT = C.WOD_UNKNOWN

	///
	/// Current tab. This is the default in most cases.
	///
	WodCurrentTab CWindowOpenDispositionT = C.WOD_CURRENT_TAB

	///
	/// Indicates that only one tab with the url should exist in the same window.
	///
	WodSingletonTab CWindowOpenDispositionT = C.WOD_SINGLETON_TAB

	///
	/// Shift key + Middle mouse button or meta/ctrl key while clicking.
	///
	WodNewForegroundTab CWindowOpenDispositionT = C.WOD_NEW_FOREGROUND_TAB

	///
	/// Middle mouse button or meta/ctrl key while clicking.
	///
	WodNewBackgroundTab CWindowOpenDispositionT = C.WOD_NEW_BACKGROUND_TAB

	///
	/// New popup window.
	///
	WodNewPopup CWindowOpenDispositionT = C.WOD_NEW_POPUP

	///
	/// Shift key while clicking.
	///
	WodNewWindow CWindowOpenDispositionT = C.WOD_NEW_WINDOW

	///
	/// Alt key while clicking.
	///
	WodSaveToDisk CWindowOpenDispositionT = C.WOD_SAVE_TO_DISK

	///
	/// New off-the-record (incognito) window.
	///
	WodOffTheRecord CWindowOpenDispositionT = C.WOD_OFF_THE_RECORD

	///
	/// Special case error condition from the renderer.
	///
	WodIgnoreAction CWindowOpenDispositionT = C.WOD_IGNORE_ACTION

	///
	/// Activates an existing tab containing the url, rather than navigating.
	/// This is similar to SINGLETON_TAB, but searches across all windows from
	/// the current profile and anonymity (instead of just the current one);
	/// closes the current tab on switching if the current tab was the NTP with
	/// no session history; and behaves like CURRENT_TAB instead of
	/// NEW_FOREGROUND_TAB when no existing tab is found.
	///
	WodSwitchToTab CWindowOpenDispositionT = C.WOD_SWITCH_TO_TAB

	///
	/// Creates a new document picture-in-picture window showing a child WebView.
	///
	WodNewPictureInPicture CWindowOpenDispositionT = C.WOD_NEW_PICTURE_IN_PICTURE
)

// /
// / "Verb" of a drag-and-drop operation as negotiated between the source and
// / destination. These constants match their equivalents in WebCore's
// / DragActions.h and should not be renumbered.
// /
type CDragOperationsMaskT C.cef_drag_operations_mask_t

const (
	DragOperationNone    CDragOperationsMaskT = C.DRAG_OPERATION_NONE
	DragOperationCopy    CDragOperationsMaskT = C.DRAG_OPERATION_COPY
	DragOperationLink    CDragOperationsMaskT = C.DRAG_OPERATION_LINK
	DragOperationGeneric CDragOperationsMaskT = C.DRAG_OPERATION_GENERIC
	DragOperationPrivate CDragOperationsMaskT = C.DRAG_OPERATION_PRIVATE
	DragOperationMove    CDragOperationsMaskT = C.DRAG_OPERATION_MOVE
	DragOperationDelete  CDragOperationsMaskT = C.DRAG_OPERATION_DELETE
	DragOperationEvery   CDragOperationsMaskT = C.DRAG_OPERATION_EVERY
)

// /
// / Input mode of a virtual keyboard. These constants match their equivalents
// / in Chromium's text_input_mode.h and should not be renumbered.
// / See https://html.spec.whatwg.org/#input-modalities:-the-inputmode-attribute
// /
type CTextInputModeT C.cef_text_input_mode_t

const (
	CefTextInputModeDefault CTextInputModeT = C.CEF_TEXT_INPUT_MODE_DEFAULT
	CefTextInputModeNone    CTextInputModeT = C.CEF_TEXT_INPUT_MODE_NONE
	CefTextInputModeText    CTextInputModeT = C.CEF_TEXT_INPUT_MODE_TEXT
	CefTextInputModeTel     CTextInputModeT = C.CEF_TEXT_INPUT_MODE_TEL
	CefTextInputModeUrl     CTextInputModeT = C.CEF_TEXT_INPUT_MODE_URL
	CefTextInputModeEmail   CTextInputModeT = C.CEF_TEXT_INPUT_MODE_EMAIL
	CefTextInputModeNumeric CTextInputModeT = C.CEF_TEXT_INPUT_MODE_NUMERIC
	CefTextInputModeDecimal CTextInputModeT = C.CEF_TEXT_INPUT_MODE_DECIMAL
	CefTextInputModeSearch  CTextInputModeT = C.CEF_TEXT_INPUT_MODE_SEARCH
	CefTextInputModeMax     CTextInputModeT = C.CEF_TEXT_INPUT_MODE_MAX
)

// /
// / V8 access control values.
// /
type CV8AccesscontrolT C.cef_v8_accesscontrol_t

const (
	V8AccessControlDefault              CV8AccesscontrolT = C.V8_ACCESS_CONTROL_DEFAULT
	V8AccessControlAllCanRead           CV8AccesscontrolT = C.V8_ACCESS_CONTROL_ALL_CAN_READ
	V8AccessControlAllCanWrite          CV8AccesscontrolT = C.V8_ACCESS_CONTROL_ALL_CAN_WRITE
	V8AccessControlProhibitsOverwriting CV8AccesscontrolT = C.V8_ACCESS_CONTROL_PROHIBITS_OVERWRITING
)

// /
// / V8 property attribute values.
// /
type CV8PropertyattributeT C.cef_v8_propertyattribute_t

const (

	///
	/// Writeable, Enumerable, Configurable
	///
	V8PropertyAttributeNone CV8PropertyattributeT = C.V8_PROPERTY_ATTRIBUTE_NONE

	///
	/// Not writeable
	///
	V8PropertyAttributeReadonly CV8PropertyattributeT = C.V8_PROPERTY_ATTRIBUTE_READONLY

	///
	/// Not enumerable
	///
	V8PropertyAttributeDontenum CV8PropertyattributeT = C.V8_PROPERTY_ATTRIBUTE_DONTENUM

	///
	/// Not configurable
	///
	V8PropertyAttributeDontdelete CV8PropertyattributeT = C.V8_PROPERTY_ATTRIBUTE_DONTDELETE
)

// /
// / Post data elements may represent either bytes or files.
// /
type CPostdataelementTypeT C.cef_postdataelement_type_t

const (
	PdeTypeEmpty CPostdataelementTypeT = C.PDE_TYPE_EMPTY
	PdeTypeBytes CPostdataelementTypeT = C.PDE_TYPE_BYTES
	PdeTypeFile  CPostdataelementTypeT = C.PDE_TYPE_FILE
)

// /
// / Resource type for a request. These constants match their equivalents in
// / Chromium's ResourceType and should not be renumbered.
// /
type CResourceTypeT C.cef_resource_type_t

const (

	///
	/// Top level page.
	///
	RtMainFrame CResourceTypeT = C.RT_MAIN_FRAME

	///
	/// Frame or iframe.
	///
	RtSubFrame CResourceTypeT = C.RT_SUB_FRAME

	///
	/// CSS stylesheet.
	///
	RtStylesheet CResourceTypeT = C.RT_STYLESHEET

	///
	/// External script.
	///
	RtScript CResourceTypeT = C.RT_SCRIPT

	///
	/// Image (jpg/gif/png/etc).
	///
	RtImage CResourceTypeT = C.RT_IMAGE

	///
	/// Font.
	///
	RtFontResource CResourceTypeT = C.RT_FONT_RESOURCE

	///
	/// Some other subresource. This is the default type if the actual type is
	/// unknown.
	///
	RtSubResource CResourceTypeT = C.RT_SUB_RESOURCE

	///
	/// Object (or embed) tag for a plugin, or a resource that a plugin requested.
	///
	RtObject CResourceTypeT = C.RT_OBJECT

	///
	/// Media resource.
	///
	RtMedia CResourceTypeT = C.RT_MEDIA

	///
	/// Main resource of a dedicated worker.
	///
	RtWorker CResourceTypeT = C.RT_WORKER

	///
	/// Main resource of a shared worker.
	///
	RtSharedWorker CResourceTypeT = C.RT_SHARED_WORKER

	///
	/// Explicitly requested prefetch.
	///
	RtPrefetch CResourceTypeT = C.RT_PREFETCH

	///
	/// Favicon.
	///
	RtFavicon CResourceTypeT = C.RT_FAVICON

	///
	/// XMLHttpRequest.
	///
	RtXhr CResourceTypeT = C.RT_XHR

	///
	/// A request for a "<ping>".
	///
	RtPing CResourceTypeT = C.RT_PING

	///
	/// Main resource of a service worker.
	///
	RtServiceWorker CResourceTypeT = C.RT_SERVICE_WORKER

	///
	/// A report of Content Security Policy violations.
	///
	RtCspReport CResourceTypeT = C.RT_CSP_REPORT

	///
	/// A resource that a plugin requested.
	///
	RtPluginResource CResourceTypeT = C.RT_PLUGIN_RESOURCE

	///
	/// A main-frame service worker navigation preload request.
	///
	RtNavigationPreloadMainFrame CResourceTypeT = C.RT_NAVIGATION_PRELOAD_MAIN_FRAME

	///
	/// A sub-frame service worker navigation preload request.
	///
	RtNavigationPreloadSubFrame CResourceTypeT = C.RT_NAVIGATION_PRELOAD_SUB_FRAME
)

// /
// / Transition type for a request. Made up of one source value and 0 or more
// / qualifiers.
// /
type CTransitionTypeT C.cef_transition_type_t

const (

	///
	/// Source is a link click or the JavaScript window.open function. This is
	/// also the default value for requests like sub-resource loads that are not
	/// navigations.
	///
	TtLink CTransitionTypeT = C.TT_LINK

	///
	/// Source is some other "explicit" navigation. This is the default value for
	/// navigations where the actual type is unknown. See also
	/// TT_DIRECT_LOAD_FLAG.
	///
	TtExplicit CTransitionTypeT = C.TT_EXPLICIT

	///
	/// User got to this page through a suggestion in the UI (for example, via the
	/// destinations page). Chrome runtime only.
	///
	TtAutoBookmark CTransitionTypeT = C.TT_AUTO_BOOKMARK

	///
	/// Source is a subframe navigation. This is any content that is automatically
	/// loaded in a non-toplevel frame. For example, if a page consists of several
	/// frames containing ads, those ad URLs will have this transition type.
	/// The user may not even realize the content in these pages is a separate
	/// frame, so may not care about the URL.
	///
	TtAutoSubframe CTransitionTypeT = C.TT_AUTO_SUBFRAME

	///
	/// Source is a subframe navigation explicitly requested by the user that will
	/// generate new navigation entries in the back/forward list. These are
	/// probably more important than frames that were automatically loaded in
	/// the background because the user probably cares about the fact that this
	/// link was loaded.
	///
	TtManualSubframe CTransitionTypeT = C.TT_MANUAL_SUBFRAME

	///
	/// User got to this page by typing in the URL bar and selecting an entry
	/// that did not look like a URL.  For example, a match might have the URL
	/// of a Google search result page, but appear like "Search Google for ...".
	/// These are not quite the same as EXPLICIT navigations because the user
	/// didn't type or see the destination URL. Chrome runtime only.
	/// See also TT_KEYWORD.
	///
	TtGenerated CTransitionTypeT = C.TT_GENERATED

	///
	/// This is a toplevel navigation. This is any content that is automatically
	/// loaded in a toplevel frame.  For example, opening a tab to show the ASH
	/// screen saver, opening the devtools window, opening the NTP after the safe
	/// browsing warning, opening web-based dialog boxes are examples of
	/// AUTO_TOPLEVEL navigations. Chrome runtime only.
	///
	TtAutoToplevel CTransitionTypeT = C.TT_AUTO_TOPLEVEL

	///
	/// Source is a form submission by the user. NOTE: In some situations
	/// submitting a form does not result in this transition type. This can happen
	/// if the form uses a script to submit the contents.
	///
	TtFormSubmit CTransitionTypeT = C.TT_FORM_SUBMIT

	///
	/// Source is a "reload" of the page via the Reload function or by re-visiting
	/// the same URL. NOTE: This is distinct from the concept of whether a
	/// particular load uses "reload semantics" (i.e. bypasses cached data).
	///
	TtReload CTransitionTypeT = C.TT_RELOAD

	///
	/// The url was generated from a replaceable keyword other than the default
	/// search provider. If the user types a keyword (which also applies to
	/// tab-to-search) in the omnibox this qualifier is applied to the transition
	/// type of the generated url. TemplateURLModel then may generate an
	/// additional visit with a transition type of TT_KEYWORD_GENERATED against
	/// the url 'http://' + keyword. For example, if you do a tab-to-search
	/// against wikipedia the generated url has a transition qualifer of
	/// TT_KEYWORD, and TemplateURLModel generates a visit for 'wikipedia.org'
	/// with a transition type of TT_KEYWORD_GENERATED. Chrome runtime only.
	///
	TtKeyword CTransitionTypeT = C.TT_KEYWORD

	///
	/// Corresponds to a visit generated for a keyword. See description of
	/// TT_KEYWORD for more details. Chrome runtime only.
	///
	TtKeywordGenerated CTransitionTypeT = C.TT_KEYWORD_GENERATED

	///
	/// General mask defining the bits used for the source values.
	///
	TtSourceMask CTransitionTypeT = C.TT_SOURCE_MASK

	///
	/// Attempted to visit a URL but was blocked.
	///
	TtBlockedFlag CTransitionTypeT = C.TT_BLOCKED_FLAG

	///
	/// Used the Forward or Back function to navigate among browsing history.
	/// Will be ORed to the transition type for the original load.
	///
	TtForwardBackFlag CTransitionTypeT = C.TT_FORWARD_BACK_FLAG

	///
	/// Loaded a URL directly via CreateBrowser, LoadURL or LoadRequest.
	///
	TtDirectLoadFlag CTransitionTypeT = C.TT_DIRECT_LOAD_FLAG

	///
	/// User is navigating to the home page. Chrome runtime only.
	///
	TtHomePageFlag CTransitionTypeT = C.TT_HOME_PAGE_FLAG

	///
	/// The transition originated from an external application; the exact
	/// definition of this is embedder dependent. Chrome runtime and
	/// extension system only.
	///
	TtFromApiFlag CTransitionTypeT = C.TT_FROM_API_FLAG

	///
	/// The beginning of a navigation chain.
	///
	TtChainStartFlag CTransitionTypeT = C.TT_CHAIN_START_FLAG

	///
	/// The last transition in a redirect chain.
	///
	TtChainEndFlag CTransitionTypeT = C.TT_CHAIN_END_FLAG

	///
	/// Redirects caused by JavaScript or a meta refresh tag on the page.
	///
	TtClientRedirectFlag CTransitionTypeT = C.TT_CLIENT_REDIRECT_FLAG

	///
	/// Redirects sent from the server by HTTP headers.
	///
	TtServerRedirectFlag CTransitionTypeT = C.TT_SERVER_REDIRECT_FLAG

	///
	/// Used to test whether a transition involves a redirect.
	///
	TtIsRedirectMask CTransitionTypeT = C.TT_IS_REDIRECT_MASK

	///
	/// General mask defining the bits used for the qualifiers.
	///
	TtQualifierMask CTransitionTypeT = C.TT_QUALIFIER_MASK
)

// /
// / Flags used to customize the behavior of CefURLRequest.
// /
type CUrlrequestFlagsT C.cef_urlrequest_flags_t

const (

	///
	/// Default behavior.
	///
	UrFlagNone CUrlrequestFlagsT = C.UR_FLAG_NONE

	///
	/// If set the cache will be skipped when handling the request. Setting this
	/// value is equivalent to specifying the "Cache-Control: no-cache" request
	/// header. Setting this value in combination with UR_FLAG_ONLY_FROM_CACHE
	/// will cause the request to fail.
	///
	UrFlagSkipCache CUrlrequestFlagsT = C.UR_FLAG_SKIP_CACHE

	///
	/// If set the request will fail if it cannot be served from the cache (or
	/// some equivalent local store). Setting this value is equivalent to
	/// specifying the "Cache-Control: only-if-cached" request header. Setting
	/// this value in combination with UR_FLAG_SKIP_CACHE or UR_FLAG_DISABLE_CACHE
	/// will cause the request to fail.
	///
	UrFlagOnlyFromCache CUrlrequestFlagsT = C.UR_FLAG_ONLY_FROM_CACHE

	///
	/// If set the cache will not be used at all. Setting this value is equivalent
	/// to specifying the "Cache-Control: no-store" request header. Setting this
	/// value in combination with UR_FLAG_ONLY_FROM_CACHE will cause the request
	/// to fail.
	///
	UrFlagDisableCache CUrlrequestFlagsT = C.UR_FLAG_DISABLE_CACHE

	///
	/// If set user name, password, and cookies may be sent with the request, and
	/// cookies may be saved from the response.
	///
	UrFlagAllowStoredCredentials CUrlrequestFlagsT = C.UR_FLAG_ALLOW_STORED_CREDENTIALS

	///
	/// If set upload progress events will be generated when a request has a body.
	///
	UrFlagReportUploadProgress CUrlrequestFlagsT = C.UR_FLAG_REPORT_UPLOAD_PROGRESS

	///
	/// If set the CefURLRequestClient::OnDownloadData method will not be called.
	///
	UrFlagNoDownloadData CUrlrequestFlagsT = C.UR_FLAG_NO_DOWNLOAD_DATA

	///
	/// If set 5XX redirect errors will be propagated to the observer instead of
	/// automatically re-tried. This currently only applies for requests
	/// originated in the browser process.
	///
	UrFlagNoRetryOn5xx CUrlrequestFlagsT = C.UR_FLAG_NO_RETRY_ON_5XX

	///
	/// If set 3XX responses will cause the fetch to halt immediately rather than
	/// continue through the redirect.
	///
	UrFlagStopOnRedirect CUrlrequestFlagsT = C.UR_FLAG_STOP_ON_REDIRECT
)

// /
// / Flags that represent CefURLRequest status.
// /
type CUrlrequestStatusT C.cef_urlrequest_status_t

const (

	///
	/// Unknown status.
	///
	UrUnknown CUrlrequestStatusT = C.UR_UNKNOWN

	///
	/// Request succeeded.
	///
	UrSuccess CUrlrequestStatusT = C.UR_SUCCESS

	///
	/// An IO request is pending, and the caller will be informed when it is
	/// completed.
	///
	UrIoPending CUrlrequestStatusT = C.UR_IO_PENDING

	///
	/// Request was canceled programatically.
	///
	UrCanceled CUrlrequestStatusT = C.UR_CANCELED

	///
	/// Request failed for some reason.
	///
	UrFailed CUrlrequestStatusT = C.UR_FAILED
)

// / Structure representing a draggable region.
// /
type CDraggableRegionT C.cef_draggable_region_t

func NewCDraggableRegionT() *CDraggableRegionT {
	s := &CDraggableRegionT{}
	return s
}

func (st *CDraggableRegionT) Bounds() CRectT {
	return CRectT(st.bounds)
}

func (st *CDraggableRegionT) SetBounds(v CRectT) {
	st.bounds = (C.cef_rect_t)(v)
}

func (st *CDraggableRegionT) Draggable() bool {
	return st.draggable != 0
}

func (st *CDraggableRegionT) SetDraggable(v bool) {
	if v {
		st.draggable = 1
	} else {
		st.draggable = 0
	}
}

// /
// / Existing process IDs.
// /
type CProcessIdT C.cef_process_id_t

const (

	///
	/// Browser process.
	///
	PidBrowser CProcessIdT = C.PID_BROWSER

	///
	/// Renderer process.
	///
	PidRenderer CProcessIdT = C.PID_RENDERER
)

// /
// / Existing thread IDs.
// /
type CThreadIdT C.cef_thread_id_t

const (

	///
	/// The main thread in the browser. This will be the same as the main
	/// application thread if CefInitialize() is called with a
	/// CefSettings.multi_threaded_message_loop value of false. Do not perform
	/// blocking tasks on this thread. All tasks posted after
	/// CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()
	/// are guaranteed to run. This thread will outlive all other CEF threads.
	///
	TidUi CThreadIdT = C.TID_UI

	///
	/// Used for blocking tasks like file system access where the user won't
	/// notice if the task takes an arbitrarily long time to complete. All tasks
	/// posted after CefBrowserProcessHandler::OnContextInitialized() and before
	/// CefShutdown() are guaranteed to run.
	///
	TidFileBackground CThreadIdT = C.TID_FILE_BACKGROUND

	///
	/// Used for blocking tasks like file system access that affect UI or
	/// responsiveness of future user interactions. Do not use if an immediate
	/// response to a user interaction is expected. All tasks posted after
	/// CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()
	/// are guaranteed to run.
	/// Examples:
	/// - Updating the UI to reflect progress on a long task.
	/// - Loading data that might be shown in the UI after a future user
	///   interaction.
	///
	TidFileUserVisible CThreadIdT = C.TID_FILE_USER_VISIBLE

	///
	/// Used for blocking tasks like file system access that affect UI
	/// immediately after a user interaction. All tasks posted after
	/// CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()
	/// are guaranteed to run.
	/// Example: Generating data shown in the UI immediately after a click.
	///
	TidFileUserBlocking CThreadIdT = C.TID_FILE_USER_BLOCKING

	///
	/// Used to launch and terminate browser processes.
	///
	TidProcessLauncher CThreadIdT = C.TID_PROCESS_LAUNCHER

	///
	/// Used to process IPC and network messages. Do not perform blocking tasks on
	/// this thread. All tasks posted after
	/// CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()
	/// are guaranteed to run.
	///
	TidIo CThreadIdT = C.TID_IO

	///
	/// The main thread in the renderer. Used for all WebKit and V8 interaction.
	/// Tasks may be posted to this thread after
	/// CefRenderProcessHandler::OnWebKitInitialized but are not guaranteed to
	/// run before sub-process termination (sub-processes may be killed at any
	/// time without warning).
	///
	TidRenderer CThreadIdT = C.TID_RENDERER
)

// /
// / Thread priority values listed in increasing order of importance.
// /
type CThreadPriorityT C.cef_thread_priority_t

const (

	///
	/// Suitable for threads that shouldn't disrupt high priority work.
	///
	TpBackground CThreadPriorityT = C.TP_BACKGROUND

	///
	/// Default priority level.
	///
	TpNormal CThreadPriorityT = C.TP_NORMAL

	///
	/// Suitable for threads which generate data for the display (at ~60Hz).
	///
	TpDisplay CThreadPriorityT = C.TP_DISPLAY

	///
	/// Suitable for low-latency, glitch-resistant audio.
	///
	TpRealtimeAudio CThreadPriorityT = C.TP_REALTIME_AUDIO
)

// /
// / Message loop types. Indicates the set of asynchronous events that a message
// / loop can process.
// /
type CMessageLoopTypeT C.cef_message_loop_type_t

const (

	///
	/// Supports tasks and timers.
	///
	MlTypeDefault CMessageLoopTypeT = C.ML_TYPE_DEFAULT

	///
	/// Supports tasks, timers and native UI events (e.g. Windows messages).
	///
	MlTypeUi CMessageLoopTypeT = C.ML_TYPE_UI

	///
	/// Supports tasks, timers and asynchronous IO events.
	///
	MlTypeIo CMessageLoopTypeT = C.ML_TYPE_IO
)

// /
// / Windows COM initialization mode. Specifies how COM will be initialized for a
// / new thread.
// /
type CComInitModeT C.cef_com_init_mode_t

const (

	///
	/// No COM initialization.
	///
	ComInitModeNone CComInitModeT = C.COM_INIT_MODE_NONE

	///
	/// Initialize COM using single-threaded apartments.
	///
	ComInitModeSta CComInitModeT = C.COM_INIT_MODE_STA

	///
	/// Initialize COM using multi-threaded apartments.
	///
	ComInitModeMta CComInitModeT = C.COM_INIT_MODE_MTA
)

// /
// / Supported value types.
// /
type CValueTypeT C.cef_value_type_t

const (
	VtypeInvalid    CValueTypeT = C.VTYPE_INVALID
	VtypeNull       CValueTypeT = C.VTYPE_NULL
	VtypeBool       CValueTypeT = C.VTYPE_BOOL
	VtypeInt        CValueTypeT = C.VTYPE_INT
	VtypeDouble     CValueTypeT = C.VTYPE_DOUBLE
	VtypeString     CValueTypeT = C.VTYPE_STRING
	VtypeBinary     CValueTypeT = C.VTYPE_BINARY
	VtypeDictionary CValueTypeT = C.VTYPE_DICTIONARY
	VtypeList       CValueTypeT = C.VTYPE_LIST
)

// /
// / Supported JavaScript dialog types.
// /
type CJsdialogTypeT C.cef_jsdialog_type_t

const (
	JsdialogtypeAlert   CJsdialogTypeT = C.JSDIALOGTYPE_ALERT
	JsdialogtypeConfirm CJsdialogTypeT = C.JSDIALOGTYPE_CONFIRM
	JsdialogtypePrompt  CJsdialogTypeT = C.JSDIALOGTYPE_PROMPT
)

// /
// / Screen information used when window rendering is disabled. This structure is
// / passed as a parameter to CefRenderHandler::GetScreenInfo and should be
// / filled in by the client.
// /
type CScreenInfoT C.cef_screen_info_t

func NewCScreenInfoT() *CScreenInfoT {
	s := &CScreenInfoT{}
	return s
}

func (st *CScreenInfoT) DeviceScaleFactor() float32 {
	return float32(st.device_scale_factor)
}

func (st *CScreenInfoT) SetDeviceScaleFactor(v float32) {
	st.device_scale_factor = (C.float)(v)
}

func (st *CScreenInfoT) Depth() int {
	return int(st.depth)
}

func (st *CScreenInfoT) SetDepth(v int) {
	st.depth = (C.int)(v)
}

func (st *CScreenInfoT) DepthPerComponent() int {
	return int(st.depth_per_component)
}

func (st *CScreenInfoT) SetDepthPerComponent(v int) {
	st.depth_per_component = (C.int)(v)
}

func (st *CScreenInfoT) IsMonochrome() int {
	return int(st.is_monochrome)
}

func (st *CScreenInfoT) SetIsMonochrome(v int) {
	st.is_monochrome = (C.int)(v)
}

func (st *CScreenInfoT) Rect() CRectT {
	return CRectT(st.rect)
}

func (st *CScreenInfoT) SetRect(v CRectT) {
	st.rect = (C.cef_rect_t)(v)
}

func (st *CScreenInfoT) AvailableRect() CRectT {
	return CRectT(st.available_rect)
}

func (st *CScreenInfoT) SetAvailableRect(v CRectT) {
	st.available_rect = (C.cef_rect_t)(v)
}

// /
// / Supported menu IDs. Non-English translations can be provided for the
// / IDS_MENU_* strings in CefResourceBundleHandler::GetLocalizedString().
// /
type CMenuIdT C.cef_menu_id_t

const (

	// Navigation.
	MenuIdBack          CMenuIdT = C.MENU_ID_BACK
	MenuIdForward       CMenuIdT = C.MENU_ID_FORWARD
	MenuIdReload        CMenuIdT = C.MENU_ID_RELOAD
	MenuIdReloadNocache CMenuIdT = C.MENU_ID_RELOAD_NOCACHE
	MenuIdStopload      CMenuIdT = C.MENU_ID_STOPLOAD

	// Editing.
	MenuIdUndo      CMenuIdT = C.MENU_ID_UNDO
	MenuIdRedo      CMenuIdT = C.MENU_ID_REDO
	MenuIdCut       CMenuIdT = C.MENU_ID_CUT
	MenuIdCopy      CMenuIdT = C.MENU_ID_COPY
	MenuIdPaste     CMenuIdT = C.MENU_ID_PASTE
	MenuIdDelete    CMenuIdT = C.MENU_ID_DELETE
	MenuIdSelectAll CMenuIdT = C.MENU_ID_SELECT_ALL

	// Miscellaneous.
	MenuIdFind       CMenuIdT = C.MENU_ID_FIND
	MenuIdPrint      CMenuIdT = C.MENU_ID_PRINT
	MenuIdViewSource CMenuIdT = C.MENU_ID_VIEW_SOURCE

	// Spell checking word correction suggestions.
	MenuIdSpellcheckSuggestion0    CMenuIdT = C.MENU_ID_SPELLCHECK_SUGGESTION_0
	MenuIdSpellcheckSuggestion1    CMenuIdT = C.MENU_ID_SPELLCHECK_SUGGESTION_1
	MenuIdSpellcheckSuggestion2    CMenuIdT = C.MENU_ID_SPELLCHECK_SUGGESTION_2
	MenuIdSpellcheckSuggestion3    CMenuIdT = C.MENU_ID_SPELLCHECK_SUGGESTION_3
	MenuIdSpellcheckSuggestion4    CMenuIdT = C.MENU_ID_SPELLCHECK_SUGGESTION_4
	MenuIdSpellcheckSuggestionLast CMenuIdT = C.MENU_ID_SPELLCHECK_SUGGESTION_LAST
	MenuIdNoSpellingSuggestions    CMenuIdT = C.MENU_ID_NO_SPELLING_SUGGESTIONS
	MenuIdAddToDictionary          CMenuIdT = C.MENU_ID_ADD_TO_DICTIONARY

	// Custom menu items originating from the renderer process.
	MenuIdCustomFirst CMenuIdT = C.MENU_ID_CUSTOM_FIRST
	MenuIdCustomLast  CMenuIdT = C.MENU_ID_CUSTOM_LAST

	// All user-defined menu IDs should come between MENU_ID_USER_FIRST and
	// MENU_ID_USER_LAST to avoid overlapping the Chromium and CEF ID ranges
	// defined in the tools/gritsettings/resource_ids file.
	MenuIdUserFirst CMenuIdT = C.MENU_ID_USER_FIRST
	MenuIdUserLast  CMenuIdT = C.MENU_ID_USER_LAST
)

// /
// / Mouse button types.
// /
type CMouseButtonTypeT C.cef_mouse_button_type_t

const (
	MbtLeft   CMouseButtonTypeT = C.MBT_LEFT
	MbtMiddle CMouseButtonTypeT = C.MBT_MIDDLE
	MbtRight  CMouseButtonTypeT = C.MBT_RIGHT
)

// /
// / Structure representing mouse event information.
// /
type CMouseEventT C.cef_mouse_event_t

func NewCMouseEventT() *CMouseEventT {
	s := &CMouseEventT{}
	return s
}

func (st *CMouseEventT) X() int {
	return int(st.x)
}

func (st *CMouseEventT) SetX(v int) {
	st.x = (C.int)(v)
}

func (st *CMouseEventT) Y() int {
	return int(st.y)
}

func (st *CMouseEventT) SetY(v int) {
	st.y = (C.int)(v)
}

func (st *CMouseEventT) Modifiers() uint32 {
	return uint32(st.modifiers)
}

func (st *CMouseEventT) SetModifiers(v uint32) {
	st.modifiers = (C.uint32_t)(v)
}

// /
// / Touch points states types.
// /
type CTouchEventTypeT C.cef_touch_event_type_t

const (
	CefTetReleased  CTouchEventTypeT = C.CEF_TET_RELEASED
	CefTetPressed   CTouchEventTypeT = C.CEF_TET_PRESSED
	CefTetMoved     CTouchEventTypeT = C.CEF_TET_MOVED
	CefTetCancelled CTouchEventTypeT = C.CEF_TET_CANCELLED
)

// /
// / The device type that caused the event.
// /
type CPointerTypeT C.cef_pointer_type_t

const (
	CefPointerTypeTouch   CPointerTypeT = C.CEF_POINTER_TYPE_TOUCH
	CefPointerTypeMouse   CPointerTypeT = C.CEF_POINTER_TYPE_MOUSE
	CefPointerTypePen     CPointerTypeT = C.CEF_POINTER_TYPE_PEN
	CefPointerTypeEraser  CPointerTypeT = C.CEF_POINTER_TYPE_ERASER
	CefPointerTypeUnknown CPointerTypeT = C.CEF_POINTER_TYPE_UNKNOWN
)

// /
// / Structure representing touch event information.
// /
type CTouchEventT C.cef_touch_event_t

func NewCTouchEventT() *CTouchEventT {
	s := &CTouchEventT{}
	return s
}

func (st *CTouchEventT) Id() int {
	return int(st.id)
}

func (st *CTouchEventT) SetId(v int) {
	st.id = (C.int)(v)
}

func (st *CTouchEventT) X() float32 {
	return float32(st.x)
}

func (st *CTouchEventT) SetX(v float32) {
	st.x = (C.float)(v)
}

func (st *CTouchEventT) Y() float32 {
	return float32(st.y)
}

func (st *CTouchEventT) SetY(v float32) {
	st.y = (C.float)(v)
}

func (st *CTouchEventT) RadiusX() float32 {
	return float32(st.radius_x)
}

func (st *CTouchEventT) SetRadiusX(v float32) {
	st.radius_x = (C.float)(v)
}

func (st *CTouchEventT) RadiusY() float32 {
	return float32(st.radius_y)
}

func (st *CTouchEventT) SetRadiusY(v float32) {
	st.radius_y = (C.float)(v)
}

func (st *CTouchEventT) RotationAngle() float32 {
	return float32(st.rotation_angle)
}

func (st *CTouchEventT) SetRotationAngle(v float32) {
	st.rotation_angle = (C.float)(v)
}

func (st *CTouchEventT) Pressure() float32 {
	return float32(st.pressure)
}

func (st *CTouchEventT) SetPressure(v float32) {
	st.pressure = (C.float)(v)
}

func (st *CTouchEventT) Type() CTouchEventTypeT {
	return CTouchEventTypeT(st._type)
}

func (st *CTouchEventT) SetType(v CTouchEventTypeT) {
	st._type = (C.cef_touch_event_type_t)(v)
}

func (st *CTouchEventT) Modifiers() uint32 {
	return uint32(st.modifiers)
}

func (st *CTouchEventT) SetModifiers(v uint32) {
	st.modifiers = (C.uint32_t)(v)
}

func (st *CTouchEventT) PointerType() CPointerTypeT {
	return CPointerTypeT(st.pointer_type)
}

func (st *CTouchEventT) SetPointerType(v CPointerTypeT) {
	st.pointer_type = (C.cef_pointer_type_t)(v)
}

// /
// / Paint element types.
// /
type CPaintElementTypeT C.cef_paint_element_type_t

const (
	PetView  CPaintElementTypeT = C.PET_VIEW
	PetPopup CPaintElementTypeT = C.PET_POPUP
)

// /
// / Supported event bit flags.
// /
type CEventFlagsT C.cef_event_flags_t

const (
	EventflagNone              CEventFlagsT = C.EVENTFLAG_NONE
	EventflagCapsLockOn        CEventFlagsT = C.EVENTFLAG_CAPS_LOCK_ON
	EventflagShiftDown         CEventFlagsT = C.EVENTFLAG_SHIFT_DOWN
	EventflagControlDown       CEventFlagsT = C.EVENTFLAG_CONTROL_DOWN
	EventflagAltDown           CEventFlagsT = C.EVENTFLAG_ALT_DOWN
	EventflagLeftMouseButton   CEventFlagsT = C.EVENTFLAG_LEFT_MOUSE_BUTTON
	EventflagMiddleMouseButton CEventFlagsT = C.EVENTFLAG_MIDDLE_MOUSE_BUTTON
	EventflagRightMouseButton  CEventFlagsT = C.EVENTFLAG_RIGHT_MOUSE_BUTTON

	/// Mac OS-X command key.
	EventflagCommandDown CEventFlagsT = C.EVENTFLAG_COMMAND_DOWN
	EventflagNumLockOn   CEventFlagsT = C.EVENTFLAG_NUM_LOCK_ON
	EventflagIsKeyPad    CEventFlagsT = C.EVENTFLAG_IS_KEY_PAD
	EventflagIsLeft      CEventFlagsT = C.EVENTFLAG_IS_LEFT
	EventflagIsRight     CEventFlagsT = C.EVENTFLAG_IS_RIGHT
	EventflagAltgrDown   CEventFlagsT = C.EVENTFLAG_ALTGR_DOWN
	EventflagIsRepeat    CEventFlagsT = C.EVENTFLAG_IS_REPEAT
)

// /
// / Supported menu item types.
// /
type CMenuItemTypeT C.cef_menu_item_type_t

const (
	MenuitemtypeNone      CMenuItemTypeT = C.MENUITEMTYPE_NONE
	MenuitemtypeCommand   CMenuItemTypeT = C.MENUITEMTYPE_COMMAND
	MenuitemtypeCheck     CMenuItemTypeT = C.MENUITEMTYPE_CHECK
	MenuitemtypeRadio     CMenuItemTypeT = C.MENUITEMTYPE_RADIO
	MenuitemtypeSeparator CMenuItemTypeT = C.MENUITEMTYPE_SEPARATOR
	MenuitemtypeSubmenu   CMenuItemTypeT = C.MENUITEMTYPE_SUBMENU
)

// /
// / Supported context menu type flags.
// /
type CContextMenuTypeFlagsT C.cef_context_menu_type_flags_t

const (

	///
	/// No node is selected.
	///
	CmTypeflagNone CContextMenuTypeFlagsT = C.CM_TYPEFLAG_NONE

	///
	/// The top page is selected.
	///
	CmTypeflagPage CContextMenuTypeFlagsT = C.CM_TYPEFLAG_PAGE

	///
	/// A subframe page is selected.
	///
	CmTypeflagFrame CContextMenuTypeFlagsT = C.CM_TYPEFLAG_FRAME

	///
	/// A link is selected.
	///
	CmTypeflagLink CContextMenuTypeFlagsT = C.CM_TYPEFLAG_LINK

	///
	/// A media node is selected.
	///
	CmTypeflagMedia CContextMenuTypeFlagsT = C.CM_TYPEFLAG_MEDIA

	///
	/// There is a textual or mixed selection that is selected.
	///
	CmTypeflagSelection CContextMenuTypeFlagsT = C.CM_TYPEFLAG_SELECTION

	///
	/// An editable element is selected.
	///
	CmTypeflagEditable CContextMenuTypeFlagsT = C.CM_TYPEFLAG_EDITABLE
)

// /
// / Supported context menu media types. These constants match their equivalents
// / in Chromium's ContextMenuDataMediaType and should not be renumbered.
// /
type CContextMenuMediaTypeT C.cef_context_menu_media_type_t

const (

	///
	/// No special node is in context.
	///
	CmMediatypeNone CContextMenuMediaTypeT = C.CM_MEDIATYPE_NONE

	///
	/// An image node is selected.
	///
	CmMediatypeImage CContextMenuMediaTypeT = C.CM_MEDIATYPE_IMAGE

	///
	/// A video node is selected.
	///
	CmMediatypeVideo CContextMenuMediaTypeT = C.CM_MEDIATYPE_VIDEO

	///
	/// An audio node is selected.
	///
	CmMediatypeAudio CContextMenuMediaTypeT = C.CM_MEDIATYPE_AUDIO

	///
	/// An canvas node is selected.
	///
	CmMediatypeCanvas CContextMenuMediaTypeT = C.CM_MEDIATYPE_CANVAS

	///
	/// A file node is selected.
	///
	CmMediatypeFile CContextMenuMediaTypeT = C.CM_MEDIATYPE_FILE

	///
	/// A plugin node is selected.
	///
	CmMediatypePlugin CContextMenuMediaTypeT = C.CM_MEDIATYPE_PLUGIN
)

// /
// / Supported context menu media state bit flags. These constants match their
// / equivalents in Chromium's ContextMenuData::MediaFlags and should not be
// / renumbered.
// /
type CContextMenuMediaStateFlagsT C.cef_context_menu_media_state_flags_t

const (
	CmMediaflagNone                CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_NONE
	CmMediaflagInError             CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_IN_ERROR
	CmMediaflagPaused              CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_PAUSED
	CmMediaflagMuted               CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_MUTED
	CmMediaflagLoop                CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_LOOP
	CmMediaflagCanSave             CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_CAN_SAVE
	CmMediaflagHasAudio            CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_HAS_AUDIO
	CmMediaflagCanToggleControls   CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_CAN_TOGGLE_CONTROLS
	CmMediaflagControls            CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_CONTROLS
	CmMediaflagCanPrint            CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_CAN_PRINT
	CmMediaflagCanRotate           CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_CAN_ROTATE
	CmMediaflagCanPictureInPicture CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_CAN_PICTURE_IN_PICTURE
	CmMediaflagPictureInPicture    CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_PICTURE_IN_PICTURE
	CmMediaflagCanLoop             CContextMenuMediaStateFlagsT = C.CM_MEDIAFLAG_CAN_LOOP
)

// /
// / Supported context menu edit state bit flags. These constants match their
// / equivalents in Chromium's ContextMenuDataEditFlags and should not be
// / renumbered.
// /
type CContextMenuEditStateFlagsT C.cef_context_menu_edit_state_flags_t

const (
	CmEditflagNone          CContextMenuEditStateFlagsT = C.CM_EDITFLAG_NONE
	CmEditflagCanUndo       CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_UNDO
	CmEditflagCanRedo       CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_REDO
	CmEditflagCanCut        CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_CUT
	CmEditflagCanCopy       CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_COPY
	CmEditflagCanPaste      CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_PASTE
	CmEditflagCanDelete     CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_DELETE
	CmEditflagCanSelectAll  CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_SELECT_ALL
	CmEditflagCanTranslate  CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_TRANSLATE
	CmEditflagCanEditRichly CContextMenuEditStateFlagsT = C.CM_EDITFLAG_CAN_EDIT_RICHLY
)

// /
// / Supported quick menu state bit flags.
// /
type CQuickMenuEditStateFlagsT C.cef_quick_menu_edit_state_flags_t

const (
	QmEditflagNone        CQuickMenuEditStateFlagsT = C.QM_EDITFLAG_NONE
	QmEditflagCanEllipsis CQuickMenuEditStateFlagsT = C.QM_EDITFLAG_CAN_ELLIPSIS
	QmEditflagCanCut      CQuickMenuEditStateFlagsT = C.QM_EDITFLAG_CAN_CUT
	QmEditflagCanCopy     CQuickMenuEditStateFlagsT = C.QM_EDITFLAG_CAN_COPY
	QmEditflagCanPaste    CQuickMenuEditStateFlagsT = C.QM_EDITFLAG_CAN_PASTE
)

// /
// / Key event types.
// /
type CKeyEventTypeT C.cef_key_event_type_t

const (

	///
	/// Notification that a key transitioned from "up" to "down".
	///
	KeyeventRawkeydown CKeyEventTypeT = C.KEYEVENT_RAWKEYDOWN

	///
	/// Notification that a key was pressed. This does not necessarily correspond
	/// to a character depending on the key and language. Use KEYEVENT_CHAR for
	/// character input.
	///
	KeyeventKeydown CKeyEventTypeT = C.KEYEVENT_KEYDOWN

	///
	/// Notification that a key was released.
	///
	KeyeventKeyup CKeyEventTypeT = C.KEYEVENT_KEYUP

	///
	/// Notification that a character was typed. Use this for text input. Key
	/// down events may generate 0, 1, or more than one character event depending
	/// on the key, locale, and operating system.
	///
	KeyeventChar CKeyEventTypeT = C.KEYEVENT_CHAR
)

// /
// / Structure representing keyboard event information.
// /
type CKeyEventT C.cef_key_event_t

func NewCKeyEventT() *CKeyEventT {
	s := &CKeyEventT{}
	return s
}

func (st *CKeyEventT) Type() CKeyEventTypeT {
	return CKeyEventTypeT(st._type)
}

func (st *CKeyEventT) SetType(v CKeyEventTypeT) {
	st._type = (C.cef_key_event_type_t)(v)
}

func (st *CKeyEventT) Modifiers() uint32 {
	return uint32(st.modifiers)
}

func (st *CKeyEventT) SetModifiers(v uint32) {
	st.modifiers = (C.uint32_t)(v)
}

func (st *CKeyEventT) WindowsKeyCode() int {
	return int(st.windows_key_code)
}

func (st *CKeyEventT) SetWindowsKeyCode(v int) {
	st.windows_key_code = (C.int)(v)
}

func (st *CKeyEventT) NativeKeyCode() int {
	return int(st.native_key_code)
}

func (st *CKeyEventT) SetNativeKeyCode(v int) {
	st.native_key_code = (C.int)(v)
}

func (st *CKeyEventT) IsSystemKey() int {
	return int(st.is_system_key)
}

func (st *CKeyEventT) SetIsSystemKey(v int) {
	st.is_system_key = (C.int)(v)
}

func (st *CKeyEventT) Character() uint16 {
	return uint16(st.character)
}

func (st *CKeyEventT) SetCharacter(v uint16) {
	st.character = (C.char16_t)(v)
}

func (st *CKeyEventT) UnmodifiedCharacter() uint16 {
	return uint16(st.unmodified_character)
}

func (st *CKeyEventT) SetUnmodifiedCharacter(v uint16) {
	st.unmodified_character = (C.char16_t)(v)
}

func (st *CKeyEventT) FocusOnEditableField() int {
	return int(st.focus_on_editable_field)
}

func (st *CKeyEventT) SetFocusOnEditableField(v int) {
	st.focus_on_editable_field = (C.int)(v)
}

// /
// / Focus sources.
// /
type CFocusSourceT C.cef_focus_source_t

const (

	///
	/// The source is explicit navigation via the API (LoadURL(), etc).
	///
	FocusSourceNavigation CFocusSourceT = C.FOCUS_SOURCE_NAVIGATION

	///
	/// The source is a system-generated focus event.
	///
	FocusSourceSystem CFocusSourceT = C.FOCUS_SOURCE_SYSTEM
)

// /
// / Navigation types.
// /
type CNavigationTypeT C.cef_navigation_type_t

const (
	NavigationLinkClicked     CNavigationTypeT = C.NAVIGATION_LINK_CLICKED
	NavigationFormSubmitted   CNavigationTypeT = C.NAVIGATION_FORM_SUBMITTED
	NavigationBackForward     CNavigationTypeT = C.NAVIGATION_BACK_FORWARD
	NavigationReload          CNavigationTypeT = C.NAVIGATION_RELOAD
	NavigationFormResubmitted CNavigationTypeT = C.NAVIGATION_FORM_RESUBMITTED
	NavigationOther           CNavigationTypeT = C.NAVIGATION_OTHER
)

// /
// / Supported XML encoding types. The parser supports ASCII, ISO-8859-1, and
// / UTF16 (LE and BE) by default. All other types must be translated to UTF8
// / before being passed to the parser. If a BOM is detected and the correct
// / decoder is available then that decoder will be used automatically.
// /
type CXmlEncodingTypeT C.cef_xml_encoding_type_t

const (
	XmlEncodingNone    CXmlEncodingTypeT = C.XML_ENCODING_NONE
	XmlEncodingUtf8    CXmlEncodingTypeT = C.XML_ENCODING_UTF8
	XmlEncodingUtf16le CXmlEncodingTypeT = C.XML_ENCODING_UTF16LE
	XmlEncodingUtf16be CXmlEncodingTypeT = C.XML_ENCODING_UTF16BE
	XmlEncodingAscii   CXmlEncodingTypeT = C.XML_ENCODING_ASCII
)

// /
// / XML node types.
// /
type CXmlNodeTypeT C.cef_xml_node_type_t

const (
	XmlNodeUnsupported           CXmlNodeTypeT = C.XML_NODE_UNSUPPORTED
	XmlNodeProcessingInstruction CXmlNodeTypeT = C.XML_NODE_PROCESSING_INSTRUCTION
	XmlNodeDocumentType          CXmlNodeTypeT = C.XML_NODE_DOCUMENT_TYPE
	XmlNodeElementStart          CXmlNodeTypeT = C.XML_NODE_ELEMENT_START
	XmlNodeElementEnd            CXmlNodeTypeT = C.XML_NODE_ELEMENT_END
	XmlNodeAttribute             CXmlNodeTypeT = C.XML_NODE_ATTRIBUTE
	XmlNodeText                  CXmlNodeTypeT = C.XML_NODE_TEXT
	XmlNodeCdata                 CXmlNodeTypeT = C.XML_NODE_CDATA
	XmlNodeEntityReference       CXmlNodeTypeT = C.XML_NODE_ENTITY_REFERENCE
	XmlNodeWhitespace            CXmlNodeTypeT = C.XML_NODE_WHITESPACE
	XmlNodeComment               CXmlNodeTypeT = C.XML_NODE_COMMENT
)

// /
// / Popup window features.
// /
type CPopupFeaturesT C.cef_popup_features_t

func NewCPopupFeaturesT() *CPopupFeaturesT {
	s := &CPopupFeaturesT{}
	return s
}

func (st *CPopupFeaturesT) X() int {
	return int(st.x)
}

func (st *CPopupFeaturesT) SetX(v int) {
	st.x = (C.int)(v)
}

func (st *CPopupFeaturesT) XSet() bool {
	return st.xSet != 0
}

func (st *CPopupFeaturesT) SetXSet(v bool) {
	if v {
		st.xSet = 1
	} else {
		st.xSet = 0
	}
}

func (st *CPopupFeaturesT) Y() int {
	return int(st.y)
}

func (st *CPopupFeaturesT) SetY(v int) {
	st.y = (C.int)(v)
}

func (st *CPopupFeaturesT) YSet() bool {
	return st.ySet != 0
}

func (st *CPopupFeaturesT) SetYSet(v bool) {
	if v {
		st.ySet = 1
	} else {
		st.ySet = 0
	}
}

func (st *CPopupFeaturesT) Width() int {
	return int(st.width)
}

func (st *CPopupFeaturesT) SetWidth(v int) {
	st.width = (C.int)(v)
}

func (st *CPopupFeaturesT) WidthSet() bool {
	return st.widthSet != 0
}

func (st *CPopupFeaturesT) SetWidthSet(v bool) {
	if v {
		st.widthSet = 1
	} else {
		st.widthSet = 0
	}
}

func (st *CPopupFeaturesT) Height() int {
	return int(st.height)
}

func (st *CPopupFeaturesT) SetHeight(v int) {
	st.height = (C.int)(v)
}

func (st *CPopupFeaturesT) HeightSet() bool {
	return st.heightSet != 0
}

func (st *CPopupFeaturesT) SetHeightSet(v bool) {
	if v {
		st.heightSet = 1
	} else {
		st.heightSet = 0
	}
}

func (st *CPopupFeaturesT) IsPopup() int {
	return int(st.isPopup)
}

func (st *CPopupFeaturesT) SetIsPopup(v int) {
	st.isPopup = (C.int)(v)
}

// /
// / DOM document types.
// /
type CDomDocumentTypeT C.cef_dom_document_type_t

const (
	DomDocumentTypeUnknown CDomDocumentTypeT = C.DOM_DOCUMENT_TYPE_UNKNOWN
	DomDocumentTypeHtml    CDomDocumentTypeT = C.DOM_DOCUMENT_TYPE_HTML
	DomDocumentTypeXhtml   CDomDocumentTypeT = C.DOM_DOCUMENT_TYPE_XHTML
	DomDocumentTypePlugin  CDomDocumentTypeT = C.DOM_DOCUMENT_TYPE_PLUGIN
)

// /
// / DOM event category flags.
// /
type CDomEventCategoryT C.cef_dom_event_category_t

const (
	DomEventCategoryUnknown                CDomEventCategoryT = C.DOM_EVENT_CATEGORY_UNKNOWN
	DomEventCategoryUi                     CDomEventCategoryT = C.DOM_EVENT_CATEGORY_UI
	DomEventCategoryMouse                  CDomEventCategoryT = C.DOM_EVENT_CATEGORY_MOUSE
	DomEventCategoryMutation               CDomEventCategoryT = C.DOM_EVENT_CATEGORY_MUTATION
	DomEventCategoryKeyboard               CDomEventCategoryT = C.DOM_EVENT_CATEGORY_KEYBOARD
	DomEventCategoryText                   CDomEventCategoryT = C.DOM_EVENT_CATEGORY_TEXT
	DomEventCategoryComposition            CDomEventCategoryT = C.DOM_EVENT_CATEGORY_COMPOSITION
	DomEventCategoryDrag                   CDomEventCategoryT = C.DOM_EVENT_CATEGORY_DRAG
	DomEventCategoryClipboard              CDomEventCategoryT = C.DOM_EVENT_CATEGORY_CLIPBOARD
	DomEventCategoryMessage                CDomEventCategoryT = C.DOM_EVENT_CATEGORY_MESSAGE
	DomEventCategoryWheel                  CDomEventCategoryT = C.DOM_EVENT_CATEGORY_WHEEL
	DomEventCategoryBeforeTextInserted     CDomEventCategoryT = C.DOM_EVENT_CATEGORY_BEFORE_TEXT_INSERTED
	DomEventCategoryOverflow               CDomEventCategoryT = C.DOM_EVENT_CATEGORY_OVERFLOW
	DomEventCategoryPageTransition         CDomEventCategoryT = C.DOM_EVENT_CATEGORY_PAGE_TRANSITION
	DomEventCategoryPopstate               CDomEventCategoryT = C.DOM_EVENT_CATEGORY_POPSTATE
	DomEventCategoryProgress               CDomEventCategoryT = C.DOM_EVENT_CATEGORY_PROGRESS
	DomEventCategoryXmlhttprequestProgress CDomEventCategoryT = C.DOM_EVENT_CATEGORY_XMLHTTPREQUEST_PROGRESS
)

// /
// / DOM event processing phases.
// /
type CDomEventPhaseT C.cef_dom_event_phase_t

const (
	DomEventPhaseUnknown   CDomEventPhaseT = C.DOM_EVENT_PHASE_UNKNOWN
	DomEventPhaseCapturing CDomEventPhaseT = C.DOM_EVENT_PHASE_CAPTURING
	DomEventPhaseAtTarget  CDomEventPhaseT = C.DOM_EVENT_PHASE_AT_TARGET
	DomEventPhaseBubbling  CDomEventPhaseT = C.DOM_EVENT_PHASE_BUBBLING
)

// /
// / DOM node types.
// /
type CDomNodeTypeT C.cef_dom_node_type_t

const (
	DomNodeTypeUnsupported            CDomNodeTypeT = C.DOM_NODE_TYPE_UNSUPPORTED
	DomNodeTypeElement                CDomNodeTypeT = C.DOM_NODE_TYPE_ELEMENT
	DomNodeTypeAttribute              CDomNodeTypeT = C.DOM_NODE_TYPE_ATTRIBUTE
	DomNodeTypeText                   CDomNodeTypeT = C.DOM_NODE_TYPE_TEXT
	DomNodeTypeCdataSection           CDomNodeTypeT = C.DOM_NODE_TYPE_CDATA_SECTION
	DomNodeTypeProcessingInstructions CDomNodeTypeT = C.DOM_NODE_TYPE_PROCESSING_INSTRUCTIONS
	DomNodeTypeComment                CDomNodeTypeT = C.DOM_NODE_TYPE_COMMENT
	DomNodeTypeDocument               CDomNodeTypeT = C.DOM_NODE_TYPE_DOCUMENT
	DomNodeTypeDocumentType           CDomNodeTypeT = C.DOM_NODE_TYPE_DOCUMENT_TYPE
	DomNodeTypeDocumentFragment       CDomNodeTypeT = C.DOM_NODE_TYPE_DOCUMENT_FRAGMENT
)

// /
// / Supported file dialog modes.
// /
type CFileDialogModeT C.cef_file_dialog_mode_t

const (

	///
	/// Requires that the file exists before allowing the user to pick it.
	///
	FileDialogOpen CFileDialogModeT = C.FILE_DIALOG_OPEN

	///
	/// Like Open, but allows picking multiple files to open.
	///
	FileDialogOpenMultiple CFileDialogModeT = C.FILE_DIALOG_OPEN_MULTIPLE

	///
	/// Like Open, but selects a folder to open.
	///
	FileDialogOpenFolder CFileDialogModeT = C.FILE_DIALOG_OPEN_FOLDER

	///
	/// Allows picking a nonexistent file, and prompts to overwrite if the file
	/// already exists.
	///
	FileDialogSave CFileDialogModeT = C.FILE_DIALOG_SAVE
)

// /
// / Print job color mode values.
// /
type CColorModelT C.cef_color_model_t

const (
	ColorModelUnknown                    CColorModelT = C.COLOR_MODEL_UNKNOWN
	ColorModelGray                       CColorModelT = C.COLOR_MODEL_GRAY
	ColorModelColor                      CColorModelT = C.COLOR_MODEL_COLOR
	ColorModelCmyk                       CColorModelT = C.COLOR_MODEL_CMYK
	ColorModelCmy                        CColorModelT = C.COLOR_MODEL_CMY
	ColorModelKcmy                       CColorModelT = C.COLOR_MODEL_KCMY
	ColorModelCmyK                       CColorModelT = C.COLOR_MODEL_CMY_K
	ColorModelBlack                      CColorModelT = C.COLOR_MODEL_BLACK
	ColorModelGrayscale                  CColorModelT = C.COLOR_MODEL_GRAYSCALE
	ColorModelRgb                        CColorModelT = C.COLOR_MODEL_RGB
	ColorModelRgb16                      CColorModelT = C.COLOR_MODEL_RGB16
	ColorModelRgba                       CColorModelT = C.COLOR_MODEL_RGBA
	ColorModelColormodeColor             CColorModelT = C.COLOR_MODEL_COLORMODE_COLOR
	ColorModelColormodeMonochrome        CColorModelT = C.COLOR_MODEL_COLORMODE_MONOCHROME
	ColorModelHpColorColor               CColorModelT = C.COLOR_MODEL_HP_COLOR_COLOR
	ColorModelHpColorBlack               CColorModelT = C.COLOR_MODEL_HP_COLOR_BLACK
	ColorModelPrintoutmodeNormal         CColorModelT = C.COLOR_MODEL_PRINTOUTMODE_NORMAL
	ColorModelPrintoutmodeNormalGray     CColorModelT = C.COLOR_MODEL_PRINTOUTMODE_NORMAL_GRAY
	ColorModelProcesscolormodelCmyk      CColorModelT = C.COLOR_MODEL_PROCESSCOLORMODEL_CMYK
	ColorModelProcesscolormodelGreyscale CColorModelT = C.COLOR_MODEL_PROCESSCOLORMODEL_GREYSCALE
	ColorModelProcesscolormodelRgb       CColorModelT = C.COLOR_MODEL_PROCESSCOLORMODEL_RGB
)

// /
// / Print job duplex mode values.
// /
type CDuplexModeT C.cef_duplex_mode_t

const (
	DuplexModeUnknown   CDuplexModeT = C.DUPLEX_MODE_UNKNOWN
	DuplexModeSimplex   CDuplexModeT = C.DUPLEX_MODE_SIMPLEX
	DuplexModeLongEdge  CDuplexModeT = C.DUPLEX_MODE_LONG_EDGE
	DuplexModeShortEdge CDuplexModeT = C.DUPLEX_MODE_SHORT_EDGE
)

// /
// / Cursor type values.
// /
type CCursorTypeT C.cef_cursor_type_t

const (
	CtPointer                  CCursorTypeT = C.CT_POINTER
	CtCross                    CCursorTypeT = C.CT_CROSS
	CtHand                     CCursorTypeT = C.CT_HAND
	CtIbeam                    CCursorTypeT = C.CT_IBEAM
	CtWait                     CCursorTypeT = C.CT_WAIT
	CtHelp                     CCursorTypeT = C.CT_HELP
	CtEastresize               CCursorTypeT = C.CT_EASTRESIZE
	CtNorthresize              CCursorTypeT = C.CT_NORTHRESIZE
	CtNortheastresize          CCursorTypeT = C.CT_NORTHEASTRESIZE
	CtNorthwestresize          CCursorTypeT = C.CT_NORTHWESTRESIZE
	CtSouthresize              CCursorTypeT = C.CT_SOUTHRESIZE
	CtSoutheastresize          CCursorTypeT = C.CT_SOUTHEASTRESIZE
	CtSouthwestresize          CCursorTypeT = C.CT_SOUTHWESTRESIZE
	CtWestresize               CCursorTypeT = C.CT_WESTRESIZE
	CtNorthsouthresize         CCursorTypeT = C.CT_NORTHSOUTHRESIZE
	CtEastwestresize           CCursorTypeT = C.CT_EASTWESTRESIZE
	CtNortheastsouthwestresize CCursorTypeT = C.CT_NORTHEASTSOUTHWESTRESIZE
	CtNorthwestsoutheastresize CCursorTypeT = C.CT_NORTHWESTSOUTHEASTRESIZE
	CtColumnresize             CCursorTypeT = C.CT_COLUMNRESIZE
	CtRowresize                CCursorTypeT = C.CT_ROWRESIZE
	CtMiddlepanning            CCursorTypeT = C.CT_MIDDLEPANNING
	CtEastpanning              CCursorTypeT = C.CT_EASTPANNING
	CtNorthpanning             CCursorTypeT = C.CT_NORTHPANNING
	CtNortheastpanning         CCursorTypeT = C.CT_NORTHEASTPANNING
	CtNorthwestpanning         CCursorTypeT = C.CT_NORTHWESTPANNING
	CtSouthpanning             CCursorTypeT = C.CT_SOUTHPANNING
	CtSoutheastpanning         CCursorTypeT = C.CT_SOUTHEASTPANNING
	CtSouthwestpanning         CCursorTypeT = C.CT_SOUTHWESTPANNING
	CtWestpanning              CCursorTypeT = C.CT_WESTPANNING
	CtMove                     CCursorTypeT = C.CT_MOVE
	CtVerticaltext             CCursorTypeT = C.CT_VERTICALTEXT
	CtCell                     CCursorTypeT = C.CT_CELL
	CtContextmenu              CCursorTypeT = C.CT_CONTEXTMENU
	CtAlias                    CCursorTypeT = C.CT_ALIAS
	CtProgress                 CCursorTypeT = C.CT_PROGRESS
	CtNodrop                   CCursorTypeT = C.CT_NODROP
	CtCopy                     CCursorTypeT = C.CT_COPY
	CtNone                     CCursorTypeT = C.CT_NONE
	CtNotallowed               CCursorTypeT = C.CT_NOTALLOWED
	CtZoomin                   CCursorTypeT = C.CT_ZOOMIN
	CtZoomout                  CCursorTypeT = C.CT_ZOOMOUT
	CtGrab                     CCursorTypeT = C.CT_GRAB
	CtGrabbing                 CCursorTypeT = C.CT_GRABBING
	CtMiddlePanningVertical    CCursorTypeT = C.CT_MIDDLE_PANNING_VERTICAL
	CtMiddlePanningHorizontal  CCursorTypeT = C.CT_MIDDLE_PANNING_HORIZONTAL
	CtCustom                   CCursorTypeT = C.CT_CUSTOM
	CtDndNone                  CCursorTypeT = C.CT_DND_NONE
	CtDndMove                  CCursorTypeT = C.CT_DND_MOVE
	CtDndCopy                  CCursorTypeT = C.CT_DND_COPY
	CtDndLink                  CCursorTypeT = C.CT_DND_LINK
)

// /
// / Structure representing cursor information. |buffer| will be
// / |size.width|*|size.height|*4 bytes in size and represents a BGRA image with
// / an upper-left origin.
// /
type CCursorInfoT C.cef_cursor_info_t

func NewCCursorInfoT() *CCursorInfoT {
	s := &CCursorInfoT{}
	return s
}

func (st *CCursorInfoT) Hotspot() CPointT {
	return CPointT(st.hotspot)
}

func (st *CCursorInfoT) SetHotspot(v CPointT) {
	st.hotspot = (C.cef_point_t)(v)
}

func (st *CCursorInfoT) ImageScaleFactor() float32 {
	return float32(st.image_scale_factor)
}

func (st *CCursorInfoT) SetImageScaleFactor(v float32) {
	st.image_scale_factor = (C.float)(v)
}

func (st *CCursorInfoT) Buffer() unsafe.Pointer {
	return unsafe.Pointer(st.buffer)
}

func (st *CCursorInfoT) SetBuffer(v unsafe.Pointer) {
	st.buffer = (unsafe.Pointer)(v)
}

func (st *CCursorInfoT) Size() CSizeT {
	return CSizeT(st.size)
}

func (st *CCursorInfoT) SetSize(v CSizeT) {
	st.size = (C.cef_size_t)(v)
}

// /
// / URI unescape rules passed to CefURIDecode().
// /
type CUriUnescapeRuleT C.cef_uri_unescape_rule_t

const (

	///
	/// Don't unescape anything at all.
	///
	UuNone CUriUnescapeRuleT = C.UU_NONE

	///
	/// Don't unescape anything special, but all normal unescaping will happen.
	/// This is a placeholder and can't be combined with other flags (since it's
	/// just the absence of them). All other unescape rules imply "normal" in
	/// addition to their special meaning. Things like escaped letters, digits,
	/// and most symbols will get unescaped with this mode.
	///
	UuNormal CUriUnescapeRuleT = C.UU_NORMAL

	///
	/// Convert %20 to spaces. In some places where we're showing URLs, we may
	/// want this. In places where the URL may be copied and pasted out, then
	/// you wouldn't want this since it might not be interpreted in one piece
	/// by other applications.
	///
	UuSpaces CUriUnescapeRuleT = C.UU_SPACES

	///
	/// Unescapes '/' and '\\'. If these characters were unescaped, the resulting
	/// URL won't be the same as the source one. Moreover, they are dangerous to
	/// unescape in strings that will be used as file paths or names. This value
	/// should only be used when slashes don't have special meaning, like data
	/// URLs.
	///
	UuPathSeparators CUriUnescapeRuleT = C.UU_PATH_SEPARATORS

	///
	/// Unescapes various characters that will change the meaning of URLs,
	/// including '%', '+', '&', '#'. Does not unescape path separators.
	/// If these characters were unescaped, the resulting URL won't be the same
	/// as the source one. This flag is used when generating final output like
	/// filenames for URLs where we won't be interpreting as a URL and want to do
	/// as much unescaping as possible.
	///
	UuUrlSpecialCharsExceptPathSeparators CUriUnescapeRuleT = C.UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS

	///
	/// URL queries use "+" for space. This flag controls that replacement.
	///
	UuReplacePlusWithSpace CUriUnescapeRuleT = C.UU_REPLACE_PLUS_WITH_SPACE
)

// /
// / Options that can be passed to CefParseJSON.
// /
type CJsonParserOptionsT C.cef_json_parser_options_t

const (

	///
	/// Parses the input strictly according to RFC 4627. See comments in
	/// Chromium's base/json/json_reader.h file for known limitations/
	/// deviations from the RFC.
	///
	JsonParserRfc CJsonParserOptionsT = C.JSON_PARSER_RFC

	///
	/// Allows commas to exist after the last element in structures.
	///
	JsonParserAllowTrailingCommas CJsonParserOptionsT = C.JSON_PARSER_ALLOW_TRAILING_COMMAS
)

// /
// / Options that can be passed to CefWriteJSON.
// /
type CJsonWriterOptionsT C.cef_json_writer_options_t

const (

	///
	/// Default behavior.
	///
	JsonWriterDefault CJsonWriterOptionsT = C.JSON_WRITER_DEFAULT

	///
	/// This option instructs the writer that if a Binary value is encountered,
	/// the value (and key if within a dictionary) will be omitted from the
	/// output, and success will be returned. Otherwise, if a binary value is
	/// encountered, failure will be returned.
	///
	JsonWriterOmitBinaryValues CJsonWriterOptionsT = C.JSON_WRITER_OMIT_BINARY_VALUES

	///
	/// This option instructs the writer to write doubles that have no fractional
	/// part as a normal integer (i.e., without using exponential notation
	/// or appending a '.0') as long as the value is within the range of a
	/// 64-bit int.
	///
	JsonWriterOmitDoubleTypePreservation CJsonWriterOptionsT = C.JSON_WRITER_OMIT_DOUBLE_TYPE_PRESERVATION

	///
	/// Return a slightly nicer formatted json string (pads with whitespace to
	/// help with readability).
	///
	JsonWriterPrettyPrint CJsonWriterOptionsT = C.JSON_WRITER_PRETTY_PRINT
)

// /
// / Margin type for PDF printing.
// /
type CPdfPrintMarginTypeT C.cef_pdf_print_margin_type_t

const (

	///
	/// Default margins of 1cm (~0.4 inches).
	///
	PdfPrintMarginDefault CPdfPrintMarginTypeT = C.PDF_PRINT_MARGIN_DEFAULT

	///
	/// No margins.
	///
	PdfPrintMarginNone CPdfPrintMarginTypeT = C.PDF_PRINT_MARGIN_NONE

	///
	/// Custom margins using the |margin_*| values from cef_pdf_print_settings_t.
	///
	PdfPrintMarginCustom CPdfPrintMarginTypeT = C.PDF_PRINT_MARGIN_CUSTOM
)

// /
// / Structure representing PDF print settings. These values match the parameters
// / supported by the DevTools Page.printToPDF function. See
// / https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF
// /
type CPdfPrintSettingsT C.cef_pdf_print_settings_t

func NewCPdfPrintSettingsT() *CPdfPrintSettingsT {
	s := &CPdfPrintSettingsT{}
	return s
}

func (st *CPdfPrintSettingsT) Landscape() bool {
	return st.landscape != 0
}

func (st *CPdfPrintSettingsT) SetLandscape(v bool) {
	if v {
		st.landscape = 1
	} else {
		st.landscape = 0
	}
}

func (st *CPdfPrintSettingsT) PrintBackground() int {
	return int(st.print_background)
}

func (st *CPdfPrintSettingsT) SetPrintBackground(v int) {
	st.print_background = (C.int)(v)
}

func (st *CPdfPrintSettingsT) Scale() float64 {
	return float64(st.scale)
}

func (st *CPdfPrintSettingsT) SetScale(v float64) {
	st.scale = (C.double)(v)
}

func (st *CPdfPrintSettingsT) PaperWidth() float64 {
	return float64(st.paper_width)
}

func (st *CPdfPrintSettingsT) SetPaperWidth(v float64) {
	st.paper_width = (C.double)(v)
}

func (st *CPdfPrintSettingsT) PaperHeight() float64 {
	return float64(st.paper_height)
}

func (st *CPdfPrintSettingsT) SetPaperHeight(v float64) {
	st.paper_height = (C.double)(v)
}

func (st *CPdfPrintSettingsT) PreferCssPageSize() int {
	return int(st.prefer_css_page_size)
}

func (st *CPdfPrintSettingsT) SetPreferCssPageSize(v int) {
	st.prefer_css_page_size = (C.int)(v)
}

func (st *CPdfPrintSettingsT) MarginType() CPdfPrintMarginTypeT {
	return CPdfPrintMarginTypeT(st.margin_type)
}

func (st *CPdfPrintSettingsT) SetMarginType(v CPdfPrintMarginTypeT) {
	st.margin_type = (C.cef_pdf_print_margin_type_t)(v)
}

func (st *CPdfPrintSettingsT) MarginTop() float64 {
	return float64(st.margin_top)
}

func (st *CPdfPrintSettingsT) SetMarginTop(v float64) {
	st.margin_top = (C.double)(v)
}

func (st *CPdfPrintSettingsT) MarginRight() float64 {
	return float64(st.margin_right)
}

func (st *CPdfPrintSettingsT) SetMarginRight(v float64) {
	st.margin_right = (C.double)(v)
}

func (st *CPdfPrintSettingsT) MarginBottom() float64 {
	return float64(st.margin_bottom)
}

func (st *CPdfPrintSettingsT) SetMarginBottom(v float64) {
	st.margin_bottom = (C.double)(v)
}

func (st *CPdfPrintSettingsT) MarginLeft() float64 {
	return float64(st.margin_left)
}

func (st *CPdfPrintSettingsT) SetMarginLeft(v float64) {
	st.margin_left = (C.double)(v)
}

func (st *CPdfPrintSettingsT) PageRanges() string {
	return string_from_cef_string(&st.page_ranges)
}

func (st *CPdfPrintSettingsT) SetPageRanges(v string) {
	set_cef_string(&st.page_ranges, v)
}

func (st *CPdfPrintSettingsT) DisplayHeaderFooter() int {
	return int(st.display_header_footer)
}

func (st *CPdfPrintSettingsT) SetDisplayHeaderFooter(v int) {
	st.display_header_footer = (C.int)(v)
}

func (st *CPdfPrintSettingsT) HeaderTemplate() string {
	return string_from_cef_string(&st.header_template)
}

func (st *CPdfPrintSettingsT) SetHeaderTemplate(v string) {
	set_cef_string(&st.header_template, v)
}

func (st *CPdfPrintSettingsT) FooterTemplate() string {
	return string_from_cef_string(&st.footer_template)
}

func (st *CPdfPrintSettingsT) SetFooterTemplate(v string) {
	set_cef_string(&st.footer_template, v)
}

// /
// / Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for
// / density independent resources such as string, html/js files or an image that
// / can be used for any scale factors (such as wallpapers).
// /
type CScaleFactorT C.cef_scale_factor_t

const (
	ScaleFactorNone CScaleFactorT = C.SCALE_FACTOR_NONE
	ScaleFactor100p CScaleFactorT = C.SCALE_FACTOR_100P
	ScaleFactor125p CScaleFactorT = C.SCALE_FACTOR_125P
	ScaleFactor133p CScaleFactorT = C.SCALE_FACTOR_133P
	ScaleFactor140p CScaleFactorT = C.SCALE_FACTOR_140P
	ScaleFactor150p CScaleFactorT = C.SCALE_FACTOR_150P
	ScaleFactor180p CScaleFactorT = C.SCALE_FACTOR_180P
	ScaleFactor200p CScaleFactorT = C.SCALE_FACTOR_200P
	ScaleFactor250p CScaleFactorT = C.SCALE_FACTOR_250P
	ScaleFactor300p CScaleFactorT = C.SCALE_FACTOR_300P
)

// /
// / Policy for how the Referrer HTTP header value will be sent during
// / navigation. If the `--no-referrers` command-line flag is specified then the
// / policy value will be ignored and the Referrer value will never be sent. Must
// / be kept synchronized with net::URLRequest::ReferrerPolicy from Chromium.
// /
type CReferrerPolicyT C.cef_referrer_policy_t

const (

	///
	/// Clear the referrer header if the header value is HTTPS but the request
	/// destination is HTTP. This is the default behavior.
	///
	ReferrerPolicyClearReferrerOnTransitionFromSecureToInsecure CReferrerPolicyT = C.REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE
	ReferrerPolicyDefault                                       CReferrerPolicyT = C.REFERRER_POLICY_DEFAULT

	///
	/// A slight variant on CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE:
	/// If the request destination is HTTP, an HTTPS referrer will be cleared. If
	/// the request's destination is cross-origin with the referrer (but does not
	/// downgrade), the referrer's granularity will be stripped down to an origin
	/// rather than a full URL. Same-origin requests will send the full referrer.
	///
	ReferrerPolicyReduceReferrerGranularityOnTransitionCrossOrigin CReferrerPolicyT = C.REFERRER_POLICY_REDUCE_REFERRER_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN

	///
	/// Strip the referrer down to an origin when the origin of the referrer is
	/// different from the destination's origin.
	///
	ReferrerPolicyOriginOnlyOnTransitionCrossOrigin CReferrerPolicyT = C.REFERRER_POLICY_ORIGIN_ONLY_ON_TRANSITION_CROSS_ORIGIN

	///
	/// Never change the referrer.
	///
	ReferrerPolicyNeverClearReferrer CReferrerPolicyT = C.REFERRER_POLICY_NEVER_CLEAR_REFERRER

	///
	/// Strip the referrer down to the origin regardless of the redirect location.
	///
	ReferrerPolicyOrigin CReferrerPolicyT = C.REFERRER_POLICY_ORIGIN

	///
	/// Clear the referrer when the request's referrer is cross-origin with the
	/// request's destination.
	///
	ReferrerPolicyClearReferrerOnTransitionCrossOrigin CReferrerPolicyT = C.REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_CROSS_ORIGIN

	///
	/// Strip the referrer down to the origin, but clear it entirely if the
	/// referrer value is HTTPS and the destination is HTTP.
	///
	ReferrerPolicyOriginClearOnTransitionFromSecureToInsecure CReferrerPolicyT = C.REFERRER_POLICY_ORIGIN_CLEAR_ON_TRANSITION_FROM_SECURE_TO_INSECURE

	///
	/// Always clear the referrer regardless of the request destination.
	///
	ReferrerPolicyNoReferrer CReferrerPolicyT = C.REFERRER_POLICY_NO_REFERRER

	/// Always the last value in this enumeration.
	ReferrerPolicyLastValue CReferrerPolicyT = C.REFERRER_POLICY_LAST_VALUE
)

// /
// / Return values for CefResponseFilter::Filter().
// /
type CResponseFilterStatusT C.cef_response_filter_status_t

const (

	///
	/// Some or all of the pre-filter data was read successfully but more data is
	/// needed in order to continue filtering (filtered output is pending).
	///
	ResponseFilterNeedMoreData CResponseFilterStatusT = C.RESPONSE_FILTER_NEED_MORE_DATA

	///
	/// Some or all of the pre-filter data was read successfully and all available
	/// filtered output has been written.
	///
	ResponseFilterDone CResponseFilterStatusT = C.RESPONSE_FILTER_DONE

	///
	/// An error occurred during filtering.
	///
	ResponseFilterError CResponseFilterStatusT = C.RESPONSE_FILTER_ERROR
)

// /
// / Describes how to interpret the components of a pixel.
// /
type CColorTypeT C.cef_color_type_t

const (

	///
	/// RGBA with 8 bits per pixel (32bits total).
	///
	CefColorTypeRgba8888 CColorTypeT = C.CEF_COLOR_TYPE_RGBA_8888

	///
	/// BGRA with 8 bits per pixel (32bits total).
	///
	CefColorTypeBgra8888 CColorTypeT = C.CEF_COLOR_TYPE_BGRA_8888
)

// /
// / Describes how to interpret the alpha component of a pixel.
// /
type CAlphaTypeT C.cef_alpha_type_t

const (

	///
	/// No transparency. The alpha component is ignored.
	///
	CefAlphaTypeOpaque CAlphaTypeT = C.CEF_ALPHA_TYPE_OPAQUE

	///
	/// Transparency with pre-multiplied alpha component.
	///
	CefAlphaTypePremultiplied CAlphaTypeT = C.CEF_ALPHA_TYPE_PREMULTIPLIED

	///
	/// Transparency with post-multiplied alpha component.
	///
	CefAlphaTypePostmultiplied CAlphaTypeT = C.CEF_ALPHA_TYPE_POSTMULTIPLIED
)

// /
// / Text style types. Should be kepy in sync with gfx::TextStyle.
// /
type CTextStyleT C.cef_text_style_t

const (
	CefTextStyleBold           CTextStyleT = C.CEF_TEXT_STYLE_BOLD
	CefTextStyleItalic         CTextStyleT = C.CEF_TEXT_STYLE_ITALIC
	CefTextStyleStrike         CTextStyleT = C.CEF_TEXT_STYLE_STRIKE
	CefTextStyleDiagonalStrike CTextStyleT = C.CEF_TEXT_STYLE_DIAGONAL_STRIKE
	CefTextStyleUnderline      CTextStyleT = C.CEF_TEXT_STYLE_UNDERLINE
)

// /
// / Specifies where along the main axis the CefBoxLayout child views should be
// / laid out.
// /
type CMainAxisAlignmentT C.cef_main_axis_alignment_t

const (

	///
	/// Child views will be left-aligned.
	///
	CefMainAxisAlignmentStart CMainAxisAlignmentT = C.CEF_MAIN_AXIS_ALIGNMENT_START

	///
	/// Child views will be center-aligned.
	///
	CefMainAxisAlignmentCenter CMainAxisAlignmentT = C.CEF_MAIN_AXIS_ALIGNMENT_CENTER

	///
	/// Child views will be right-aligned.
	///
	CefMainAxisAlignmentEnd CMainAxisAlignmentT = C.CEF_MAIN_AXIS_ALIGNMENT_END
)

// /
// / Specifies where along the cross axis the CefBoxLayout child views should be
// / laid out.
// /
type CCrossAxisAlignmentT C.cef_cross_axis_alignment_t

const (

	///
	/// Child views will be stretched to fit.
	///
	CefCrossAxisAlignmentStretch CCrossAxisAlignmentT = C.CEF_CROSS_AXIS_ALIGNMENT_STRETCH

	///
	/// Child views will be left-aligned.
	///
	CefCrossAxisAlignmentStart CCrossAxisAlignmentT = C.CEF_CROSS_AXIS_ALIGNMENT_START

	///
	/// Child views will be center-aligned.
	///
	CefCrossAxisAlignmentCenter CCrossAxisAlignmentT = C.CEF_CROSS_AXIS_ALIGNMENT_CENTER

	///
	/// Child views will be right-aligned.
	///
	CefCrossAxisAlignmentEnd CCrossAxisAlignmentT = C.CEF_CROSS_AXIS_ALIGNMENT_END
)

// /
// / Settings used when initializing a CefBoxLayout.
// /
type CBoxLayoutSettingsT C.cef_box_layout_settings_t

func NewCBoxLayoutSettingsT() *CBoxLayoutSettingsT {
	s := &CBoxLayoutSettingsT{}
	return s
}

func (st *CBoxLayoutSettingsT) Horizontal() bool {
	return st.horizontal != 0
}

func (st *CBoxLayoutSettingsT) SetHorizontal(v bool) {
	if v {
		st.horizontal = 1
	} else {
		st.horizontal = 0
	}
}

func (st *CBoxLayoutSettingsT) InsideBorderHorizontalSpacing() int {
	return int(st.inside_border_horizontal_spacing)
}

func (st *CBoxLayoutSettingsT) SetInsideBorderHorizontalSpacing(v int) {
	st.inside_border_horizontal_spacing = (C.int)(v)
}

func (st *CBoxLayoutSettingsT) InsideBorderVerticalSpacing() int {
	return int(st.inside_border_vertical_spacing)
}

func (st *CBoxLayoutSettingsT) SetInsideBorderVerticalSpacing(v int) {
	st.inside_border_vertical_spacing = (C.int)(v)
}

func (st *CBoxLayoutSettingsT) InsideBorderInsets() CInsetsT {
	return CInsetsT(st.inside_border_insets)
}

func (st *CBoxLayoutSettingsT) SetInsideBorderInsets(v CInsetsT) {
	st.inside_border_insets = (C.cef_insets_t)(v)
}

func (st *CBoxLayoutSettingsT) BetweenChildSpacing() int {
	return int(st.between_child_spacing)
}

func (st *CBoxLayoutSettingsT) SetBetweenChildSpacing(v int) {
	st.between_child_spacing = (C.int)(v)
}

func (st *CBoxLayoutSettingsT) MainAxisAlignment() CMainAxisAlignmentT {
	return CMainAxisAlignmentT(st.main_axis_alignment)
}

func (st *CBoxLayoutSettingsT) SetMainAxisAlignment(v CMainAxisAlignmentT) {
	st.main_axis_alignment = (C.cef_main_axis_alignment_t)(v)
}

func (st *CBoxLayoutSettingsT) CrossAxisAlignment() CCrossAxisAlignmentT {
	return CCrossAxisAlignmentT(st.cross_axis_alignment)
}

func (st *CBoxLayoutSettingsT) SetCrossAxisAlignment(v CCrossAxisAlignmentT) {
	st.cross_axis_alignment = (C.cef_cross_axis_alignment_t)(v)
}

func (st *CBoxLayoutSettingsT) MinimumCrossAxisSize() int {
	return int(st.minimum_cross_axis_size)
}

func (st *CBoxLayoutSettingsT) SetMinimumCrossAxisSize(v int) {
	st.minimum_cross_axis_size = (C.int)(v)
}

func (st *CBoxLayoutSettingsT) DefaultFlex() int {
	return int(st.default_flex)
}

func (st *CBoxLayoutSettingsT) SetDefaultFlex(v int) {
	st.default_flex = (C.int)(v)
}

// /
// / Specifies the button display state.
// /
type CButtonStateT C.cef_button_state_t

const (
	CefButtonStateNormal   CButtonStateT = C.CEF_BUTTON_STATE_NORMAL
	CefButtonStateHovered  CButtonStateT = C.CEF_BUTTON_STATE_HOVERED
	CefButtonStatePressed  CButtonStateT = C.CEF_BUTTON_STATE_PRESSED
	CefButtonStateDisabled CButtonStateT = C.CEF_BUTTON_STATE_DISABLED
)

// /
// / Specifies the horizontal text alignment mode.
// /
type CHorizontalAlignmentT C.cef_horizontal_alignment_t

const (

	///
	/// Align the text's left edge with that of its display area.
	///
	CefHorizontalAlignmentLeft CHorizontalAlignmentT = C.CEF_HORIZONTAL_ALIGNMENT_LEFT

	///
	/// Align the text's center with that of its display area.
	///
	CefHorizontalAlignmentCenter CHorizontalAlignmentT = C.CEF_HORIZONTAL_ALIGNMENT_CENTER

	///
	/// Align the text's right edge with that of its display area.
	///
	CefHorizontalAlignmentRight CHorizontalAlignmentT = C.CEF_HORIZONTAL_ALIGNMENT_RIGHT
)

// /
// / Specifies how a menu will be anchored for non-RTL languages. The opposite
// / position will be used for RTL languages.
// /
type CMenuAnchorPositionT C.cef_menu_anchor_position_t

const (
	CefMenuAnchorTopleft      CMenuAnchorPositionT = C.CEF_MENU_ANCHOR_TOPLEFT
	CefMenuAnchorTopright     CMenuAnchorPositionT = C.CEF_MENU_ANCHOR_TOPRIGHT
	CefMenuAnchorBottomcenter CMenuAnchorPositionT = C.CEF_MENU_ANCHOR_BOTTOMCENTER
)

// /
// / Supported color types for menu items.
// /
type CMenuColorTypeT C.cef_menu_color_type_t

const (
	CefMenuColorText                   CMenuColorTypeT = C.CEF_MENU_COLOR_TEXT
	CefMenuColorTextHovered            CMenuColorTypeT = C.CEF_MENU_COLOR_TEXT_HOVERED
	CefMenuColorTextAccelerator        CMenuColorTypeT = C.CEF_MENU_COLOR_TEXT_ACCELERATOR
	CefMenuColorTextAcceleratorHovered CMenuColorTypeT = C.CEF_MENU_COLOR_TEXT_ACCELERATOR_HOVERED
	CefMenuColorBackground             CMenuColorTypeT = C.CEF_MENU_COLOR_BACKGROUND
	CefMenuColorBackgroundHovered      CMenuColorTypeT = C.CEF_MENU_COLOR_BACKGROUND_HOVERED
	CefMenuColorCount                  CMenuColorTypeT = C.CEF_MENU_COLOR_COUNT
)

// / Supported SSL version values. See net/ssl/ssl_connection_status_flags.h
// / for more information.
type CSslVersionT C.cef_ssl_version_t

const (
	SslConnectionVersionUnknown CSslVersionT = C.SSL_CONNECTION_VERSION_UNKNOWN
	SslConnectionVersionSsl2    CSslVersionT = C.SSL_CONNECTION_VERSION_SSL2
	SslConnectionVersionSsl3    CSslVersionT = C.SSL_CONNECTION_VERSION_SSL3
	SslConnectionVersionTls1    CSslVersionT = C.SSL_CONNECTION_VERSION_TLS1
	SslConnectionVersionTls11   CSslVersionT = C.SSL_CONNECTION_VERSION_TLS1_1
	SslConnectionVersionTls12   CSslVersionT = C.SSL_CONNECTION_VERSION_TLS1_2
	SslConnectionVersionTls13   CSslVersionT = C.SSL_CONNECTION_VERSION_TLS1_3
	SslConnectionVersionQuic    CSslVersionT = C.SSL_CONNECTION_VERSION_QUIC
)

// / Supported SSL content status flags. See content/public/common/ssl_status.h
// / for more information.
type CSslContentStatusT C.cef_ssl_content_status_t

const (
	SslContentNormalContent            CSslContentStatusT = C.SSL_CONTENT_NORMAL_CONTENT
	SslContentDisplayedInsecureContent CSslContentStatusT = C.SSL_CONTENT_DISPLAYED_INSECURE_CONTENT
	SslContentRanInsecureContent       CSslContentStatusT = C.SSL_CONTENT_RAN_INSECURE_CONTENT
)

// / Configuration options for registering a custom scheme.
// / These values are used when calling AddCustomScheme.
type CSchemeOptionsT C.cef_scheme_options_t

const (
	CefSchemeOptionNone CSchemeOptionsT = C.CEF_SCHEME_OPTION_NONE

	///
	/// If CEF_SCHEME_OPTION_STANDARD is set the scheme will be treated as a
	/// standard scheme. Standard schemes are subject to URL canonicalization and
	/// parsing rules as defined in the Common Internet Scheme Syntax RFC 1738
	/// Section 3.1 available at http://www.ietf.org/rfc/rfc1738.txt
	//
	/// In particular, the syntax for standard scheme URLs must be of the form:
	/// <pre>
	///  [scheme]://[username]:[password]@[host]:[port]/[url-path]
	/// </pre> Standard scheme URLs must have a host component that is a fully
	/// qualified domain name as defined in Section 3.5 of RFC 1034 [13] and
	/// Section 2.1 of RFC 1123. These URLs will be canonicalized to
	/// "scheme://host/path" in the simplest case and
	/// "scheme://username:password@host:port/path" in the most explicit case. For
	/// example, "scheme:host/path" and "scheme:///host/path" will both be
	/// canonicalized to "scheme://host/path". The origin of a standard scheme URL
	/// is the combination of scheme, host and port (i.e., "scheme://host:port" in
	/// the most explicit case).
	//
	/// For non-standard scheme URLs only the "scheme:" component is parsed and
	/// canonicalized. The remainder of the URL will be passed to the handler as-
	/// is. For example, "scheme:///some%20text" will remain the same.
	/// Non-standard scheme URLs cannot be used as a target for form submission.
	///
	CefSchemeOptionStandard CSchemeOptionsT = C.CEF_SCHEME_OPTION_STANDARD

	///
	/// If CEF_SCHEME_OPTION_LOCAL is set the scheme will be treated with the same
	/// security rules as those applied to "file" URLs. Normal pages cannot link
	/// to or access local URLs. Also, by default, local URLs can only perform
	/// XMLHttpRequest calls to the same URL (origin + path) that originated the
	/// request. To allow XMLHttpRequest calls from a local URL to other URLs with
	/// the same origin set the CefSettings.file_access_from_file_urls_allowed
	/// value to true (1). To allow XMLHttpRequest calls from a local URL to all
	/// origins set the CefSettings.universal_access_from_file_urls_allowed value
	/// to true (1).
	///
	CefSchemeOptionLocal CSchemeOptionsT = C.CEF_SCHEME_OPTION_LOCAL

	///
	/// If CEF_SCHEME_OPTION_DISPLAY_ISOLATED is set the scheme can only be
	/// displayed from other content hosted with the same scheme. For example,
	/// pages in other origins cannot create iframes or hyperlinks to URLs with
	/// the scheme. For schemes that must be accessible from other schemes don't
	/// set this, set CEF_SCHEME_OPTION_CORS_ENABLED, and use CORS
	/// "Access-Control-Allow-Origin" headers to further restrict access.
	///
	CefSchemeOptionDisplayIsolated CSchemeOptionsT = C.CEF_SCHEME_OPTION_DISPLAY_ISOLATED

	///
	/// If CEF_SCHEME_OPTION_SECURE is set the scheme will be treated with the
	/// same security rules as those applied to "https" URLs. For example, loading
	/// this scheme from other secure schemes will not trigger mixed content
	/// warnings.
	///
	CefSchemeOptionSecure CSchemeOptionsT = C.CEF_SCHEME_OPTION_SECURE

	///
	/// If CEF_SCHEME_OPTION_CORS_ENABLED is set the scheme can be sent CORS
	/// requests. This value should be set in most cases where
	/// CEF_SCHEME_OPTION_STANDARD is set.
	///
	CefSchemeOptionCorsEnabled CSchemeOptionsT = C.CEF_SCHEME_OPTION_CORS_ENABLED

	///
	/// If CEF_SCHEME_OPTION_CSP_BYPASSING is set the scheme can bypass Content-
	/// Security-Policy (CSP) checks. This value should not be set in most cases
	/// where CEF_SCHEME_OPTION_STANDARD is set.
	///
	CefSchemeOptionCspBypassing CSchemeOptionsT = C.CEF_SCHEME_OPTION_CSP_BYPASSING

	///
	/// If CEF_SCHEME_OPTION_FETCH_ENABLED is set the scheme can perform Fetch API
	/// requests.
	///
	CefSchemeOptionFetchEnabled CSchemeOptionsT = C.CEF_SCHEME_OPTION_FETCH_ENABLED
)

// /
// / Structure representing a range.
// /
type CRangeT C.cef_range_t

func NewCRangeT() *CRangeT {
	s := &CRangeT{}
	return s
}

func (st *CRangeT) From() uint32 {
	return uint32(st.from)
}

func (st *CRangeT) SetFrom(v uint32) {
	st.from = (C.uint32_t)(v)
}

func (st *CRangeT) To() uint32 {
	return uint32(st.to)
}

func (st *CRangeT) SetTo(v uint32) {
	st.to = (C.uint32_t)(v)
}

// /
// / Composition underline style.
// /
type CCompositionUnderlineStyleT C.cef_composition_underline_style_t

const (
	CefCusSolid CCompositionUnderlineStyleT = C.CEF_CUS_SOLID
	CefCusDot   CCompositionUnderlineStyleT = C.CEF_CUS_DOT
	CefCusDash  CCompositionUnderlineStyleT = C.CEF_CUS_DASH
	CefCusNone  CCompositionUnderlineStyleT = C.CEF_CUS_NONE
)

// /
// / Structure representing IME composition underline information. This is a thin
// / wrapper around Blink's WebCompositionUnderline class and should be kept in
// / sync with that.
// /
type CCompositionUnderlineT C.cef_composition_underline_t

func NewCCompositionUnderlineT() *CCompositionUnderlineT {
	s := &CCompositionUnderlineT{}
	return s
}

func (st *CCompositionUnderlineT) Range() CRangeT {
	return CRangeT(st._range)
}

func (st *CCompositionUnderlineT) SetRange(v CRangeT) {
	st._range = (C.cef_range_t)(v)
}

func (st *CCompositionUnderlineT) Color() CColorT {
	return CColorT(st.color)
}

func (st *CCompositionUnderlineT) SetColor(v CColorT) {
	st.color = (C.cef_color_t)(v)
}

func (st *CCompositionUnderlineT) BackgroundColor() CColorT {
	return CColorT(st.background_color)
}

func (st *CCompositionUnderlineT) SetBackgroundColor(v CColorT) {
	st.background_color = (C.cef_color_t)(v)
}

func (st *CCompositionUnderlineT) Thick() bool {
	return st.thick != 0
}

func (st *CCompositionUnderlineT) SetThick(v bool) {
	if v {
		st.thick = 1
	} else {
		st.thick = 0
	}
}

func (st *CCompositionUnderlineT) Style() CCompositionUnderlineStyleT {
	return CCompositionUnderlineStyleT(st.style)
}

func (st *CCompositionUnderlineT) SetStyle(v CCompositionUnderlineStyleT) {
	st.style = (C.cef_composition_underline_style_t)(v)
}

// /
// / Enumerates the various representations of the ordering of audio channels.
// / Must be kept synchronized with media::ChannelLayout from Chromium.
// / See media\base\channel_layout.h
// /
type CChannelLayoutT C.cef_channel_layout_t

const (
	CefChannelLayoutNone        CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_NONE
	CefChannelLayoutUnsupported CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_UNSUPPORTED

	/// Front C
	CefChannelLayoutMono CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_MONO

	/// Front L, Front R
	CefChannelLayoutStereo CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_STEREO

	/// Front L, Front R, Back C
	CefChannelLayout21 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_2_1

	/// Front L, Front R, Front C
	CefChannelLayoutSurround CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_SURROUND

	/// Front L, Front R, Front C, Back C
	CefChannelLayout40 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_4_0

	/// Front L, Front R, Side L, Side R
	CefChannelLayout22 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_2_2

	/// Front L, Front R, Back L, Back R
	CefChannelLayoutQuad CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_QUAD

	/// Front L, Front R, Front C, Side L, Side R
	CefChannelLayout50 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_5_0

	/// Front L, Front R, Front C, LFE, Side L, Side R
	CefChannelLayout51 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_5_1

	/// Front L, Front R, Front C, Back L, Back R
	CefChannelLayout50Back CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_5_0_BACK

	/// Front L, Front R, Front C, LFE, Back L, Back R
	CefChannelLayout51Back CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_5_1_BACK

	/// Front L, Front R, Front C, Side L, Side R, Back L, Back R
	CefChannelLayout70 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_7_0

	/// Front L, Front R, Front C, LFE, Side L, Side R, Back L, Back R
	CefChannelLayout71 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_7_1

	/// Front L, Front R, Front C, LFE, Side L, Side R, Front LofC, Front RofC
	CefChannelLayout71Wide CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_7_1_WIDE

	/// Stereo L, Stereo R
	CefChannelLayoutStereoDownmix CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_STEREO_DOWNMIX

	/// Stereo L, Stereo R, LFE
	CefChannelLayout2point1 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_2POINT1

	/// Stereo L, Stereo R, Front C, LFE
	CefChannelLayout31 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_3_1

	/// Stereo L, Stereo R, Front C, Rear C, LFE
	CefChannelLayout41 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_4_1

	/// Stereo L, Stereo R, Front C, Side L, Side R, Back C
	CefChannelLayout60 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_6_0

	/// Stereo L, Stereo R, Side L, Side R, Front LofC, Front RofC
	CefChannelLayout60Front CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_6_0_FRONT

	/// Stereo L, Stereo R, Front C, Rear L, Rear R, Rear C
	CefChannelLayoutHexagonal CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_HEXAGONAL

	/// Stereo L, Stereo R, Front C, LFE, Side L, Side R, Rear Center
	CefChannelLayout61 CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_6_1

	/// Stereo L, Stereo R, Front C, LFE, Back L, Back R, Rear Center
	CefChannelLayout61Back CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_6_1_BACK

	/// Stereo L, Stereo R, Side L, Side R, Front LofC, Front RofC, LFE
	CefChannelLayout61Front CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_6_1_FRONT

	/// Front L, Front R, Front C, Side L, Side R, Front LofC, Front RofC
	CefChannelLayout70Front CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_7_0_FRONT

	/// Front L, Front R, Front C, LFE, Back L, Back R, Front LofC, Front RofC
	CefChannelLayout71WideBack CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_7_1_WIDE_BACK

	/// Front L, Front R, Front C, Side L, Side R, Rear L, Back R, Back C.
	CefChannelLayoutOctagonal CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_OCTAGONAL

	/// Channels are not explicitly mapped to speakers.
	CefChannelLayoutDiscrete CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_DISCRETE

	/// Front L, Front R, Front C. Front C contains the keyboard mic audio. This
	/// layout is only intended for input for WebRTC. The Front C channel
	/// is stripped away in the WebRTC audio input pipeline and never seen outside
	/// of that.
	CefChannelLayoutStereoAndKeyboardMic CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC

	/// Front L, Front R, Side L, Side R, LFE
	CefChannelLayout41QuadSide CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_4_1_QUAD_SIDE

	/// Actual channel layout is specified in the bitstream and the actual channel
	/// count is unknown at Chromium media pipeline level (useful for audio
	/// pass-through mode).
	CefChannelLayoutBitstream CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_BITSTREAM

	/// Front L, Front R, Front C, LFE, Side L, Side R,
	/// Front Height L, Front Height R, Rear Height L, Rear Height R
	/// Will be represented as six channels (5.1) due to eight channel limit
	/// kMaxConcurrentChannels
	CefChannelLayout514Downmix CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_5_1_4_DOWNMIX

	/// Max value, must always equal the largest entry ever logged.
	CefChannelLayoutMax CChannelLayoutT = C.CEF_CHANNEL_LAYOUT_MAX
)

// /
// / Structure representing the audio parameters for setting up the audio
// / handler.
// /
type CAudioParametersT C.cef_audio_parameters_t

func NewCAudioParametersT() *CAudioParametersT {
	s := &CAudioParametersT{}
	return s
}

func (st *CAudioParametersT) ChannelLayout() CChannelLayoutT {
	return CChannelLayoutT(st.channel_layout)
}

func (st *CAudioParametersT) SetChannelLayout(v CChannelLayoutT) {
	st.channel_layout = (C.cef_channel_layout_t)(v)
}

func (st *CAudioParametersT) SampleRate() int {
	return int(st.sample_rate)
}

func (st *CAudioParametersT) SetSampleRate(v int) {
	st.sample_rate = (C.int)(v)
}

func (st *CAudioParametersT) FramesPerBuffer() int {
	return int(st.frames_per_buffer)
}

func (st *CAudioParametersT) SetFramesPerBuffer(v int) {
	st.frames_per_buffer = (C.int)(v)
}

// /
// / Result codes for CefMediaRouter::CreateRoute. Should be kept in sync with
// / Chromium's media_router::mojom::RouteRequestResultCode type.
// /
type CMediaRouteCreateResultT C.cef_media_route_create_result_t

const (
	CefMrcrUnknownError           CMediaRouteCreateResultT = C.CEF_MRCR_UNKNOWN_ERROR
	CefMrcrOk                     CMediaRouteCreateResultT = C.CEF_MRCR_OK
	CefMrcrTimedOut               CMediaRouteCreateResultT = C.CEF_MRCR_TIMED_OUT
	CefMrcrRouteNotFound          CMediaRouteCreateResultT = C.CEF_MRCR_ROUTE_NOT_FOUND
	CefMrcrSinkNotFound           CMediaRouteCreateResultT = C.CEF_MRCR_SINK_NOT_FOUND
	CefMrcrInvalidOrigin          CMediaRouteCreateResultT = C.CEF_MRCR_INVALID_ORIGIN
	CefMrcrNoSupportedProvider    CMediaRouteCreateResultT = C.CEF_MRCR_NO_SUPPORTED_PROVIDER
	CefMrcrCancelled              CMediaRouteCreateResultT = C.CEF_MRCR_CANCELLED
	CefMrcrRouteAlreadyExists     CMediaRouteCreateResultT = C.CEF_MRCR_ROUTE_ALREADY_EXISTS
	CefMrcrRouteAlreadyTerminated CMediaRouteCreateResultT = C.CEF_MRCR_ROUTE_ALREADY_TERMINATED
)

// /
// / Connection state for a MediaRoute object.
// /
type CMediaRouteConnectionStateT C.cef_media_route_connection_state_t

const (
	CefMrcsUnknown    CMediaRouteConnectionStateT = C.CEF_MRCS_UNKNOWN
	CefMrcsConnecting CMediaRouteConnectionStateT = C.CEF_MRCS_CONNECTING
	CefMrcsConnected  CMediaRouteConnectionStateT = C.CEF_MRCS_CONNECTED
	CefMrcsClosed     CMediaRouteConnectionStateT = C.CEF_MRCS_CLOSED
	CefMrcsTerminated CMediaRouteConnectionStateT = C.CEF_MRCS_TERMINATED
)

// /
// / Icon types for a MediaSink object. Should be kept in sync with Chromium's
// / media_router::SinkIconType type.
// /
type CMediaSinkIconTypeT C.cef_media_sink_icon_type_t

const (
	CefMsitCast           CMediaSinkIconTypeT = C.CEF_MSIT_CAST
	CefMsitCastAudioGroup CMediaSinkIconTypeT = C.CEF_MSIT_CAST_AUDIO_GROUP
	CefMsitCastAudio      CMediaSinkIconTypeT = C.CEF_MSIT_CAST_AUDIO
	CefMsitMeeting        CMediaSinkIconTypeT = C.CEF_MSIT_MEETING
	CefMsitHangout        CMediaSinkIconTypeT = C.CEF_MSIT_HANGOUT
	CefMsitEducation      CMediaSinkIconTypeT = C.CEF_MSIT_EDUCATION
	CefMsitWiredDisplay   CMediaSinkIconTypeT = C.CEF_MSIT_WIRED_DISPLAY
	CefMsitGeneric        CMediaSinkIconTypeT = C.CEF_MSIT_GENERIC
	CefMsitTotalCount     CMediaSinkIconTypeT = C.CEF_MSIT_TOTAL_COUNT
)

// /
// / Device information for a MediaSink object.
// /
type CMediaSinkDeviceInfoT C.cef_media_sink_device_info_t

func NewCMediaSinkDeviceInfoT() *CMediaSinkDeviceInfoT {
	s := &CMediaSinkDeviceInfoT{}
	return s
}

func (st *CMediaSinkDeviceInfoT) IpAddress() string {
	return string_from_cef_string(&st.ip_address)
}

func (st *CMediaSinkDeviceInfoT) SetIpAddress(v string) {
	set_cef_string(&st.ip_address, v)
}

func (st *CMediaSinkDeviceInfoT) Port() int {
	return int(st.port)
}

func (st *CMediaSinkDeviceInfoT) SetPort(v int) {
	st.port = (C.int)(v)
}

func (st *CMediaSinkDeviceInfoT) ModelName() string {
	return string_from_cef_string(&st.model_name)
}

func (st *CMediaSinkDeviceInfoT) SetModelName(v string) {
	set_cef_string(&st.model_name, v)
}

// /
// / Represents commands available to TextField.
// /
type CTextFieldCommandsT C.cef_text_field_commands_t

const (
	CefTfcCut       CTextFieldCommandsT = C.CEF_TFC_CUT
	CefTfcCopy      CTextFieldCommandsT = C.CEF_TFC_COPY
	CefTfcPaste     CTextFieldCommandsT = C.CEF_TFC_PASTE
	CefTfcUndo      CTextFieldCommandsT = C.CEF_TFC_UNDO
	CefTfcDelete    CTextFieldCommandsT = C.CEF_TFC_DELETE
	CefTfcSelectAll CTextFieldCommandsT = C.CEF_TFC_SELECT_ALL
)

// /
// / Chrome toolbar types.
// /
type CChromeToolbarTypeT C.cef_chrome_toolbar_type_t

const (
	CefCttNone     CChromeToolbarTypeT = C.CEF_CTT_NONE
	CefCttNormal   CChromeToolbarTypeT = C.CEF_CTT_NORMAL
	CefCttLocation CChromeToolbarTypeT = C.CEF_CTT_LOCATION
)

// /
// / Chrome page action icon types. Should be kept in sync with Chromium's
// / PageActionIconType type.
// /
type CChromePageActionIconTypeT C.cef_chrome_page_action_icon_type_t

const (
	CefCpaitBookmarkStar              CChromePageActionIconTypeT = C.CEF_CPAIT_BOOKMARK_STAR
	CefCpaitClickToCall               CChromePageActionIconTypeT = C.CEF_CPAIT_CLICK_TO_CALL
	CefCpaitCookieControls            CChromePageActionIconTypeT = C.CEF_CPAIT_COOKIE_CONTROLS
	CefCpaitFileSystemAccess          CChromePageActionIconTypeT = C.CEF_CPAIT_FILE_SYSTEM_ACCESS
	CefCpaitFind                      CChromePageActionIconTypeT = C.CEF_CPAIT_FIND
	CefCpaitHighEfficiency            CChromePageActionIconTypeT = C.CEF_CPAIT_HIGH_EFFICIENCY
	CefCpaitIntentPicker              CChromePageActionIconTypeT = C.CEF_CPAIT_INTENT_PICKER
	CefCpaitLocalCardMigration        CChromePageActionIconTypeT = C.CEF_CPAIT_LOCAL_CARD_MIGRATION
	CefCpaitManagePasswords           CChromePageActionIconTypeT = C.CEF_CPAIT_MANAGE_PASSWORDS
	CefCpaitPaymentsOfferNotification CChromePageActionIconTypeT = C.CEF_CPAIT_PAYMENTS_OFFER_NOTIFICATION
	CefCpaitPriceTracking             CChromePageActionIconTypeT = C.CEF_CPAIT_PRICE_TRACKING
	CefCpaitPwaInstall                CChromePageActionIconTypeT = C.CEF_CPAIT_PWA_INSTALL
	CefCpaitQrCodeGenerator           CChromePageActionIconTypeT = C.CEF_CPAIT_QR_CODE_GENERATOR
	CefCpaitReaderMode                CChromePageActionIconTypeT = C.CEF_CPAIT_READER_MODE
	CefCpaitSaveAutofillAddress       CChromePageActionIconTypeT = C.CEF_CPAIT_SAVE_AUTOFILL_ADDRESS
	CefCpaitSaveCard                  CChromePageActionIconTypeT = C.CEF_CPAIT_SAVE_CARD
	CefCpaitSendTabToSelf             CChromePageActionIconTypeT = C.CEF_CPAIT_SEND_TAB_TO_SELF
	CefCpaitSharingHub                CChromePageActionIconTypeT = C.CEF_CPAIT_SHARING_HUB
	CefCpaitSideSearch                CChromePageActionIconTypeT = C.CEF_CPAIT_SIDE_SEARCH
	CefCpaitSmsRemoteFetcher          CChromePageActionIconTypeT = C.CEF_CPAIT_SMS_REMOTE_FETCHER
	CefCpaitTranslate                 CChromePageActionIconTypeT = C.CEF_CPAIT_TRANSLATE
	CefCpaitVirtualCardEnroll         CChromePageActionIconTypeT = C.CEF_CPAIT_VIRTUAL_CARD_ENROLL
	CefCpaitVirtualCardManualFallback CChromePageActionIconTypeT = C.CEF_CPAIT_VIRTUAL_CARD_MANUAL_FALLBACK
	CefCpaitZoom                      CChromePageActionIconTypeT = C.CEF_CPAIT_ZOOM
	CefCpaitSaveIban                  CChromePageActionIconTypeT = C.CEF_CPAIT_SAVE_IBAN
	CefCpaitMandatoryReauth           CChromePageActionIconTypeT = C.CEF_CPAIT_MANDATORY_REAUTH
	CefCpaitMaxValue                  CChromePageActionIconTypeT = C.CEF_CPAIT_MAX_VALUE
)

// /
// / Chrome toolbar button types. Should be kept in sync with CEF's internal
// / ToolbarButtonType type.
// /
type CChromeToolbarButtonTypeT C.cef_chrome_toolbar_button_type_t

const (
	CefCtbtCast          CChromeToolbarButtonTypeT = C.CEF_CTBT_CAST
	CefCtbtDownload      CChromeToolbarButtonTypeT = C.CEF_CTBT_DOWNLOAD
	CefCtbtSendTabToSelf CChromeToolbarButtonTypeT = C.CEF_CTBT_SEND_TAB_TO_SELF
	CefCtbtSidePanel     CChromeToolbarButtonTypeT = C.CEF_CTBT_SIDE_PANEL
	CefCtbtMaxValue      CChromeToolbarButtonTypeT = C.CEF_CTBT_MAX_VALUE
)

// /
// / Docking modes supported by CefWindow::AddOverlay.
// /
type CDockingModeT C.cef_docking_mode_t

const (
	CefDockingModeTopLeft     CDockingModeT = C.CEF_DOCKING_MODE_TOP_LEFT
	CefDockingModeTopRight    CDockingModeT = C.CEF_DOCKING_MODE_TOP_RIGHT
	CefDockingModeBottomLeft  CDockingModeT = C.CEF_DOCKING_MODE_BOTTOM_LEFT
	CefDockingModeBottomRight CDockingModeT = C.CEF_DOCKING_MODE_BOTTOM_RIGHT
	CefDockingModeCustom      CDockingModeT = C.CEF_DOCKING_MODE_CUSTOM
)

// /
// / Show states supported by CefWindowDelegate::GetInitialShowState.
// /
type CShowStateT C.cef_show_state_t

const (
	CefShowStateNormal     CShowStateT = C.CEF_SHOW_STATE_NORMAL
	CefShowStateMinimized  CShowStateT = C.CEF_SHOW_STATE_MINIMIZED
	CefShowStateMaximized  CShowStateT = C.CEF_SHOW_STATE_MAXIMIZED
	CefShowStateFullscreen CShowStateT = C.CEF_SHOW_STATE_FULLSCREEN
)

// /
// / Values indicating what state of the touch handle is set.
// /
type CTouchHandleStateFlagsT C.cef_touch_handle_state_flags_t

const (
	CefThsFlagNone        CTouchHandleStateFlagsT = C.CEF_THS_FLAG_NONE
	CefThsFlagEnabled     CTouchHandleStateFlagsT = C.CEF_THS_FLAG_ENABLED
	CefThsFlagOrientation CTouchHandleStateFlagsT = C.CEF_THS_FLAG_ORIENTATION
	CefThsFlagOrigin      CTouchHandleStateFlagsT = C.CEF_THS_FLAG_ORIGIN
	CefThsFlagAlpha       CTouchHandleStateFlagsT = C.CEF_THS_FLAG_ALPHA
)

type CTouchHandleStateT C.cef_touch_handle_state_t

func NewCTouchHandleStateT() *CTouchHandleStateT {
	s := &CTouchHandleStateT{}
	return s
}

func (st *CTouchHandleStateT) TouchHandleId() int {
	return int(st.touch_handle_id)
}

func (st *CTouchHandleStateT) SetTouchHandleId(v int) {
	st.touch_handle_id = (C.int)(v)
}

func (st *CTouchHandleStateT) Flags() uint32 {
	return uint32(st.flags)
}

func (st *CTouchHandleStateT) SetFlags(v uint32) {
	st.flags = (C.uint32_t)(v)
}

func (st *CTouchHandleStateT) Enabled() int {
	return int(st.enabled)
}

func (st *CTouchHandleStateT) SetEnabled(v int) {
	st.enabled = (C.int)(v)
}

func (st *CTouchHandleStateT) Orientation() CHorizontalAlignmentT {
	return CHorizontalAlignmentT(st.orientation)
}

func (st *CTouchHandleStateT) SetOrientation(v CHorizontalAlignmentT) {
	st.orientation = (C.cef_horizontal_alignment_t)(v)
}

func (st *CTouchHandleStateT) MirrorVertical() int {
	return int(st.mirror_vertical)
}

func (st *CTouchHandleStateT) SetMirrorVertical(v int) {
	st.mirror_vertical = (C.int)(v)
}

func (st *CTouchHandleStateT) MirrorHorizontal() int {
	return int(st.mirror_horizontal)
}

func (st *CTouchHandleStateT) SetMirrorHorizontal(v int) {
	st.mirror_horizontal = (C.int)(v)
}

func (st *CTouchHandleStateT) Origin() CPointT {
	return CPointT(st.origin)
}

func (st *CTouchHandleStateT) SetOrigin(v CPointT) {
	st.origin = (C.cef_point_t)(v)
}

func (st *CTouchHandleStateT) Alpha() float32 {
	return float32(st.alpha)
}

func (st *CTouchHandleStateT) SetAlpha(v float32) {
	st.alpha = (C.float)(v)
}

// /
// / Media access permissions used by OnRequestMediaAccessPermission.
// /
type CMediaAccessPermissionTypesT C.cef_media_access_permission_types_t

const (

	///
	/// No permission.
	///
	CefMediaPermissionNone CMediaAccessPermissionTypesT = C.CEF_MEDIA_PERMISSION_NONE

	///
	/// Device audio capture permission.
	///
	CefMediaPermissionDeviceAudioCapture CMediaAccessPermissionTypesT = C.CEF_MEDIA_PERMISSION_DEVICE_AUDIO_CAPTURE

	///
	/// Device video capture permission.
	///
	CefMediaPermissionDeviceVideoCapture CMediaAccessPermissionTypesT = C.CEF_MEDIA_PERMISSION_DEVICE_VIDEO_CAPTURE

	///
	/// Desktop audio capture permission.
	///
	CefMediaPermissionDesktopAudioCapture CMediaAccessPermissionTypesT = C.CEF_MEDIA_PERMISSION_DESKTOP_AUDIO_CAPTURE

	///
	/// Desktop video capture permission.
	///
	CefMediaPermissionDesktopVideoCapture CMediaAccessPermissionTypesT = C.CEF_MEDIA_PERMISSION_DESKTOP_VIDEO_CAPTURE
)

// /
// / Permission types used with OnShowPermissionPrompt. Some types are
// / platform-specific or only supported with the Chrome runtime. Should be kept
// / in sync with Chromium's permissions::RequestType type.
// /
type CPermissionRequestTypesT C.cef_permission_request_types_t

const (
	CefPermissionTypeNone                     CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_NONE
	CefPermissionTypeAccessibilityEvents      CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_ACCESSIBILITY_EVENTS
	CefPermissionTypeArSession                CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_AR_SESSION
	CefPermissionTypeCameraPanTiltZoom        CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_CAMERA_PAN_TILT_ZOOM
	CefPermissionTypeCameraStream             CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_CAMERA_STREAM
	CefPermissionTypeClipboard                CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_CLIPBOARD
	CefPermissionTypeTopLevelStorageAccess    CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_TOP_LEVEL_STORAGE_ACCESS
	CefPermissionTypeDiskQuota                CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_DISK_QUOTA
	CefPermissionTypeLocalFonts               CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_LOCAL_FONTS
	CefPermissionTypeGeolocation              CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_GEOLOCATION
	CefPermissionTypeIdleDetection            CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_IDLE_DETECTION
	CefPermissionTypeMicStream                CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_MIC_STREAM
	CefPermissionTypeMidiSysex                CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_MIDI_SYSEX
	CefPermissionTypeMultipleDownloads        CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_MULTIPLE_DOWNLOADS
	CefPermissionTypeNotifications            CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_NOTIFICATIONS
	CefPermissionTypeProtectedMediaIdentifier CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_PROTECTED_MEDIA_IDENTIFIER
	CefPermissionTypeRegisterProtocolHandler  CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_REGISTER_PROTOCOL_HANDLER
	CefPermissionTypeSecurityAttestation      CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_SECURITY_ATTESTATION
	CefPermissionTypeStorageAccess            CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_STORAGE_ACCESS
	CefPermissionTypeU2fApiRequest            CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_U2F_API_REQUEST
	CefPermissionTypeVrSession                CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_VR_SESSION
	CefPermissionTypeWindowManagement         CPermissionRequestTypesT = C.CEF_PERMISSION_TYPE_WINDOW_MANAGEMENT
)

// /
// / Permission request results.
// /
type CPermissionRequestResultT C.cef_permission_request_result_t

const (

	///
	/// Accept the permission request as an explicit user action.
	///
	CefPermissionResultAccept CPermissionRequestResultT = C.CEF_PERMISSION_RESULT_ACCEPT

	///
	/// Deny the permission request as an explicit user action.
	///
	CefPermissionResultDeny CPermissionRequestResultT = C.CEF_PERMISSION_RESULT_DENY

	///
	/// Dismiss the permission request as an explicit user action.
	///
	CefPermissionResultDismiss CPermissionRequestResultT = C.CEF_PERMISSION_RESULT_DISMISS

	///
	/// Ignore the permission request. If the prompt remains unhandled (e.g.
	/// OnShowPermissionPrompt returns false and there is no default permissions
	/// UI) then any related promises may remain unresolved.
	///
	CefPermissionResultIgnore CPermissionRequestResultT = C.CEF_PERMISSION_RESULT_IGNORE
)

// /
// / Certificate types supported by CefTestServer::CreateAndStart. The matching
// / certificate file must exist in the "net/data/ssl/certificates" directory.
// / See CefSetDataDirectoryForTests() for related configuration.
// /
type CTestCertTypeT C.cef_test_cert_type_t

const (

	/// Valid certificate using the IP (127.0.0.1). Loads the "ok_cert.pem" file.
	CefTestCertOkIp CTestCertTypeT = C.CEF_TEST_CERT_OK_IP

	/// Valid certificate using the domain ("localhost"). Loads the
	/// "localhost_cert.pem" file.
	CefTestCertOkDomain CTestCertTypeT = C.CEF_TEST_CERT_OK_DOMAIN

	/// Expired certificate. Loads the "expired_cert.pem" file.
	CefTestCertExpired CTestCertTypeT = C.CEF_TEST_CERT_EXPIRED
)

// /
// / Preferences type passed to
// / CefBrowserProcessHandler::OnRegisterCustomPreferences.
// /
type CPreferencesTypeT C.cef_preferences_type_t

const (

	/// Global preferences registered a single time at application startup.
	CefPreferencesTypeGlobal CPreferencesTypeT = C.CEF_PREFERENCES_TYPE_GLOBAL

	/// Request context preferences registered each time a new CefRequestContext
	/// is created.
	CefPreferencesTypeRequestContext CPreferencesTypeT = C.CEF_PREFERENCES_TYPE_REQUEST_CONTEXT
)

// /
// / Download interrupt reasons. Should be kept in sync with
// / Chromium's download::DownloadInterruptReason type.
// /
type CDownloadInterruptReasonT C.cef_download_interrupt_reason_t

const (
	CefDownloadInterruptReasonNone CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_NONE

	/// Generic file operation failure.
	CefDownloadInterruptReasonFileFailed CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_FAILED

	/// The file cannot be accessed due to security restrictions.
	CefDownloadInterruptReasonFileAccessDenied CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_ACCESS_DENIED

	/// There is not enough room on the drive.
	CefDownloadInterruptReasonFileNoSpace CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NO_SPACE

	/// The directory or file name is too long.
	CefDownloadInterruptReasonFileNameTooLong CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_NAME_TOO_LONG

	/// The file is too large for the file system to handle.
	CefDownloadInterruptReasonFileTooLarge CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_LARGE

	/// The file contains a virus.
	CefDownloadInterruptReasonFileVirusInfected CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_VIRUS_INFECTED

	/// The file was in use. Too many files are opened at once. We have run out of
	/// memory.
	CefDownloadInterruptReasonFileTransientError CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TRANSIENT_ERROR

	/// The file was blocked due to local policy.
	CefDownloadInterruptReasonFileBlocked CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_BLOCKED

	/// An attempt to check the safety of the download failed due to unexpected
	/// reasons. See http://crbug.com/153212.
	CefDownloadInterruptReasonFileSecurityCheckFailed CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SECURITY_CHECK_FAILED

	/// An attempt was made to seek past the end of a file in opening
	/// a file (as part of resuming a previously interrupted download).
	CefDownloadInterruptReasonFileTooShort CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_TOO_SHORT

	/// The partial file didn't match the expected hash.
	CefDownloadInterruptReasonFileHashMismatch CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_HASH_MISMATCH

	/// The source and the target of the download were the same.
	CefDownloadInterruptReasonFileSameAsSource CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_FILE_SAME_AS_SOURCE

	/// Generic network failure.
	CefDownloadInterruptReasonNetworkFailed CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_FAILED

	/// The network operation timed out.
	CefDownloadInterruptReasonNetworkTimeout CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_TIMEOUT

	/// The network connection has been lost.
	CefDownloadInterruptReasonNetworkDisconnected CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_DISCONNECTED

	/// The server has gone down.
	CefDownloadInterruptReasonNetworkServerDown CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_SERVER_DOWN

	/// The network request was invalid. This may be due to the original URL or a
	/// redirected URL:
	/// - Having an unsupported scheme.
	/// - Being an invalid URL.
	/// - Being disallowed by policy.
	CefDownloadInterruptReasonNetworkInvalidRequest CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST

	/// The server indicates that the operation has failed (generic).
	CefDownloadInterruptReasonServerFailed CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FAILED

	/// The server does not support range requests.
	/// Internal use only:  must restart from the beginning.
	CefDownloadInterruptReasonServerNoRange CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_NO_RANGE

	/// The server does not have the requested data.
	CefDownloadInterruptReasonServerBadContent CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_BAD_CONTENT

	/// Server didn't authorize access to resource.
	CefDownloadInterruptReasonServerUnauthorized CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNAUTHORIZED

	/// Server certificate problem.
	CefDownloadInterruptReasonServerCertProblem CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CERT_PROBLEM

	/// Server access forbidden.
	CefDownloadInterruptReasonServerForbidden CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_FORBIDDEN

	/// Unexpected server response. This might indicate that the responding server
	/// may not be the intended server.
	CefDownloadInterruptReasonServerUnreachable CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_UNREACHABLE

	/// The server sent fewer bytes than the content-length header. It may
	/// indicate that the connection was closed prematurely, or the Content-Length
	/// header was invalid. The download is only interrupted if strong validators
	/// are present. Otherwise, it is treated as finished.
	CefDownloadInterruptReasonServerContentLengthMismatch CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CONTENT_LENGTH_MISMATCH

	/// An unexpected cross-origin redirect happened.
	CefDownloadInterruptReasonServerCrossOriginRedirect CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_SERVER_CROSS_ORIGIN_REDIRECT

	/// The user canceled the download.
	CefDownloadInterruptReasonUserCanceled CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_USER_CANCELED

	/// The user shut down the browser.
	/// Internal use only:  resume pending downloads if possible.
	CefDownloadInterruptReasonUserShutdown CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN

	/// The browser crashed.
	/// Internal use only:  resume pending downloads if possible.
	CefDownloadInterruptReasonCrash CDownloadInterruptReasonT = C.CEF_DOWNLOAD_INTERRUPT_REASON_CRASH
)

// /
// / Specifies the gesture commands.
// /
type CGestureCommandT C.cef_gesture_command_t

const (
	CefGestureCommandBack    CGestureCommandT = C.CEF_GESTURE_COMMAND_BACK
	CefGestureCommandForward CGestureCommandT = C.CEF_GESTURE_COMMAND_FORWARD
)

// cef_types_content_settings.h, include/internal/cef_types_content_settings.h:347:3,

// /
// / Supported content setting types. Some types are platform-specific or only
// / supported with the Chrome runtime. Should be kept in sync with Chromium's
// / ContentSettingsType type.
// /
type CContentSettingTypesT C.cef_content_setting_types_t

const (
	CefContentSettingTypeCookies    CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_COOKIES
	CefContentSettingTypeImages     CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_IMAGES
	CefContentSettingTypeJavascript CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_JAVASCRIPT

	/// This setting governs both popups and unwanted redirects like tab-unders
	/// and framebusting.
	CefContentSettingTypePopups                    CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_POPUPS
	CefContentSettingTypeGeolocation               CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_GEOLOCATION
	CefContentSettingTypeNotifications             CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_NOTIFICATIONS
	CefContentSettingTypeAutoSelectCertificate     CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_AUTO_SELECT_CERTIFICATE
	CefContentSettingTypeMixedscript               CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_MIXEDSCRIPT
	CefContentSettingTypeMediastreamMic            CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_MIC
	CefContentSettingTypeMediastreamCamera         CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_MEDIASTREAM_CAMERA
	CefContentSettingTypeProtocolHandlers          CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PROTOCOL_HANDLERS
	CefContentSettingTypeDeprecatedPpapiBroker     CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_DEPRECATED_PPAPI_BROKER
	CefContentSettingTypeAutomaticDownloads        CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_AUTOMATIC_DOWNLOADS
	CefContentSettingTypeMidiSysex                 CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_MIDI_SYSEX
	CefContentSettingTypeSslCertDecisions          CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_SSL_CERT_DECISIONS
	CefContentSettingTypeProtectedMediaIdentifier  CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PROTECTED_MEDIA_IDENTIFIER
	CefContentSettingTypeAppBanner                 CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_APP_BANNER
	CefContentSettingTypeSiteEngagement            CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_SITE_ENGAGEMENT
	CefContentSettingTypeDurableStorage            CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_DURABLE_STORAGE
	CefContentSettingTypeUsbChooserData            CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_USB_CHOOSER_DATA
	CefContentSettingTypeBluetoothGuard            CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_BLUETOOTH_GUARD
	CefContentSettingTypeBackgroundSync            CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_BACKGROUND_SYNC
	CefContentSettingTypeAutoplay                  CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_AUTOPLAY
	CefContentSettingTypeImportantSiteInfo         CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_IMPORTANT_SITE_INFO
	CefContentSettingTypePermissionAutoblockerData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOBLOCKER_DATA
	CefContentSettingTypeAds                       CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_ADS

	/// Website setting which stores metadata for the subresource filter to aid in
	/// decisions for whether or not to show the UI.
	CefContentSettingTypeAdsData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_ADS_DATA

	/// This is special-cased in the permissions layer to always allow, and as
	/// such doesn't have associated prefs data.
	CefContentSettingTypeMidi CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_MIDI

	/// This content setting type is for caching password protection service's
	/// verdicts of each origin.
	CefContentSettingTypePasswordProtection CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PASSWORD_PROTECTION

	/// Website setting which stores engagement data for media related to a
	/// specific origin.
	CefContentSettingTypeMediaEngagement CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_MEDIA_ENGAGEMENT

	/// Content setting which stores whether or not the site can play audible
	/// sound. This will not block playback but instead the user will not hear it.
	CefContentSettingTypeSound CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_SOUND

	/// Website setting which stores the list of client hints that the origin
	/// requested the browser to remember. The browser is expected to send all
	/// client hints in the HTTP request headers for every resource requested
	/// from that origin.
	CefContentSettingTypeClientHints CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_CLIENT_HINTS

	/// Generic Sensor API covering ambient-light-sensor, accelerometer, gyroscope
	/// and magnetometer are all mapped to a single content_settings_type.
	/// Setting for the Generic Sensor API covering ambient-light-sensor,
	/// accelerometer, gyroscope and magnetometer. These are all mapped to a
	/// single ContentSettingsType.
	CefContentSettingTypeSensors CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_SENSORS

	/// Content setting which stores whether or not the user has granted the site
	/// permission to respond to accessibility events, which can be used to
	/// provide a custom accessibility experience. Requires explicit user consent
	/// because some users may not want sites to know they're using assistive
	/// technology.
	CefContentSettingTypeAccessibilityEvents CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_ACCESSIBILITY_EVENTS

	/// Used to store whether to allow a website to install a payment handler.
	CefContentSettingTypePaymentHandler CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PAYMENT_HANDLER

	/// Content setting which stores whether to allow sites to ask for permission
	/// to access USB devices. If this is allowed specific device permissions are
	/// stored under USB_CHOOSER_DATA.
	CefContentSettingTypeUsbGuard CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_USB_GUARD

	/// Nothing is stored in this setting at present. Please refer to
	/// BackgroundFetchPermissionContext for details on how this permission
	/// is ascertained.
	CefContentSettingTypeBackgroundFetch CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_BACKGROUND_FETCH

	/// Website setting which stores the amount of times the user has dismissed
	/// intent picker UI without explicitly choosing an option.
	CefContentSettingTypeIntentPickerDisplay CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_INTENT_PICKER_DISPLAY

	/// Used to store whether to allow a website to detect user active/idle state.
	CefContentSettingTypeIdleDetection CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_IDLE_DETECTION

	/// Setting for enabling auto-select of all screens for getDisplayMediaSet.
	CefContentSettingTypeGetDisplayMediaSetSelectAllScreens CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_GET_DISPLAY_MEDIA_SET_SELECT_ALL_SCREENS

	/// Content settings for access to serial ports. The "guard" content setting
	/// stores whether to allow sites to ask for permission to access a port. The
	/// permissions granted to access particular ports are stored in the "chooser
	/// data" website setting.
	CefContentSettingTypeSerialGuard       CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_SERIAL_GUARD
	CefContentSettingTypeSerialChooserData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_SERIAL_CHOOSER_DATA

	/// Nothing is stored in this setting at present. Please refer to
	/// PeriodicBackgroundSyncPermissionContext for details on how this permission
	/// is ascertained.
	/// This content setting is not registered because it does not require access
	/// to any existing providers.
	CefContentSettingTypePeriodicBackgroundSync CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PERIODIC_BACKGROUND_SYNC

	/// Content setting which stores whether to allow sites to ask for permission
	/// to do Bluetooth scanning.
	CefContentSettingTypeBluetoothScanning CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_BLUETOOTH_SCANNING

	/// Content settings for access to HID devices. The "guard" content setting
	/// stores whether to allow sites to ask for permission to access a device.
	/// The permissions granted to access particular devices are stored in the
	/// "chooser data" website setting.
	CefContentSettingTypeHidGuard       CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_HID_GUARD
	CefContentSettingTypeHidChooserData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_HID_CHOOSER_DATA

	/// Wake Lock API, which has two lock types: screen and system locks.
	/// Currently, screen locks do not need any additional permission, and system
	/// locks are always denied while the right UI is worked out.
	CefContentSettingTypeWakeLockScreen CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SCREEN
	CefContentSettingTypeWakeLockSystem CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_WAKE_LOCK_SYSTEM

	/// Legacy SameSite cookie behavior. This disables SameSite=Lax-by-default,
	/// SameSite=None requires Secure, and Schemeful Same-Site, forcing the
	/// legacy behavior wherein 1) cookies that don't specify SameSite are treated
	/// as SameSite=None, 2) SameSite=None cookies are not required to be Secure,
	/// and 3) schemeful same-site is not active.
	///
	/// This will also be used to revert to legacy behavior when future changes
	/// in cookie handling are introduced.
	CefContentSettingTypeLegacyCookieAccess CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_LEGACY_COOKIE_ACCESS

	/// Content settings which stores whether to allow sites to ask for permission
	/// to save changes to an original file selected by the user through the
	/// File System Access API.
	CefContentSettingTypeFileSystemWriteGuard CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_WRITE_GUARD

	/// Used to store whether to allow a website to exchange data with NFC
	/// devices.
	CefContentSettingTypeNfc CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_NFC

	/// Website setting to store permissions granted to access particular
	/// Bluetooth devices.
	CefContentSettingTypeBluetoothChooserData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_BLUETOOTH_CHOOSER_DATA

	/// Full access to the system clipboard (sanitized read without user gesture,
	/// and unsanitized read and write with user gesture).
	CefContentSettingTypeClipboardReadWrite CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_CLIPBOARD_READ_WRITE

	/// This is special-cased in the permissions layer to always allow, and as
	/// such doesn't have associated prefs data.
	CefContentSettingTypeClipboardSanitizedWrite CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_CLIPBOARD_SANITIZED_WRITE

	/// This content setting type is for caching safe browsing real time url
	/// check's verdicts of each origin.
	CefContentSettingTypeSafeBrowsingUrlCheckData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_SAFE_BROWSING_URL_CHECK_DATA

	/// Used to store whether a site is allowed to request AR or VR sessions with
	/// the WebXr Device API.
	CefContentSettingTypeVr CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_VR
	CefContentSettingTypeAr CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_AR

	/// Content setting which stores whether to allow site to open and read files
	/// and directories selected through the File System Access API.
	CefContentSettingTypeFileSystemReadGuard CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_READ_GUARD

	/// Access to first party storage in a third-party context. Exceptions are
	/// scoped to the combination of requesting/top-level origin, and are managed
	/// through the Storage Access API. For the time being, this content setting
	/// exists in parallel to third-party cookie rules stored in COOKIES.
	CefContentSettingTypeStorageAccess CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_STORAGE_ACCESS

	/// Content setting which stores whether to allow a site to control camera
	/// movements. It does not give access to camera.
	CefContentSettingTypeCameraPanTiltZoom CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_CAMERA_PAN_TILT_ZOOM

	/// Content setting for Screen Enumeration and Screen Detail functionality.
	/// Permits access to detailed multi-screen information, like size and
	/// position. Permits placing fullscreen and windowed content on specific
	/// screens. See also: https://w3c.github.io/window-placement
	CefContentSettingTypeWindowManagement CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_WINDOW_MANAGEMENT

	/// Stores whether to allow insecure websites to make local network requests.
	/// See also: https://wicg.github.io/local-network-access
	/// Set through enterprise policies only.
	CefContentSettingTypeInsecureLocalNetwork CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_INSECURE_LOCAL_NETWORK

	/// Content setting which stores whether or not a site can access low-level
	/// locally installed font data using the Local Fonts Access API.
	CefContentSettingTypeLocalFonts CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_LOCAL_FONTS

	/// Stores per-origin state for permission auto-revocation (for all permission
	/// types).
	CefContentSettingTypePermissionAutorevocationData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PERMISSION_AUTOREVOCATION_DATA

	/// Stores per-origin state of the most recently selected directory for the
	/// use by the File System Access API.
	CefContentSettingTypeFileSystemLastPickedDirectory CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_LAST_PICKED_DIRECTORY

	/// Controls access to the getDisplayMedia API when {preferCurrentTab: true}
	/// is specified.
	CefContentSettingTypeDisplayCapture CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_DISPLAY_CAPTURE

	/// Website setting to store permissions metadata granted to paths on the
	/// local file system via the File System Access API.
	/// |FILE_SYSTEM_WRITE_GUARD| is the corresponding "guard" setting.
	CefContentSettingTypeFileSystemAccessChooserData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FILE_SYSTEM_ACCESS_CHOOSER_DATA

	/// Stores a grant that allows a relying party to send a request for identity
	/// information to specified identity providers, potentially through any
	/// anti-tracking measures that would otherwise prevent it. This setting is
	/// associated with the relying party's origin.
	CefContentSettingTypeFederatedIdentitySharing CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_SHARING

	/// Whether to use the v8 optimized JIT for running JavaScript on the page.
	CefContentSettingTypeJavascriptJit CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_JAVASCRIPT_JIT

	/// Content setting which stores user decisions to allow loading a site over
	/// HTTP. Entries are added by hostname when a user bypasses the HTTPS-First
	/// Mode interstitial warning when a site does not support HTTPS. Allowed
	/// hosts are exact hostname matches -- subdomains of a host on the allowlist
	/// must be separately allowlisted.
	CefContentSettingTypeHttpAllowed CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_HTTP_ALLOWED

	/// Stores metadata related to form fill, such as e.g. whether user data was
	/// autofilled on a specific website.
	CefContentSettingTypeFormfillMetadata CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FORMFILL_METADATA

	/// Setting to indicate that there is an active federated sign-in session
	/// between a specified relying party and a specified identity provider for
	/// a specified account. When this is present it allows access to session
	/// management capabilities between the sites. This setting is associated
	/// with the relying party's origin.
	CefContentSettingTypeFederatedIdentityActiveSession CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_ACTIVE_SESSION

	/// Setting to indicate whether Chrome should automatically apply darkening to
	/// web content.
	CefContentSettingTypeAutoDarkWebContent CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_AUTO_DARK_WEB_CONTENT

	/// Setting to indicate whether Chrome should request the desktop view of a
	/// site instead of the mobile one.
	CefContentSettingTypeRequestDesktopSite CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_REQUEST_DESKTOP_SITE

	/// Setting to indicate whether browser should allow signing into a website
	/// via the browser FedCM API.
	CefContentSettingTypeFederatedIdentityApi CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_API

	/// Stores notification interactions per origin for the past 90 days.
	/// Interactions per origin are pre-aggregated over seven-day windows: A
	/// notification interaction or display is assigned to the last Monday
	/// midnight in local time.
	CefContentSettingTypeNotificationInteractions CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_NOTIFICATION_INTERACTIONS

	/// Website setting which stores the last reduced accept language negotiated
	/// for a given origin, to be used on future visits to the origin.
	CefContentSettingTypeReducedAcceptLanguage CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_REDUCED_ACCEPT_LANGUAGE

	/// Website setting which is used for NotificationPermissionReviewService to
	/// store origin blocklist from review notification permissions feature.
	CefContentSettingTypeNotificationPermissionReview CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_NOTIFICATION_PERMISSION_REVIEW

	/// Website setting to store permissions granted to access particular devices
	/// in private network.
	CefContentSettingTypePrivateNetworkGuard       CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_GUARD
	CefContentSettingTypePrivateNetworkChooserData CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_PRIVATE_NETWORK_CHOOSER_DATA

	/// Website setting which stores whether the browser has observed the user
	/// signing into an identity-provider based on observing the IdP-SignIn-Status
	/// HTTP header.
	CefContentSettingTypeFederatedIdentityIdentityProviderSigninStatus CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_SIGNIN_STATUS

	/// Website setting which is used for UnusedSitePermissionsService to
	/// store revoked permissions of unused sites from unused site permissions
	/// feature.
	CefContentSettingTypeRevokedUnusedSitePermissions CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_REVOKED_UNUSED_SITE_PERMISSIONS

	/// Similar to STORAGE_ACCESS, but applicable at the page-level rather than
	/// being specific to a frame.
	CefContentSettingTypeTopLevelStorageAccess CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_TOP_LEVEL_STORAGE_ACCESS

	/// Setting to indicate whether user has opted in to allowing auto re-authn
	/// via the FedCM API.
	CefContentSettingTypeFederatedIdentityAutoReauthnPermission CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_AUTO_REAUTHN_PERMISSION

	/// Website setting which stores whether the user has explicitly registered
	/// a website as an identity-provider.
	CefContentSettingTypeFederatedIdentityIdentityProviderRegistration CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_FEDERATED_IDENTITY_IDENTITY_PROVIDER_REGISTRATION

	/// Content setting which is used to indicate whether anti-abuse functionality
	/// should be enabled.
	CefContentSettingTypeAntiAbuse CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_ANTI_ABUSE

	/// Content setting used to indicate whether third-party storage partitioning
	/// should be enabled.
	CefContentSettingTypeThirdPartyStoragePartitioning CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_THIRD_PARTY_STORAGE_PARTITIONING

	/// Used to indicate whether HTTPS-First Mode is enabled on the hostname.
	CefContentSettingTypeHttpsEnforced CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_HTTPS_ENFORCED
	CefContentSettingTypeNumTypes      CContentSettingTypesT = C.CEF_CONTENT_SETTING_TYPE_NUM_TYPES
)

// /
// / Supported content setting values. Should be kept in sync with Chromium's
// / ContentSetting type.
// /
type CContentSettingValuesT C.cef_content_setting_values_t

const (
	CefContentSettingValueDefault                CContentSettingValuesT = C.CEF_CONTENT_SETTING_VALUE_DEFAULT
	CefContentSettingValueAllow                  CContentSettingValuesT = C.CEF_CONTENT_SETTING_VALUE_ALLOW
	CefContentSettingValueBlock                  CContentSettingValuesT = C.CEF_CONTENT_SETTING_VALUE_BLOCK
	CefContentSettingValueAsk                    CContentSettingValuesT = C.CEF_CONTENT_SETTING_VALUE_ASK
	CefContentSettingValueSessionOnly            CContentSettingValuesT = C.CEF_CONTENT_SETTING_VALUE_SESSION_ONLY
	CefContentSettingValueDetectImportantContent CContentSettingValuesT = C.CEF_CONTENT_SETTING_VALUE_DETECT_IMPORTANT_CONTENT
	CefContentSettingValueNumValues              CContentSettingValuesT = C.CEF_CONTENT_SETTING_VALUE_NUM_VALUES
)

// cef_types_geometry.h, include/internal/cef_types_geometry.h:44:3,

// /
// / Structure representing a point.
// /
type CPointT C.cef_point_t

func NewCPointT() *CPointT {
	s := &CPointT{}
	return s
}

func (st *CPointT) X() int {
	return int(st.x)
}

func (st *CPointT) SetX(v int) {
	st.x = (C.int)(v)
}

func (st *CPointT) Y() int {
	return int(st.y)
}

func (st *CPointT) SetY(v int) {
	st.y = (C.int)(v)
}

// /
// / Structure representing a rectangle.
// /
type CRectT C.cef_rect_t

func NewCRectT() *CRectT {
	s := &CRectT{}
	return s
}

func (st *CRectT) X() int {
	return int(st.x)
}

func (st *CRectT) SetX(v int) {
	st.x = (C.int)(v)
}

func (st *CRectT) Y() int {
	return int(st.y)
}

func (st *CRectT) SetY(v int) {
	st.y = (C.int)(v)
}

func (st *CRectT) Width() int {
	return int(st.width)
}

func (st *CRectT) SetWidth(v int) {
	st.width = (C.int)(v)
}

func (st *CRectT) Height() int {
	return int(st.height)
}

func (st *CRectT) SetHeight(v int) {
	st.height = (C.int)(v)
}

// /
// / Structure representing a size.
// /
type CSizeT C.cef_size_t

func NewCSizeT() *CSizeT {
	s := &CSizeT{}
	return s
}

func (st *CSizeT) Width() int {
	return int(st.width)
}

func (st *CSizeT) SetWidth(v int) {
	st.width = (C.int)(v)
}

func (st *CSizeT) Height() int {
	return int(st.height)
}

func (st *CSizeT) SetHeight(v int) {
	st.height = (C.int)(v)
}

// /
// / Structure representing insets.
// /
type CInsetsT C.cef_insets_t

func NewCInsetsT() *CInsetsT {
	s := &CInsetsT{}
	return s
}

func (st *CInsetsT) Top() int {
	return int(st.top)
}

func (st *CInsetsT) SetTop(v int) {
	st.top = (C.int)(v)
}

func (st *CInsetsT) Left() int {
	return int(st.left)
}

func (st *CInsetsT) SetLeft(v int) {
	st.left = (C.int)(v)
}

func (st *CInsetsT) Bottom() int {
	return int(st.bottom)
}

func (st *CInsetsT) SetBottom(v int) {
	st.bottom = (C.int)(v)
}

func (st *CInsetsT) Right() int {
	return int(st.right)
}

func (st *CInsetsT) SetRight(v int) {
	st.right = (C.int)(v)
}
